diff --git a/.gitignore b/.gitignore
index baa529015..14f0e1a5d 100644
--- a/.gitignore
+++ b/.gitignore
@@ -43,6 +43,7 @@ stage
 /snap/plugins/__pycache__
 
 /Telegram/*.user.*
+*.txt.user
 *.pro.user
 /Linux/
 /Telegram/Makefile
diff --git a/.gitmodules b/.gitmodules
index 1ad23f5b7..f206a48c7 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -49,3 +49,18 @@
 [submodule "Telegram/lib_spellcheck"]
 	path = Telegram/lib_spellcheck
 	url = https://github.com/desktop-app/lib_spellcheck
+[submodule "Telegram/lib_storage"]
+	path = Telegram/lib_storage
+	url = https://github.com/desktop-app/lib_storage.git
+[submodule "cmake"]
+	path = cmake
+	url = https://github.com/desktop-app/cmake_helpers.git
+[submodule "Telegram/ThirdParty/expected"]
+	path = Telegram/ThirdParty/expected
+	url = https://github.com/TartanLlama/expected
+[submodule "Telegram/ThirdParty/QR"]
+	path = Telegram/ThirdParty/QR
+	url = https://github.com/nayuki/QR-Code-generator
+[submodule "Telegram/lib_qr"]
+	path = Telegram/lib_qr
+	url = https://github.com/desktop-app/lib_qr.git
diff --git a/.travis.yml b/.travis.yml
index 983351096..d5b16eaea 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -43,12 +43,14 @@ addons:
       - liblzma-dev
       - libopus-dev
       - libpulse-dev
+      - libenchant-dev
       - libssl-dev
       - libdee-dev
       - libva-dev
       - libvdpau-dev
       - libxcb-xkb-dev
       - libxkbcommon-dev
+      - libatspi2.0-dev
       - lintian
       - quilt
       - valac
diff --git a/.travis/build.sh b/.travis/build.sh
index 91d9e06b1..6033b51d3 100755
--- a/.travis/build.sh
+++ b/.travis/build.sh
@@ -17,7 +17,7 @@ XKB_PATH="$BUILD/libxkbcommon"
 XKB_CACHE_VERSION="3"
 
 QT_PATH="$BUILD/qt"
-QT_CACHE_VERSION="4"
+QT_CACHE_VERSION="5"
 QT_PATCH="$EXTERNAL/patches/qtbase_${QT_VERSION//\./_}.diff"
 
 BREAKPAD_PATH="$BUILD/breakpad"
@@ -694,7 +694,6 @@ buildTelegram() {
       -Dlinux_path_qt=$QT_PATH \
       -Dlinux_path_breakpad=$BREAKPAD_PATH \
       -Dlinux_path_libexif_lib=/usr/local/lib \
-      -Dlinux_path_opus_include=/usr/include/opus \
       -Dlinux_lib_ssl=-lssl \
       -Dlinux_lib_crypto=-lcrypto \
       -Dlinux_lib_icu=-licuuc\ -licutu\ -licui18n \
diff --git a/CMakeLists.txt b/CMakeLists.txt
new file mode 100644
index 000000000..ff9adc66d
--- /dev/null
+++ b/CMakeLists.txt
@@ -0,0 +1,36 @@
+# This file is part of Telegram Desktop,
+# the official desktop application for the Telegram messaging service.
+#
+# For license and copyright information please follow this link:
+# https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+
+cmake_minimum_required(VERSION 3.16)
+cmake_policy(SET CMP0076 NEW)
+cmake_policy(SET CMP0091 NEW)
+
+set_property(GLOBAL PROPERTY USE_FOLDERS ON)
+
+include(cmake/variables.cmake)
+include(cmake/version.cmake)
+desktop_app_parse_version(Telegram/build/version)
+
+project(Telegram
+    LANGUAGES C CXX
+    VERSION ${desktop_app_version_cmake}
+    DESCRIPTION "Official Telegram Desktop messenger"
+    HOMEPAGE_URL "https://desktop.telegram.org"
+)
+set_property(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT Telegram)
+
+include(cmake/nice_target_sources.cmake)
+include(cmake/target_link_static_libraries.cmake)
+include(cmake/target_link_frameworks.cmake)
+include(cmake/init_target.cmake)
+include(cmake/generate_target.cmake)
+
+include(cmake/options.cmake)
+
+include(cmake/external/qt/package.cmake)
+
+add_subdirectory(cmake)
+add_subdirectory(Telegram)
diff --git a/Telegram/CMakeLists.txt b/Telegram/CMakeLists.txt
new file mode 100644
index 000000000..130792cc3
--- /dev/null
+++ b/Telegram/CMakeLists.txt
@@ -0,0 +1,1167 @@
+# This file is part of Telegram Desktop,
+# the official desktop application for the Telegram messaging service.
+#
+# For license and copyright information please follow this link:
+# https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+
+add_executable(Telegram WIN32 MACOSX_BUNDLE)
+init_target(Telegram)
+
+add_subdirectory(lib_rpl)
+add_subdirectory(lib_crl)
+add_subdirectory(lib_base)
+add_subdirectory(lib_ui)
+add_subdirectory(lib_tl)
+if (NOT DESKTOP_APP_DISABLE_SPELLCHECK)
+    add_subdirectory(lib_spellcheck)
+endif()
+add_subdirectory(lib_storage)
+add_subdirectory(lib_lottie)
+add_subdirectory(lib_qr)
+add_subdirectory(codegen)
+
+include(lib_ui/cmake/generate_styles.cmake)
+include(cmake/generate_lang.cmake)
+include(cmake/generate_numbers.cmake)
+
+get_filename_component(src_loc SourceFiles REALPATH)
+get_filename_component(res_loc Resources REALPATH)
+
+include(cmake/telegram_options.cmake)
+include(cmake/lib_export.cmake)
+include(cmake/lib_ffmpeg.cmake)
+include(cmake/lib_mtproto.cmake)
+include(cmake/lib_scheme.cmake)
+include(cmake/lib_tgvoip.cmake)
+
+set(style_files
+    boxes/boxes.style
+    calls/calls.style
+    dialogs/dialogs.style
+    export/view/export.style
+    history/history.style
+    info/info.style
+    intro/intro.style
+    media/view/mediaview.style
+    media/player/media_player.style
+    overview/overview.style
+    passport/passport.style
+    profile/profile.style
+    settings/settings.style
+    chat_helpers/chat_helpers.style
+    window/window.style
+)
+
+set(dependent_style_files
+    ${submodules_loc}/lib_ui/ui/colors.palette
+    ${submodules_loc}/lib_ui/ui/basic.style
+    ${submodules_loc}/lib_ui/ui/layers/layers.style
+    ${submodules_loc}/lib_ui/ui/widgets/widgets.style
+)
+
+generate_styles(Telegram ${src_loc} "${style_files}" "${dependent_style_files}")
+generate_lang(Telegram ${res_loc}/langs/lang.strings)
+generate_numbers(Telegram ${res_loc}/numbers.txt)
+
+set_target_properties(Telegram PROPERTIES AUTOMOC ON AUTORCC ON)
+
+target_link_libraries(Telegram
+PRIVATE
+    tdesktop::lib_mtproto
+    tdesktop::lib_scheme
+    tdesktop::lib_export
+    desktop-app::lib_base
+    desktop-app::lib_crl
+    desktop-app::lib_ui
+    desktop-app::lib_tl
+    desktop-app::lib_storage
+    desktop-app::lib_lottie
+    desktop-app::lib_qr
+    desktop-app::lib_ffmpeg
+    desktop-app::external_lz4
+    desktop-app::external_rlottie
+    desktop-app::external_zlib
+    desktop-app::external_qt
+    desktop-app::external_qr_code_generator
+    desktop-app::external_auto_updates
+    tdesktop::lib_tgvoip
+    desktop-app::external_openssl
+    desktop-app::external_opus
+    desktop-app::external_openal
+)
+
+if (NOT DESKTOP_APP_DISABLE_CRASH_REPORTS)
+    target_link_libraries(Telegram PRIVATE desktop-app::external_crash_reports)
+endif()
+
+target_precompile_headers(Telegram PRIVATE ${src_loc}/stdafx.h)
+nice_target_sources(Telegram ${src_loc}
+PRIVATE
+    ${style_files}
+
+    api/api_common.h
+    api/api_hash.h
+    api/api_self_destruct.cpp
+    api/api_self_destruct.h
+    api/api_sending.cpp
+    api/api_sending.h
+    api/api_sensitive_content.cpp
+    api/api_sensitive_content.h
+    api/api_single_message_search.cpp
+    api/api_single_message_search.h
+    api/api_text_entities.cpp
+    api/api_text_entities.h
+    boxes/peers/add_participants_box.cpp
+    boxes/peers/add_participants_box.h
+    boxes/peers/edit_contact_box.cpp
+    boxes/peers/edit_contact_box.h
+    boxes/peers/edit_linked_chat_box.cpp
+    boxes/peers/edit_linked_chat_box.h
+    boxes/peers/edit_participant_box.cpp
+    boxes/peers/edit_participant_box.h
+    boxes/peers/edit_participants_box.cpp
+    boxes/peers/edit_participants_box.h
+    boxes/peers/edit_peer_info_box.cpp
+    boxes/peers/edit_peer_info_box.h
+    boxes/peers/edit_peer_type_box.cpp
+    boxes/peers/edit_peer_type_box.h
+    boxes/peers/edit_peer_history_visibility_box.cpp
+    boxes/peers/edit_peer_history_visibility_box.h
+    boxes/peers/edit_peer_permissions_box.cpp
+    boxes/peers/edit_peer_permissions_box.h
+    boxes/about_box.cpp
+    boxes/about_box.h
+    boxes/abstract_box.cpp
+    boxes/abstract_box.h
+    boxes/add_contact_box.cpp
+    boxes/add_contact_box.h
+    boxes/auto_lock_box.cpp
+    boxes/auto_lock_box.h
+    boxes/auto_download_box.cpp
+    boxes/auto_download_box.h
+    boxes/background_box.cpp
+    boxes/background_box.h
+    boxes/background_preview_box.cpp
+    boxes/background_preview_box.h
+    boxes/calendar_box.cpp
+    boxes/calendar_box.h
+    boxes/change_phone_box.cpp
+    boxes/change_phone_box.h
+    boxes/confirm_box.cpp
+    boxes/confirm_box.h
+    boxes/confirm_phone_box.cpp
+    boxes/confirm_phone_box.h
+    boxes/connection_box.cpp
+    boxes/connection_box.h
+    boxes/create_poll_box.cpp
+    boxes/create_poll_box.h
+    boxes/download_path_box.cpp
+    boxes/download_path_box.h
+    boxes/edit_caption_box.cpp
+    boxes/edit_caption_box.h
+    boxes/edit_color_box.cpp
+    boxes/edit_color_box.h
+    boxes/edit_privacy_box.cpp
+    boxes/edit_privacy_box.h
+    boxes/fonts_box.cpp
+    boxes/fonts_box.h
+    boxes/language_box.cpp
+    boxes/language_box.h
+    boxes/local_storage_box.cpp
+    boxes/local_storage_box.h
+    boxes/mute_settings_box.cpp
+    boxes/mute_settings_box.h
+    boxes/net_boost_box.cpp
+    boxes/net_boost_box.h
+    boxes/peer_list_box.cpp
+    boxes/peer_list_box.h
+    boxes/peer_list_controllers.cpp
+    boxes/peer_list_controllers.h
+    boxes/passcode_box.cpp
+    boxes/passcode_box.h
+    boxes/photo_crop_box.cpp
+    boxes/photo_crop_box.h
+    boxes/rate_call_box.cpp
+    boxes/rate_call_box.h
+    boxes/report_box.cpp
+    boxes/report_box.h
+    boxes/self_destruction_box.cpp
+    boxes/self_destruction_box.h
+    boxes/send_files_box.cpp
+    boxes/send_files_box.h
+    boxes/sessions_box.cpp
+    boxes/sessions_box.h
+    boxes/share_box.cpp
+    boxes/share_box.h
+    boxes/single_choice_box.cpp
+    boxes/single_choice_box.h
+    boxes/sticker_set_box.cpp
+    boxes/sticker_set_box.h
+    boxes/stickers_box.cpp
+    boxes/stickers_box.h
+    boxes/url_auth_box.cpp
+    boxes/url_auth_box.h
+    boxes/username_box.cpp
+    boxes/username_box.h
+    calls/calls_box_controller.cpp
+    calls/calls_box_controller.h
+    calls/calls_call.cpp
+    calls/calls_call.h
+    calls/calls_emoji_fingerprint.cpp
+    calls/calls_emoji_fingerprint.h
+    calls/calls_instance.cpp
+    calls/calls_instance.h
+    calls/calls_panel.cpp
+    calls/calls_panel.h
+    calls/calls_top_bar.cpp
+    calls/calls_top_bar.h
+    chat_helpers/bot_keyboard.cpp
+    chat_helpers/bot_keyboard.h
+    chat_helpers/emoji_keywords.cpp
+    chat_helpers/emoji_keywords.h
+    chat_helpers/emoji_list_widget.cpp
+    chat_helpers/emoji_list_widget.h
+    chat_helpers/emoji_sets_manager.cpp
+    chat_helpers/emoji_sets_manager.h
+    chat_helpers/emoji_suggestions_widget.cpp
+    chat_helpers/emoji_suggestions_widget.h
+    chat_helpers/field_autocomplete.cpp
+    chat_helpers/field_autocomplete.h
+    chat_helpers/gifs_list_widget.cpp
+    chat_helpers/gifs_list_widget.h
+    chat_helpers/message_field.cpp
+    chat_helpers/message_field.h
+    chat_helpers/stickers.cpp
+    chat_helpers/stickers.h
+    chat_helpers/stickers_emoji_pack.cpp
+    chat_helpers/stickers_emoji_pack.h
+    chat_helpers/stickers_list_widget.cpp
+    chat_helpers/stickers_list_widget.h
+    chat_helpers/tabbed_panel.cpp
+    chat_helpers/tabbed_panel.h
+    chat_helpers/tabbed_section.cpp
+    chat_helpers/tabbed_section.h
+    chat_helpers/tabbed_selector.cpp
+    chat_helpers/tabbed_selector.h
+    core/application.cpp
+    core/application.h
+    core/base_integration.cpp
+    core/base_integration.h
+    core/changelogs.cpp
+    core/changelogs.h
+    core/click_handler_types.cpp
+    core/click_handler_types.h
+    core/core_cloud_password.cpp
+    core/core_cloud_password.h
+    core/core_settings.cpp
+    core/core_settings.h
+    core/crash_report_window.cpp
+    core/crash_report_window.h
+    core/crash_reports.cpp
+    core/crash_reports.h
+    core/file_utilities.cpp
+    core/file_utilities.h
+    core/launcher.cpp
+    core/launcher.h
+    core/local_url_handlers.cpp
+    core/local_url_handlers.h
+    core/kotato_settings.cpp
+    core/kotato_settings.h
+    core/media_active_cache.h
+    core/mime_type.cpp
+    core/mime_type.h
+    core/sandbox.cpp
+    core/sandbox.h
+    core/shortcuts.cpp
+    core/shortcuts.h
+    core/ui_integration.cpp
+    core/ui_integration.h
+    core/update_checker.cpp
+    core/update_checker.h
+    core/utils.cpp
+    core/utils.h
+    core/version.h
+    data/data_abstract_structure.cpp
+    data/data_abstract_structure.h
+    data/data_auto_download.cpp
+    data/data_auto_download.h
+    data/data_chat.cpp
+    data/data_chat.h
+    data/data_channel.cpp
+    data/data_channel.h
+    data/data_channel_admins.cpp
+    data/data_channel_admins.h
+    data/data_cloud_themes.cpp
+    data/data_cloud_themes.h
+    data/data_countries.cpp
+    data/data_countries.h
+    data/data_document.cpp
+    data/data_document.h
+    data/data_document_good_thumbnail.cpp
+    data/data_document_good_thumbnail.h
+    data/data_drafts.cpp
+    data/data_drafts.h
+    data/data_folder.cpp
+    data/data_folder.h
+    # data/data_feed_messages.cpp
+    # data/data_feed_messages.h
+    data/data_file_origin.cpp
+    data/data_file_origin.h
+    data/data_flags.h
+    data/data_game.h
+    data/data_groups.cpp
+    data/data_groups.h
+    data/data_location.cpp
+    data/data_location.h
+    data/data_media_types.cpp
+    data/data_media_types.h
+    data/data_messages.cpp
+    data/data_messages.h
+    data/data_notify_settings.cpp
+    data/data_notify_settings.h
+    data/data_peer.cpp
+    data/data_peer.h
+    data/data_peer_values.cpp
+    data/data_peer_values.h
+    data/data_photo.cpp
+    data/data_photo.h
+    data/data_poll.cpp
+    data/data_poll.h
+    data/data_pts_waiter.cpp
+    data/data_pts_waiter.h
+    data/data_search_controller.cpp
+    data/data_search_controller.h
+    data/data_session.cpp
+    data/data_session.h
+    data/data_scheduled_messages.cpp
+    data/data_scheduled_messages.h
+    data/data_shared_media.cpp
+    data/data_shared_media.h
+    data/data_sparse_ids.cpp
+    data/data_sparse_ids.h
+    data/data_streaming.cpp
+    data/data_streaming.h
+    data/data_types.cpp
+    data/data_types.h
+    data/data_user.cpp
+    data/data_user.h
+    data/data_user_photos.cpp
+    data/data_user_photos.h
+    data/data_wall_paper.cpp
+    data/data_wall_paper.h
+    data/data_web_page.cpp
+    data/data_web_page.h
+    dialogs/dialogs_entry.cpp
+    dialogs/dialogs_entry.h
+    dialogs/dialogs_indexed_list.cpp
+    dialogs/dialogs_indexed_list.h
+    dialogs/dialogs_inner_widget.cpp
+    dialogs/dialogs_inner_widget.h
+    dialogs/dialogs_key.cpp
+    dialogs/dialogs_key.h
+    dialogs/dialogs_layout.cpp
+    dialogs/dialogs_layout.h
+    dialogs/dialogs_list.cpp
+    dialogs/dialogs_list.h
+    dialogs/dialogs_main_list.cpp
+    dialogs/dialogs_main_list.h
+    dialogs/dialogs_pinned_list.cpp
+    dialogs/dialogs_pinned_list.h
+    dialogs/dialogs_row.cpp
+    dialogs/dialogs_row.h
+    dialogs/dialogs_search_from_controllers.cpp
+    dialogs/dialogs_search_from_controllers.h
+    dialogs/dialogs_widget.cpp
+    dialogs/dialogs_widget.h
+    export/view/export_view_content.cpp
+    export/view/export_view_content.h
+    export/view/export_view_panel_controller.cpp
+    export/view/export_view_panel_controller.h
+    export/view/export_view_progress.cpp
+    export/view/export_view_progress.h
+    export/view/export_view_settings.cpp
+    export/view/export_view_settings.h
+    export/view/export_view_top_bar.cpp
+    export/view/export_view_top_bar.h
+    history/admin_log/history_admin_log_filter.cpp
+    history/admin_log/history_admin_log_filter.h
+    history/admin_log/history_admin_log_inner.cpp
+    history/admin_log/history_admin_log_inner.h
+    history/admin_log/history_admin_log_item.cpp
+    history/admin_log/history_admin_log_item.h
+    history/admin_log/history_admin_log_section.cpp
+    history/admin_log/history_admin_log_section.h
+    # history/feed/history_feed_section.cpp
+    # history/feed/history_feed_section.h
+    history/view/media/history_view_call.h
+    history/view/media/history_view_call.cpp
+    history/view/media/history_view_contact.h
+    history/view/media/history_view_contact.cpp
+    history/view/media/history_view_document.h
+    history/view/media/history_view_document.cpp
+    history/view/media/history_view_file.h
+    history/view/media/history_view_file.cpp
+    history/view/media/history_view_game.h
+    history/view/media/history_view_game.cpp
+    history/view/media/history_view_gif.h
+    history/view/media/history_view_gif.cpp
+    history/view/media/history_view_invoice.h
+    history/view/media/history_view_invoice.cpp
+    history/view/media/history_view_large_emoji.h
+    history/view/media/history_view_large_emoji.cpp
+    history/view/media/history_view_location.h
+    history/view/media/history_view_location.cpp
+    history/view/media/history_view_media.h
+    history/view/media/history_view_media.cpp
+    history/view/media/history_view_media_common.h
+    history/view/media/history_view_media_common.cpp
+    history/view/media/history_view_media_grouped.h
+    history/view/media/history_view_media_grouped.cpp
+    history/view/media/history_view_media_unwrapped.h
+    history/view/media/history_view_media_unwrapped.cpp
+    history/view/media/history_view_photo.h
+    history/view/media/history_view_photo.cpp
+    history/view/media/history_view_poll.h
+    history/view/media/history_view_poll.cpp
+    history/view/media/history_view_sticker.h
+    history/view/media/history_view_sticker.cpp
+    history/view/media/history_view_theme_document.h
+    history/view/media/history_view_theme_document.cpp
+    history/view/media/history_view_web_page.h
+    history/view/media/history_view_web_page.cpp
+    history/view/history_view_compose_controls.cpp
+    history/view/history_view_compose_controls.h
+    history/view/history_view_contact_status.cpp
+    history/view/history_view_contact_status.h
+    history/view/history_view_context_menu.cpp
+    history/view/history_view_context_menu.h
+    history/view/history_view_cursor_state.cpp
+    history/view/history_view_cursor_state.h
+    history/view/history_view_element.cpp
+    history/view/history_view_element.h
+    history/view/history_view_list_widget.cpp
+    history/view/history_view_list_widget.h
+    history/view/history_view_message.cpp
+    history/view/history_view_message.h
+    history/view/history_view_object.h
+    history/view/history_view_schedule_box.cpp
+    history/view/history_view_schedule_box.h
+    history/view/history_view_scheduled_section.cpp
+    history/view/history_view_scheduled_section.h
+    history/view/history_view_service_message.cpp
+    history/view/history_view_service_message.h
+    history/view/history_view_top_bar_widget.cpp
+    history/view/history_view_top_bar_widget.h
+    history/history.cpp
+    history/history.h
+    history/history_drag_area.cpp
+    history/history_drag_area.h
+    history/history_item.cpp
+    history/history_item.h
+    history/history_item_components.cpp
+    history/history_item_components.h
+    history/history_item_text.cpp
+    history/history_item_text.h
+    history/history_inner_widget.cpp
+    history/history_inner_widget.h
+    history/history_location_manager.cpp
+    history/history_location_manager.h
+    history/history_message.cpp
+    history/history_message.h
+    history/history_service.cpp
+    history/history_service.h
+    history/history_widget.cpp
+    history/history_widget.h
+    info/info_content_widget.cpp
+    info/info_content_widget.h
+    info/info_controller.cpp
+    info/info_controller.h
+    info/info_layer_widget.cpp
+    info/info_layer_widget.h
+    info/info_memento.cpp
+    info/info_memento.h
+    info/info_section_widget.cpp
+    info/info_section_widget.h
+    info/info_top_bar.cpp
+    info/info_top_bar.h
+    info/info_wrap_widget.cpp
+    info/info_wrap_widget.h
+    # info/channels/info_channels_widget.cpp
+    # info/channels/info_channels_widget.h
+    info/common_groups/info_common_groups_inner_widget.cpp
+    info/common_groups/info_common_groups_inner_widget.h
+    info/common_groups/info_common_groups_widget.cpp
+    info/common_groups/info_common_groups_widget.h
+    # info/feed/info_feed_channels.cpp
+    # info/feed/info_feed_channels.h
+    # info/feed/info_feed_channels_controllers.cpp
+    # info/feed/info_feed_channels_controllers.h
+    # info/feed/info_feed_cover.cpp
+    # info/feed/info_feed_cover.h
+    # info/feed/info_feed_profile_inner_widget.cpp
+    # info/feed/info_feed_profile_inner_widget.h
+    # info/feed/info_feed_profile_widget.cpp
+    # info/feed/info_feed_profile_widget.h
+    info/media/info_media_buttons.h
+    info/media/info_media_empty_widget.cpp
+    info/media/info_media_empty_widget.h
+    info/media/info_media_inner_widget.cpp
+    info/media/info_media_inner_widget.h
+    info/media/info_media_list_widget.cpp
+    info/media/info_media_list_widget.h
+    info/media/info_media_widget.cpp
+    info/media/info_media_widget.h
+    info/members/info_members_widget.cpp
+    info/members/info_members_widget.h
+    info/profile/info_profile_actions.cpp
+    info/profile/info_profile_actions.h
+    info/profile/info_profile_cover.cpp
+    info/profile/info_profile_cover.h
+    info/profile/info_profile_icon.cpp
+    info/profile/info_profile_icon.h
+    info/profile/info_profile_inner_widget.cpp
+    info/profile/info_profile_inner_widget.h
+    info/profile/info_profile_members.cpp
+    info/profile/info_profile_members.h
+    info/profile/info_profile_members_controllers.cpp
+    info/profile/info_profile_members_controllers.h
+    info/profile/info_profile_text.cpp
+    info/profile/info_profile_text.h
+    info/profile/info_profile_values.cpp
+    info/profile/info_profile_values.h
+    info/profile/info_profile_widget.cpp
+    info/profile/info_profile_widget.h
+    info/settings/info_settings_widget.cpp
+    info/settings/info_settings_widget.h
+    inline_bots/inline_bot_layout_internal.cpp
+    inline_bots/inline_bot_layout_internal.h
+    inline_bots/inline_bot_layout_item.cpp
+    inline_bots/inline_bot_layout_item.h
+    inline_bots/inline_bot_result.cpp
+    inline_bots/inline_bot_result.h
+    inline_bots/inline_bot_send_data.cpp
+    inline_bots/inline_bot_send_data.h
+    inline_bots/inline_results_widget.cpp
+    inline_bots/inline_results_widget.h
+    intro/intro_code.cpp
+    intro/intro_code.h
+    intro/intro_password_check.cpp
+    intro/intro_password_check.h
+    intro/intro_phone.cpp
+    intro/intro_phone.h
+    intro/intro_qr.cpp
+    intro/intro_qr.h
+    intro/intro_signup.cpp
+    intro/intro_signup.h
+    intro/intro_start.cpp
+    intro/intro_start.h
+    intro/intro_step.cpp
+    intro/intro_step.h
+    intro/intro_widget.cpp
+    intro/intro_widget.h
+    lang/lang_cloud_manager.cpp
+    lang/lang_cloud_manager.h
+    lang/lang_file_parser.cpp
+    lang/lang_file_parser.h
+    lang/lang_hardcoded.h
+    lang/lang_instance.cpp
+    lang/lang_instance.h
+    lang/lang_keys.cpp
+    lang/lang_keys.h
+    lang/lang_numbers_animation.cpp
+    lang/lang_numbers_animation.h
+    lang/lang_tag.cpp
+    lang/lang_tag.h
+    lang/lang_text_entity.cpp
+    lang/lang_text_entity.h
+    lang/lang_translator.cpp
+    lang/lang_translator.h
+    lang/lang_values.cpp
+    lang/lang_values.h
+    main/main_account.cpp
+    main/main_account.h
+    main/main_app_config.cpp
+    main/main_app_config.h
+    main/main_session.cpp
+    main/main_session.h
+    main/main_settings.cpp
+    main/main_settings.h
+    media/audio/media_audio.cpp
+    media/audio/media_audio.h
+    media/audio/media_audio_capture.cpp
+    media/audio/media_audio_capture.h
+    media/audio/media_audio_ffmpeg_loader.cpp
+    media/audio/media_audio_ffmpeg_loader.h
+    media/audio/media_audio_loader.cpp
+    media/audio/media_audio_loader.h
+    media/audio/media_audio_loaders.cpp
+    media/audio/media_audio_loaders.h
+    media/audio/media_audio_track.cpp
+    media/audio/media_audio_track.h
+    media/audio/media_child_ffmpeg_loader.cpp
+    media/audio/media_child_ffmpeg_loader.h
+    media/clip/media_clip_check_streaming.cpp
+    media/clip/media_clip_check_streaming.h
+    media/clip/media_clip_ffmpeg.cpp
+    media/clip/media_clip_ffmpeg.h
+    media/clip/media_clip_implementation.cpp
+    media/clip/media_clip_implementation.h
+    media/clip/media_clip_reader.cpp
+    media/clip/media_clip_reader.h
+    media/player/media_player_button.cpp
+    media/player/media_player_button.h
+    media/player/media_player_float.cpp
+    media/player/media_player_float.h
+    media/player/media_player_instance.cpp
+    media/player/media_player_instance.h
+    media/player/media_player_panel.cpp
+    media/player/media_player_panel.h
+    media/player/media_player_volume_controller.cpp
+    media/player/media_player_volume_controller.h
+    media/player/media_player_widget.cpp
+    media/player/media_player_widget.h
+    media/streaming/media_streaming_audio_track.cpp
+    media/streaming/media_streaming_audio_track.h
+    media/streaming/media_streaming_common.h
+    media/streaming/media_streaming_document.cpp
+    media/streaming/media_streaming_document.h
+    media/streaming/media_streaming_file.cpp
+    media/streaming/media_streaming_file.h
+    media/streaming/media_streaming_file_delegate.h
+    media/streaming/media_streaming_instance.cpp
+    media/streaming/media_streaming_instance.h
+    media/streaming/media_streaming_loader.cpp
+    media/streaming/media_streaming_loader.h
+    media/streaming/media_streaming_loader_local.cpp
+    media/streaming/media_streaming_loader_local.h
+    media/streaming/media_streaming_loader_mtproto.cpp
+    media/streaming/media_streaming_loader_mtproto.h
+    media/streaming/media_streaming_player.cpp
+    media/streaming/media_streaming_player.h
+    media/streaming/media_streaming_reader.cpp
+    media/streaming/media_streaming_reader.h
+    media/streaming/media_streaming_utility.cpp
+    media/streaming/media_streaming_utility.h
+    media/streaming/media_streaming_video_track.cpp
+    media/streaming/media_streaming_video_track.h
+    media/view/media_view_playback_controls.cpp
+    media/view/media_view_playback_controls.h
+    media/view/media_view_playback_progress.cpp
+    media/view/media_view_playback_progress.h
+    media/view/media_view_group_thumbs.cpp
+    media/view/media_view_group_thumbs.h
+    media/view/media_view_overlay_widget.cpp
+    media/view/media_view_overlay_widget.h
+    mtproto/config_loader.cpp
+    mtproto/config_loader.h
+    mtproto/connection_abstract.cpp
+    mtproto/connection_abstract.h
+    mtproto/connection_http.cpp
+    mtproto/connection_http.h
+    mtproto/connection_resolving.cpp
+    mtproto/connection_resolving.h
+    mtproto/connection_tcp.cpp
+    mtproto/connection_tcp.h
+    mtproto/core_types.h
+    mtproto/dc_options.cpp
+    mtproto/dc_options.h
+    mtproto/dedicated_file_loader.cpp
+    mtproto/dedicated_file_loader.h
+    mtproto/facade.cpp
+    mtproto/facade.h
+    mtproto/mtp_instance.cpp
+    mtproto/mtp_instance.h
+    mtproto/sender.h
+    mtproto/session.cpp
+    mtproto/session.h
+    mtproto/session_private.cpp
+    mtproto/session_private.h
+    mtproto/special_config_request.cpp
+    mtproto/special_config_request.h
+    mtproto/type_utils.h
+    overview/overview_layout.cpp
+    overview/overview_layout.h
+    passport/passport_encryption.cpp
+    passport/passport_encryption.h
+    passport/passport_form_controller.cpp
+    passport/passport_form_controller.h
+    passport/passport_form_view_controller.cpp
+    passport/passport_form_view_controller.h
+    passport/passport_panel.cpp
+    passport/passport_panel.h
+    passport/passport_panel_controller.cpp
+    passport/passport_panel_controller.h
+    passport/passport_panel_details_row.cpp
+    passport/passport_panel_details_row.h
+    passport/passport_panel_edit_contact.cpp
+    passport/passport_panel_edit_contact.h
+    passport/passport_panel_edit_document.cpp
+    passport/passport_panel_edit_document.h
+    passport/passport_panel_edit_scans.cpp
+    passport/passport_panel_edit_scans.h
+    passport/passport_panel_form.cpp
+    passport/passport_panel_form.h
+    passport/passport_panel_password.cpp
+    passport/passport_panel_password.h
+    platform/linux/linux_desktop_environment.cpp
+    platform/linux/linux_desktop_environment.h
+    platform/linux/linux_gdk_helper.cpp
+    platform/linux/linux_gdk_helper.h
+    platform/linux/linux_libs.cpp
+    platform/linux/linux_libs.h
+    platform/linux/file_utilities_linux.cpp
+    platform/linux/file_utilities_linux.h
+    platform/linux/launcher_linux.cpp
+    platform/linux/launcher_linux.h
+    platform/linux/main_window_linux.cpp
+    platform/linux/main_window_linux.h
+    platform/linux/notifications_manager_linux.cpp
+    platform/linux/notifications_manager_linux.h
+    platform/linux/specific_linux.cpp
+    platform/linux/specific_linux.h
+    platform/mac/file_utilities_mac.mm
+    platform/mac/file_utilities_mac.h
+    platform/mac/launcher_mac.mm
+    platform/mac/launcher_mac.h
+    platform/mac/mac_iconv_helper.c
+    platform/mac/main_window_mac.mm
+    platform/mac/main_window_mac.h
+    platform/mac/notifications_manager_mac.mm
+    platform/mac/notifications_manager_mac.h
+    platform/mac/specific_mac.mm
+    platform/mac/specific_mac.h
+    platform/mac/specific_mac_p.mm
+    platform/mac/specific_mac_p.h
+    platform/mac/window_title_mac.mm
+    platform/mac/window_title_mac.h
+    platform/mac/mac_touchbar.h
+    platform/mac/mac_touchbar.mm
+    platform/win/audio_win.cpp
+    platform/win/audio_win.h
+    platform/win/file_utilities_win.cpp
+    platform/win/file_utilities_win.h
+    platform/win/launcher_win.cpp
+    platform/win/launcher_win.h
+    platform/win/main_window_win.cpp
+    platform/win/main_window_win.h
+    platform/win/notifications_manager_win.cpp
+    platform/win/notifications_manager_win.h
+    platform/win/specific_win.cpp
+    platform/win/specific_win.h
+    platform/win/window_title_win.cpp
+    platform/win/window_title_win.h
+    platform/win/windows_app_user_model_id.cpp
+    platform/win/windows_app_user_model_id.h
+    platform/win/windows_dlls.cpp
+    platform/win/windows_dlls.h
+    platform/win/windows_event_filter.cpp
+    platform/win/windows_event_filter.h
+    platform/win/wrapper_wrl_implements_h.h
+    platform/platform_audio.h
+    platform/platform_file_utilities.h
+    platform/platform_launcher.h
+    platform/platform_main_window.h
+    platform/platform_notifications_manager.h
+    platform/platform_specific.h
+    platform/platform_window_title.h
+    profile/profile_back_button.cpp
+    profile/profile_back_button.h
+    profile/profile_block_group_members.cpp
+    profile/profile_block_group_members.h
+    profile/profile_block_peer_list.cpp
+    profile/profile_block_peer_list.h
+    profile/profile_block_widget.cpp
+    profile/profile_block_widget.h
+    profile/profile_cover_drop_area.cpp
+    profile/profile_cover_drop_area.h
+    settings/settings_advanced.cpp
+    settings/settings_advanced.h
+    settings/settings_chat.cpp
+    settings/settings_chat.h
+    settings/settings_calls.cpp
+    settings/settings_calls.h
+    settings/settings_codes.cpp
+    settings/settings_codes.h
+    settings/settings_common.cpp
+    settings/settings_common.h
+    settings/settings_information.cpp
+    settings/settings_information.h
+    settings/settings_intro.cpp
+    settings/settings_intro.h
+    settings/settings_kotato.cpp
+    settings/settings_kotato.h
+    settings/settings_main.cpp
+    settings/settings_main.h
+    settings/settings_notifications.cpp
+    settings/settings_notifications.h
+    settings/settings_privacy_controllers.cpp
+    settings/settings_privacy_controllers.h
+    settings/settings_privacy_security.cpp
+    settings/settings_privacy_security.h
+    storage/download_manager_mtproto.cpp
+    storage/download_manager_mtproto.h
+    storage/file_download.cpp
+    storage/file_download.h
+    storage/file_download_mtproto.cpp
+    storage/file_download_mtproto.h
+    storage/file_download_web.cpp
+    storage/file_download_web.h
+    storage/file_upload.cpp
+    storage/file_upload.h
+    storage/localimageloader.cpp
+    storage/localimageloader.h
+    storage/localstorage.cpp
+    storage/localstorage.h
+    storage/serialize_common.cpp
+    storage/serialize_common.h
+    storage/serialize_document.cpp
+    storage/serialize_document.h
+    storage/storage_facade.cpp
+    storage/storage_facade.h
+    # storage/storage_feed_messages.cpp
+    # storage/storage_feed_messages.h
+    storage/storage_media_prepare.cpp
+    storage/storage_media_prepare.h
+    storage/storage_shared_media.cpp
+    storage/storage_shared_media.h
+    storage/storage_sparse_ids_list.cpp
+    storage/storage_sparse_ids_list.h
+    storage/storage_user_photos.cpp
+    storage/storage_user_photos.h
+    storage/streamed_file_downloader.cpp
+    storage/streamed_file_downloader.h
+    support/support_autocomplete.cpp
+    support/support_autocomplete.h
+    support/support_common.cpp
+    support/support_common.h
+    support/support_helper.cpp
+    support/support_helper.h
+    support/support_templates.cpp
+    support/support_templates.h
+    ui/effects/round_checkbox.cpp
+    ui/effects/round_checkbox.h
+    ui/effects/send_action_animations.cpp
+    ui/effects/send_action_animations.h
+    ui/image/image.cpp
+    ui/image/image.h
+    ui/image/image_location.cpp
+    ui/image/image_location.h
+    ui/image/image_source.cpp
+    ui/image/image_source.h
+    ui/widgets/continuous_sliders.cpp
+    ui/widgets/continuous_sliders.h
+    ui/widgets/discrete_sliders.cpp
+    ui/widgets/discrete_sliders.h
+    ui/widgets/level_meter.cpp
+    ui/widgets/level_meter.h
+    ui/widgets/multi_select.cpp
+    ui/widgets/multi_select.h
+    ui/widgets/separate_panel.cpp
+    ui/widgets/separate_panel.h
+    ui/countryinput.cpp
+    ui/countryinput.h
+    ui/empty_userpic.cpp
+    ui/empty_userpic.h
+    ui/grouped_layout.cpp
+    ui/grouped_layout.h
+    ui/resize_area.h
+    ui/search_field_controller.cpp
+    ui/search_field_controller.h
+    ui/special_buttons.cpp
+    ui/special_buttons.h
+    ui/special_fields.cpp
+    ui/special_fields.h
+    ui/text_options.cpp
+    ui/text_options.h
+    ui/unread_badge.cpp
+    ui/unread_badge.h
+    window/main_window.cpp
+    window/main_window.h
+    window/notifications_manager.cpp
+    window/notifications_manager.h
+    window/notifications_manager_default.cpp
+    window/notifications_manager_default.h
+    window/notifications_utilities.cpp
+    window/notifications_utilities.h
+    window/section_memento.h
+    window/section_widget.cpp
+    window/section_widget.h
+    window/window_connecting_widget.cpp
+    window/window_connecting_widget.h
+    window/window_controller.cpp
+    window/window_controller.h
+    window/window_history_hider.cpp
+    window/window_history_hider.h
+    window/window_lock_widgets.cpp
+    window/window_lock_widgets.h
+    window/window_main_menu.cpp
+    window/window_main_menu.h
+    window/window_media_preview.cpp
+    window/window_media_preview.h
+    window/window_outdated_bar.cpp
+    window/window_outdated_bar.h
+    window/window_peer_menu.cpp
+    window/window_peer_menu.h
+    window/window_session_controller.cpp
+    window/window_session_controller.h
+    window/window_slide_animation.cpp
+    window/window_slide_animation.h
+    window/window_title.h
+    window/window_top_bar_wrap.h
+    window/themes/window_theme.cpp
+    window/themes/window_theme.h
+    window/themes/window_theme_editor.cpp
+    window/themes/window_theme_editor.h
+    window/themes/window_theme_editor_block.cpp
+    window/themes/window_theme_editor_block.h
+    window/themes/window_theme_editor_box.cpp
+    window/themes/window_theme_editor_box.h
+    window/themes/window_theme_preview.cpp
+    window/themes/window_theme_preview.h
+    window/themes/window_theme_warning.cpp
+    window/themes/window_theme_warning.h
+    window/themes/window_themes_cloud_list.cpp
+    window/themes/window_themes_cloud_list.h
+    window/themes/window_themes_embedded.cpp
+    window/themes/window_themes_embedded.h
+    window/themes/window_themes_generate_name.cpp
+    window/themes/window_themes_generate_name.h
+    apiwrap.cpp
+    apiwrap.h
+    app.cpp
+    app.h
+    config.h
+    facades.cpp
+    facades.h
+    layout.cpp
+    layout.h
+    logs.cpp
+    logs.h
+    main.cpp
+    mainwidget.cpp
+    mainwidget.h
+    mainwindow.cpp
+    mainwindow.h
+    observer_peer.cpp
+    observer_peer.h
+    qt_static_plugins.cpp
+    settings.cpp
+    settings.h
+)
+
+nice_target_sources(Telegram ${res_loc}
+PRIVATE
+    qrc/emoji_1.qrc
+    qrc/emoji_2.qrc
+    qrc/emoji_3.qrc
+    qrc/emoji_4.qrc
+    qrc/emoji_5.qrc
+    qrc/emoji_preview.qrc
+    qrc/telegram/telegram.qrc
+    qrc/telegram/sounds.qrc
+    winrc/Telegram.rc
+    winrc/Telegram.manifest
+    langs/lang.strings
+    numbers.txt
+)
+
+if (WIN32)
+    # message(${CMAKE_GENERATOR})
+    # mt.exe -manifest "${res_loc}/winrc/Telegram.manifest" "-inputresource:\"$<TARGET_FILE:Telegram>\";#1" "-outputresource:\"$<TARGET_FILE:Telegram>\";#1" >NUL
+    # set(hash_symbol "#")
+    # set(release $<CONFIG:Release>)
+    # add_custom_command(
+    # TARGET
+    #     Telegram
+    # POST_BUILD COMMAND
+    #     $<IF:${release},mt.exe,echo.> $<${release}:-manifest> $<${release}:"${res_loc}/winrc/Telegram.manifest"> $<${release}:-inputresource:"$<TARGET_FILE:Telegram>"$<SEMICOLON>${hash_symbol}1> $<${release}:-outputresource:"$<TARGET_FILE:Telegram>"$<SEMICOLON>${hash_symbol}1> $<${release}:$<ANGLE-R>NUL>
+    # COMMENT
+    #     $<IF:${release},"Appending compatibility manifest.","Finalizing build.">
+    # )
+elseif (APPLE)
+    target_link_libraries(Telegram
+    PRIVATE
+        desktop-app::external_sp_media_key_tap
+        desktop-app::external_iconv
+    )
+
+    set(icons_path ${CMAKE_CURRENT_SOURCE_DIR}/Telegram/Images.xcassets)
+    set_target_properties(Telegram PROPERTIES RESOURCE ${icons_path})
+    target_sources(Telegram PRIVATE ${icons_path})
+
+    set(lang_packs
+        en
+        de
+        es
+        it
+        nl
+        ko
+        pt-BR
+    )
+    foreach (lang ${lang_packs})
+        set(strings_path ${res_loc}/langs/${lang}.lproj/Localizable.strings)
+        set_source_files_properties(${strings_path} PROPERTIES
+        MACOSX_PACKAGE_LOCATION
+            Resources/${lang}.lproj
+        )
+        target_sources(Telegram PRIVATE ${strings_path})
+        source_group(TREE ${res_loc} PREFIX Resources FILES ${strings_path})
+    endforeach()
+
+    if (NOT build_macstore)
+        add_custom_command(TARGET Telegram
+        PRE_LINK
+            COMMAND mkdir -p $<TARGET_FILE_DIR:Telegram>/../Frameworks
+            COMMAND cp $<TARGET_FILE:Updater> $<TARGET_FILE_DIR:Telegram>/../Frameworks/
+        )
+        if (NOT DESKTOP_APP_DISABLE_CRASH_REPORTS)
+            add_custom_command(TARGET Telegram
+            PRE_LINK
+                COMMAND mkdir -p $<TARGET_FILE_DIR:Telegram>/../Helpers
+                COMMAND cp ${libs_loc}/crashpad/out/$<IF:$<CONFIG:Debug>,Debug,Release>/crashpad_handler $<TARGET_FILE_DIR:Telegram>/../Helpers/
+            )
+        endif()
+    endif()
+elseif (LINUX)
+    if (NOT TDESKTOP_DISABLE_GTK_INTEGRATION)
+        find_package(PkgConfig REQUIRED)
+
+        pkg_check_modules(GTK2 REQUIRED gtk+-2.0)
+        target_include_directories(Telegram PRIVATE ${GTK2_INCLUDE_DIRS})
+        target_compile_options(Telegram PRIVATE -Wno-register)
+
+        set(appindicator_packages
+            ayatana-appindicator3-0.1
+            ayatana-appindicator-0.1
+            appindicator3-0.1
+            appindicator-0.1
+        )
+        set(appindicator_found 0)
+        foreach (package ${appindicator_packages})
+            pkg_check_modules(APPIND_${package} ${package})
+            if (APPIND_${package}_FOUND)
+                set(appindicator_found 1)
+                target_include_directories(Telegram PRIVATE "${APPIND_${package}_INCLUDE_DIRS}")
+                if (${package} MATCHES "ayatana")
+                    target_compile_definitions(Telegram PRIVATE TDESKTOP_USE_AYATANA_INDICATORS)
+                endif()
+                break()
+            endif()
+        endforeach()
+        if (NOT ${appindicator_found})
+            message(FATAL_ERROR "No libappindicator found by pkg-config.")
+        endif()
+    endif()
+endif()
+
+if (build_macstore)
+    set(bundle_identifier "org.telegram.desktop")
+    set(bundle_entitlements "Telegram Desktop.entitlements")
+    set(output_name "Telegram Desktop")
+    set_target_properties(Telegram PROPERTIES
+        XCODE_ATTRIBUTE_FRAMEWORK_SEARCH_PATHS ${libs_loc}/breakpad/src/client/mac/build/Release
+    )
+    target_link_frameworks(Telegram PRIVATE Breakpad)
+    add_custom_command(TARGET Telegram
+    PRE_LINK
+        COMMAND rm -rf $<TARGET_FILE_DIR:Telegram>/../Frameworks
+        COMMAND mkdir -p $<TARGET_FILE_DIR:Telegram>/../Frameworks
+        COMMAND cp -a ${libs_loc}/breakpad/src/client/mac/build/Release/Breakpad.framework $<TARGET_FILE_DIR:Telegram>/../Frameworks/Breakpad.framework
+    )
+elseif (build_osx)
+    set(bundle_identifier "com.tdesktop.Telegram$<$<CONFIG:Debug>:DebugOsx>")
+    set(bundle_entitlements "Telegram.entitlements")
+    set(output_name "Telegram")
+else()
+    set(bundle_identifier "com.tdesktop.Telegram$<$<CONFIG:Debug>:Debug>")
+    set(bundle_entitlements "Telegram.entitlements")
+    set(output_name "Telegram")
+endif()
+
+set_target_properties(Telegram PROPERTIES
+    OUTPUT_NAME ${output_name}
+    MACOSX_BUNDLE_GUI_IDENTIFIER ${bundle_identifier}
+    MACOSX_BUNDLE_INFO_PLIST ${CMAKE_CURRENT_SOURCE_DIR}/Telegram.plist
+    XCODE_ATTRIBUTE_CODE_SIGN_ENTITLEMENTS "${CMAKE_CURRENT_SOURCE_DIR}/Telegram/${bundle_entitlements}"
+    XCODE_ATTRIBUTE_PRODUCT_BUNDLE_IDENTIFIER ${bundle_identifier}
+    XCODE_ATTRIBUTE_CURRENT_PROJECT_VERSION ${desktop_app_version_string}
+    XCODE_ATTRIBUTE_PRODUCT_NAME ${output_name}
+    XCODE_ATTRIBUTE_DEBUG_INFORMATION_FORMAT $<$<NOT:$<CONFIG:Debug>>:dwarf-with-dsym>
+    XCODE_ATTRIBUTE_ASSETCATALOG_COMPILER_APPICON_NAME AppIcon
+    XCODE_ATTRIBUTE_ENABLE_HARDENED_RUNTIME YES
+    XCODE_ATTRIBUTE_COMBINE_HIDPI_IMAGES YES
+    XCODE_ATTRIBUTE_COPY_PHASE_STRIP NO
+    XCODE_ATTRIBUTE_ALWAYS_SEARCH_USER_PATHS NO
+    XCODE_ATTRIBUTE_CLANG_CXX_LIBRARY libc++
+    XCODE_ATTRIBUTE_OTHER_CODE_SIGN_FLAGS --deep
+)
+set(entitlement_sources
+    "${CMAKE_CURRENT_SOURCE_DIR}/Telegram/Telegram.entitlements"
+    "${CMAKE_CURRENT_SOURCE_DIR}/Telegram/Telegram Desktop.entitlements"
+)
+target_sources(Telegram PRIVATE ${entitlement_sources})
+source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR}/Telegram PREFIX Resources FILES ${entitlement_sources})
+
+target_include_directories(Telegram
+PRIVATE
+    ${src_loc}
+    ${third_party_loc}/minizip
+)
+
+target_compile_definitions(Telegram
+PRIVATE
+    TDESKTOP_API_ID=${TDESKTOP_API_ID}
+    TDESKTOP_API_HASH=${TDESKTOP_API_HASH}
+    AL_LIBTYPE_STATIC
+    AL_ALEXT_PROTOTYPES
+)
+
+if (${CMAKE_GENERATOR} MATCHES "(Visual Studio|Xcode|Ninja)")
+    set(output_folder ${CMAKE_BINARY_DIR})
+elseif((${CMAKE_GENERATOR} MATCHES "(Unix Makefiles)") AND DESKTOP_APP_SPECIAL_TARGET STREQUAL "")
+    set(output_folder ${CMAKE_BINARY_DIR}/bin)
+else()
+    set(output_folder ${CMAKE_BINARY_DIR}/$<IF:$<CONFIG:Debug>,Debug,Release>)
+endif()
+
+set_target_properties(Telegram PROPERTIES RUNTIME_OUTPUT_DIRECTORY ${output_folder})
+
+if (NOT build_macstore AND NOT build_winstore)
+    add_executable(Updater WIN32)
+    init_target(Updater)
+
+    add_dependencies(Telegram Updater)
+
+    nice_target_sources(Updater ${src_loc}
+    PRIVATE
+        _other/updater_win.cpp
+        _other/updater_linux.cpp
+        _other/updater_osx.m
+        _other/updater.h
+    )
+
+    set_target_properties(Updater PROPERTIES RUNTIME_OUTPUT_DIRECTORY ${output_folder})
+
+    if (DESKTOP_APP_SPECIAL_TARGET)
+        add_executable(Packer WIN32)
+        init_target(Packer)
+
+        add_dependencies(Telegram Packer)
+
+        nice_target_sources(Packer ${src_loc}
+        PRIVATE
+            _other/packer.cpp
+            _other/packer.h
+        )
+
+        target_link_libraries(Packer
+        PRIVATE
+            desktop-app::external_qt
+            desktop-app::external_zlib
+            desktop-app::external_auto_updates
+            desktop-app::external_openssl
+        )
+
+        set_target_properties(Packer PROPERTIES RUNTIME_OUTPUT_DIRECTORY ${output_folder})
+    endif()
+endif()
diff --git a/Telegram/Resources/icons/intro_qr_plane.png b/Telegram/Resources/icons/intro_qr_plane.png
new file mode 100644
index 000000000..cdc309f9d
Binary files /dev/null and b/Telegram/Resources/icons/intro_qr_plane.png differ
diff --git a/Telegram/Resources/icons/intro_qr_plane@2x.png b/Telegram/Resources/icons/intro_qr_plane@2x.png
new file mode 100644
index 000000000..3d0c2e9af
Binary files /dev/null and b/Telegram/Resources/icons/intro_qr_plane@2x.png differ
diff --git a/Telegram/Resources/icons/intro_qr_plane@3x.png b/Telegram/Resources/icons/intro_qr_plane@3x.png
new file mode 100644
index 000000000..ae5c5442e
Binary files /dev/null and b/Telegram/Resources/icons/intro_qr_plane@3x.png differ
diff --git a/Telegram/Resources/langs/lang.strings b/Telegram/Resources/langs/lang.strings
index ff2b42142..4738da233 100644
--- a/Telegram/Resources/langs/lang.strings
+++ b/Telegram/Resources/langs/lang.strings
@@ -178,8 +178,15 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 "lng_photo_caption" = "Caption";
 "lng_photos_comment" = "Comment";
 
+"lng_intro_qr_title" = "Scan From Mobile Telegram";
+"lng_intro_qr_step1" = "Open Telegram on your phone";
+"lng_intro_qr_step2" = "Go to Settings > Devices > Scan QR Code";
+"lng_intro_qr_step3" = "Scan this image to Log In";
+"lng_intro_qr_skip" = "Or log in using your phone number";
+
 "lng_phone_title" = "Your Phone Number";
 "lng_phone_desc" = "Please confirm your country code and\nenter your mobile phone number.";
+"lng_phone_to_qr" = "Quick log in using QR code";
 "lng_country_code" = "Country Code";
 "lng_bad_country_code" = "Invalid Country Code";
 "lng_country_ph" = "Search";
@@ -408,7 +415,9 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 "lng_settings_system_integration" = "System integration";
 "lng_settings_performance" = "Performance";
 "lng_settings_enable_animations" = "Enable animations";
-"lng_settings_autoplay_gifs" = "Autoplay GIFs";
+"lng_settings_sensitive_title" = "Sensitive content";
+"lng_settings_sensitive_disable_filtering" = "Disable filtering";
+"lng_settings_sensitive_about" = "Display sensitive media in public channels on all your Telegram devices.";
 
 "lng_settings_spellchecker" = "Spell checker";
 "lng_settings_system_spellchecker" = "Use system spell checker";
@@ -1143,12 +1152,11 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 "lng_media_auto_in_groups" = "In groups";
 "lng_media_auto_in_channels" = "In channels";
 "lng_media_auto_title" = "Automatically download";
+"lng_media_auto_play" = "Autoplay";
 "lng_media_photo_title" = "Photos";
 "lng_media_video_title" = "Video files";
-"lng_media_audio_title" = "Voice messages";
 "lng_media_video_messages_title" = "Round video messages";
 "lng_media_file_title" = "Files";
-"lng_media_music_title" = "Music";
 "lng_media_animation_title" = "Animated GIFs";
 "lng_media_size_limit" = "Limit by size";
 "lng_media_size_up_to" = "up to {size}";
@@ -2231,6 +2239,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 "lng_mac_menu_new_group" = "New Group";
 "lng_mac_menu_new_channel" = "New Channel";
 "lng_mac_menu_show" = "Show Telegram";
+"lng_mac_menu_emoji_and_symbols" = "Emoji & Symbols";
 
 "lng_mac_touchbar_favorite_stickers" = "Favorite stickers";
 
diff --git a/Telegram/Resources/tl/api.tl b/Telegram/Resources/tl/api.tl
index 5baf29966..982f05af7 100644
--- a/Telegram/Resources/tl/api.tl
+++ b/Telegram/Resources/tl/api.tl
@@ -89,6 +89,7 @@ inputDocumentFileLocation#bad07584 id:long access_hash:long file_reference:bytes
 inputSecureFileLocation#cbc7ee28 id:long access_hash:long = InputFileLocation;
 inputTakeoutFileLocation#29be5899 = InputFileLocation;
 inputPhotoFileLocation#40181ffe id:long access_hash:long file_reference:bytes thumb_size:string = InputFileLocation;
+inputPhotoLegacyFileLocation#d83466f3 id:long access_hash:long file_reference:bytes volume_id:long local_id:int secret:long = InputFileLocation;
 inputPeerPhotoFileLocation#27d69997 flags:# big:flags.0?true peer:InputPeer volume_id:long local_id:int = InputFileLocation;
 inputStickerSetThumb#dbaeae9 stickerset:InputStickerSet volume_id:long local_id:int = InputFileLocation;
 
@@ -213,6 +214,7 @@ peerNotifySettings#af509d20 flags:# show_previews:flags.0?Bool silent:flags.1?Bo
 peerSettings#818426cd flags:# report_spam:flags.0?true add_contact:flags.1?true block_contact:flags.2?true share_contact:flags.3?true need_contacts_exception:flags.4?true report_geo:flags.5?true = PeerSettings;
 
 wallPaper#a437c3ed id:long flags:# creator:flags.0?true default:flags.1?true pattern:flags.3?true dark:flags.4?true access_hash:long slug:string document:Document settings:flags.2?WallPaperSettings = WallPaper;
+wallPaperNoFile#8af40b25 flags:# default:flags.1?true dark:flags.4?true settings:flags.2?WallPaperSettings = WallPaper;
 
 inputReportReasonSpam#58dbcab8 = ReportReason;
 inputReportReasonViolence#1e22c78d = ReportReason;
@@ -347,6 +349,8 @@ updatePeerLocated#b4afcfb0 peers:Vector<PeerLocated> = Update;
 updateNewScheduledMessage#39a51dfb message:Message = Update;
 updateDeleteScheduledMessages#90866cee peer:Peer messages:Vector<int> = Update;
 updateTheme#8216fba3 theme:Theme = Update;
+updateGeoLiveViewed#871fb939 peer:Peer msg_id:int = Update;
+updateLoginToken#564fe691 = Update;
 
 updates.state#a56c2a3e pts:int qts:int date:int seq:int unread_count:int = updates.State;
 
@@ -496,7 +500,7 @@ messages.affectedMessages#84d19185 pts:int pts_count:int = messages.AffectedMess
 
 webPageEmpty#eb1477e8 id:long = WebPage;
 webPagePending#c586da1c id:long date:int = WebPage;
-webPage#fa64e172 flags:# id:long url:string display_url:string hash:int type:flags.0?string site_name:flags.1?string title:flags.2?string description:flags.3?string photo:flags.4?Photo embed_url:flags.5?string embed_type:flags.5?string embed_width:flags.6?int embed_height:flags.6?int duration:flags.7?int author:flags.8?string document:flags.9?Document documents:flags.11?Vector<Document> cached_page:flags.10?Page = WebPage;
+webPage#e89c45b2 flags:# id:long url:string display_url:string hash:int type:flags.0?string site_name:flags.1?string title:flags.2?string description:flags.3?string photo:flags.4?Photo embed_url:flags.5?string embed_type:flags.5?string embed_width:flags.6?int embed_height:flags.6?int duration:flags.7?int author:flags.8?string document:flags.9?Document cached_page:flags.10?Page attributes:flags.12?Vector<WebPageAttribute> = WebPage;
 webPageNotModified#85849473 = WebPage;
 
 authorization#ad01d61d flags:# current:flags.0?true official_app:flags.1?true password_pending:flags.2?true hash:long device_model:string platform:string system_version:string api_id:int app_name:string app_version:string date_created:int date_active:int ip:string country:string region:string = Authorization;
@@ -1027,15 +1031,16 @@ chatBannedRights#9f120418 flags:# view_messages:flags.0?true send_messages:flags
 
 inputWallPaper#e630b979 id:long access_hash:long = InputWallPaper;
 inputWallPaperSlug#72091c80 slug:string = InputWallPaper;
+inputWallPaperNoFile#8427bbac = InputWallPaper;
 
 account.wallPapersNotModified#1c199183 = account.WallPapers;
 account.wallPapers#702b65a9 hash:int wallpapers:Vector<WallPaper> = account.WallPapers;
 
 codeSettings#debebe83 flags:# allow_flashcall:flags.0?true current_number:flags.1?true allow_app_hash:flags.4?true = CodeSettings;
 
-wallPaperSettings#a12f40b8 flags:# blur:flags.1?true motion:flags.2?true background_color:flags.0?int intensity:flags.3?int = WallPaperSettings;
+wallPaperSettings#5086cf8 flags:# blur:flags.1?true motion:flags.2?true background_color:flags.0?int second_background_color:flags.4?int intensity:flags.3?int rotation:flags.4?int = WallPaperSettings;
 
-autoDownloadSettings#d246fd47 flags:# disabled:flags.0?true video_preload_large:flags.1?true audio_preload_next:flags.2?true phonecalls_less_data:flags.3?true photo_size_max:int video_size_max:int file_size_max:int = AutoDownloadSettings;
+autoDownloadSettings#e04232f3 flags:# disabled:flags.0?true video_preload_large:flags.1?true audio_preload_next:flags.2?true phonecalls_less_data:flags.3?true photo_size_max:int video_size_max:int file_size_max:int video_upload_maxbitrate:int = AutoDownloadSettings;
 
 account.autoDownloadSettings#63cacf26 low:AutoDownloadSettings medium:AutoDownloadSettings high:AutoDownloadSettings = account.AutoDownloadSettings;
 
@@ -1073,7 +1078,7 @@ inputTheme#3c5693e9 id:long access_hash:long = InputTheme;
 inputThemeSlug#f5890df1 slug:string = InputTheme;
 
 themeDocumentNotModified#483d270c = Theme;
-theme#f7d90ce0 flags:# creator:flags.0?true default:flags.1?true id:long access_hash:long slug:string title:string document:flags.2?Document installs_count:int = Theme;
+theme#28f1114 flags:# creator:flags.0?true default:flags.1?true id:long access_hash:long slug:string title:string document:flags.2?Document settings:flags.3?ThemeSettings installs_count:int = Theme;
 
 account.themesNotModified#f41eb622 = account.Themes;
 account.themes#7f676421 hash:int themes:Vector<Theme> = account.Themes;
@@ -1082,6 +1087,26 @@ wallet.liteResponse#764386d7 response:bytes = wallet.LiteResponse;
 
 wallet.secretSalt#dd484d64 salt:bytes = wallet.KeySecretSalt;
 
+auth.loginToken#629f1980 expires:int token:bytes = auth.LoginToken;
+auth.loginTokenMigrateTo#68e9916 dc_id:int token:bytes = auth.LoginToken;
+auth.loginTokenSuccess#390d5c5e authorization:auth.Authorization = auth.LoginToken;
+
+account.contentSettings#57e28221 flags:# sensitive_enabled:flags.0?true sensitive_can_change:flags.1?true = account.ContentSettings;
+
+messages.inactiveChats#a927fec5 dates:Vector<int> chats:Vector<Chat> users:Vector<User> = messages.InactiveChats;
+
+baseThemeClassic#c3a12462 = BaseTheme;
+baseThemeDay#fbd81688 = BaseTheme;
+baseThemeNight#b7b31ea8 = BaseTheme;
+baseThemeTinted#6d5f77ee = BaseTheme;
+baseThemeArctic#5b11125a = BaseTheme;
+
+inputThemeSettings#bd507cd1 flags:# base_theme:BaseTheme accent_color:int message_top_color:flags.0?int message_bottom_color:flags.0?int wallpaper:flags.1?InputWallPaper wallpaper_settings:flags.1?WallPaperSettings = InputThemeSettings;
+
+themeSettings#9c14984a flags:# base_theme:BaseTheme accent_color:int message_top_color:flags.0?int message_bottom_color:flags.0?int wallpaper:flags.1?WallPaper = ThemeSettings;
+
+webPageAttributeTheme#54b56617 flags:# documents:flags.0?Vector<Document> settings:flags.1?ThemeSettings = WebPageAttribute;
+
 ---functions---
 
 invokeAfterMsg#cb9f372d {X:Type} msg_id:long query:!X = X;
@@ -1107,6 +1132,9 @@ auth.recoverPassword#4ea56e92 code:string = auth.Authorization;
 auth.resendCode#3ef1a9bf phone_number:string phone_code_hash:string = auth.SentCode;
 auth.cancelCode#1f040578 phone_number:string phone_code_hash:string = Bool;
 auth.dropTempAuthKeys#8e48a188 except_auth_keys:Vector<long> = Bool;
+auth.exportLoginToken#b1b41517 api_id:int api_hash:string except_ids:Vector<int> = auth.LoginToken;
+auth.importLoginToken#95ac5ce4 token:bytes = auth.LoginToken;
+auth.acceptLoginToken#e894ad4d token:bytes = Authorization;
 
 account.registerDevice#68976c6f flags:# no_muted:flags.0?true token_type:int token:string app_sandbox:Bool secret:bytes other_uids:Vector<int> = Bool;
 account.unregisterDevice#3076c4bf token_type:int token:string other_uids:Vector<int> = Bool;
@@ -1164,12 +1192,15 @@ account.resetWallPapers#bb3b9804 = Bool;
 account.getAutoDownloadSettings#56da0b3f = account.AutoDownloadSettings;
 account.saveAutoDownloadSettings#76f36233 flags:# low:flags.0?true high:flags.1?true settings:AutoDownloadSettings = Bool;
 account.uploadTheme#1c3db333 flags:# file:InputFile thumb:flags.0?InputFile file_name:string mime_type:string = Document;
-account.createTheme#2b7ffd7f slug:string title:string document:InputDocument = Theme;
-account.updateTheme#3b8ea202 flags:# format:string theme:InputTheme slug:flags.0?string title:flags.1?string document:flags.2?InputDocument = Theme;
+account.createTheme#8432c21f flags:# slug:string title:string document:flags.2?InputDocument settings:flags.3?InputThemeSettings = Theme;
+account.updateTheme#5cb367d5 flags:# format:string theme:InputTheme slug:flags.0?string title:flags.1?string document:flags.2?InputDocument settings:flags.3?InputThemeSettings = Theme;
 account.saveTheme#f257106c theme:InputTheme unsave:Bool = Bool;
 account.installTheme#7ae43737 flags:# dark:flags.0?true format:flags.1?string theme:flags.1?InputTheme = Bool;
 account.getTheme#8d9d742b format:string theme:InputTheme document_id:long = Theme;
 account.getThemes#285946f8 format:string hash:int = account.Themes;
+account.setContentSettings#b574b16b flags:# sensitive_enabled:flags.0?true = Bool;
+account.getContentSettings#8b9b4dae = account.ContentSettings;
+account.getMultiWallPapers#65ad71dc wallpapers:Vector<InputWallPaper> = Vector<WallPaper>;
 
 users.getUsers#d91a548 id:Vector<InputUser> = Vector<User>;
 users.getFullUser#ca30a5b1 id:InputUser = UserFull;
@@ -1385,6 +1416,7 @@ channels.setDiscussionGroup#40582bb2 broadcast:InputChannel group:InputChannel =
 channels.editCreator#8f38cd1f channel:InputChannel user_id:InputUser password:InputCheckPasswordSRP = Updates;
 channels.editLocation#58e63f6d channel:InputChannel geo_point:InputGeoPoint address:string = Bool;
 channels.toggleSlowMode#edd49ef0 channel:InputChannel seconds:int = Updates;
+channels.getInactiveChannels#11e831ee = messages.InactiveChats;
 
 bots.sendCustomRequest#aa2769ed custom_method:string params:DataJSON = DataJSON;
 bots.answerWebhookJSONQuery#e6213f4d query_id:long data:DataJSON = Bool;
@@ -1422,4 +1454,4 @@ folders.deleteFolder#1c295881 folder_id:int = Updates;
 wallet.sendLiteRequest#e2c9d33e body:bytes = wallet.LiteResponse;
 wallet.getKeySecretSalt#b57f346 revoke:Bool = wallet.KeySecretSalt;
 
-// LAYER 106
+// LAYER 108
diff --git a/Telegram/Resources/tl/mtproto.tl b/Telegram/Resources/tl/mtproto.tl
index 83a770292..4b92c3e6e 100644
--- a/Telegram/Resources/tl/mtproto.tl
+++ b/Telegram/Resources/tl/mtproto.tl
@@ -21,6 +21,8 @@ p_q_inner_data_dc#a9f55f95 pq:string p:string q:string nonce:int128 server_nonce
 p_q_inner_data_temp#3c6a84d4 pq:string p:string q:string nonce:int128 server_nonce:int128 new_nonce:int256 expires_in:int = P_Q_inner_data;
 p_q_inner_data_temp_dc#56fddf88 pq:string p:string q:string nonce:int128 server_nonce:int128 new_nonce:int256 dc:int expires_in:int = P_Q_inner_data;
 
+bind_auth_key_inner#75a3f765 nonce:long temp_auth_key_id:long perm_auth_key_id:long temp_session_id:long expires_at:int = BindAuthKeyInner;
+
 server_DH_params_fail#79cb045d nonce:int128 server_nonce:int128 new_nonce_hash:int128 = Server_DH_Params;
 server_DH_params_ok#d0e8075c nonce:int128 server_nonce:int128 encrypted_answer:string = Server_DH_Params;
 
diff --git a/Telegram/Resources/uwp/AppX/AppxManifest.xml b/Telegram/Resources/uwp/AppX/AppxManifest.xml
index 91eed0956..86fe72d89 100644
--- a/Telegram/Resources/uwp/AppX/AppxManifest.xml
+++ b/Telegram/Resources/uwp/AppX/AppxManifest.xml
@@ -9,7 +9,7 @@
   <Identity Name="TelegramMessengerLLP.TelegramDesktop"
     ProcessorArchitecture="ARCHITECTURE"
     Publisher="CN=536BC709-8EE1-4478-AF22-F0F0F26FF64A"
-    Version="1.9.1.0" />
+    Version="1.9.3.0" />
   <Properties>
     <DisplayName>Telegram Desktop</DisplayName>
     <PublisherDisplayName>Telegram FZ-LLC</PublisherDisplayName>
diff --git a/Telegram/SourceFiles/_other/updater.cpp b/Telegram/SourceFiles/_other/updater_win.cpp
similarity index 100%
rename from Telegram/SourceFiles/_other/updater.cpp
rename to Telegram/SourceFiles/_other/updater_win.cpp
diff --git a/Telegram/SourceFiles/api/api_self_destruct.cpp b/Telegram/SourceFiles/api/api_self_destruct.cpp
new file mode 100644
index 000000000..80ae25186
--- /dev/null
+++ b/Telegram/SourceFiles/api/api_self_destruct.cpp
@@ -0,0 +1,51 @@
+/*
+This file is part of Telegram Desktop,
+the official desktop application for the Telegram messaging service.
+
+For license and copyright information please follow this link:
+https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+*/
+#include "api/api_self_destruct.h"
+
+#include "apiwrap.h"
+
+namespace Api {
+
+SelfDestruct::SelfDestruct(not_null<ApiWrap*> api)
+: _api(api->instance()) {
+}
+
+void SelfDestruct::reload() {
+	if (_requestId) {
+		return;
+	}
+	_requestId = _api.request(MTPaccount_GetAccountTTL(
+	)).done([=](const MTPAccountDaysTTL &result) {
+		_requestId = 0;
+		result.match([&](const MTPDaccountDaysTTL &data) {
+			_days = data.vdays().v;
+		});
+	}).fail([=](const RPCError &error) {
+		_requestId = 0;
+	}).send();
+}
+
+rpl::producer<int> SelfDestruct::days() const {
+	using namespace rpl::mappers;
+
+	return _days.value() | rpl::filter(_1 != 0);
+}
+
+void SelfDestruct::update(int days) {
+	_api.request(_requestId).cancel();
+	_requestId = _api.request(MTPaccount_SetAccountTTL(
+		MTP_accountDaysTTL(MTP_int(days))
+	)).done([=](const MTPBool &result) {
+		_requestId = 0;
+	}).fail([=](const RPCError &result) {
+		_requestId = 0;
+	}).send();
+	_days = days;
+}
+
+} // namespace Api
diff --git a/Telegram/SourceFiles/api/api_self_destruct.h b/Telegram/SourceFiles/api/api_self_destruct.h
new file mode 100644
index 000000000..d9534a423
--- /dev/null
+++ b/Telegram/SourceFiles/api/api_self_destruct.h
@@ -0,0 +1,32 @@
+/*
+This file is part of Telegram Desktop,
+the official desktop application for the Telegram messaging service.
+
+For license and copyright information please follow this link:
+https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+*/
+#pragma once
+
+#include "mtproto/sender.h"
+
+class ApiWrap;
+
+namespace Api {
+
+class SelfDestruct final {
+public:
+	explicit SelfDestruct(not_null<ApiWrap*> api);
+
+	void reload();
+	void update(int days);
+
+	rpl::producer<int> days() const;
+
+private:
+	MTP::Sender _api;
+	mtpRequestId _requestId = 0;
+	rpl::variable<int> _days = 0;
+
+};
+
+} // namespace Api
diff --git a/Telegram/SourceFiles/api/api_sensitive_content.cpp b/Telegram/SourceFiles/api/api_sensitive_content.cpp
new file mode 100644
index 000000000..7ff3dd610
--- /dev/null
+++ b/Telegram/SourceFiles/api/api_sensitive_content.cpp
@@ -0,0 +1,74 @@
+/*
+This file is part of Telegram Desktop,
+the official desktop application for the Telegram messaging service.
+
+For license and copyright information please follow this link:
+https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+*/
+#include "api/api_sensitive_content.h"
+
+#include "apiwrap.h"
+#include "main/main_session.h"
+#include "main/main_account.h"
+#include "main/main_app_config.h"
+
+namespace Api {
+namespace {
+
+constexpr auto kRefreshAppConfigTimeout = 3 * crl::time(1000);
+
+} // namespace
+
+SensitiveContent::SensitiveContent(not_null<ApiWrap*> api)
+: _session(&api->session())
+, _api(api->instance())
+, _appConfigReloadTimer([=] { _session->account().appConfig().refresh(); }) {
+}
+
+void SensitiveContent::reload() {
+	if (_requestId) {
+		return;
+	}
+	_requestId = _api.request(MTPaccount_GetContentSettings(
+	)).done([=](const MTPaccount_ContentSettings &result) {
+		_requestId = 0;
+		result.match([&](const MTPDaccount_contentSettings &data) {
+			_enabled = data.is_sensitive_enabled();
+			_canChange = data.is_sensitive_can_change();
+		});
+	}).fail([=](const RPCError &error) {
+		_requestId = 0;
+	}).send();
+}
+
+bool SensitiveContent::enabledCurrent() const {
+	return _enabled.current();
+}
+
+rpl::producer<bool> SensitiveContent::enabled() const {
+	return _enabled.value();
+}
+
+rpl::producer<bool> SensitiveContent::canChange() const {
+	return _canChange.value();
+}
+
+void SensitiveContent::update(bool enabled) {
+	if (!_canChange.current()) {
+		return;
+	}
+	using Flag = MTPaccount_SetContentSettings::Flag;
+	_api.request(_requestId).cancel();
+	_requestId = _api.request(MTPaccount_SetContentSettings(
+		MTP_flags(enabled ? Flag::f_sensitive_enabled : Flag(0))
+	)).done([=](const MTPBool &result) {
+		_requestId = 0;
+	}).fail([=](const RPCError &error) {
+		_requestId = 0;
+	}).send();
+	_enabled = enabled;
+
+	_appConfigReloadTimer.callOnce(kRefreshAppConfigTimeout);
+}
+
+} // namespace Api
diff --git a/Telegram/SourceFiles/api/api_sensitive_content.h b/Telegram/SourceFiles/api/api_sensitive_content.h
new file mode 100644
index 000000000..0a61f9da7
--- /dev/null
+++ b/Telegram/SourceFiles/api/api_sensitive_content.h
@@ -0,0 +1,42 @@
+/*
+This file is part of Telegram Desktop,
+the official desktop application for the Telegram messaging service.
+
+For license and copyright information please follow this link:
+https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+*/
+#pragma once
+
+#include "mtproto/sender.h"
+#include "base/timer.h"
+
+class ApiWrap;
+
+namespace Main {
+class Session;
+} // namespace Main
+
+namespace Api {
+
+class SensitiveContent final {
+public:
+	explicit SensitiveContent(not_null<ApiWrap*> api);
+
+	void reload();
+	void update(bool enabled);
+
+	[[nodiscard]] bool enabledCurrent() const;
+	[[nodiscard]] rpl::producer<bool> enabled() const;
+	[[nodiscard]] rpl::producer<bool> canChange() const;
+
+private:
+	const not_null<Main::Session*> _session;
+	MTP::Sender _api;
+	mtpRequestId _requestId = 0;
+	rpl::variable<bool> _enabled = false;
+	rpl::variable<bool> _canChange = false;
+	base::Timer _appConfigReloadTimer;
+
+};
+
+} // namespace Api
diff --git a/Telegram/SourceFiles/apiwrap.cpp b/Telegram/SourceFiles/apiwrap.cpp
index b33afa76a..64a4432f1 100644
--- a/Telegram/SourceFiles/apiwrap.cpp
+++ b/Telegram/SourceFiles/apiwrap.cpp
@@ -8,6 +8,8 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "apiwrap.h"
 
 #include "api/api_text_entities.h"
+#include "api/api_self_destruct.h"
+#include "api/api_sensitive_content.h"
 #include "data/data_drafts.h"
 #include "data/data_photo.h"
 #include "data/data_web_page.h"
@@ -40,6 +42,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 //#include "history/feed/history_feed_section.h" // #feed
 #include "storage/localstorage.h"
 #include "main/main_session.h"
+#include "main/main_account.h"
 #include "boxes/confirm_box.h"
 #include "boxes/stickers_box.h"
 #include "boxes/sticker_set_box.h"
@@ -54,7 +57,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "ui/emoji_config.h"
 #include "support/support_helper.h"
 #include "storage/localimageloader.h"
-#include "storage/file_download.h"
+#include "storage/download_manager_mtproto.h"
 #include "storage/file_upload.h"
 #include "storage/storage_facade.h"
 #include "storage/storage_shared_media.h"
@@ -222,7 +225,8 @@ bool ApiWrap::BlockedUsersSlice::operator!=(const BlockedUsersSlice &other) cons
 }
 
 ApiWrap::ApiWrap(not_null<Main::Session*> session)
-: _session(session)
+: MTP::Sender(session->account().mtp())
+, _session(session)
 , _messageDataResolveDelayed([=] { resolveMessageDatas(); })
 , _webPagesTimer([=] { resolveWebPages(); })
 , _draftsSaveTimer([=] { saveDraftsToCloud(); })
@@ -231,7 +235,9 @@ ApiWrap::ApiWrap(not_null<Main::Session*> session)
 , _fileLoader(std::make_unique<TaskQueue>(kFileLoaderQueueStopTimeout))
 //, _feedReadTimer([=] { readFeeds(); }) // #feed
 , _proxyPromotionTimer([=] { refreshProxyPromotion(); })
-, _updateNotifySettingsTimer([=] { sendNotifySettingsUpdates(); }) {
+, _updateNotifySettingsTimer([=] { sendNotifySettingsUpdates(); })
+, _selfDestruct(std::make_unique<Api::SelfDestruct>(this))
+, _sensitiveContent(std::make_unique<Api::SensitiveContent>(this)) {
 	crl::on_main([=] {
 		// You can't use _session->lifetime() in the constructor,
 		// only queued, because it is not constructed yet.
@@ -244,6 +250,8 @@ ApiWrap::ApiWrap(not_null<Main::Session*> session)
 	});
 }
 
+ApiWrap::~ApiWrap() = default;
+
 Main::Session &ApiWrap::session() const {
 	return *_session;
 }
@@ -280,11 +288,11 @@ void ApiWrap::refreshProxyPromotion() {
 		return;
 	}
 	const auto key = [&]() -> std::pair<QString, uint32> {
-		if (Global::ProxySettings() != ProxyData::Settings::Enabled) {
+		if (Global::ProxySettings() != MTP::ProxyData::Settings::Enabled) {
 			return {};
 		}
 		const auto &proxy = Global::SelectedProxy();
-		if (proxy.type != ProxyData::Type::Mtproto) {
+		if (proxy.type != MTP::ProxyData::Type::Mtproto) {
 			return {};
 		}
 		return { proxy.host, proxy.port };
@@ -2971,12 +2979,12 @@ void ApiWrap::requestFileReference(
 
 void ApiWrap::refreshFileReference(
 		Data::FileOrigin origin,
-		not_null<mtpFileLoader*> loader,
+		not_null<Storage::DownloadMtprotoTask*> task,
 		int requestId,
 		const QByteArray &current) {
-	return refreshFileReference(origin, crl::guard(loader, [=](
+	return refreshFileReference(origin, crl::guard(task, [=](
 			const UpdatedFileReferences &data) {
-		loader->refreshFileReferenceFrom(data, requestId, current);
+		task->refreshFileReferenceFrom(data, requestId, current);
 	}));
 }
 
@@ -5798,42 +5806,12 @@ auto ApiWrap::blockedUsersSlice() -> rpl::producer<BlockedUsersSlice> {
 		: (_blockedUsersChanges.events() | rpl::type_erased());
 }
 
-void ApiWrap::reloadSelfDestruct() {
-	if (_selfDestructRequestId) {
-		return;
-	}
-	_selfDestructRequestId = request(MTPaccount_GetAccountTTL(
-	)).done([=](const MTPAccountDaysTTL &result) {
-		_selfDestructRequestId = 0;
-		result.match([&](const MTPDaccountDaysTTL &data) {
-			setSelfDestructDays(data.vdays().v);
-		});
-	}).fail([=](const RPCError &error) {
-		_selfDestructRequestId = 0;
-	}).send();
+Api::SelfDestruct &ApiWrap::selfDestruct() {
+	return *_selfDestruct;
 }
 
-rpl::producer<int> ApiWrap::selfDestructValue() const {
-	return _selfDestructDays
-		? _selfDestructChanges.events_starting_with_copy(*_selfDestructDays)
-		: (_selfDestructChanges.events() | rpl::type_erased());
-}
-
-void ApiWrap::saveSelfDestruct(int days) {
-	request(_selfDestructRequestId).cancel();
-	_selfDestructRequestId = request(MTPaccount_SetAccountTTL(
-		MTP_accountDaysTTL(MTP_int(days))
-	)).done([=](const MTPBool &result) {
-		_selfDestructRequestId = 0;
-	}).fail([=](const RPCError &result) {
-		_selfDestructRequestId = 0;
-	}).send();
-	setSelfDestructDays(days);
-}
-
-void ApiWrap::setSelfDestructDays(int days) {
-	_selfDestructDays = days;
-	_selfDestructChanges.fire_copy(days);
+Api::SensitiveContent &ApiWrap::sensitiveContent() {
+	return *_sensitiveContent;
 }
 
 void ApiWrap::createPoll(
@@ -6105,5 +6083,3 @@ void ApiWrap::sendReadRequest(not_null<PeerData*> peer, MsgId upTo) {
 	}();
 	_readRequests.emplace(peer, requestId, upTo);
 }
-
-ApiWrap::~ApiWrap() = default;
diff --git a/Telegram/SourceFiles/apiwrap.h b/Telegram/SourceFiles/apiwrap.h
index 0656d974b..0a57a619b 100644
--- a/Telegram/SourceFiles/apiwrap.h
+++ b/Telegram/SourceFiles/apiwrap.h
@@ -20,7 +20,6 @@ struct MessageGroupId;
 struct SendingAlbum;
 enum class SendMediaType;
 struct FileLoadTo;
-class mtpFileLoader;
 
 namespace Main {
 class Session;
@@ -38,6 +37,7 @@ class Result;
 namespace Storage {
 enum class SharedMediaType : signed char;
 struct PreparedList;
+class DownloadMtprotoTask;
 } // namespace Storage
 
 namespace Dialogs {
@@ -83,6 +83,9 @@ QString RequestKey(Types &&...values) {
 	return result;
 }
 
+class SelfDestruct;
+class SensitiveContent;
+
 } // namespace Api
 
 class ApiWrap : public MTP::Sender, private base::Subscriber {
@@ -131,6 +134,7 @@ public:
 	};
 
 	explicit ApiWrap(not_null<Main::Session*> session);
+	~ApiWrap();
 
 	Main::Session &session() const;
 
@@ -201,7 +205,7 @@ public:
 		FileReferencesHandler &&handler);
 	void refreshFileReference(
 		Data::FileOrigin origin,
-		not_null<mtpFileLoader*> loader,
+		not_null<Storage::DownloadMtprotoTask*> task,
 		int requestId,
 		const QByteArray &current);
 
@@ -465,9 +469,8 @@ public:
 	void reloadBlockedUsers();
 	rpl::producer<BlockedUsersSlice> blockedUsersSlice();
 
-	void reloadSelfDestruct();
-	rpl::producer<int> selfDestructValue() const;
-	void saveSelfDestruct(int days);
+	[[nodiscard]] Api::SelfDestruct &selfDestruct();
+	[[nodiscard]] Api::SensitiveContent &sensitiveContent();
 
 	void createPoll(
 		const PollData &data,
@@ -480,8 +483,6 @@ public:
 	void closePoll(not_null<HistoryItem*> item);
 	void reloadPollResults(not_null<HistoryItem*> item);
 
-	~ApiWrap();
-
 private:
 	struct MessageDataRequest {
 		using Callbacks = QList<RequestMessageDataCallback>;
@@ -679,8 +680,6 @@ private:
 		const QVector<MTPPrivacyRule> &rules);
 	void updatePrivacyLastSeens(const QVector<MTPPrivacyRule> &rules);
 
-	void setSelfDestructDays(int days);
-
 	void migrateDone(
 		not_null<PeerData*> peer,
 		not_null<ChannelData*> channel);
@@ -874,9 +873,8 @@ private:
 	std::optional<BlockedUsersSlice> _blockedUsersSlice;
 	rpl::event_stream<BlockedUsersSlice> _blockedUsersChanges;
 
-	mtpRequestId _selfDestructRequestId = 0;
-	std::optional<int> _selfDestructDays;
-	rpl::event_stream<int> _selfDestructChanges;
+	const std::unique_ptr<Api::SelfDestruct> _selfDestruct;
+	const std::unique_ptr<Api::SensitiveContent> _sensitiveContent;
 
 	base::flat_map<FullMsgId, mtpRequestId> _pollVotesRequestIds;
 	base::flat_map<FullMsgId, mtpRequestId> _pollCloseRequestIds;
diff --git a/Telegram/SourceFiles/boxes/add_contact_box.cpp b/Telegram/SourceFiles/boxes/add_contact_box.cpp
index ed831de5f..06e10fc37 100644
--- a/Telegram/SourceFiles/boxes/add_contact_box.cpp
+++ b/Telegram/SourceFiles/boxes/add_contact_box.cpp
@@ -203,7 +203,7 @@ void ShowAddParticipantsError(
 	Ui::show(Box<InformBox>(text), Ui::LayerOption::KeepOther);
 }
 
-class RevokePublicLinkBox::Inner : public TWidget, private MTP::Sender {
+class RevokePublicLinkBox::Inner : public TWidget {
 public:
 	Inner(
 		QWidget *parent,
@@ -228,6 +228,7 @@ private:
 	void updateSelected();
 
 	const not_null<Main::Session*> _session;
+	MTP::Sender _api;
 
 	PeerData *_selected = nullptr;
 	PeerData *_pressed = nullptr;
@@ -450,6 +451,7 @@ GroupInfoBox::GroupInfoBox(
 	const QString &title,
 	Fn<void(not_null<ChannelData*>)> channelDone)
 : _navigation(navigation)
+, _api(_navigation->session().api().instance())
 , _type(type)
 , _initialTitle(title)
 , _channelDone(std::move(channelDone)) {
@@ -569,7 +571,7 @@ void GroupInfoBox::createGroup(
 	if (inputs.empty()) {
 		return;
 	}
-	_creationRequestId = request(MTPmessages_CreateChat(
+	_creationRequestId = _api.request(MTPmessages_CreateChat(
 		MTP_vector<MTPInputUser>(inputs),
 		MTP_string(title)
 	)).done([=](const MTPUpdates &result) {
@@ -645,7 +647,7 @@ void GroupInfoBox::createChannel(const QString &title, const QString &descriptio
 	const auto flags = (_type == Type::Megagroup)
 		? MTPchannels_CreateChannel::Flag::f_megagroup
 		: MTPchannels_CreateChannel::Flag::f_broadcast;
-	_creationRequestId = request(MTPchannels_CreateChannel(
+	_creationRequestId = _api.request(MTPchannels_CreateChannel(
 		MTP_flags(flags),
 		MTP_string(title),
 		MTP_string(description),
@@ -682,7 +684,7 @@ void GroupInfoBox::createChannel(const QString &title, const QString &descriptio
 						std::move(image));
 				}
 				_createdChannel = channel;
-				_creationRequestId = request(MTPmessages_ExportChatInvite(
+				_creationRequestId = _api.request(MTPmessages_ExportChatInvite(
 					_createdChannel->input
 				)).done([=](const MTPExportedChatInvite &result) {
 					_creationRequestId = 0;
@@ -1287,6 +1289,7 @@ RevokePublicLinkBox::Inner::Inner(
 	Fn<void()> revokeCallback)
 : TWidget(parent)
 , _session(session)
+, _api(_session->api().instance())
 , _rowHeight(st::contactsPadding.top() + st::contactsPhotoSize + st::contactsPadding.bottom())
 , _revokeWidth(st::normalFont->width(tr::lng_channels_too_much_public_revoke(tr::now)))
 , _revokeCallback(std::move(revokeCallback)) {
@@ -1294,7 +1297,7 @@ RevokePublicLinkBox::Inner::Inner(
 
 	resize(width(), 5 * _rowHeight);
 
-	request(MTPchannels_GetAdminedPublicChannels(
+	_api.request(MTPchannels_GetAdminedPublicChannels(
 		MTP_flags(0)
 	)).done([=](const MTPmessages_Chats &result) {
 		const auto &chats = result.match([](const auto &data) {
@@ -1401,7 +1404,7 @@ void RevokePublicLinkBox::Inner::mouseReleaseEvent(QMouseEvent *e) {
 		auto confirmText = tr::lng_channels_too_much_public_revoke(tr::now);
 		_weakRevokeConfirmBox = Ui::show(Box<ConfirmBox>(text, confirmText, crl::guard(this, [this, pressed]() {
 			if (_revokeRequestId) return;
-			_revokeRequestId = request(MTPchannels_UpdateUsername(
+			_revokeRequestId = _api.request(MTPchannels_UpdateUsername(
 				pressed->asChannel()->inputChannel,
 				MTP_string()
 			)).done([=](const MTPBool &result) {
diff --git a/Telegram/SourceFiles/boxes/add_contact_box.h b/Telegram/SourceFiles/boxes/add_contact_box.h
index e97eff55e..488893da8 100644
--- a/Telegram/SourceFiles/boxes/add_contact_box.h
+++ b/Telegram/SourceFiles/boxes/add_contact_box.h
@@ -94,7 +94,7 @@ private:
 
 };
 
-class GroupInfoBox : public Ui::BoxContent, private MTP::Sender {
+class GroupInfoBox : public Ui::BoxContent {
 public:
 	enum class Type {
 		Group,
@@ -124,6 +124,7 @@ private:
 	void updateMaxHeight();
 
 	const not_null<Window::SessionNavigation*> _navigation;
+	MTP::Sender _api;
 
 	Type _type = Type::Group;
 	QString _initialTitle;
diff --git a/Telegram/SourceFiles/boxes/auto_download_box.cpp b/Telegram/SourceFiles/boxes/auto_download_box.cpp
index 21d44e0c2..6b4ff9d48 100644
--- a/Telegram/SourceFiles/boxes/auto_download_box.cpp
+++ b/Telegram/SourceFiles/boxes/auto_download_box.cpp
@@ -10,6 +10,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "lang/lang_keys.h"
 #include "main/main_session.h"
 #include "data/data_session.h"
+#include "data/data_auto_download.h"
 #include "ui/widgets/continuous_sliders.h"
 #include "ui/widgets/buttons.h"
 #include "ui/wrap/vertical_layout.h"
@@ -24,8 +25,53 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 namespace {
 
 constexpr auto kMegabyte = 1024 * 1024;
-constexpr auto kDefaultLimit = 10 * kMegabyte;
+constexpr auto kDefaultDownloadLimit = 10 * kMegabyte;
+constexpr auto kDefaultAutoPlayLimit = 50 * kMegabyte;
 
+using Type = Data::AutoDownload::Type;
+
+not_null<int*> AddSizeLimitSlider(
+		not_null<Ui::VerticalLayout*> container,
+		const base::flat_map<Type, int> &values,
+		int defaultValue) {
+	using namespace Settings;
+	using Pair = base::flat_map<Type, int>::value_type;
+
+	const auto limits = Ui::CreateChild<rpl::event_stream<int>>(
+		container.get());
+	const auto currentLimit = ranges::max_element(
+		values,
+		std::less<>(),
+		[](Pair pair) { return pair.second; })->second;
+	const auto initialLimit = currentLimit ? currentLimit : defaultValue;
+	const auto result = Ui::CreateChild<int>(container.get(), initialLimit);
+	AddButtonWithLabel(
+		container,
+		tr::lng_media_size_limit(),
+		limits->events_starting_with_copy(
+			initialLimit
+		) | rpl::map([](int value) {
+			return tr::lng_media_size_up_to(
+				tr::now,
+				lt_size,
+				QString::number(value / kMegabyte) + " MB");
+		}),
+		st::autoDownloadLimitButton
+	)->setAttribute(Qt::WA_TransparentForMouseEvents);
+	const auto slider = container->add(
+		object_ptr<Ui::MediaSlider>(container, st::autoDownloadLimitSlider),
+		st::autoDownloadLimitPadding);
+	slider->resize(st::autoDownloadLimitSlider.seekSize);
+	slider->setPseudoDiscrete(
+		Export::View::kSizeValueCount,
+		Export::View::SizeLimitByIndex,
+		*result,
+		[=](int value) {
+			*result = value;
+			limits->fire_copy(value);
+		});
+	return result;
+}
 } // namespace
 
 AutoDownloadBox::AutoDownloadBox(
@@ -41,12 +87,13 @@ void AutoDownloadBox::prepare() {
 }
 
 void AutoDownloadBox::setupContent() {
+	using namespace rpl::mappers;
 	using namespace Settings;
 	using namespace Data::AutoDownload;
-	using namespace rpl::mappers;
 	using Type = Data::AutoDownload::Type;
+	using Pair = base::flat_map<Type, int>::value_type;
 
-	setTitle(tr::lng_media_auto_title());
+	setTitle(tr::lng_profile_settings_section());
 
 	const auto settings = &_session->settings().autoDownload();
 	const auto checked = [=](Source source, Type type) {
@@ -59,17 +106,10 @@ void AutoDownloadBox::setupContent() {
 		this,
 		std::move(wrap)));
 
-	static const auto kHidden = {
-		Type::Video,
-		Type::Music,
-		Type::VoiceMessage
-	};
-
-	const auto values = Ui::CreateChild<base::flat_map<Type, int>>(content);
-	const auto add = [&](Type type, rpl::producer<QString> label) {
-		if (ranges::find(kHidden, type) != end(kHidden)) {
-			return;
-		}
+	const auto add = [&](
+			not_null<base::flat_map<Type, int>*> values,
+			Type type,
+			rpl::producer<QString> label) {
 		const auto value = settings->bytesLimit(_source, type);
 		AddButton(
 			content,
@@ -83,77 +123,78 @@ void AutoDownloadBox::setupContent() {
 		}, content->lifetime());
 		values->emplace(type, value);
 	};
-	add(Type::Photo, tr::lng_media_photo_title());
-	add(Type::VoiceMessage, tr::lng_media_audio_title());
-	add(Type::VideoMessage, tr::lng_media_video_messages_title());
-	add(Type::Video, tr::lng_media_video_title());
-	add(Type::File, tr::lng_media_file_title());
-	add(Type::Music, tr::lng_media_music_title());
-	add(Type::GIF, tr::lng_media_animation_title());
-
-	const auto limits = Ui::CreateChild<rpl::event_stream<int>>(content);
-	using Pair = base::flat_map<Type, int>::value_type;
-	const auto settingsLimit = ranges::max_element(
-		*values,
-		std::less<>(),
-		[](Pair pair) { return pair.second; })->second;
-	const auto initialLimit = settingsLimit ? settingsLimit : kDefaultLimit;
-	const auto limit = Ui::CreateChild<int>(content, initialLimit);
-	AddButtonWithLabel(
+
+	AddSubsectionTitle(content, tr::lng_media_auto_title());
+
+	const auto downloadValues = Ui::CreateChild<base::flat_map<Type, int>>(
+		content);
+	add(downloadValues, Type::Photo, tr::lng_media_photo_title());
+	add(downloadValues, Type::File, tr::lng_media_file_title());
+
+	const auto downloadLimit = AddSizeLimitSlider(
 		content,
-		tr::lng_media_size_limit(),
-		limits->events_starting_with_copy(
-			initialLimit
-		) | rpl::map([](int value) {
-			return tr::lng_media_size_up_to(
-				tr::now,
-				lt_size,
-				QString::number(value / kMegabyte) + " MB");
-		}),
-		st::autoDownloadLimitButton
-	)->setAttribute(Qt::WA_TransparentForMouseEvents);
-	const auto slider = content->add(
-		object_ptr<Ui::MediaSlider>(content, st::autoDownloadLimitSlider),
-		st::autoDownloadLimitPadding);
-	slider->resize(st::autoDownloadLimitSlider.seekSize);
-	slider->setPseudoDiscrete(
-		Export::View::kSizeValueCount,
-		Export::View::SizeLimitByIndex,
-		*limit,
-		[=](int value) {
-			*limit = value;
-			limits->fire_copy(value);
-		});
+		*downloadValues,
+		kDefaultDownloadLimit);
+
+	AddSkip(content);
+	AddSubsectionTitle(content, tr::lng_media_auto_play());
+
+	const auto autoPlayValues = Ui::CreateChild<base::flat_map<Type, int>>(
+		content);
+	add(
+		autoPlayValues,
+		Type::AutoPlayVideoMessage,
+		tr::lng_media_video_messages_title());
+	add(autoPlayValues, Type::AutoPlayVideo, tr::lng_media_video_title());
+	add(autoPlayValues, Type::AutoPlayGIF, tr::lng_media_animation_title());
+
+	const auto autoPlayLimit = AddSizeLimitSlider(
+		content,
+		*autoPlayValues,
+		kDefaultAutoPlayLimit);
+
+	const auto limitByType = [=](Type type) {
+		return (ranges::find(kAutoPlayTypes, type) != end(kAutoPlayTypes))
+			? *autoPlayLimit
+			: *downloadLimit;
+	};
 
 	addButton(tr::lng_connection_save(), [=] {
-		auto allowMore = ranges::view::all(
-			*values
-		) | ranges::view::filter([&](Pair pair) {
+		auto &&values = ranges::view::concat(
+			*downloadValues,
+			*autoPlayValues);
+		auto allowMore = values | ranges::view::filter([&](Pair pair) {
 			const auto [type, enabled] = pair;
-			const auto value = enabled ? *limit : 0;
+			const auto value = enabled ? limitByType(type) : 0;
 			const auto old = settings->bytesLimit(_source, type);
 			return (old < value);
 		}) | ranges::view::transform([](Pair pair) {
 			return pair.first;
 		});
+		const auto less = ranges::find_if(*autoPlayValues, [&](Pair pair) {
+			const auto [type, enabled] = pair;
+			const auto value = enabled ? limitByType(type) : 0;
+			return value < settings->bytesLimit(_source, type);
+		}) != end(*autoPlayValues);
 		const auto allowMoreTypes = base::flat_set<Type>(
 			allowMore.begin(),
 			allowMore.end());
 
-		const auto changed = ranges::find_if(*values, [&](Pair pair) {
+		const auto changed = ranges::find_if(values, [&](Pair pair) {
 			const auto [type, enabled] = pair;
-			const auto value = enabled ? *limit : 0;
-			return settings->bytesLimit(_source, type) != value;
-		}) != end(*values);
+			const auto value = enabled ? limitByType(type) : 0;
+			return value != settings->bytesLimit(_source, type);
+		}) != end(values);
 
+		const auto &kHidden = kStreamedTypes;
 		const auto hiddenChanged = ranges::find_if(kHidden, [&](Type type) {
 			const auto now = settings->bytesLimit(_source, type);
-			return (now > 0) && (now != *limit);
+			return (now > 0) && (now != limitByType(type));
 		}) != end(kHidden);
 
 		if (changed) {
-			for (const auto [type, enabled] : *values) {
-				const auto value = enabled ? *limit : 0;
+			for (const auto [type, enabled] : values) {
+				const auto value = enabled ? limitByType(type) : 0;
 				settings->setBytesLimit(_source, type, value);
 			}
 		}
@@ -161,7 +202,10 @@ void AutoDownloadBox::setupContent() {
 			for (const auto type : kHidden) {
 				const auto now = settings->bytesLimit(_source, type);
 				if (now > 0) {
-					settings->setBytesLimit(_source, type, *limit);
+					settings->setBytesLimit(
+						_source,
+						type,
+						limitByType(type));
 				}
 			}
 		}
@@ -175,6 +219,9 @@ void AutoDownloadBox::setupContent() {
 			!= allowMoreTypes.end()) {
 			_session->data().documentLoadSettingsChanged();
 		}
+		if (less) {
+			_session->data().checkPlayingVideoFiles();
+		}
 		closeBox();
 	});
 	addButton(tr::lng_cancel(), [=] { closeBox(); });
diff --git a/Telegram/SourceFiles/boxes/background_box.cpp b/Telegram/SourceFiles/boxes/background_box.cpp
index 9d91c177a..f69aac5db 100644
--- a/Telegram/SourceFiles/boxes/background_box.cpp
+++ b/Telegram/SourceFiles/boxes/background_box.cpp
@@ -53,10 +53,7 @@ QImage TakeMiddleSample(QImage original, QSize size) {
 
 } // namespace
 
-class BackgroundBox::Inner
-	: public Ui::RpWidget
-	, private MTP::Sender
-	, private base::Subscriber {
+class BackgroundBox::Inner : public Ui::RpWidget, private base::Subscriber {
 public:
 	Inner(
 		QWidget *parent,
@@ -114,6 +111,7 @@ private:
 	void validatePaperThumbnail(const Paper &paper) const;
 
 	const not_null<Main::Session*> _session;
+	MTP::Sender _api;
 
 	std::vector<Paper> _papers;
 
@@ -185,6 +183,7 @@ BackgroundBox::Inner::Inner(
 	not_null<Main::Session*> session)
 : RpWidget(parent)
 , _session(session)
+, _api(_session->api().instance())
 , _check(std::make_unique<Ui::RoundCheckbox>(st::overviewCheck, [=] { update(); })) {
 	_check->setChecked(true, Ui::RoundCheckbox::SetStyle::Fast);
 	if (_session->data().wallpapers().empty()) {
@@ -209,7 +208,7 @@ BackgroundBox::Inner::Inner(
 }
 
 void BackgroundBox::Inner::requestPapers() {
-	request(MTPaccount_GetWallPapers(
+	_api.request(MTPaccount_GetWallPapers(
 		MTP_int(_session->data().wallpapersHash())
 	)).done([=](const MTPaccount_WallPapers &result) {
 		if (_session->data().updateWallpapers(result)) {
diff --git a/Telegram/SourceFiles/boxes/background_preview_box.cpp b/Telegram/SourceFiles/boxes/background_preview_box.cpp
index 61c3a1c05..e72908a01 100644
--- a/Telegram/SourceFiles/boxes/background_preview_box.cpp
+++ b/Telegram/SourceFiles/boxes/background_preview_box.cpp
@@ -716,6 +716,9 @@ void BackgroundPreviewBox::checkLoadedDocument() {
 		return;
 	}
 	const auto generateCallback = [=](QImage &&image) {
+		if (image.isNull()) {
+			return;
+		}
 		crl::async([
 			this,
 			image = std::move(image),
diff --git a/Telegram/SourceFiles/boxes/calendar_box.cpp b/Telegram/SourceFiles/boxes/calendar_box.cpp
index 25bbbfe79..48cfdd794 100644
--- a/Telegram/SourceFiles/boxes/calendar_box.cpp
+++ b/Telegram/SourceFiles/boxes/calendar_box.cpp
@@ -7,6 +7,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 */
 #include "boxes/calendar_box.h"
 
+#include "mtproto/mtproto_rpc_sender.h"
 #include "ui/widgets/buttons.h"
 #include "lang/lang_keys.h"
 #include "ui/effects/ripple_animation.h"
diff --git a/Telegram/SourceFiles/boxes/confirm_box.cpp b/Telegram/SourceFiles/boxes/confirm_box.cpp
index 402facdc0..c8b6efcd2 100644
--- a/Telegram/SourceFiles/boxes/confirm_box.cpp
+++ b/Telegram/SourceFiles/boxes/confirm_box.cpp
@@ -30,6 +30,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "data/data_channel.h"
 #include "data/data_chat.h"
 #include "data/data_user.h"
+#include "data/data_file_origin.h"
 #include "base/unixtime.h"
 #include "main/main_session.h"
 #include "observer_peer.h"
diff --git a/Telegram/SourceFiles/boxes/confirm_box.h b/Telegram/SourceFiles/boxes/confirm_box.h
index 07c4971c0..d3c53edda 100644
--- a/Telegram/SourceFiles/boxes/confirm_box.h
+++ b/Telegram/SourceFiles/boxes/confirm_box.h
@@ -8,6 +8,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #pragma once
 
 #include "boxes/abstract_box.h"
+#include "mtproto/mtproto_rpc_sender.h"
 
 namespace Main {
 class Session;
diff --git a/Telegram/SourceFiles/boxes/confirm_phone_box.cpp b/Telegram/SourceFiles/boxes/confirm_phone_box.cpp
index 8e4b8bf48..6cd1a62e2 100644
--- a/Telegram/SourceFiles/boxes/confirm_phone_box.cpp
+++ b/Telegram/SourceFiles/boxes/confirm_phone_box.cpp
@@ -19,6 +19,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "numbers.h"
 #include "app.h"
 #include "lang/lang_keys.h"
+#include "mtproto/facade.h"
 #include "styles/style_layers.h"
 #include "styles/style_boxes.h"
 
diff --git a/Telegram/SourceFiles/boxes/confirm_phone_box.h b/Telegram/SourceFiles/boxes/confirm_phone_box.h
index d2963f960..398b8062f 100644
--- a/Telegram/SourceFiles/boxes/confirm_phone_box.h
+++ b/Telegram/SourceFiles/boxes/confirm_phone_box.h
@@ -10,6 +10,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "boxes/abstract_box.h"
 #include "base/timer.h"
 #include "ui/widgets/input_fields.h"
+#include "mtproto/mtproto_rpc_sender.h"
 
 namespace Ui {
 class InputField;
diff --git a/Telegram/SourceFiles/boxes/connection_box.cpp b/Telegram/SourceFiles/boxes/connection_box.cpp
index e67b894c3..a96648e17 100644
--- a/Telegram/SourceFiles/boxes/connection_box.cpp
+++ b/Telegram/SourceFiles/boxes/connection_box.cpp
@@ -14,6 +14,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "base/call_delayed.h"
 #include "core/application.h"
 #include "main/main_account.h"
+#include "mtproto/facade.h"
 #include "ui/widgets/checkbox.h"
 #include "ui/widgets/buttons.h"
 #include "ui/widgets/input_fields.h"
@@ -38,6 +39,8 @@ namespace {
 
 constexpr auto kSaveSettingsDelayedTimeout = crl::time(1000);
 
+using ProxyData = MTP::ProxyData;
+
 class Base64UrlInput : public Ui::MaskedInputField {
 public:
 	Base64UrlInput(
@@ -1057,7 +1060,7 @@ void ProxiesBoxController::refreshChecker(Item &item) {
 
 	item.state = ItemState::Checking;
 	const auto setup = [&](Checker &checker, const bytes::vector &secret) {
-		checker = MTP::internal::AbstractConnection::Create(
+		checker = MTP::details::AbstractConnection::Create(
 			mtproto,
 			type,
 			QThread::currentThread(),
@@ -1105,7 +1108,7 @@ void ProxiesBoxController::refreshChecker(Item &item) {
 }
 
 void ProxiesBoxController::setupChecker(int id, const Checker &checker) {
-	using Connection = MTP::internal::AbstractConnection;
+	using Connection = MTP::details::AbstractConnection;
 	const auto pointer = checker.get();
 	pointer->connect(pointer, &Connection::connected, [=] {
 		const auto item = findById(id);
@@ -1148,7 +1151,7 @@ object_ptr<Ui::BoxContent> ProxiesBoxController::create() {
 	for (const auto &item : _list) {
 		updateView(item);
 	}
-	return std::move(result);
+	return result;
 }
 
 auto ProxiesBoxController::findById(int id) -> std::vector<Item>::iterator {
diff --git a/Telegram/SourceFiles/boxes/connection_box.h b/Telegram/SourceFiles/boxes/connection_box.h
index 37e7040f2..fbefdacb5 100644
--- a/Telegram/SourceFiles/boxes/connection_box.h
+++ b/Telegram/SourceFiles/boxes/connection_box.h
@@ -10,6 +10,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "base/timer.h"
 #include "base/object_ptr.h"
 #include "mtproto/connection_abstract.h"
+#include "mtproto/mtproto_proxy_data.h"
 
 namespace Ui {
 class BoxContent;
@@ -25,6 +26,7 @@ class Radioenum;
 
 class ProxiesBoxController : public base::Subscriber {
 public:
+	using ProxyData = MTP::ProxyData;
 	using Type = ProxyData::Type;
 
 	ProxiesBoxController();
@@ -73,7 +75,7 @@ public:
 	~ProxiesBoxController();
 
 private:
-	using Checker = MTP::internal::ConnectionPointer;
+	using Checker = MTP::details::ConnectionPointer;
 	struct Item {
 		int id = 0;
 		ProxyData data;
diff --git a/Telegram/SourceFiles/boxes/create_poll_box.cpp b/Telegram/SourceFiles/boxes/create_poll_box.cpp
index ad9a1db47..11d44d311 100644
--- a/Telegram/SourceFiles/boxes/create_poll_box.cpp
+++ b/Telegram/SourceFiles/boxes/create_poll_box.cpp
@@ -768,7 +768,7 @@ object_ptr<Ui::RpWidget> CreatePollBox::setupContent() {
 		FocusAtEnd(question);
 	}, lifetime());
 
-	return std::move(result);
+	return result;
 }
 
 void CreatePollBox::prepare() {
diff --git a/Telegram/SourceFiles/boxes/edit_caption_box.h b/Telegram/SourceFiles/boxes/edit_caption_box.h
index 14e7cd5c3..d5136afb4 100644
--- a/Telegram/SourceFiles/boxes/edit_caption_box.h
+++ b/Telegram/SourceFiles/boxes/edit_caption_box.h
@@ -11,6 +11,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "storage/storage_media_prepare.h"
 #include "ui/wrap/slide_wrap.h"
 #include "media/clip/media_clip_reader.h"
+#include "mtproto/mtproto_rpc_sender.h"
 
 namespace ChatHelpers {
 class TabbedPanel;
diff --git a/Telegram/SourceFiles/boxes/edit_privacy_box.h b/Telegram/SourceFiles/boxes/edit_privacy_box.h
index 1060157fd..4310d1b51 100644
--- a/Telegram/SourceFiles/boxes/edit_privacy_box.h
+++ b/Telegram/SourceFiles/boxes/edit_privacy_box.h
@@ -100,7 +100,7 @@ private:
 
 };
 
-class EditPrivacyBox : public Ui::BoxContent, private MTP::Sender {
+class EditPrivacyBox : public Ui::BoxContent {
 public:
 	using Value = ApiWrap::Privacy;
 	using Option = Value::Option;
diff --git a/Telegram/SourceFiles/boxes/passcode_box.cpp b/Telegram/SourceFiles/boxes/passcode_box.cpp
index 19f3d2f2e..8a9ed9318 100644
--- a/Telegram/SourceFiles/boxes/passcode_box.cpp
+++ b/Telegram/SourceFiles/boxes/passcode_box.cpp
@@ -12,6 +12,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "boxes/confirm_box.h"
 #include "boxes/confirm_phone_box.h"
 #include "mainwindow.h"
+#include "apiwrap.h"
 #include "main/main_session.h"
 #include "storage/localstorage.h"
 #include "ui/widgets/buttons.h"
@@ -47,6 +48,7 @@ PasscodeBox::PasscodeBox(
 	not_null<Main::Session*> session,
 	bool turningOff)
 : _session(session)
+, _api(_session->api().instance())
 , _turningOff(turningOff)
 , _about(st::boxWidth - st::boxPadding.left() * 1.5)
 , _oldPasscode(this, st::defaultInputField, tr::lng_passcode_enter_old())
@@ -62,6 +64,7 @@ PasscodeBox::PasscodeBox(
 	not_null<Main::Session*> session,
 	const CloudFields &fields)
 : _session(session)
+, _api(_session->api().instance())
 , _turningOff(fields.turningOff)
 , _cloudPwd(true)
 , _cloudFields(fields)
@@ -357,7 +360,7 @@ void PasscodeBox::validateEmail(
 		if (_setRequest) {
 			return;
 		}
-		_setRequest = request(MTPaccount_ConfirmPasswordEmail(
+		_setRequest = _api.request(MTPaccount_ConfirmPasswordEmail(
 			MTP_string(code)
 		)).done([=](const MTPBool &result) {
 			*set = true;
@@ -387,7 +390,7 @@ void PasscodeBox::validateEmail(
 		if (_setRequest) {
 			return;
 		}
-		_setRequest = request(MTPaccount_ResendPasswordEmail(
+		_setRequest = _api.request(MTPaccount_ResendPasswordEmail(
 		)).done([=](const MTPBool &result) {
 			_setRequest = 0;
 			resent->fire(tr::lng_cloud_password_resent(tr::now));
@@ -597,8 +600,8 @@ void PasscodeBox::requestPasswordData() {
 		return serverError();
 	}
 
-	request(base::take(_setRequest)).cancel();
-	_setRequest = request(
+	_api.request(base::take(_setRequest)).cancel();
+	_setRequest = _api.request(
 		MTPaccount_GetPassword()
 	).done([=](const MTPaccount_Password &result) {
 		_setRequest = 0;
@@ -636,7 +639,7 @@ void PasscodeBox::sendClearCloudPassword(
 		| MTPDaccount_passwordInputSettings::Flag::f_new_password_hash
 		| MTPDaccount_passwordInputSettings::Flag::f_hint
 		| MTPDaccount_passwordInputSettings::Flag::f_email;
-	_setRequest = request(MTPaccount_UpdatePasswordSettings(
+	_setRequest = _api.request(MTPaccount_UpdatePasswordSettings(
 		check.result,
 		MTP_account_passwordInputSettings(
 			MTP_flags(flags),
@@ -667,7 +670,7 @@ void PasscodeBox::setNewCloudPassword(const QString &newPassword) {
 		| MTPDaccount_passwordInputSettings::Flag::f_hint
 		| MTPDaccount_passwordInputSettings::Flag::f_email;
 	_checkPasswordCallback = nullptr;
-	_setRequest = request(MTPaccount_UpdatePasswordSettings(
+	_setRequest = _api.request(MTPaccount_UpdatePasswordSettings(
 		MTP_inputCheckPasswordEmpty(),
 		MTP_account_passwordInputSettings(
 			MTP_flags(flags),
@@ -695,7 +698,7 @@ void PasscodeBox::changeCloudPassword(
 		const QString &oldPassword,
 		const Core::CloudPasswordResult &check,
 		const QString &newPassword) {
-	_setRequest = request(MTPaccount_GetPasswordSettings(
+	_setRequest = _api.request(MTPaccount_GetPasswordSettings(
 		check.result
 	)).done([=](const MTPaccount_PasswordSettings &result) {
 		_setRequest = 0;
@@ -760,7 +763,7 @@ void PasscodeBox::resetSecret(
 		const QString &newPassword,
 		Fn<void()> callback) {
 	using Flag = MTPDaccount_passwordInputSettings::Flag;
-	_setRequest = request(MTPaccount_UpdatePasswordSettings(
+	_setRequest = _api.request(MTPaccount_UpdatePasswordSettings(
 		check.result,
 		MTP_account_passwordInputSettings(
 			MTP_flags(Flag::f_new_secure_settings),
@@ -814,7 +817,7 @@ void PasscodeBox::sendChangeCloudPassword(
 				_cloudFields.newSecureSecretAlgo,
 				bytes::make_span(newPasswordBytes)));
 	}
-	_setRequest = request(MTPaccount_UpdatePasswordSettings(
+	_setRequest = _api.request(MTPaccount_UpdatePasswordSettings(
 		check.result,
 		MTP_account_passwordInputSettings(
 			MTP_flags(flags),
@@ -873,7 +876,7 @@ void PasscodeBox::emailChanged() {
 void PasscodeBox::recoverByEmail() {
 	if (_pattern.isEmpty()) {
 		_pattern = "-";
-		request(MTPauth_RequestPasswordRecovery(
+		_api.request(MTPauth_RequestPasswordRecovery(
 		)).done([=](const MTPauth_PasswordRecovery &result) {
 			recoverStarted(result);
 		}).fail([=](const RPCError &error) {
diff --git a/Telegram/SourceFiles/boxes/passcode_box.h b/Telegram/SourceFiles/boxes/passcode_box.h
index a8ad5ea8c..03ab68f87 100644
--- a/Telegram/SourceFiles/boxes/passcode_box.h
+++ b/Telegram/SourceFiles/boxes/passcode_box.h
@@ -25,7 +25,7 @@ namespace Core {
 struct CloudPasswordState;
 } // namespace Core
 
-class PasscodeBox : public Ui::BoxContent, private MTP::Sender {
+class PasscodeBox : public Ui::BoxContent {
 public:
 	PasscodeBox(QWidget*, not_null<Main::Session*> session, bool turningOff);
 
@@ -130,6 +130,7 @@ private:
 	void serverError();
 
 	const not_null<Main::Session*> _session;
+	MTP::Sender _api;
 
 	QString _pattern;
 
diff --git a/Telegram/SourceFiles/boxes/peer_list_box.cpp b/Telegram/SourceFiles/boxes/peer_list_box.cpp
index 33721e8e4..2ecddf4bc 100644
--- a/Telegram/SourceFiles/boxes/peer_list_box.cpp
+++ b/Telegram/SourceFiles/boxes/peer_list_box.cpp
@@ -1313,7 +1313,6 @@ void PeerListContent::loadProfilePhotos() {
 
 	auto yFrom = _visibleTop;
 	auto yTo = _visibleBottom + (_visibleBottom - _visibleTop) * PreloadHeightsCount;
-	_controller->session().downloader().clearPriorities();
 
 	if (yTo < 0) return;
 	if (yFrom < 0) yFrom = 0;
diff --git a/Telegram/SourceFiles/boxes/peer_list_controllers.cpp b/Telegram/SourceFiles/boxes/peer_list_controllers.cpp
index 190c2f372..606ecc4f4 100644
--- a/Telegram/SourceFiles/boxes/peer_list_controllers.cpp
+++ b/Telegram/SourceFiles/boxes/peer_list_controllers.cpp
@@ -142,7 +142,8 @@ void PeerListRowWithLink::paintAction(
 
 PeerListGlobalSearchController::PeerListGlobalSearchController(
 	not_null<Window::SessionNavigation*> navigation)
-: _navigation(navigation) {
+: _navigation(navigation)
+, _api(_navigation->session().api().instance()) {
 	_timer.setCallback([this] { searchOnServer(); });
 }
 
@@ -169,7 +170,7 @@ bool PeerListGlobalSearchController::searchInCache() {
 }
 
 void PeerListGlobalSearchController::searchOnServer() {
-	_requestId = request(MTPcontacts_Search(
+	_requestId = _api.request(MTPcontacts_Search(
 		MTP_string(_query),
 		MTP_int(SearchPeopleLimit)
 	)).done([=](const MTPcontacts_Found &result, mtpRequestId requestId) {
diff --git a/Telegram/SourceFiles/boxes/peer_list_controllers.h b/Telegram/SourceFiles/boxes/peer_list_controllers.h
index ddc4ba4f8..a1a52e701 100644
--- a/Telegram/SourceFiles/boxes/peer_list_controllers.h
+++ b/Telegram/SourceFiles/boxes/peer_list_controllers.h
@@ -59,9 +59,7 @@ private:
 
 };
 
-class PeerListGlobalSearchController
-	: public PeerListSearchController
-	, private MTP::Sender {
+class PeerListGlobalSearchController : public PeerListSearchController {
 public:
 	PeerListGlobalSearchController(
 		not_null<Window::SessionNavigation*> navigation);
@@ -78,6 +76,7 @@ private:
 	void searchDone(const MTPcontacts_Found &result, mtpRequestId requestId);
 
 	const not_null<Window::SessionNavigation*> _navigation;
+	MTP::Sender _api;
 	base::Timer _timer;
 	QString _query;
 	mtpRequestId _requestId = 0;
diff --git a/Telegram/SourceFiles/boxes/peers/add_participants_box.cpp b/Telegram/SourceFiles/boxes/peers/add_participants_box.cpp
index 08c95bc72..ff7d2c3d1 100644
--- a/Telegram/SourceFiles/boxes/peers/add_participants_box.cpp
+++ b/Telegram/SourceFiles/boxes/peers/add_participants_box.cpp
@@ -276,6 +276,7 @@ AddSpecialBoxController::AddSpecialBoxController(
 	peer,
 	&_additional))
 , _peer(peer)
+, _api(_peer->session().api().instance())
 , _role(role)
 , _additional(peer, Role::Members)
 , _adminDoneCallback(std::move(adminDoneCallback))
@@ -408,7 +409,7 @@ void AddSpecialBoxController::loadMoreRows() {
 	const auto participantsHash = 0;
 	const auto channel = _peer->asChannel();
 
-	_loadRequestId = request(MTPchannels_GetParticipants(
+	_loadRequestId = _api.request(MTPchannels_GetParticipants(
 		channel->inputChannel,
 		MTP_channelParticipantsRecent(),
 		MTP_int(_offset),
@@ -464,7 +465,7 @@ bool AddSpecialBoxController::checkInfoLoaded(
 
 	// We don't know what this user status is in the group.
 	const auto channel = _peer->asChannel();
-	request(MTPchannels_GetParticipant(
+	_api.request(MTPchannels_GetParticipant(
 		channel->inputChannel,
 		user->inputUser
 	)).done([=](const MTPchannels_ChannelParticipant &result) {
@@ -829,6 +830,7 @@ AddSpecialBoxSearchController::AddSpecialBoxSearchController(
 	not_null<ParticipantsAdditionalData*> additional)
 : _peer(peer)
 , _additional(additional)
+, _api(_peer->session().api().instance())
 , _timer([=] { searchOnServer(); }) {
 	subscribeToMigration();
 }
@@ -924,7 +926,7 @@ void AddSpecialBoxSearchController::requestParticipants() {
 	const auto participantsHash = 0;
 	const auto channel = _peer->asChannel();
 
-	_requestId = request(MTPchannels_GetParticipants(
+	_requestId = _api.request(MTPchannels_GetParticipants(
 		channel->inputChannel,
 		MTP_channelParticipantsSearch(MTP_string(_query)),
 		MTP_int(_offset),
@@ -1012,7 +1014,7 @@ void AddSpecialBoxSearchController::requestGlobal() {
 	}
 
 	auto perPage = SearchPeopleLimit;
-	_requestId = request(MTPcontacts_Search(
+	_requestId = _api.request(MTPcontacts_Search(
 		MTP_string(_query),
 		MTP_int(perPage)
 	)).done([=](const MTPcontacts_Found &result, mtpRequestId requestId) {
diff --git a/Telegram/SourceFiles/boxes/peers/add_participants_box.h b/Telegram/SourceFiles/boxes/peers/add_participants_box.h
index d15f474e8..2761d172d 100644
--- a/Telegram/SourceFiles/boxes/peers/add_participants_box.h
+++ b/Telegram/SourceFiles/boxes/peers/add_participants_box.h
@@ -69,7 +69,6 @@ private:
 class AddSpecialBoxController
 	: public PeerListController
 	, private base::Subscriber
-	, private MTP::Sender
 	, public base::has_weak_ptr {
 public:
 	using Role = ParticipantsBoxController::Role;
@@ -87,12 +86,12 @@ public:
 		AdminDoneCallback adminDoneCallback,
 		BannedDoneCallback bannedDoneCallback);
 
-	Main::Session &session() const override;
+	[[nodiscard]] Main::Session &session() const override;
 	void prepare() override;
 	void rowClicked(not_null<PeerListRow*> row) override;
 	void loadMoreRows() override;
 
-	std::unique_ptr<PeerListRow> createSearchRow(
+	[[nodiscard]] std::unique_ptr<PeerListRow> createSearchRow(
 		not_null<PeerData*> peer) override;
 
 private:
@@ -120,6 +119,7 @@ private:
 	void migrate(not_null<ChannelData*> channel);
 
 	not_null<PeerData*> _peer;
+	MTP::Sender _api;
 	Role _role = Role::Admins;
 	int _offset = 0;
 	mtpRequestId _loadRequestId = 0;
@@ -139,7 +139,6 @@ protected:
 // Finds chat/channel members, then contacts, then global search results.
 class AddSpecialBoxSearchController
 	: public PeerListSearchController
-	, private MTP::Sender
 	, private base::Subscriber {
 public:
 	using Role = ParticipantsBoxController::Role;
@@ -181,6 +180,7 @@ private:
 
 	not_null<PeerData*> _peer;
 	not_null<ParticipantsAdditionalData*> _additional;
+	MTP::Sender _api;
 
 	base::Timer _timer;
 	QString _query;
diff --git a/Telegram/SourceFiles/boxes/peers/edit_linked_chat_box.cpp b/Telegram/SourceFiles/boxes/peers/edit_linked_chat_box.cpp
index d490a38f4..cc55265a8 100644
--- a/Telegram/SourceFiles/boxes/peers/edit_linked_chat_box.cpp
+++ b/Telegram/SourceFiles/boxes/peers/edit_linked_chat_box.cpp
@@ -223,7 +223,7 @@ object_ptr<Ui::RpWidget> SetupAbout(
 			tr::now,
 			Ui::Text::WithEntities);
 	}());
-	return std::move(about);
+	return about;
 }
 
 object_ptr<Ui::RpWidget> SetupFooter(
diff --git a/Telegram/SourceFiles/boxes/peers/edit_participant_box.h b/Telegram/SourceFiles/boxes/peers/edit_participant_box.h
index 7ef9e877e..689b08a7b 100644
--- a/Telegram/SourceFiles/boxes/peers/edit_participant_box.h
+++ b/Telegram/SourceFiles/boxes/peers/edit_participant_box.h
@@ -10,6 +10,8 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "boxes/abstract_box.h"
 #include "base/unique_qptr.h"
 
+class RPCError;
+
 namespace Ui {
 class FlatLabel;
 class LinkButton;
diff --git a/Telegram/SourceFiles/boxes/peers/edit_participants_box.cpp b/Telegram/SourceFiles/boxes/peers/edit_participants_box.cpp
index af2cedbfe..afe9af512 100644
--- a/Telegram/SourceFiles/boxes/peers/edit_participants_box.cpp
+++ b/Telegram/SourceFiles/boxes/peers/edit_participants_box.cpp
@@ -750,6 +750,7 @@ ParticipantsBoxController::ParticipantsBoxController(
 : PeerListController(CreateSearchController(peer, role, &_additional))
 , _navigation(navigation)
 , _peer(peer)
+, _api(_peer->session().api().instance())
 , _role(role)
 , _additional(peer, _role) {
 	subscribeToMigration();
@@ -1029,7 +1030,7 @@ void ParticipantsBoxController::restoreState(
 		: nullptr;
 	if (const auto my = dynamic_cast<SavedState*>(typeErasedState)) {
 		if (const auto requestId = base::take(_loadRequestId)) {
-			request(requestId).cancel();
+			_api.request(requestId).cancel();
 		}
 
 		_additional = std::move(my->additional);
@@ -1260,7 +1261,7 @@ void ParticipantsBoxController::loadMoreRows() {
 		: kParticipantsFirstPageCount;
 	const auto participantsHash = 0;
 
-	_loadRequestId = request(MTPchannels_GetParticipants(
+	_loadRequestId = _api.request(MTPchannels_GetParticipants(
 		channel->inputChannel,
 		filter,
 		MTP_int(_offset),
@@ -1797,7 +1798,7 @@ std::unique_ptr<PeerListRow> ParticipantsBoxController::createRow(
 			row->setActionLink(tr::lng_profile_kick(tr::now));
 		}
 	}
-	return std::move(row);
+	return row;
 }
 
 auto ParticipantsBoxController::computeType(
@@ -1920,7 +1921,8 @@ ParticipantsBoxSearchController::ParticipantsBoxSearchController(
 	not_null<ParticipantsAdditionalData*> additional)
 : _channel(channel)
 , _role(role)
-, _additional(additional) {
+, _additional(additional)
+, _api(_channel->session().api().instance()) {
 	_timer.setCallback([=] { searchOnServer(); });
 }
 
@@ -1945,14 +1947,14 @@ auto ParticipantsBoxSearchController::saveState() const
 	result->offset = _offset;
 	result->allLoaded = _allLoaded;
 	result->wasLoading = (_requestId != 0);
-	return std::move(result);
+	return result;
 }
 
 void ParticipantsBoxSearchController::restoreState(
 		std::unique_ptr<SavedStateBase> state) {
 	if (auto my = dynamic_cast<SavedState*>(state.get())) {
 		if (auto requestId = base::take(_requestId)) {
-			request(requestId).cancel();
+			_api.request(requestId).cancel();
 		}
 		_cache.clear();
 		_queries.clear();
@@ -2017,7 +2019,7 @@ bool ParticipantsBoxSearchController::loadMoreRows() {
 	auto perPage = kParticipantsPerPage;
 	auto participantsHash = 0;
 
-	_requestId = request(MTPchannels_GetParticipants(
+	_requestId = _api.request(MTPchannels_GetParticipants(
 		_channel->inputChannel,
 		filter,
 		MTP_int(_offset),
diff --git a/Telegram/SourceFiles/boxes/peers/edit_participants_box.h b/Telegram/SourceFiles/boxes/peers/edit_participants_box.h
index db271a3aa..0e958751f 100644
--- a/Telegram/SourceFiles/boxes/peers/edit_participants_box.h
+++ b/Telegram/SourceFiles/boxes/peers/edit_participants_box.h
@@ -135,7 +135,6 @@ private:
 class ParticipantsBoxController
 	: public PeerListController
 	, private base::Subscriber
-	, private MTP::Sender
 	, public base::has_weak_ptr {
 public:
 	using Role = ParticipantsRole;
@@ -239,6 +238,7 @@ private:
 
 	not_null<Window::SessionNavigation*> _navigation;
 	not_null<PeerData*> _peer;
+	MTP::Sender _api;
 	Role _role = Role::Admins;
 	int _offset = 0;
 	mtpRequestId _loadRequestId = 0;
@@ -252,9 +252,7 @@ private:
 };
 
 // Members, banned and restricted users server side search.
-class ParticipantsBoxSearchController
-	: public PeerListSearchController
-	, private MTP::Sender {
+class ParticipantsBoxSearchController : public PeerListSearchController {
 public:
 	using Role = ParticipantsBoxController::Role;
 
@@ -296,6 +294,7 @@ private:
 	not_null<ChannelData*> _channel;
 	Role _role = Role::Restricted;
 	not_null<ParticipantsAdditionalData*> _additional;
+	MTP::Sender _api;
 
 	base::Timer _timer;
 	QString _query;
diff --git a/Telegram/SourceFiles/boxes/peers/edit_peer_info_box.cpp b/Telegram/SourceFiles/boxes/peers/edit_peer_info_box.cpp
index d14fbde3d..5ee2cd89a 100644
--- a/Telegram/SourceFiles/boxes/peers/edit_peer_info_box.cpp
+++ b/Telegram/SourceFiles/boxes/peers/edit_peer_info_box.cpp
@@ -240,9 +240,7 @@ namespace {
 constexpr auto kMaxGroupChannelTitle = 128; // See also add_contact_box.
 constexpr auto kMaxChannelDescription = 255; // See also add_contact_box.
 
-class Controller
-	: public base::has_weak_ptr
-	, private MTP::Sender {
+class Controller : public base::has_weak_ptr {
 public:
 	Controller(
 		not_null<Window::SessionNavigation*> navigation,
@@ -334,6 +332,7 @@ private:
 	const not_null<Window::SessionNavigation*> _navigation;
 	const not_null<Ui::BoxContent*> _box;
 	not_null<PeerData*> _peer;
+	MTP::Sender _api;
 	const bool _isGroup = false;
 
 	base::unique_qptr<Ui::VerticalLayout> _wrap;
@@ -344,7 +343,6 @@ private:
 
 	const rpl::event_stream<Privacy> _privacyTypeUpdates;
 	const rpl::event_stream<ChannelData*> _linkedChatUpdates;
-	MTP::Sender _linkedChatsRequester;
 	mtpRequestId _linkedChatsRequestId = 0;
 
 	rpl::lifetime _lifetime;
@@ -358,6 +356,7 @@ Controller::Controller(
 : _navigation(navigation)
 , _box(box)
 , _peer(peer)
+, _api(_peer->session().api().instance())
 , _isGroup(_peer->isChat() || _peer->isMegagroup()) {
 	_box->setTitle(_isGroup
 		? tr::lng_edit_group()
@@ -478,7 +477,7 @@ object_ptr<Ui::RpWidget> Controller::createTitleEdit() {
 		[=] { submitTitle(); });
 
 	_controls.title = result->entity();
-	return std::move(result);
+	return result;
 }
 
 object_ptr<Ui::RpWidget> Controller::createDescriptionEdit() {
@@ -512,7 +511,7 @@ object_ptr<Ui::RpWidget> Controller::createDescriptionEdit() {
 		[=] { submitDescription(); });
 
 	_controls.description = result->entity();
-	return std::move(result);
+	return result;
 }
 
 object_ptr<Ui::RpWidget> Controller::createManageGroupButtons() {
@@ -526,7 +525,7 @@ object_ptr<Ui::RpWidget> Controller::createManageGroupButtons() {
 
 	fillManageSection();
 
-	return std::move(result);
+	return result;
 }
 
 object_ptr<Ui::RpWidget> Controller::createStickersEdit() {
@@ -564,7 +563,7 @@ object_ptr<Ui::RpWidget> Controller::createStickersEdit() {
 		Ui::show(Box<StickersBox>(channel), Ui::LayerOption::KeepOther);
 	});
 
-	return std::move(result);
+	return result;
 }
 
 bool Controller::canEditInformation() const {
@@ -644,7 +643,7 @@ void Controller::showEditLinkedChatBox() {
 		callback(_linkedChatOriginalValue);
 		return;
 	}
-	_linkedChatsRequestId = _linkedChatsRequester.request(
+	_linkedChatsRequestId = _api.request(
 		MTPchannels_GetGroupsForDiscussion()
 	).done([=](const MTPmessages_Chats &result) {
 		_linkedChatsRequestId = 0;
@@ -1187,7 +1186,7 @@ void Controller::saveUsername() {
 		return;
 	}
 
-	request(MTPchannels_UpdateUsername(
+	_api.request(MTPchannels_UpdateUsername(
 		channel->inputChannel,
 		MTP_string(*_savingData.username)
 	)).done([=](const MTPBool &result) {
@@ -1242,7 +1241,7 @@ void Controller::saveLinkedChat() {
 	const auto input = *_savingData.linkedChat
 		? (*_savingData.linkedChat)->inputChannel
 		: MTP_inputChannelEmpty();
-	request(MTPchannels_SetDiscussionGroup(
+	_api.request(MTPchannels_SetDiscussionGroup(
 		(channel->isBroadcast() ? channel->inputChannel : input),
 		(channel->isBroadcast() ? input : channel->inputChannel)
 	)).done([=](const MTPBool &result) {
@@ -1283,14 +1282,14 @@ void Controller::saveTitle() {
 	};
 
 	if (const auto channel = _peer->asChannel()) {
-		request(MTPchannels_EditTitle(
+		_api.request(MTPchannels_EditTitle(
 			channel->inputChannel,
 			MTP_string(*_savingData.title)
 		)).done(std::move(onDone)
 		).fail(std::move(onFail)
 		).send();
 	} else if (const auto chat = _peer->asChat()) {
-		request(MTPmessages_EditChatTitle(
+		_api.request(MTPmessages_EditChatTitle(
 			chat->inputChat,
 			MTP_string(*_savingData.title)
 		)).done(std::move(onDone)
@@ -1311,7 +1310,7 @@ void Controller::saveDescription() {
 		_peer->setAbout(*_savingData.description);
 		continueSave();
 	};
-	request(MTPmessages_EditChatAbout(
+	_api.request(MTPmessages_EditChatAbout(
 		_peer->input,
 		MTP_string(*_savingData.description)
 	)).done([=](const MTPBool &result) {
@@ -1368,7 +1367,7 @@ void Controller::togglePreHistoryHidden(
 
 		done();
 	};
-	request(MTPchannels_TogglePreHistoryHidden(
+	_api.request(MTPchannels_TogglePreHistoryHidden(
 		channel->inputChannel,
 		MTP_bool(hidden)
 	)).done([=](const MTPUpdates &result) {
@@ -1390,7 +1389,7 @@ void Controller::saveSignatures() {
 		|| *_savingData.signatures == channel->addsSignature()) {
 		return continueSave();
 	}
-	request(MTPchannels_ToggleSignatures(
+	_api.request(MTPchannels_ToggleSignatures(
 		channel->inputChannel,
 		MTP_bool(*_savingData.signatures)
 	)).done([=](const MTPUpdates &result) {
diff --git a/Telegram/SourceFiles/boxes/peers/edit_peer_type_box.cpp b/Telegram/SourceFiles/boxes/peers/edit_peer_type_box.cpp
index 7c67aba61..71ee082ca 100644
--- a/Telegram/SourceFiles/boxes/peers/edit_peer_type_box.cpp
+++ b/Telegram/SourceFiles/boxes/peers/edit_peer_type_box.cpp
@@ -51,9 +51,7 @@ namespace {
 constexpr auto kUsernameCheckTimeout = crl::time(200);
 constexpr auto kMinUsernameLength = 5;
 
-class Controller
-	: public base::has_weak_ptr
-	, private MTP::Sender {
+class Controller : public base::has_weak_ptr {
 public:
 	Controller(
 		not_null<Ui::VerticalLayout*> container,
@@ -144,6 +142,7 @@ private:
 	QString inviteLinkText();
 
 	not_null<PeerData*> _peer;
+	MTP::Sender _api;
 	std::optional<Privacy> _privacySavedValue;
 	std::optional<QString> _usernameSavedValue;
 
@@ -169,6 +168,7 @@ Controller::Controller(
 	std::optional<Privacy> privacySavedValue,
 	std::optional<QString> usernameSavedValue)
 : _peer(peer)
+, _api(_peer->session().api().instance())
 , _privacySavedValue(privacySavedValue)
 , _usernameSavedValue(usernameSavedValue)
 , _useLocationPhrases(useLocationPhrases)
@@ -364,7 +364,7 @@ object_ptr<Ui::RpWidget> Controller::createUsernameEdit() {
 	const auto shown = (_controls.privacy->value() == Privacy::HasUsername);
 	result->toggle(shown, anim::type::instant);
 
-	return std::move(result);
+	return result;
 }
 
 void Controller::privacyChanged(Privacy value) {
@@ -401,7 +401,7 @@ void Controller::privacyChanged(Privacy value) {
 		refreshVisibilities();
 		_controls.usernameInput->setDisplayFocused(true);
 	} else {
-		request(base::take(_checkUsernameRequestId)).cancel();
+		_api.request(base::take(_checkUsernameRequestId)).cancel();
 		_checkUsernameTimer.cancel();
 		refreshVisibilities();
 	}
@@ -420,11 +420,11 @@ void Controller::checkUsernameAvailability() {
 		return;
 	}
 	if (_checkUsernameRequestId) {
-		request(_checkUsernameRequestId).cancel();
+		_api.request(_checkUsernameRequestId).cancel();
 	}
 	const auto channel = _peer->migrateToOrMe()->asChannel();
 	const auto username = channel ? channel->username : QString();
-	_checkUsernameRequestId = request(MTPchannels_CheckUsername(
+	_checkUsernameRequestId = _api.request(MTPchannels_CheckUsername(
 		channel ? channel->inputChannel : MTP_inputChannelEmpty(),
 		MTP_string(checking)
 	)).done([=](const MTPBool &result) {
@@ -630,7 +630,7 @@ object_ptr<Ui::RpWidget> Controller::createInviteLinkEdit() {
 
 	observeInviteLink();
 
-	return std::move(result);
+	return result;
 }
 
 void Controller::refreshEditInviteLink() {
@@ -692,7 +692,7 @@ object_ptr<Ui::RpWidget> Controller::createInviteLinkCreate() {
 
 	observeInviteLink();
 
-	return std::move(result);
+	return result;
 }
 
 void Controller::refreshCreateInviteLink() {
diff --git a/Telegram/SourceFiles/boxes/rate_call_box.cpp b/Telegram/SourceFiles/boxes/rate_call_box.cpp
index be102184b..85294a3fe 100644
--- a/Telegram/SourceFiles/boxes/rate_call_box.cpp
+++ b/Telegram/SourceFiles/boxes/rate_call_box.cpp
@@ -31,6 +31,7 @@ RateCallBox::RateCallBox(
 	uint64 callId,
 	uint64 callAccessHash)
 : _session(session)
+, _api(_session->api().instance())
 , _callId(callId)
 , _callAccessHash(callAccessHash) {
 }
@@ -120,7 +121,7 @@ void RateCallBox::send() {
 		return;
 	}
 	auto comment = _comment ? _comment->getLastText().trimmed() : QString();
-	_requestId = request(MTPphone_SetCallRating(
+	_requestId = _api.request(MTPphone_SetCallRating(
 		MTP_flags(0),
 		MTP_inputPhoneCall(MTP_long(_callId), MTP_long(_callAccessHash)),
 		MTP_int(_rating),
diff --git a/Telegram/SourceFiles/boxes/rate_call_box.h b/Telegram/SourceFiles/boxes/rate_call_box.h
index 9efaa4d53..99ca677d8 100644
--- a/Telegram/SourceFiles/boxes/rate_call_box.h
+++ b/Telegram/SourceFiles/boxes/rate_call_box.h
@@ -20,7 +20,7 @@ namespace Main {
 class Session;
 } // namespace Main
 
-class RateCallBox : public Ui::BoxContent, private MTP::Sender {
+class RateCallBox : public Ui::BoxContent {
 public:
 	RateCallBox(
 		QWidget*,
@@ -41,6 +41,7 @@ private:
 	void commentResized();
 
 	const not_null<Main::Session*> _session;
+	MTP::Sender _api;
 
 	uint64 _callId = 0;
 	uint64 _callAccessHash = 0;
diff --git a/Telegram/SourceFiles/boxes/report_box.cpp b/Telegram/SourceFiles/boxes/report_box.cpp
index 5ad271db2..28697df52 100644
--- a/Telegram/SourceFiles/boxes/report_box.cpp
+++ b/Telegram/SourceFiles/boxes/report_box.cpp
@@ -14,6 +14,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "ui/widgets/buttons.h"
 #include "ui/widgets/input_fields.h"
 #include "ui/toast/toast.h"
+#include "mtproto/facade.h"
 #include "mainwindow.h"
 #include "styles/style_layers.h"
 #include "styles/style_boxes.h"
diff --git a/Telegram/SourceFiles/boxes/report_box.h b/Telegram/SourceFiles/boxes/report_box.h
index d7afc3761..05782b8ce 100644
--- a/Telegram/SourceFiles/boxes/report_box.h
+++ b/Telegram/SourceFiles/boxes/report_box.h
@@ -8,6 +8,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #pragma once
 
 #include "boxes/abstract_box.h"
+#include "mtproto/mtproto_rpc_sender.h"
 
 namespace Ui {
 template <typename Enum>
diff --git a/Telegram/SourceFiles/boxes/self_destruction_box.cpp b/Telegram/SourceFiles/boxes/self_destruction_box.cpp
index 79b5cf517..acc9e2427 100644
--- a/Telegram/SourceFiles/boxes/self_destruction_box.cpp
+++ b/Telegram/SourceFiles/boxes/self_destruction_box.cpp
@@ -11,6 +11,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "ui/widgets/checkbox.h"
 #include "ui/widgets/labels.h"
 #include "apiwrap.h"
+#include "api/api_self_destruct.h"
 #include "main/main_session.h"
 #include "styles/style_layers.h"
 #include "styles/style_boxes.h"
@@ -76,7 +77,7 @@ void SelfDestructionBox::showContent() {
 
 	clearButtons();
 	addButton(tr::lng_settings_save(), [=] {
-		_session->api().saveSelfDestruct(_ttlGroup->value());
+		_session->api().selfDestruct().update(_ttlGroup->value());
 		closeBox();
 	});
 	addButton(tr::lng_cancel(), [=] { closeBox(); });
diff --git a/Telegram/SourceFiles/boxes/self_destruction_box.h b/Telegram/SourceFiles/boxes/self_destruction_box.h
index 475f59749..95f7928c8 100644
--- a/Telegram/SourceFiles/boxes/self_destruction_box.h
+++ b/Telegram/SourceFiles/boxes/self_destruction_box.h
@@ -20,7 +20,7 @@ namespace Main {
 class Session;
 } // namespace Main
 
-class SelfDestructionBox : public Ui::BoxContent, private MTP::Sender {
+class SelfDestructionBox : public Ui::BoxContent {
 public:
 	SelfDestructionBox(
 		QWidget*,
diff --git a/Telegram/SourceFiles/boxes/send_files_box.cpp b/Telegram/SourceFiles/boxes/send_files_box.cpp
index 0f5a43054..3bbd168da 100644
--- a/Telegram/SourceFiles/boxes/send_files_box.cpp
+++ b/Telegram/SourceFiles/boxes/send_files_box.cpp
@@ -365,6 +365,7 @@ void AlbumThumb::prepareCache(QSize size, int shrink) {
 		ImageRoundRadius::Large,
 		_albumCorners,
 		QRect(QPoint(), size * cIntRetinaFactor()));
+	_albumCache.setDevicePixelRatio(cRetinaFactor());
 }
 
 void AlbumThumb::drawSimpleFrame(Painter &p, QRect to, QSize size) const {
diff --git a/Telegram/SourceFiles/boxes/sessions_box.cpp b/Telegram/SourceFiles/boxes/sessions_box.cpp
index 91247790d..071058b17 100644
--- a/Telegram/SourceFiles/boxes/sessions_box.cpp
+++ b/Telegram/SourceFiles/boxes/sessions_box.cpp
@@ -11,6 +11,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "storage/localstorage.h"
 #include "mainwidget.h"
 #include "mainwindow.h"
+#include "apiwrap.h"
 #include "main/main_session.h"
 #include "data/data_session.h"
 #include "base/unixtime.h"
@@ -77,6 +78,7 @@ private:
 
 SessionsBox::SessionsBox(QWidget*, not_null<Main::Session*> session)
 : _session(session)
+, _api(_session->api().instance())
 , _shortPollTimer([=] { shortPollSessions(); }) {
 }
 
@@ -280,7 +282,7 @@ void SessionsBox::shortPollSessions() {
 	if (_shortPollRequest) {
 		return;
 	}
-	_shortPollRequest = request(MTPaccount_GetAuthorizations(
+	_shortPollRequest = _api.request(MTPaccount_GetAuthorizations(
 	)).done([=](const MTPaccount_Authorizations &result) {
 		got(result);
 	}).send();
@@ -294,7 +296,7 @@ void SessionsBox::terminateOne(uint64 hash) {
 			_terminateBox->closeBox();
 			_terminateBox = nullptr;
 		}
-		request(MTPaccount_ResetAuthorization(
+		_api.request(MTPaccount_ResetAuthorization(
 			MTP_long(hash)
 		)).done([=](const MTPBool &result) {
 			_inner->terminatingOne(hash, false);
@@ -330,12 +332,12 @@ void SessionsBox::terminateAll() {
 			_terminateBox->closeBox();
 			_terminateBox = nullptr;
 		}
-		request(MTPauth_ResetAuthorizations(
+		_api.request(MTPauth_ResetAuthorizations(
 		)).done([=](const MTPBool &result) {
-			request(base::take(_shortPollRequest)).cancel();
+			_api.request(base::take(_shortPollRequest)).cancel();
 			shortPollSessions();
 		}).fail([=](const RPCError &result) {
-			request(base::take(_shortPollRequest)).cancel();
+			_api.request(base::take(_shortPollRequest)).cancel();
 			shortPollSessions();
 		}).send();
 		setLoading(true);
diff --git a/Telegram/SourceFiles/boxes/sessions_box.h b/Telegram/SourceFiles/boxes/sessions_box.h
index b27ec5dd4..b2c7953eb 100644
--- a/Telegram/SourceFiles/boxes/sessions_box.h
+++ b/Telegram/SourceFiles/boxes/sessions_box.h
@@ -22,7 +22,7 @@ namespace Main {
 class Session;
 } // namespace Main
 
-class SessionsBox : public Ui::BoxContent, private MTP::Sender {
+class SessionsBox : public Ui::BoxContent {
 public:
 	SessionsBox(QWidget*, not_null<Main::Session*> session);
 
@@ -60,6 +60,7 @@ private:
 	void terminateAll();
 
 	const not_null<Main::Session*> _session;
+	MTP::Sender _api;
 
 	bool _loading = false;
 	Full _data;
diff --git a/Telegram/SourceFiles/boxes/share_box.cpp b/Telegram/SourceFiles/boxes/share_box.cpp
index 0f319b401..49c2b32ee 100644
--- a/Telegram/SourceFiles/boxes/share_box.cpp
+++ b/Telegram/SourceFiles/boxes/share_box.cpp
@@ -722,7 +722,6 @@ void ShareBox::Inner::loadProfilePhotos(int yFrom) {
 	yFrom *= _columnCount;
 	yTo *= _columnCount;
 
-	_navigation->session().downloader().clearPriorities();
 	if (_filter.isEmpty()) {
 		if (!_chatsIndexed->empty()) {
 			auto i = _chatsIndexed->cfind(yFrom, _rowHeight);
diff --git a/Telegram/SourceFiles/boxes/share_box.h b/Telegram/SourceFiles/boxes/share_box.h
index 55d223c04..b5d3f5397 100644
--- a/Telegram/SourceFiles/boxes/share_box.h
+++ b/Telegram/SourceFiles/boxes/share_box.h
@@ -12,6 +12,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "base/timer.h"
 #include "ui/effects/animations.h"
 #include "ui/effects/round_checkbox.h"
+#include "mtproto/mtproto_rpc_sender.h"
 
 enum class SendMenuType;
 
diff --git a/Telegram/SourceFiles/boxes/sticker_set_box.cpp b/Telegram/SourceFiles/boxes/sticker_set_box.cpp
index 597d71826..ca7130b2b 100644
--- a/Telegram/SourceFiles/boxes/sticker_set_box.cpp
+++ b/Telegram/SourceFiles/boxes/sticker_set_box.cpp
@@ -9,6 +9,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 
 #include "data/data_document.h"
 #include "data/data_session.h"
+#include "data/data_file_origin.h"
 #include "lang/lang_keys.h"
 #include "chat_helpers/stickers.h"
 #include "boxes/confirm_box.h"
@@ -99,7 +100,7 @@ private:
 	void showPreview();
 
 	not_null<Window::SessionController*> _controller;
-	MTP::Sender _mtp;
+	MTP::Sender _api;
 	std::vector<Element> _elements;
 	std::unique_ptr<Lottie::MultiPlayer> _lottiePlayer;
 	Stickers::Pack _pack;
@@ -220,6 +221,7 @@ StickerSetBox::Inner::Inner(
 	const MTPInputStickerSet &set)
 : RpWidget(parent)
 , _controller(controller)
+, _api(_controller->session().api().instance())
 , _input(set)
 , _previewTimer([=] { showPreview(); }) {
 	set.match([&](const MTPDinputStickerSetID &data) {
@@ -231,7 +233,7 @@ StickerSetBox::Inner::Inner(
 	}, [&](const MTPDinputStickerSetAnimatedEmoji &) {
 	});
 
-	_mtp.request(MTPmessages_GetStickerSet(
+	_api.request(MTPmessages_GetStickerSet(
 		_input
 	)).done([=](const MTPmessages_StickerSet &result) {
 		gotSet(result);
@@ -700,7 +702,7 @@ void StickerSetBox::Inner::install() {
 	} else if (_installRequest) {
 		return;
 	}
-	_installRequest = _mtp.request(MTPmessages_InstallStickerSet(
+	_installRequest = _api.request(MTPmessages_InstallStickerSet(
 		_input,
 		MTP_bool(false)
 	)).done([=](const MTPmessages_StickerSetInstallResult &result) {
diff --git a/Telegram/SourceFiles/boxes/stickers_box.cpp b/Telegram/SourceFiles/boxes/stickers_box.cpp
index c426a2316..5ffdfc131 100644
--- a/Telegram/SourceFiles/boxes/stickers_box.cpp
+++ b/Telegram/SourceFiles/boxes/stickers_box.cpp
@@ -10,6 +10,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "data/data_document.h"
 #include "data/data_session.h"
 #include "data/data_channel.h"
+#include "data/data_file_origin.h"
 #include "core/application.h"
 #include "lang/lang_keys.h"
 #include "mainwidget.h"
@@ -410,7 +411,7 @@ void StickersBox::updateTabsGeometry() {
 
 	auto featuredLeft = width() / 3;
 	auto featuredRight = 2 * width() / 3;
-	auto featuredTextWidth = st::stickersTabs.labelFont->width(tr::lng_stickers_featured_tab(tr::now).toUpper());
+	auto featuredTextWidth = st::stickersTabs.labelStyle.font->width(tr::lng_stickers_featured_tab(tr::now).toUpper());
 	auto featuredTextRight = featuredLeft + (featuredRight - featuredLeft - featuredTextWidth) / 2 + featuredTextWidth;
 	auto unreadBadgeLeft = featuredTextRight - st::stickersFeaturedBadgeSkip;
 	auto unreadBadgeTop = st::stickersFeaturedBadgeTop;
@@ -661,6 +662,7 @@ StickersBox::Inner::Inner(
 	StickersBox::Section section)
 : RpWidget(parent)
 , _session(session)
+, _api(_session->api().instance())
 , _section(section)
 , _rowHeight(st::contactsPadding.top() + st::contactsPhotoSize + st::contactsPadding.bottom())
 , _shiftingAnimation([=](crl::time now) {
@@ -677,6 +679,7 @@ StickersBox::Inner::Inner(
 StickersBox::Inner::Inner(QWidget *parent, not_null<ChannelData*> megagroup)
 : RpWidget(parent)
 , _session(&megagroup->session())
+, _api(_session->api().instance())
 , _section(StickersBox::Section::Installed)
 , _rowHeight(st::contactsPadding.top() + st::contactsPhotoSize + st::contactsPadding.bottom())
 , _shiftingAnimation([=](crl::time now) {
@@ -1469,11 +1472,13 @@ void StickersBox::Inner::handleMegagroupSetAddressChange() {
 			}
 		}
 	} else if (!_megagroupSetRequestId) {
-		_megagroupSetRequestId = request(MTPmessages_GetStickerSet(MTP_inputStickerSetShortName(MTP_string(text)))).done([this](const MTPmessages_StickerSet &result) {
+		_megagroupSetRequestId = _api.request(MTPmessages_GetStickerSet(
+			MTP_inputStickerSetShortName(MTP_string(text))
+		)).done([=](const MTPmessages_StickerSet &result) {
 			_megagroupSetRequestId = 0;
 			auto set = Stickers::FeedSetFull(result);
 			setMegagroupSelectedSet(MTP_inputStickerSetID(MTP_long(set->id), MTP_long(set->access)));
-		}).fail([this](const RPCError &error) {
+		}).fail([=](const RPCError &error) {
 			_megagroupSetRequestId = 0;
 			setMegagroupSelectedSet(MTP_inputStickerSetEmpty());
 		}).send();
diff --git a/Telegram/SourceFiles/boxes/stickers_box.h b/Telegram/SourceFiles/boxes/stickers_box.h
index d5aba39ed..3cdd90a18 100644
--- a/Telegram/SourceFiles/boxes/stickers_box.h
+++ b/Telegram/SourceFiles/boxes/stickers_box.h
@@ -153,8 +153,7 @@ private:
 // This class is hold in header because it requires Qt preprocessing.
 class StickersBox::Inner
 	: public Ui::RpWidget
-	, private base::Subscriber
-	, private MTP::Sender {
+	, private base::Subscriber {
 	Q_OBJECT
 
 public:
@@ -320,6 +319,7 @@ private:
 	int countMaxNameWidth() const;
 
 	const not_null<Main::Session*> _session;
+	MTP::Sender _api;
 
 	Section _section;
 
diff --git a/Telegram/SourceFiles/boxes/username_box.h b/Telegram/SourceFiles/boxes/username_box.h
index 2cc31dd52..3a78c6596 100644
--- a/Telegram/SourceFiles/boxes/username_box.h
+++ b/Telegram/SourceFiles/boxes/username_box.h
@@ -8,6 +8,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #pragma once
 
 #include "boxes/abstract_box.h"
+#include "mtproto/mtproto_rpc_sender.h"
 
 namespace Ui {
 class UsernameInput;
diff --git a/Telegram/SourceFiles/calls/calls_box_controller.cpp b/Telegram/SourceFiles/calls/calls_box_controller.cpp
index 937c34a74..7b2000892 100644
--- a/Telegram/SourceFiles/calls/calls_box_controller.cpp
+++ b/Telegram/SourceFiles/calls/calls_box_controller.cpp
@@ -21,6 +21,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "data/data_session.h"
 #include "data/data_media_types.h"
 #include "data/data_user.h"
+#include "apiwrap.h"
 #include "facades.h"
 #include "app.h"
 
@@ -216,7 +217,8 @@ void BoxController::Row::stopLastActionRipple() {
 }
 
 BoxController::BoxController(not_null<Window::SessionController*> window)
-: _window(window) {
+: _window(window)
+, _api(_window->session().api().instance()) {
 }
 
 Main::Session &BoxController::session() const {
@@ -256,7 +258,7 @@ void BoxController::loadMoreRows() {
 		return;
 	}
 
-	_loadRequestId = request(MTPmessages_Search(
+	_loadRequestId = _api.request(MTPmessages_Search(
 		MTP_flags(0),
 		MTP_inputPeerEmpty(),
 		MTP_string(),
@@ -404,8 +406,7 @@ BoxController::Row *BoxController::rowForItem(not_null<const HistoryItem*> item)
 
 std::unique_ptr<PeerListRow> BoxController::createRow(
 		not_null<HistoryItem*> item) const {
-	auto row = std::make_unique<Row>(item);
-	return std::move(row);
+	return std::make_unique<Row>(item);
 }
 
 } // namespace Calls
diff --git a/Telegram/SourceFiles/calls/calls_box_controller.h b/Telegram/SourceFiles/calls/calls_box_controller.h
index 9833469f1..d67e22c04 100644
--- a/Telegram/SourceFiles/calls/calls_box_controller.h
+++ b/Telegram/SourceFiles/calls/calls_box_controller.h
@@ -15,10 +15,7 @@ class SessionController;
 
 namespace Calls {
 
-class BoxController
-	: public PeerListController
-	, private base::Subscriber
-	, private MTP::Sender {
+class BoxController : public PeerListController, private base::Subscriber {
 public:
 	explicit BoxController(not_null<Window::SessionController*> window);
 
@@ -44,6 +41,7 @@ private:
 		not_null<HistoryItem*> item) const;
 
 	const not_null<Window::SessionController*> _window;
+	MTP::Sender _api;
 
 	MsgId _offsetId = 0;
 	mtpRequestId _loadRequestId = 0;
diff --git a/Telegram/SourceFiles/calls/calls_call.cpp b/Telegram/SourceFiles/calls/calls_call.cpp
index 428ebf94f..bf57bdca4 100644
--- a/Telegram/SourceFiles/calls/calls_call.cpp
+++ b/Telegram/SourceFiles/calls/calls_call.cpp
@@ -14,7 +14,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "boxes/rate_call_box.h"
 #include "calls/calls_instance.h"
 #include "base/openssl_help.h"
-#include "mtproto/connection.h"
+#include "mtproto/mtproto_dh_utils.h"
 #include "media/audio/media_audio_track.h"
 #include "base/platform/base_platform_info.h"
 #include "calls/calls_panel.h"
@@ -130,6 +130,7 @@ Call::Call(
 	Type type)
 : _delegate(delegate)
 , _user(user)
+, _api(_user->session().api().instance())
 , _type(type) {
 	_discardByTimeoutTimer.setCallback([this] { hangup(); });
 
@@ -189,7 +190,7 @@ void Call::startOutgoing() {
 	Expects(_state == State::Requesting);
 	Expects(_gaHash.size() == kSha256Size);
 
-	request(MTPphone_RequestCall(
+	_api.request(MTPphone_RequestCall(
 		MTP_flags(0),
 		_user->inputUser,
 		MTP_int(rand_value<int32>()),
@@ -236,11 +237,13 @@ void Call::startIncoming() {
 	Expects(_type == Type::Incoming);
 	Expects(_state == State::Starting);
 
-	request(MTPphone_ReceivedCall(MTP_inputPhoneCall(MTP_long(_id), MTP_long(_accessHash)))).done([this](const MTPBool &result) {
+	_api.request(MTPphone_ReceivedCall(
+		MTP_inputPhoneCall(MTP_long(_id), MTP_long(_accessHash))
+	)).done([=](const MTPBool &result) {
 		if (_state == State::Starting) {
 			setState(State::WaitingIncoming);
 		}
-	}).fail([this](const RPCError &error) {
+	}).fail([=](const RPCError &error) {
 		handleRequestError(error);
 	}).send();
 }
@@ -267,7 +270,7 @@ void Call::actuallyAnswer() {
 	} else {
 		_answerAfterDhConfigReceived = false;
 	}
-	request(MTPphone_AcceptCall(
+	_api.request(MTPphone_AcceptCall(
 		MTP_inputPhoneCall(MTP_long(_id), MTP_long(_accessHash)),
 		MTP_bytes(_gb),
 		MTP_phoneCallProtocol(
@@ -504,7 +507,7 @@ void Call::confirmAcceptedCall(const MTPDphoneCallAccepted &call) {
 	_keyFingerprint = ComputeFingerprint(_authKey);
 
 	setState(State::ExchangingKeys);
-	request(MTPphone_ConfirmCall(
+	_api.request(MTPphone_ConfirmCall(
 		MTP_inputPhoneCall(MTP_long(_id), MTP_long(_accessHash)),
 		MTP_bytes(_ga),
 		MTP_long(_keyFingerprint),
@@ -623,10 +626,10 @@ void Call::createAndStartController(const MTPDphoneCall &call) {
 	_controller->SetEncryptionKey(reinterpret_cast<char*>(_authKey.data()), (_type == Type::Outgoing));
 	_controller->SetCallbacks(callbacks);
 	if (Global::UseProxyForCalls()
-		&& (Global::ProxySettings() == ProxyData::Settings::Enabled)) {
+		&& (Global::ProxySettings() == MTP::ProxyData::Settings::Enabled)) {
 		const auto &proxy = Global::SelectedProxy();
 		if (proxy.supportsCalls()) {
-			Assert(proxy.type == ProxyData::Type::Socks5);
+			Assert(proxy.type == MTP::ProxyData::Type::Socks5);
 			_controller->SetProxy(
 				tgvoip::PROXY_SOCKS5,
 				proxy.host.toStdString(),
@@ -840,7 +843,7 @@ void Call::finish(FinishType type, const MTPPhoneCallDiscardReason &reason) {
 	auto duration = getDurationMs() / 1000;
 	auto connectionId = _controller ? _controller->GetPreferredRelayID() : 0;
 	_finishByTimeoutTimer.call(kHangupTimeoutMs, [this, finalState] { setState(finalState); });
-	request(MTPphone_DiscardCall(
+	_api.request(MTPphone_DiscardCall(
 		MTP_flags(0),
 		MTP_inputPhoneCall(
 			MTP_long(_id),
diff --git a/Telegram/SourceFiles/calls/calls_call.h b/Telegram/SourceFiles/calls/calls_call.h
index 04ade9804..98bc6b5a6 100644
--- a/Telegram/SourceFiles/calls/calls_call.h
+++ b/Telegram/SourceFiles/calls/calls_call.h
@@ -11,7 +11,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "base/timer.h"
 #include "base/bytes.h"
 #include "mtproto/sender.h"
-#include "mtproto/auth_key.h"
+#include "mtproto/mtproto_auth_key.h"
 
 namespace Media {
 namespace Audio {
@@ -31,7 +31,7 @@ struct DhConfig {
 	bytes::vector p;
 };
 
-class Call : public base::has_weak_ptr, private MTP::Sender {
+class Call : public base::has_weak_ptr {
 public:
 	class Delegate {
 	public:
@@ -183,6 +183,7 @@ private:
 
 	not_null<Delegate*> _delegate;
 	not_null<UserData*> _user;
+	MTP::Sender _api;
 	Type _type = Type::Outgoing;
 	State _state = State::Starting;
 	FinishType _finishAfterRequestingCall = FinishType::None;
diff --git a/Telegram/SourceFiles/calls/calls_instance.cpp b/Telegram/SourceFiles/calls/calls_instance.cpp
index b8d6a0a9c..ff4c90f62 100644
--- a/Telegram/SourceFiles/calls/calls_instance.cpp
+++ b/Telegram/SourceFiles/calls/calls_instance.cpp
@@ -7,7 +7,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 */
 #include "calls/calls_instance.h"
 
-#include "mtproto/connection.h"
+#include "mtproto/mtproto_dh_utils.h"
 #include "core/application.h"
 #include "main/main_session.h"
 #include "apiwrap.h"
@@ -32,7 +32,9 @@ constexpr auto kServerConfigUpdateTimeoutMs = 24 * 3600 * crl::time(1000);
 
 } // namespace
 
-Instance::Instance(not_null<Main::Session*> session) : _session(session) {
+Instance::Instance(not_null<Main::Session*> session)
+: _session(session)
+, _api(_session->api().instance()) {
 }
 
 void Instance::startOutgoingCall(not_null<UserData*> user) {
@@ -139,7 +141,7 @@ void Instance::refreshDhConfig() {
 	Expects(_currentCall != nullptr);
 
 	const auto weak = base::make_weak(_currentCall);
-	request(MTPmessages_GetDhConfig(
+	_api.request(MTPmessages_GetDhConfig(
 		MTP_int(_dhConfig.version),
 		MTP_int(MTP::ModExpFirst::kRandomPowerSize)
 	)).done([=](const MTPmessages_DhConfig &result) {
@@ -203,13 +205,14 @@ void Instance::refreshServerConfig() {
 	if (_lastServerConfigUpdateTime && (crl::now() - _lastServerConfigUpdateTime) < kServerConfigUpdateTimeoutMs) {
 		return;
 	}
-	_serverConfigRequestId = request(MTPphone_GetCallConfig()).done([this](const MTPDataJSON &result) {
+	_serverConfigRequestId = _api.request(MTPphone_GetCallConfig(
+	)).done([=](const MTPDataJSON &result) {
 		_serverConfigRequestId = 0;
 		_lastServerConfigUpdateTime = crl::now();
 
 		const auto &json = result.c_dataJSON().vdata().v;
 		UpdateConfig(std::string(json.data(), json.size()));
-	}).fail([this](const RPCError &error) {
+	}).fail([=](const RPCError &error) {
 		_serverConfigRequestId = 0;
 	}).send();
 }
@@ -246,7 +249,7 @@ void Instance::handleCallUpdate(const MTPPhoneCall &call) {
 			LOG(("API Error: Self found in phoneCallRequested."));
 		}
 		if (alreadyInCall() || !user || user->isSelf()) {
-			request(MTPphone_DiscardCall(
+			_api.request(MTPphone_DiscardCall(
 				MTP_flags(0),
 				MTP_inputPhoneCall(phoneCall.vid(), phoneCall.vaccess_hash()),
 				MTP_int(0),
diff --git a/Telegram/SourceFiles/calls/calls_instance.h b/Telegram/SourceFiles/calls/calls_instance.h
index f5d30fa9b..d8987f458 100644
--- a/Telegram/SourceFiles/calls/calls_instance.h
+++ b/Telegram/SourceFiles/calls/calls_instance.h
@@ -25,8 +25,7 @@ namespace Calls {
 class Panel;
 
 class Instance
-	: private MTP::Sender
-	, private Call::Delegate
+	: private Call::Delegate
 	, private base::Subscriber
 	, public base::has_weak_ptr {
 public:
@@ -74,6 +73,7 @@ private:
 	void handleCallUpdate(const MTPPhoneCall &call);
 
 	const not_null<Main::Session*> _session;
+	MTP::Sender _api;
 
 	DhConfig _dhConfig;
 
diff --git a/Telegram/SourceFiles/chat_helpers/bot_keyboard.cpp b/Telegram/SourceFiles/chat_helpers/bot_keyboard.cpp
index 2668efcc6..39d0b8d2f 100644
--- a/Telegram/SourceFiles/chat_helpers/bot_keyboard.cpp
+++ b/Telegram/SourceFiles/chat_helpers/bot_keyboard.cpp
@@ -271,7 +271,7 @@ QPoint BotKeyboard::tooltipPos() const {
 }
 
 bool BotKeyboard::tooltipWindowActive() const {
-	return Ui::InFocusChain(window());
+	return Ui::AppInFocus() && Ui::InFocusChain(window());
 }
 
 QString BotKeyboard::tooltipText() const {
diff --git a/Telegram/SourceFiles/chat_helpers/emoji_keywords.cpp b/Telegram/SourceFiles/chat_helpers/emoji_keywords.cpp
index 16803d6fb..d83638615 100644
--- a/Telegram/SourceFiles/chat_helpers/emoji_keywords.cpp
+++ b/Telegram/SourceFiles/chat_helpers/emoji_keywords.cpp
@@ -72,6 +72,12 @@ struct LangPackData {
 	return false;
 }
 
+[[nodiscard]] EmojiPtr FindExact(const QString &text) {
+	auto length = 0;
+	const auto result = Find(text, &length);
+	return (length < text.size()) ? nullptr : result;
+}
+
 void CreateCacheFilePath() {
 	QDir().mkpath(internal::CacheFileFolder() + qstr("/keywords"));
 }
@@ -120,7 +126,7 @@ void CreateCacheFilePath() {
 			const auto emoji = MustAddPostfix(text)
 				? (text + QChar(Ui::Emoji::kPostfix))
 				: text;
-			const auto entry = LangPackEmoji{ Find(emoji), text };
+			const auto entry = LangPackEmoji{ FindExact(emoji), text };
 			if (!entry.emoji) {
 				return {};
 			}
@@ -251,7 +257,7 @@ void ApplyDifference(
 				const auto emoji = MustAddPostfix(text)
 					? (text + QChar(Ui::Emoji::kPostfix))
 					: text;
-				return LangPackEmoji{ Find(emoji), text };
+				return LangPackEmoji{ FindExact(emoji), text };
 			}) | ranges::view::filter([&](const LangPackEmoji &entry) {
 				if (!entry.emoji) {
 					LOG(("API Warning: emoji %1 is not supported, word: %2."
diff --git a/Telegram/SourceFiles/chat_helpers/emoji_list_widget.cpp b/Telegram/SourceFiles/chat_helpers/emoji_list_widget.cpp
index a9b4129f0..e4b8c8ac6 100644
--- a/Telegram/SourceFiles/chat_helpers/emoji_list_widget.cpp
+++ b/Telegram/SourceFiles/chat_helpers/emoji_list_widget.cpp
@@ -427,7 +427,7 @@ object_ptr<TabbedSelector::InnerFooter> EmojiListWidget::createFooter() {
 	Expects(_footer == nullptr);
 	auto result = object_ptr<Footer>(this);
 	_footer = result;
-	return std::move(result);
+	return result;
 }
 
 template <typename Callback>
@@ -770,7 +770,7 @@ QPoint EmojiListWidget::tooltipPos() const {
 }
 
 bool EmojiListWidget::tooltipWindowActive() const {
-	return Ui::InFocusChain(window());
+	return Ui::AppInFocus() && Ui::InFocusChain(window());
 }
 
 TabbedSelector::InnerFooter *EmojiListWidget::getFooter() const {
diff --git a/Telegram/SourceFiles/chat_helpers/field_autocomplete.cpp b/Telegram/SourceFiles/chat_helpers/field_autocomplete.cpp
index 57f648d9d..2a5d03d52 100644
--- a/Telegram/SourceFiles/chat_helpers/field_autocomplete.cpp
+++ b/Telegram/SourceFiles/chat_helpers/field_autocomplete.cpp
@@ -12,6 +12,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "data/data_chat.h"
 #include "data/data_user.h"
 #include "data/data_peer_values.h"
+#include "data/data_file_origin.h"
 #include "mainwindow.h"
 #include "apiwrap.h"
 #include "storage/localstorage.h"
diff --git a/Telegram/SourceFiles/chat_helpers/gifs_list_widget.cpp b/Telegram/SourceFiles/chat_helpers/gifs_list_widget.cpp
index cd1dc1d38..5d9bce7e3 100644
--- a/Telegram/SourceFiles/chat_helpers/gifs_list_widget.cpp
+++ b/Telegram/SourceFiles/chat_helpers/gifs_list_widget.cpp
@@ -11,7 +11,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "data/data_document.h"
 #include "data/data_session.h"
 #include "data/data_user.h"
-#include "styles/style_chat_helpers.h"
+#include "data/data_file_origin.h"
 #include "ui/widgets/buttons.h"
 #include "ui/widgets/input_fields.h"
 #include "ui/effects/ripple_animation.h"
@@ -22,10 +22,12 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "storage/localstorage.h"
 #include "lang/lang_keys.h"
 #include "mainwindow.h"
+#include "apiwrap.h"
 #include "window/window_session_controller.h"
 #include "history/view/history_view_cursor_state.h"
 #include "facades.h"
 #include "app.h"
+#include "styles/style_chat_helpers.h"
 
 #include <QtWidgets/QApplication>
 
@@ -130,6 +132,7 @@ GifsListWidget::GifsListWidget(
 	QWidget *parent,
 	not_null<Window::SessionController*> controller)
 : Inner(parent, controller)
+, _api(controller->session().api().instance())
 , _section(Section::Gifs)
 , _updateInlineItems([=] { updateInlineItems(); })
 , _previewTimer([=] { showPreview(); }) {
@@ -178,7 +181,7 @@ object_ptr<TabbedSelector::InnerFooter> GifsListWidget::createFooter() {
 
 	auto result = object_ptr<Footer>(this);
 	_footer = result;
-	return std::move(result);
+	return result;
 }
 
 void GifsListWidget::visibleTopBottomUpdated(
@@ -217,7 +220,7 @@ GifsListWidget::~GifsListWidget() {
 void GifsListWidget::cancelGifsSearch() {
 	_footer->setLoading(false);
 	if (_inlineRequestId) {
-		request(_inlineRequestId).cancel();
+		_api.request(_inlineRequestId).cancel();
 		_inlineRequestId = 0;
 	}
 	_inlineRequestTimer.stop();
@@ -840,7 +843,7 @@ void GifsListWidget::searchForGifs(const QString &query) {
 	if (_inlineQuery != query) {
 		_footer->setLoading(false);
 		if (_inlineRequestId) {
-			request(_inlineRequestId).cancel();
+			_api.request(_inlineRequestId).cancel();
 			_inlineRequestId = 0;
 		}
 		if (_inlineCache.find(query) != _inlineCache.cend()) {
@@ -855,7 +858,7 @@ void GifsListWidget::searchForGifs(const QString &query) {
 
 	if (!_searchBot && !_searchBotRequestId) {
 		auto username = str_const_toString(kSearchBotUsername);
-		_searchBotRequestId = request(MTPcontacts_ResolveUsername(
+		_searchBotRequestId = _api.request(MTPcontacts_ResolveUsername(
 			MTP_string(username)
 		)).done([=](const MTPcontacts_ResolvedPeer &result) {
 			Expects(result.type() == mtpc_contacts_resolvedPeer);
@@ -905,7 +908,7 @@ void GifsListWidget::sendInlineRequest() {
 	}
 
 	_footer->setLoading(true);
-	_inlineRequestId = request(MTPmessages_GetInlineBotResults(
+	_inlineRequestId = _api.request(MTPmessages_GetInlineBotResults(
 		MTP_flags(0),
 		_searchBot->inputUser,
 		_inlineQueryPeer->input,
diff --git a/Telegram/SourceFiles/chat_helpers/gifs_list_widget.h b/Telegram/SourceFiles/chat_helpers/gifs_list_widget.h
index 1859459c0..f1ae5e73f 100644
--- a/Telegram/SourceFiles/chat_helpers/gifs_list_widget.h
+++ b/Telegram/SourceFiles/chat_helpers/gifs_list_widget.h
@@ -34,8 +34,7 @@ namespace ChatHelpers {
 class GifsListWidget
 	: public TabbedSelector::Inner
 	, public InlineBots::Layout::Context
-	, private base::Subscriber
-	, private MTP::Sender {
+	, private base::Subscriber {
 public:
 	using InlineChosen = TabbedSelector::InlineChosen;
 
@@ -119,6 +118,8 @@ private:
 	void updateInlineItems();
 	void showPreview();
 
+	MTP::Sender _api;
+
 	Section _section = Section::Gifs;
 	crl::time _lastScrolled = 0;
 	base::Timer _updateInlineItems;
diff --git a/Telegram/SourceFiles/chat_helpers/message_field.cpp b/Telegram/SourceFiles/chat_helpers/message_field.cpp
index f6ae4593f..c2f3983a5 100644
--- a/Telegram/SourceFiles/chat_helpers/message_field.cpp
+++ b/Telegram/SourceFiles/chat_helpers/message_field.cpp
@@ -278,6 +278,9 @@ void InitSpellchecker(
 		not_null<Main::Session*> session,
 		not_null<Ui::InputField*> field) {
 #ifndef TDESKTOP_DISABLE_SPELLCHECK
+	if (!Platform::Spellchecker::IsAvailable()) {
+		return;
+	}
 	const auto s = Ui::CreateChild<Spellchecker::SpellingHighlighter>(
 		field.get(),
 		session->settings().spellcheckerEnabledValue());
diff --git a/Telegram/SourceFiles/chat_helpers/stickers.cpp b/Telegram/SourceFiles/chat_helpers/stickers.cpp
index 6cebd226f..22601e302 100644
--- a/Telegram/SourceFiles/chat_helpers/stickers.cpp
+++ b/Telegram/SourceFiles/chat_helpers/stickers.cpp
@@ -9,6 +9,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 
 #include "data/data_document.h"
 #include "data/data_session.h"
+#include "data/data_file_origin.h"
 #include "boxes/stickers_box.h"
 #include "boxes/confirm_box.h"
 #include "lang/lang_keys.h"
@@ -891,7 +892,7 @@ std::optional<std::vector<not_null<EmojiPtr>>> GetEmojiListFromSet(
 		if (result.empty()) {
 			return std::nullopt;
 		}
-		return std::move(result);
+		return result;
 	}
 	return std::nullopt;
 }
diff --git a/Telegram/SourceFiles/chat_helpers/stickers_list_widget.cpp b/Telegram/SourceFiles/chat_helpers/stickers_list_widget.cpp
index e3cb75407..918da350d 100644
--- a/Telegram/SourceFiles/chat_helpers/stickers_list_widget.cpp
+++ b/Telegram/SourceFiles/chat_helpers/stickers_list_widget.cpp
@@ -10,6 +10,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "data/data_document.h"
 #include "data/data_session.h"
 #include "data/data_channel.h"
+#include "data/data_file_origin.h"
 #include "ui/widgets/buttons.h"
 #include "ui/effects/animations.h"
 #include "ui/effects/ripple_animation.h"
@@ -828,6 +829,7 @@ StickersListWidget::StickersListWidget(
 	QWidget *parent,
 	not_null<Window::SessionController*> controller)
 : Inner(parent, controller)
+, _api(controller->session().api().instance())
 , _section(Section::Stickers)
 , _megagroupSetAbout(st::columnMinimalWidthThird - st::emojiScroll.width - st::emojiPanHeaderLeft)
 , _addText(tr::lng_stickers_featured_add(tr::now).toUpper())
@@ -878,7 +880,7 @@ object_ptr<TabbedSelector::InnerFooter> StickersListWidget::createFooter() {
 
 	auto result = object_ptr<Footer>(this);
 	_footer = result;
-	return std::move(result);
+	return result;
 }
 
 void StickersListWidget::visibleTopBottomUpdated(
@@ -1069,7 +1071,7 @@ void StickersListWidget::sendSearchRequest() {
 
 	_footer->setLoading(true);
 	const auto hash = int32(0);
-	_searchRequestId = request(MTPmessages_SearchStickerSets(
+	_searchRequestId = _api.request(MTPmessages_SearchStickerSets(
 		MTP_flags(0),
 		MTP_string(_searchQuery),
 		MTP_int(hash)
@@ -1092,7 +1094,7 @@ void StickersListWidget::searchForSets(const QString &query) {
 	if (_searchQuery != cleaned) {
 		_footer->setLoading(false);
 		if (const auto requestId = base::take(_searchRequestId)) {
-			request(requestId).cancel();
+			_api.request(requestId).cancel();
 		}
 		if (_searchCache.find(cleaned) != _searchCache.cend()) {
 			_searchRequestTimer.cancel();
@@ -1108,7 +1110,7 @@ void StickersListWidget::searchForSets(const QString &query) {
 void StickersListWidget::cancelSetsSearch() {
 	_footer->setLoading(false);
 	if (const auto requestId = base::take(_searchRequestId)) {
-		request(requestId).cancel();
+		_api.request(requestId).cancel();
 	}
 	_searchRequestTimer.cancel();
 	_searchQuery = _searchNextQuery = QString();
@@ -2468,7 +2470,7 @@ void StickersListWidget::refreshMegagroupStickers(GroupStickersPlace place) {
 		return;
 	}
 	_megagroupSetIdRequested = set.vid().v;
-	request(MTPmessages_GetStickerSet(
+	_api.request(MTPmessages_GetStickerSet(
 		_megagroupSet->mgInfo->stickerSet
 	)).done([=](const MTPmessages_StickerSet &result) {
 		if (const auto set = Stickers::FeedSetFull(result)) {
@@ -2810,7 +2812,7 @@ void StickersListWidget::installSet(uint64 setId) {
 		const auto input = Stickers::inputSetId(*it);
 		if ((it->flags & MTPDstickerSet_ClientFlag::f_not_loaded)
 			|| it->stickers.empty()) {
-			request(MTPmessages_GetStickerSet(
+			_api.request(MTPmessages_GetStickerSet(
 				input
 			)).done([=](const MTPmessages_StickerSet &result) {
 				Stickers::FeedSetFull(result);
@@ -2825,7 +2827,7 @@ void StickersListWidget::installSet(uint64 setId) {
 void StickersListWidget::sendInstallRequest(
 		uint64 setId,
 		const MTPInputStickerSet &input) {
-	request(MTPmessages_InstallStickerSet(
+	_api.request(MTPmessages_InstallStickerSet(
 		input,
 		MTP_bool(false)
 	)).done([=](const MTPmessages_StickerSetInstallResult &result) {
@@ -2876,9 +2878,9 @@ void StickersListWidget::removeSet(uint64 setId) {
 			auto it = sets.find(_removingSetId);
 			if (it != sets.cend()) {
 				if (it->id && it->access) {
-					request(MTPmessages_UninstallStickerSet(MTP_inputStickerSetID(MTP_long(it->id), MTP_long(it->access)))).send();
+					_api.request(MTPmessages_UninstallStickerSet(MTP_inputStickerSetID(MTP_long(it->id), MTP_long(it->access)))).send();
 				} else if (!it->shortName.isEmpty()) {
-					request(MTPmessages_UninstallStickerSet(MTP_inputStickerSetShortName(MTP_string(it->shortName)))).send();
+					_api.request(MTPmessages_UninstallStickerSet(MTP_inputStickerSetShortName(MTP_string(it->shortName)))).send();
 				}
 				auto writeRecent = false;
 				auto &recent = Stickers::GetRecentPack();
diff --git a/Telegram/SourceFiles/chat_helpers/stickers_list_widget.h b/Telegram/SourceFiles/chat_helpers/stickers_list_widget.h
index 53c11c794..b0e17bea7 100644
--- a/Telegram/SourceFiles/chat_helpers/stickers_list_widget.h
+++ b/Telegram/SourceFiles/chat_helpers/stickers_list_widget.h
@@ -38,8 +38,7 @@ struct StickerIcon;
 
 class StickersListWidget
 	: public TabbedSelector::Inner
-	, private base::Subscriber
-	, private MTP::Sender {
+	, private base::Subscriber {
 public:
 	StickersListWidget(
 		QWidget *parent,
@@ -300,6 +299,7 @@ private:
 
 	void showPreview();
 
+	MTP::Sender _api;
 	ChannelData *_megagroupSet = nullptr;
 	uint64 _megagroupSetIdRequested = 0;
 	std::vector<Set> _mySets;
diff --git a/Telegram/SourceFiles/chat_helpers/tabbed_panel.cpp b/Telegram/SourceFiles/chat_helpers/tabbed_panel.cpp
index fad55a7d9..b5b24688c 100644
--- a/Telegram/SourceFiles/chat_helpers/tabbed_panel.cpp
+++ b/Telegram/SourceFiles/chat_helpers/tabbed_panel.cpp
@@ -51,6 +51,8 @@ TabbedPanel::TabbedPanel(
 , _heightRatio(st::emojiPanHeightRatio)
 , _minContentHeight(st::emojiPanMinHeight)
 , _maxContentHeight(st::emojiPanMaxHeight) {
+	Expects(_selector != nullptr);
+
 	_selector->setParent(this);
 	_selector->setRoundRadius(st::buttonRadius);
 	_selector->setAfterShownCallback([=](SelectorTab tab) {
@@ -145,10 +147,6 @@ void TabbedPanel::setDesiredHeightValues(
 }
 
 void TabbedPanel::updateContentHeight() {
-	if (isDestroying()) {
-		return;
-	}
-
 	auto addedHeight = innerPadding().top() + innerPadding().bottom();
 	auto marginsHeight = _selector->marginTop() + _selector->marginBottom();
 	auto availableHeight = _bottom - marginsHeight;
@@ -183,7 +181,7 @@ void TabbedPanel::paintEvent(QPaintEvent *e) {
 	auto showAnimating = _a_show.animating();
 	if (_showAnimation && !showAnimating) {
 		_showAnimation.reset();
-		if (!opacityAnimating && !isDestroying()) {
+		if (!opacityAnimating) {
 			showChildren();
 			_selector->afterShown();
 		}
@@ -217,9 +215,6 @@ void TabbedPanel::enterEventHook(QEvent *e) {
 }
 
 bool TabbedPanel::preventAutoHide() const {
-	if (isDestroying()) {
-		return false;
-	}
 	return _selector->preventAutoHide();
 }
 
@@ -267,7 +262,7 @@ void TabbedPanel::hideFast() {
 void TabbedPanel::opacityAnimationCallback() {
 	update();
 	if (!_a_opacity.animating()) {
-		if (_hiding || isDestroying()) {
+		if (_hiding) {
 			_hiding = false;
 			hideFinished();
 		} else if (!_a_show.animating()) {
@@ -363,7 +358,7 @@ void TabbedPanel::hideAnimated() {
 	}
 
 	_hideTimer.cancel();
-	if (!isDestroying() && _selector->isSliding()) {
+	if (_selector->isSliding()) {
 		_hideAfterSlide = true;
 	} else {
 		startOpacityAnimation(true);
@@ -371,9 +366,6 @@ void TabbedPanel::hideAnimated() {
 }
 
 void TabbedPanel::toggleAnimated() {
-	if (isDestroying()) {
-		return;
-	}
 	if (isHidden() || _hiding || _hideAfterSlide) {
 		showAnimated();
 	} else {
@@ -387,11 +379,7 @@ void TabbedPanel::hideFinished() {
 	_showAnimation.reset();
 	_cache = QPixmap();
 	_hiding = false;
-	if (isDestroying()) {
-		deleteLater();
-	} else {
-		_selector->hideFinished();
-	}
+	_selector->hideFinished();
 }
 
 void TabbedPanel::showAnimated() {
@@ -401,9 +389,6 @@ void TabbedPanel::showAnimated() {
 }
 
 void TabbedPanel::showStarted() {
-	if (isDestroying()) {
-		return;
-	}
 	if (isHidden()) {
 		_selector->showStarted();
 		moveByBottom();
@@ -416,9 +401,6 @@ void TabbedPanel::showStarted() {
 }
 
 bool TabbedPanel::eventFilter(QObject *obj, QEvent *e) {
-	if (isDestroying()) {
-		return false;
-	}
 	if (e->type() == QEvent::Enter) {
 		otherEnter();
 	} else if (e->type() == QEvent::Leave) {
@@ -455,6 +437,7 @@ bool TabbedPanel::overlaps(const QRect &globalRect) const {
 }
 
 TabbedPanel::~TabbedPanel() {
+	hideFast();
 	if (!_ownedSelector) {
 		_controller->takeTabbedSelectorOwnershipFrom(this);
 	}
diff --git a/Telegram/SourceFiles/chat_helpers/tabbed_panel.h b/Telegram/SourceFiles/chat_helpers/tabbed_panel.h
index 0ffdc29c2..b05966792 100644
--- a/Telegram/SourceFiles/chat_helpers/tabbed_panel.h
+++ b/Telegram/SourceFiles/chat_helpers/tabbed_panel.h
@@ -75,9 +75,6 @@ private:
 
 	void hideByTimerOrLeave();
 	void moveByBottom();
-	bool isDestroying() const {
-		return !_selector;
-	}
 	void showFromSelector();
 
 	style::margins innerPadding() const;
diff --git a/Telegram/SourceFiles/chat_helpers/tabbed_section.cpp b/Telegram/SourceFiles/chat_helpers/tabbed_section.cpp
index 990ccbd78..00480179a 100644
--- a/Telegram/SourceFiles/chat_helpers/tabbed_section.cpp
+++ b/Telegram/SourceFiles/chat_helpers/tabbed_section.cpp
@@ -20,7 +20,7 @@ object_ptr<Window::SectionWidget> TabbedMemento::createWidget(
 		const QRect &geometry) {
 	auto result = object_ptr<TabbedSection>(parent, controller);
 	result->setGeometry(geometry);
-	return std::move(result);
+	return result;
 }
 
 TabbedSection::TabbedSection(
@@ -51,6 +51,10 @@ void TabbedSection::resizeEvent(QResizeEvent *e) {
 	_selector->setGeometry(rect());
 }
 
+void TabbedSection::showFinishedHook() {
+	afterShown();
+}
+
 bool TabbedSection::showInternal(
 		not_null<Window::SectionMemento*> memento,
 		const Window::SectionShow &params) {
diff --git a/Telegram/SourceFiles/chat_helpers/tabbed_section.h b/Telegram/SourceFiles/chat_helpers/tabbed_section.h
index 200496907..a93202fd1 100644
--- a/Telegram/SourceFiles/chat_helpers/tabbed_section.h
+++ b/Telegram/SourceFiles/chat_helpers/tabbed_section.h
@@ -52,9 +52,7 @@ public:
 protected:
 	void resizeEvent(QResizeEvent *e) override;
 
-	void showFinishedHook() override {
-		afterShown();
-	}
+	void showFinishedHook() override;
 
 private:
 	const not_null<TabbedSelector*> _selector;
diff --git a/Telegram/SourceFiles/codegen/scheme/codegen_scheme.py b/Telegram/SourceFiles/codegen/scheme/codegen_scheme.py
index 08e546979..ff0e91d47 100644
--- a/Telegram/SourceFiles/codegen/scheme/codegen_scheme.py
+++ b/Telegram/SourceFiles/codegen/scheme/codegen_scheme.py
@@ -14,7 +14,7 @@ from generate_tl import generate
 
 generate({
   'namespaces': {
-    'creator': 'MTP::internal',
+    'creator': 'MTP::details',
   },
   'prefixes': {
     'type': 'MTP',
@@ -28,7 +28,6 @@ generate({
     'buffer': 'mtpBuffer',
   },
   'sections': [
-    'serialization',
     'read-write',
   ],
 
@@ -91,4 +90,8 @@ generate({
   },
   'builtinInclude': 'mtproto/core_types.h',
 
+  'dumpToText': {
+    'include': 'mtproto/details/mtproto_dump_to_text.h',
+  },
+
 })
diff --git a/Telegram/SourceFiles/core/application.cpp b/Telegram/SourceFiles/core/application.cpp
index 118e46d65..0a71fcda6 100644
--- a/Telegram/SourceFiles/core/application.cpp
+++ b/Telegram/SourceFiles/core/application.cpp
@@ -94,6 +94,7 @@ Application::Application(not_null<Launcher*> launcher)
 , _dcOptions(std::make_unique<MTP::DcOptions>())
 , _account(std::make_unique<Main::Account>(cDataFile()))
 , _langpack(std::make_unique<Lang::Instance>())
+, _langCloudManager(std::make_unique<Lang::CloudManager>(langpack()))
 , _emojiKeywords(std::make_unique<ChatHelpers::EmojiKeywords>())
 , _audio(std::make_unique<Media::Audio::Instance>())
 , _logo(Window::LoadLogo())
@@ -115,9 +116,6 @@ Application::Application(not_null<Launcher*> launcher)
 	) | rpl::filter([=](MTP::Instance *instance) {
 		return instance != nullptr;
 	}) | rpl::start_with_next([=](not_null<MTP::Instance*> mtp) {
-		_langCloudManager = std::make_unique<Lang::CloudManager>(
-			langpack(),
-			mtp);
 		if (!UpdaterDisabled()) {
 			UpdateChecker().setMtproto(mtp.get());
 		}
@@ -126,7 +124,14 @@ Application::Application(not_null<Launcher*> launcher)
 
 Application::~Application() {
 	_window.reset();
-	_mediaView.reset();
+	if (_mediaView) {
+		_mediaView->clearData();
+		_mediaView = nullptr;
+	}
+
+	if (activeAccount().sessionExists()) {
+		activeAccount().session().saveSettingsNowIfNeeded();
+	}
 
 	// This can call writeMap() that serializes Main::Session.
 	// In case it gets called after destroySession() we get missing data.
@@ -135,11 +140,6 @@ Application::~Application() {
 	// Some MTP requests can be cancelled from data clearing.
 	unlockTerms();
 	activeAccount().destroySession();
-
-	// The langpack manager should be destroyed before MTProto instance,
-	// because it is MTP::Sender and it may have pending requests.
-	_langCloudManager.reset();
-
 	activeAccount().clearMtp();
 
 	Shortcuts::Finish();
@@ -147,7 +147,6 @@ Application::~Application() {
 	Ui::Emoji::Clear();
 	Media::Clip::Finish();
 
-	stopWebLoadManager();
 	App::deinitMedia();
 
 	Window::Theme::Uninitialize();
@@ -208,9 +207,9 @@ void Application::run() {
 	style::ShortAnimationPlaying(
 	) | rpl::start_with_next([=](bool playing) {
 		if (playing) {
-			MTP::internal::pause();
+			MTP::details::pause();
 		} else {
-			MTP::internal::unpause();
+			MTP::details::unpause();
 		}
 	}, _lifetime);
 
@@ -387,12 +386,12 @@ void Application::saveSettingsDelayed(crl::time delay) {
 }
 
 void Application::setCurrentProxy(
-		const ProxyData &proxy,
-		ProxyData::Settings settings) {
+		const MTP::ProxyData &proxy,
+		MTP::ProxyData::Settings settings) {
 	const auto current = [&] {
-		return (Global::ProxySettings() == ProxyData::Settings::Enabled)
+		return (Global::ProxySettings() == MTP::ProxyData::Settings::Enabled)
 			? Global::SelectedProxy()
-			: ProxyData();
+			: MTP::ProxyData();
 	};
 	const auto was = current();
 	Global::SetSelectedProxy(proxy);
@@ -408,12 +407,12 @@ auto Application::proxyChanges() const -> rpl::producer<ProxyChange> {
 }
 
 void Application::badMtprotoConfigurationError() {
-	if (Global::ProxySettings() == ProxyData::Settings::Enabled
+	if (Global::ProxySettings() == MTP::ProxyData::Settings::Enabled
 		&& !_badProxyDisableBox) {
 		const auto disableCallback = [=] {
 			setCurrentProxy(
 				Global::SelectedProxy(),
-				ProxyData::Settings::System);
+				MTP::ProxyData::Settings::System);
 		};
 		_badProxyDisableBox = Ui::show(Box<InformBox>(
 			Lang::Hard::ProxyConfigError(),
@@ -423,14 +422,18 @@ void Application::badMtprotoConfigurationError() {
 
 void Application::startLocalStorage() {
 	Local::start();
-	subscribe(_dcOptions->changed(), [this](const MTP::DcOptions::Ids &ids) {
-		Local::writeSettings();
-		if (const auto instance = activeAccount().mtp()) {
-			for (const auto id : ids) {
-				instance->restart(id);
-			}
-		}
-	});
+
+	const auto writing = _lifetime.make_state<bool>(false);
+	_dcOptions->changed(
+	) | rpl::filter([=] {
+		return !*writing;
+	}) | rpl::start_with_next([=] {
+		*writing = true;
+		Ui::PostponeCall(this, [=] {
+			Local::writeSettings();
+		});
+	}, _lifetime);
+
 	_saveSettingsTimer.setCallback([=] { Local::writeSettings(); });
 }
 
@@ -604,27 +607,36 @@ void Application::checkStartUrl() {
 }
 
 bool Application::openLocalUrl(const QString &url, QVariant context) {
-	auto urlTrimmed = url.trimmed();
-	if (urlTrimmed.size() > 8192) urlTrimmed = urlTrimmed.mid(0, 8192);
+	return openCustomUrl("tg://", LocalUrlHandlers(), url, context);
+}
 
-	const auto protocol = qstr("tg://");
+bool Application::openInternalUrl(const QString &url, QVariant context) {
+	return openCustomUrl("internal:", InternalUrlHandlers(), url, context);
+}
+
+bool Application::openCustomUrl(
+		const QString &protocol,
+		const std::vector<LocalUrlHandler> &handlers,
+		const QString &url,
+		const QVariant &context) {
+	const auto urlTrimmed = url.trimmed();
 	if (!urlTrimmed.startsWith(protocol, Qt::CaseInsensitive) || locked()) {
 		return false;
 	}
-	auto command = urlTrimmed.midRef(protocol.size());
-
+	const auto command = urlTrimmed.midRef(protocol.size(), 8192);
 	const auto session = activeAccount().sessionExists()
 		? &activeAccount().session()
 		: nullptr;
 	using namespace qthelp;
 	const auto options = RegExOption::CaseInsensitive;
-	for (const auto &[expression, handler] : LocalUrlHandlers()) {
+	for (const auto &[expression, handler] : handlers) {
 		const auto match = regex_match(expression, command, options);
 		if (match) {
 			return handler(session, match, context);
 		}
 	}
 	return false;
+
 }
 
 void Application::lockByPasscode() {
diff --git a/Telegram/SourceFiles/core/application.h b/Telegram/SourceFiles/core/application.h
index 6129e71bd..dd0b1a805 100644
--- a/Telegram/SourceFiles/core/application.h
+++ b/Telegram/SourceFiles/core/application.h
@@ -8,7 +8,8 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #pragma once
 
 #include "core/core_settings.h"
-#include "mtproto/auth_key.h"
+#include "mtproto/mtproto_auth_key.h"
+#include "mtproto/mtproto_proxy_data.h"
 #include "base/observer.h"
 #include "base/timer.h"
 
@@ -131,12 +132,12 @@ public:
 		return _dcOptions.get();
 	}
 	struct ProxyChange {
-		ProxyData was;
-		ProxyData now;
+		MTP::ProxyData was;
+		MTP::ProxyData now;
 	};
 	void setCurrentProxy(
-		const ProxyData &proxy,
-		ProxyData::Settings settings);
+		const MTP::ProxyData &proxy,
+		MTP::ProxyData::Settings settings);
 	[[nodiscard]] rpl::producer<ProxyChange> proxyChanges() const;
 	void badMtprotoConfigurationError();
 
@@ -177,6 +178,7 @@ public:
 	QString createInternalLinkFull(const QString &query) const;
 	void checkStartUrl();
 	bool openLocalUrl(const QString &url, QVariant context);
+	bool openInternalUrl(const QString &url, QVariant context);
 
 	void forceLogOut(const TextWithEntities &explanation);
 	void checkLocalTime();
@@ -240,6 +242,12 @@ private:
 
 	void clearPasscodeLock();
 
+	bool openCustomUrl(
+		const QString &protocol,
+		const std::vector<LocalUrlHandler> &handlers,
+		const QString &url,
+		const QVariant &context);
+
 	static Application *Instance;
 	struct InstanceSetter {
 		InstanceSetter(not_null<Application*> instance) {
@@ -265,7 +273,7 @@ private:
 	std::unique_ptr<Window::Controller> _window;
 	std::unique_ptr<Media::View::OverlayWidget> _mediaView;
 	const std::unique_ptr<Lang::Instance> _langpack;
-	std::unique_ptr<Lang::CloudManager> _langCloudManager;
+	const std::unique_ptr<Lang::CloudManager> _langCloudManager;
 	const std::unique_ptr<ChatHelpers::EmojiKeywords> _emojiKeywords;
 	std::unique_ptr<Lang::Translator> _translator;
 	base::Observable<void> _passcodedChanged;
diff --git a/Telegram/SourceFiles/core/changelogs.cpp b/Telegram/SourceFiles/core/changelogs.cpp
index 6ab48f095..688a722e8 100644
--- a/Telegram/SourceFiles/core/changelogs.cpp
+++ b/Telegram/SourceFiles/core/changelogs.cpp
@@ -19,50 +19,31 @@ namespace {
 std::map<int, const char*> BetaLogs() {
 	return {
 	{
-		1006004,
-		"- Replace media when editing messages with media content.\n"
-
-		"- Jump quickly to the top of your chats list.\n"
+		1008005,
+		"\xE2\x80\xA2 Create new themes based on your color "
+		"and wallpaper choices.\n"
 
-		"- Get emoji suggestions for the first word you type in a message.\n"
+		"\xE2\x80\xA2 Share your themes with other users via links.\n"
 
-		"- Help Telegram improve emoji suggestions in your language "
-		"using this interface https://translations.telegram.org/en/emoji"
-	},
-	{
-		1007001,
-		"- Disable pinned messages notifications in Settings."
+		"\xE2\x80\xA2 Update your theme for all its users "
+		"when you change something.\n"
 	},
 	{
-		1007004,
-		"- Download video files while watching them using streaming."
-	},
-	{
-		1007008,
-		"\xE2\x80\xA2 Hide archived chats in the main menu.\n"
-
-		"\xE2\x80\xA2 See who is online straight from the chat list.\n"
-
-		"\xE2\x80\xA2 Apply formatting to selected text parts "
-		"from the MacBook Pro TouchBar."
+		1009000,
+		"\xE2\x80\xA2 System spell checker on Windows 8+ and macOS 10.12+.\n"
 	},
 	{
-		1007011,
-		"\xE2\x80\xA2 Use strikethrough and underline formatting.\n"
+		1009002,
+		"\xE2\x80\xA2 Videos in chats start playing automatically.\n"
 
-		"\xE2\x80\xA2 Bug fixes and other minor improvements."
-	},
-	{
-		1008005,
-		"\xE2\x80\xA2 Create new themes based on your color and wallpaper choices.\n"
+		"\xE2\x80\xA2 Resume playback from where you left off "
+		"when watching long videos.\n"
 
-		"\xE2\x80\xA2 Share your themes with other users via links.\n"
+		"\xE2\x80\xA2 Control videos, GIFs and round video messages "
+		"automatic playback in "
+		"Settings > Advanced > Automatic media download.\n"
 
-		"\xE2\x80\xA2 Update your theme for all its users when you change something.\n"
-	},
-	{
-		1009000,
-		"\xE2\x80\xA2 System spellchecker on Windows 8+ and macOS 10.12+.\n"
+		"\xE2\x80\xA2 Spell checker on Linux using Enchant.\n"
 	},
 	};
 };
diff --git a/Telegram/SourceFiles/core/click_handler_types.cpp b/Telegram/SourceFiles/core/click_handler_types.cpp
index e98d6a5e6..6434b56f7 100644
--- a/Telegram/SourceFiles/core/click_handler_types.cpp
+++ b/Telegram/SourceFiles/core/click_handler_types.cpp
@@ -43,7 +43,8 @@ void HiddenUrlClickHandler::Open(QString url, QVariant context) {
 	const auto open = [=] {
 		UrlClickHandler::Open(url, context);
 	};
-	if (url.startsWith(qstr("tg://"), Qt::CaseInsensitive)) {
+	if (url.startsWith(qstr("tg://"), Qt::CaseInsensitive)
+		|| url.startsWith(qstr("internal:"), Qt::CaseInsensitive)) {
 		open();
 	} else {
 		const auto parsedUrl = QUrl::fromUserInput(url);
@@ -55,7 +56,9 @@ void HiddenUrlClickHandler::Open(QString url, QVariant context) {
 				: url;
 			Ui::show(
 				Box<ConfirmBox>(
-					tr::lng_open_this_link(tr::now) + qsl("\n\n") + displayUrl,
+					(tr::lng_open_this_link(tr::now)
+						+ qsl("\n\n")
+						+ displayUrl),
 					tr::lng_open_link(tr::now),
 					[=] { Ui::hideLayer(); open(); }),
 				Ui::LayerOption::KeepOther);
diff --git a/Telegram/SourceFiles/core/core_cloud_password.cpp b/Telegram/SourceFiles/core/core_cloud_password.cpp
index 982154a96..22b14a717 100644
--- a/Telegram/SourceFiles/core/core_cloud_password.cpp
+++ b/Telegram/SourceFiles/core/core_cloud_password.cpp
@@ -8,7 +8,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "core/core_cloud_password.h"
 
 #include "base/openssl_help.h"
-#include "mtproto/connection.h"
+#include "mtproto/mtproto_dh_utils.h"
 
 namespace Core {
 namespace {
diff --git a/Telegram/SourceFiles/core/crash_report_window.cpp b/Telegram/SourceFiles/core/crash_report_window.cpp
index 583128c1b..273db108c 100644
--- a/Telegram/SourceFiles/core/crash_report_window.cpp
+++ b/Telegram/SourceFiles/core/crash_report_window.cpp
@@ -814,10 +814,10 @@ void LastCrashedWindow::onNetworkSettingsSaved(
 		QString password) {
 	Expects(host.isEmpty() || port != 0);
 
-	auto proxy = ProxyData();
+	auto proxy = MTP::ProxyData();
 	proxy.type = host.isEmpty()
-		? ProxyData::Type::None
-		: ProxyData::Type::Http;
+		? MTP::ProxyData::Type::None
+		: MTP::ProxyData::Type::Http;
 	proxy.host = host;
 	proxy.port = port;
 	proxy.user = username;
@@ -843,7 +843,7 @@ void LastCrashedWindow::proxyUpdated() {
 	activate();
 }
 
-rpl::producer<ProxyData> LastCrashedWindow::proxyChanges() const {
+rpl::producer<MTP::ProxyData> LastCrashedWindow::proxyChanges() const {
 	return _proxyChanges.events();
 }
 
diff --git a/Telegram/SourceFiles/core/crash_report_window.h b/Telegram/SourceFiles/core/crash_report_window.h
index 59b4ac72f..16507c744 100644
--- a/Telegram/SourceFiles/core/crash_report_window.h
+++ b/Telegram/SourceFiles/core/crash_report_window.h
@@ -16,6 +16,10 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include <QtNetwork/QHttpMultiPart>
 #include <QtNetwork/QNetworkAccessManager>
 
+namespace MTP {
+struct ProxyData;
+} // namespace MTP
+
 namespace Core {
 class Launcher;
 } // namespace Core
@@ -96,7 +100,7 @@ public:
 		const QByteArray &crashdump,
 		Fn<void()> launch);
 
-	rpl::producer<ProxyData> proxyChanges() const;
+	rpl::producer<MTP::ProxyData> proxyChanges() const;
 
 	rpl::lifetime &lifetime() {
 		return _lifetime;
@@ -199,7 +203,7 @@ private:
 	void setDownloadProgress(qint64 ready, qint64 total);
 
 	Fn<void()> _launch;
-	rpl::event_stream<ProxyData> _proxyChanges;
+	rpl::event_stream<MTP::ProxyData> _proxyChanges;
 	rpl::lifetime _lifetime;
 
 };
diff --git a/Telegram/SourceFiles/core/local_url_handlers.cpp b/Telegram/SourceFiles/core/local_url_handlers.cpp
index f19f54a24..fdb9a0198 100644
--- a/Telegram/SourceFiles/core/local_url_handlers.cpp
+++ b/Telegram/SourceFiles/core/local_url_handlers.cpp
@@ -23,8 +23,10 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "passport/passport_form_controller.h"
 #include "window/window_session_controller.h"
 #include "data/data_session.h"
+#include "data/data_document.h"
 #include "data/data_cloud_themes.h"
 #include "data/data_channel.h"
+#include "media/player/media_player_instance.h"
 #include "mainwindow.h"
 #include "mainwidget.h"
 #include "main/main_session.h"
@@ -163,7 +165,9 @@ bool ApplySocksProxy(
 	auto params = url_parse_params(
 		match->captured(1),
 		qthelp::UrlParamNameTransform::ToLower);
-	ProxiesBoxController::ShowApplyConfirmation(ProxyData::Type::Socks5, params);
+	ProxiesBoxController::ShowApplyConfirmation(
+		MTP::ProxyData::Type::Socks5,
+		params);
 	return true;
 }
 
@@ -174,7 +178,9 @@ bool ApplyMtprotoProxy(
 	auto params = url_parse_params(
 		match->captured(1),
 		qthelp::UrlParamNameTransform::ToLower);
-	ProxiesBoxController::ShowApplyConfirmation(ProxyData::Type::Mtproto, params);
+	ProxiesBoxController::ShowApplyConfirmation(
+		MTP::ProxyData::Type::Mtproto,
+		params);
 	return true;
 }
 
@@ -358,6 +364,40 @@ bool HandleUnknown(
 	return true;
 }
 
+bool OpenMediaTimestamp(
+		Main::Session *session,
+		const Match &match,
+		const QVariant &context) {
+	if (!session) {
+		return false;
+	}
+	const auto time = match->captured(2).toInt();
+	if (time < 0) {
+		return false;
+	}
+	const auto base = match->captured(1);
+	if (base.startsWith(qstr("doc"))) {
+		const auto parts = base.mid(3).split('_');
+		const auto documentId = parts.value(0).toULongLong();
+		const auto itemId = FullMsgId(
+			parts.value(1).toInt(),
+			parts.value(2).toInt());
+		const auto document = session->data().document(documentId);
+		session->settings().setMediaLastPlaybackPosition(
+			documentId,
+			time * crl::time(1000));
+		if (document->isVideoFile()) {
+			Core::App().showDocument(
+				document,
+				session->data().message(itemId));
+		} else if (document->isSong()) {
+			Media::Player::instance()->play({ document, itemId });
+		}
+		return true;
+	}
+	return false;
+}
+
 } // namespace
 
 const std::vector<LocalUrlHandler> &LocalUrlHandlers() {
@@ -417,7 +457,17 @@ const std::vector<LocalUrlHandler> &LocalUrlHandlers() {
 		{
 			qsl("^([^\\?]+)(\\?|#|$)"),
 			HandleUnknown
-		}
+		},
+	};
+	return Result;
+}
+
+const std::vector<LocalUrlHandler> &InternalUrlHandlers() {
+	static auto Result = std::vector<LocalUrlHandler>{
+		{
+			qsl("^media_timestamp/?\\?base=([a-zA-Z0-9\\.\\_\\-]+)&t=(\\d+)(&|$)"),
+			OpenMediaTimestamp
+		},
 	};
 	return Result;
 }
diff --git a/Telegram/SourceFiles/core/local_url_handlers.h b/Telegram/SourceFiles/core/local_url_handlers.h
index 38c437e64..98e1893c9 100644
--- a/Telegram/SourceFiles/core/local_url_handlers.h
+++ b/Telegram/SourceFiles/core/local_url_handlers.h
@@ -26,6 +26,7 @@ struct LocalUrlHandler {
 };
 
 [[nodiscard]] const std::vector<LocalUrlHandler> &LocalUrlHandlers();
+[[nodiscard]] const std::vector<LocalUrlHandler> &InternalUrlHandlers();
 
 [[nodiscard]] QString TryConvertUrlToLocal(QString url);
 
diff --git a/Telegram/SourceFiles/core/sandbox.cpp b/Telegram/SourceFiles/core/sandbox.cpp
index 6f255a94c..762fd66d6 100644
--- a/Telegram/SourceFiles/core/sandbox.cpp
+++ b/Telegram/SourceFiles/core/sandbox.cpp
@@ -329,7 +329,7 @@ void Sandbox::singleInstanceChecked() {
 			_lastCrashDump,
 			[=] { launchApplication(); });
 		window->proxyChanges(
-		) | rpl::start_with_next([=](ProxyData &&proxy) {
+		) | rpl::start_with_next([=](MTP::ProxyData &&proxy) {
 			_sandboxProxy = std::move(proxy);
 			refreshGlobalProxy();
 		}, window->lifetime());
@@ -443,15 +443,15 @@ void Sandbox::refreshGlobalProxy() {
 #ifndef TDESKTOP_DISABLE_NETWORK_PROXY
 	const auto proxy = !Global::started()
 		? _sandboxProxy
-		: (Global::ProxySettings() == ProxyData::Settings::Enabled)
+		: (Global::ProxySettings() == MTP::ProxyData::Settings::Enabled)
 		? Global::SelectedProxy()
-		: ProxyData();
-	if (proxy.type == ProxyData::Type::Socks5
-		|| proxy.type == ProxyData::Type::Http) {
+		: MTP::ProxyData();
+	if (proxy.type == MTP::ProxyData::Type::Socks5
+		|| proxy.type == MTP::ProxyData::Type::Http) {
 		QNetworkProxy::setApplicationProxy(
-			ToNetworkProxy(ToDirectIpProxy(proxy)));
+			MTP::ToNetworkProxy(MTP::ToDirectIpProxy(proxy)));
 	} else if (!Global::started()
-		|| Global::ProxySettings() == ProxyData::Settings::System) {
+		|| Global::ProxySettings() == MTP::ProxyData::Settings::System) {
 		QNetworkProxyFactory::setUseSystemConfiguration(true);
 	} else {
 		QNetworkProxy::setApplicationProxy(QNetworkProxy::NoProxy);
@@ -555,7 +555,7 @@ rpl::producer<> Sandbox::widgetUpdateRequests() const {
 	return _widgetUpdateRequests.events();
 }
 
-ProxyData Sandbox::sandboxProxy() const {
+MTP::ProxyData Sandbox::sandboxProxy() const {
 	return _sandboxProxy;
 }
 
diff --git a/Telegram/SourceFiles/core/sandbox.h b/Telegram/SourceFiles/core/sandbox.h
index 7719f8419..f2b591706 100644
--- a/Telegram/SourceFiles/core/sandbox.h
+++ b/Telegram/SourceFiles/core/sandbox.h
@@ -7,6 +7,8 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 */
 #pragma once
 
+#include "mtproto/mtproto_proxy_data.h"
+
 #include <QtWidgets/QApplication>
 #include <QtNetwork/QLocalServer>
 #include <QtNetwork/QLocalSocket>
@@ -50,7 +52,7 @@ public:
 
 	rpl::producer<> widgetUpdateRequests() const;
 
-	ProxyData sandboxProxy() const;
+	MTP::ProxyData sandboxProxy() const;
 
 	static Sandbox &Instance() {
 		Expects(QCoreApplication::instance() != nullptr);
@@ -119,7 +121,7 @@ private:
 	std::unique_ptr<UpdateChecker> _updateChecker;
 
 	QByteArray _lastCrashDump;
-	ProxyData _sandboxProxy;
+	MTP::ProxyData _sandboxProxy;
 
 	rpl::event_stream<> _widgetUpdateRequests;
 
diff --git a/Telegram/SourceFiles/core/ui_integration.cpp b/Telegram/SourceFiles/core/ui_integration.cpp
index a878b9075..ccc76aa66 100644
--- a/Telegram/SourceFiles/core/ui_integration.cpp
+++ b/Telegram/SourceFiles/core/ui_integration.cpp
@@ -126,6 +126,9 @@ bool UiIntegration::handleUrlClick(
 	} else if (local.startsWith(qstr("tg://"), Qt::CaseInsensitive)) {
 		Core::App().openLocalUrl(local, context);
 		return true;
+	} else if (local.startsWith(qstr("internal:"), Qt::CaseInsensitive)) {
+		Core::App().openInternalUrl(local, context);
+		return true;
 	}
 	return false;
 
diff --git a/Telegram/SourceFiles/core/utils.cpp b/Telegram/SourceFiles/core/utils.cpp
index 54ded4de8..13133e4fb 100644
--- a/Telegram/SourceFiles/core/utils.cpp
+++ b/Telegram/SourceFiles/core/utils.cpp
@@ -58,134 +58,6 @@ static_assert(sizeof(MTPdouble) == 8, "Basic types size check failed");
 
 static_assert(sizeof(int) >= 4, "Basic types size check failed");
 
-namespace {
-
-std::atomic<int> GlobalAtomicRequestId = 0;
-
-[[nodiscard]] bool IsHexMtprotoPassword(const QString &password) {
-	const auto size = password.size();
-	if (size < 32 || size % 2 == 1) {
-		return false;
-	}
-	const auto bad = [](QChar ch) {
-		const auto code = ch.unicode();
-		return (code < 'a' || code > 'f')
-			&& (code < 'A' || code > 'F')
-			&& (code < '0' || code > '9');
-	};
-	const auto i = std::find_if(password.begin(), password.end(), bad);
-	return (i == password.end());
-}
-
-[[nodiscard]] ProxyData::Status HexMtprotoPasswordStatus(
-		const QString &password) {
-	const auto size = password.size() / 2;
-	const auto valid = (size == 16)
-		|| (size == 17 && (password[0] == 'd') && (password[1] == 'd'))
-		|| (size >= 21 && (password[0] == 'e') && (password[1] == 'e'));
-	if (valid) {
-		return ProxyData::Status::Valid;
-	} else if (size < 16) {
-		return ProxyData::Status::Invalid;
-	}
-	return ProxyData::Status::Unsupported;
-}
-
-[[nodiscard]] bytes::vector SecretFromHexMtprotoPassword(
-		const QString &password) {
-	Expects(password.size() % 2 == 0);
-
-	const auto size = password.size() / 2;
-	const auto fromHex = [](QChar ch) -> int {
-		const auto code = int(ch.unicode());
-		if (code >= '0' && code <= '9') {
-			return (code - '0');
-		} else if (code >= 'A' && code <= 'F') {
-			return 10 + (code - 'A');
-		} else if (ch >= 'a' && ch <= 'f') {
-			return 10 + (code - 'a');
-		}
-		Unexpected("Code in ProxyData fromHex.");
-	};
-	auto result = bytes::vector(size);
-	for (auto i = 0; i != size; ++i) {
-		const auto high = fromHex(password[2 * i]);
-		const auto low = fromHex(password[2 * i + 1]);
-		if (high < 0 || low < 0) {
-			return {};
-		}
-		result[i] = static_cast<bytes::type>(high * 16 + low);
-	}
-	return result;
-}
-
-[[nodiscard]] QStringRef Base64UrlInner(const QString &password) {
-	Expects(password.size() > 2);
-
-	// Skip one or two '=' at the end of the string.
-	return password.midRef(0, [&] {
-		auto result = password.size();
-		for (auto i = 0; i != 2; ++i) {
-			const auto prev = result - 1;
-			if (password[prev] != '=') {
-				break;
-			}
-			result = prev;
-		}
-		return result;
-	}());
-}
-
-[[nodiscard]] bool IsBase64UrlMtprotoPassword(const QString &password) {
-	const auto size = password.size();
-	if (size < 22 || size % 4 == 1) {
-		return false;
-	}
-	const auto bad = [](QChar ch) {
-		const auto code = ch.unicode();
-		return (code < 'a' || code > 'z')
-			&& (code < 'A' || code > 'Z')
-			&& (code < '0' || code > '9')
-			&& (code != '_')
-			&& (code != '-');
-	};
-	const auto inner = Base64UrlInner(password);
-	const auto begin = inner.data();
-	const auto end = begin + inner.size();
-	return (std::find_if(begin, end, bad) == end);
-}
-
-[[nodiscard]] ProxyData::Status Base64UrlMtprotoPasswordStatus(
-		const QString &password) {
-	const auto inner = Base64UrlInner(password);
-	const auto size = (inner.size() * 3) / 4;
-	const auto valid = (size == 16)
-		|| (size == 17
-			&& (password[0] == '3')
-			&& ((password[1] >= 'Q' && password[1] <= 'Z')
-				|| (password[1] >= 'a' && password[1] <= 'f')))
-		|| (size >= 21
-			&& (password[0] == '7')
-			&& (password[1] >= 'g')
-			&& (password[1] <= 'v'));
-	if (size < 16) {
-		return ProxyData::Status::Invalid;
-	} else if (valid) {
-		return ProxyData::Status::Valid;
-	}
-	return ProxyData::Status::Unsupported;
-}
-
-[[nodiscard]] bytes::vector SecretFromBase64UrlMtprotoPassword(
-		const QString &password) {
-	const auto result = QByteArray::fromBase64(
-		password.toLatin1(),
-		QByteArray::Base64UrlEncoding);
-	return bytes::make_vector(bytes::make_span(result));
-}
-
-} // namespace
-
 // Precise timing functions / rand init
 
 struct CRYPTO_dynlock_value {
@@ -248,105 +120,6 @@ namespace {
 	}
 }
 
-bool ProxyData::valid() const {
-	return status() == Status::Valid;
-}
-
-ProxyData::Status ProxyData::status() const {
-	if (type == Type::None || host.isEmpty() || !port) {
-		return Status::Invalid;
-	} else if (type == Type::Mtproto) {
-		return MtprotoPasswordStatus(password);
-	}
-	return Status::Valid;
-}
-
-bool ProxyData::supportsCalls() const {
-	return (type == Type::Socks5);
-}
-
-bool ProxyData::tryCustomResolve() const {
-	return (type == Type::Socks5 || type == Type::Mtproto)
-		&& !qthelp::is_ipv6(host)
-		&& !QRegularExpression(
-			qsl("^\\d+\\.\\d+\\.\\d+\\.\\d+$")
-		).match(host).hasMatch();
-}
-
-bytes::vector ProxyData::secretFromMtprotoPassword() const {
-	Expects(type == Type::Mtproto);
-
-	if (IsHexMtprotoPassword(password)) {
-		return SecretFromHexMtprotoPassword(password);
-	} else if (IsBase64UrlMtprotoPassword(password)) {
-		return SecretFromBase64UrlMtprotoPassword(password);
-	}
-	return {};
-}
-
-ProxyData::operator bool() const {
-	return valid();
-}
-
-bool ProxyData::operator==(const ProxyData &other) const {
-	if (!valid()) {
-		return !other.valid();
-	}
-	return (type == other.type)
-		&& (host == other.host)
-		&& (port == other.port)
-		&& (user == other.user)
-		&& (password == other.password);
-}
-
-bool ProxyData::operator!=(const ProxyData &other) const {
-	return !(*this == other);
-}
-
-bool ProxyData::ValidMtprotoPassword(const QString &password) {
-	return MtprotoPasswordStatus(password) == Status::Valid;
-}
-
-ProxyData::Status ProxyData::MtprotoPasswordStatus(const QString &password) {
-	if (IsHexMtprotoPassword(password)) {
-		return HexMtprotoPasswordStatus(password);
-	} else if (IsBase64UrlMtprotoPassword(password)) {
-		return Base64UrlMtprotoPasswordStatus(password);
-	}
-	return Status::Invalid;
-}
-
-ProxyData ToDirectIpProxy(const ProxyData &proxy, int ipIndex) {
-	if (!proxy.tryCustomResolve()
-		|| ipIndex < 0
-		|| ipIndex >= proxy.resolvedIPs.size()) {
-		return proxy;
-	}
-	return {
-		proxy.type,
-		proxy.resolvedIPs[ipIndex],
-		proxy.port,
-		proxy.user,
-		proxy.password
-	};
-}
-
-QNetworkProxy ToNetworkProxy(const ProxyData &proxy) {
-	if (proxy.type == ProxyData::Type::None) {
-		return QNetworkProxy::DefaultProxy;
-	} else if (proxy.type == ProxyData::Type::Mtproto) {
-		return QNetworkProxy::NoProxy;
-	}
-	return QNetworkProxy(
-		(proxy.type == ProxyData::Type::Socks5
-			? QNetworkProxy::Socks5Proxy
-			: QNetworkProxy::HttpProxy),
-		proxy.host,
-		proxy.port,
-		proxy.user,
-		proxy.password);
-}
-
 namespace ThirdParty {
 
 	void start() {
@@ -427,14 +200,6 @@ namespace ThirdParty {
 	}
 }
 
-int GetNextRequestId() {
-	const auto result = ++GlobalAtomicRequestId;
-	if (result == std::numeric_limits<int>::max() / 2) {
-		GlobalAtomicRequestId = 0;
-	}
-	return result;
-}
-
 int32 *hashSha1(const void *data, uint32 len, void *dest) {
 	return (int32*)SHA1((const uchar*)data, (size_t)len, (uchar*)dest);
 }
@@ -939,6 +704,10 @@ QString rusKeyboardLayoutSwitch(const QString &from) {
 		fastRusKeyboardSwitch.insert(QString::fromUtf8("ь").at(0), 'm');
 		fastRusKeyboardSwitch.insert(QString::fromUtf8("б").at(0), ',');
 		fastRusKeyboardSwitch.insert(QString::fromUtf8("ю").at(0), '.');
+		fastRusKeyboardSwitch.insert(QString::fromUtf8("І").at(0), 'S');
+    		fastRusKeyboardSwitch.insert(QString::fromUtf8("і").at(0), 's');
+    		fastRusKeyboardSwitch.insert(QString::fromUtf8("Ї").at(0), ']');
+    		fastRusKeyboardSwitch.insert(QString::fromUtf8("ї").at(0), ']');
 	}
 
 	QString result;
diff --git a/Telegram/SourceFiles/core/utils.h b/Telegram/SourceFiles/core/utils.h
index c219f036e..44b2d53da 100644
--- a/Telegram/SourceFiles/core/utils.h
+++ b/Telegram/SourceFiles/core/utils.h
@@ -25,12 +25,6 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 
 namespace base {
 
-template <typename T>
-using set_of_unique_ptr = std::set<std::unique_ptr<T>, base::pointer_comparator<T>>;
-
-template <typename T>
-using set_of_shared_ptr = std::set<std::shared_ptr<T>, base::pointer_comparator<T>>;
-
 template <typename Value, typename From, typename Till>
 inline bool in_range(Value &&value, From &&from, Till &&till) {
 	return (value >= from) && (value < till);
@@ -88,8 +82,6 @@ inline QByteArray str_const_toByteArray(const str_const &str) {
 	return QByteArray::fromRawData(str.c_str(), str.size());
 }
 
-int GetNextRequestId();
-
 inline void mylocaltime(struct tm * _Tm, const time_t * _Time) {
 #ifdef Q_OS_WIN
 	localtime_s(_Tm, _Time);
@@ -167,37 +159,6 @@ T rand_value() {
 	return result;
 }
 
-class ReadLockerAttempt {
-public:
-	ReadLockerAttempt(not_null<QReadWriteLock*> lock) : _lock(lock), _locked(_lock->tryLockForRead()) {
-	}
-	ReadLockerAttempt(const ReadLockerAttempt &other) = delete;
-	ReadLockerAttempt &operator=(const ReadLockerAttempt &other) = delete;
-	ReadLockerAttempt(ReadLockerAttempt &&other) : _lock(other._lock), _locked(base::take(other._locked)) {
-	}
-	ReadLockerAttempt &operator=(ReadLockerAttempt &&other) {
-		_lock = other._lock;
-		_locked = base::take(other._locked);
-		return *this;
-	}
-	~ReadLockerAttempt() {
-		if (_locked) {
-			_lock->unlock();
-		}
-	}
-
-	operator bool() const {
-		return _locked;
-	}
-
-private:
-	not_null<QReadWriteLock*> _lock;
-	bool _locked = false;
-
-};
-
-static const QRegularExpression::PatternOptions reMultiline(QRegularExpression::DotMatchesEverythingOption | QRegularExpression::MultilineOption);
-
 template <typename T>
 inline T snap(const T &v, const T &_min, const T &_max) {
 	return (v < _min) ? _min : ((v > _max) ? _max : v);
@@ -218,50 +179,6 @@ enum DBIWorkMode {
 	dbiwmWindowOnly = 2,
 };
 
-struct ProxyData {
-	enum class Settings {
-		System,
-		Enabled,
-		Disabled,
-	};
-	enum class Type {
-		None,
-		Socks5,
-		Http,
-		Mtproto,
-	};
-	enum class Status {
-		Valid,
-		Unsupported,
-		Invalid,
-	};
-
-	Type type = Type::None;
-	QString host;
-	uint32 port = 0;
-	QString user, password;
-
-	std::vector<QString> resolvedIPs;
-	crl::time resolvedExpireAt = 0;
-
-	[[nodiscard]] bool valid() const;
-	[[nodiscard]] Status status() const;
-	[[nodiscard]] bool supportsCalls() const;
-	[[nodiscard]] bool tryCustomResolve() const;
-	[[nodiscard]] bytes::vector secretFromMtprotoPassword() const;
-	[[nodiscard]] explicit operator bool() const;
-	[[nodiscard]] bool operator==(const ProxyData &other) const;
-	[[nodiscard]] bool operator!=(const ProxyData &other) const;
-
-	[[nodiscard]] static bool ValidMtprotoPassword(const QString &password);
-	[[nodiscard]] static Status MtprotoPasswordStatus(
-		const QString &password);
-
-};
-
-ProxyData ToDirectIpProxy(const ProxyData &proxy, int ipIndex = 0);
-QNetworkProxy ToNetworkProxy(const ProxyData &proxy);
-
 static const int MatrixRowShift = 40000;
 
 inline int rowscount(int fullCount, int countPerRow) {
diff --git a/Telegram/SourceFiles/core/version.h b/Telegram/SourceFiles/core/version.h
index 68b2591e4..89b37ba22 100644
--- a/Telegram/SourceFiles/core/version.h
+++ b/Telegram/SourceFiles/core/version.h
@@ -9,15 +9,15 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 
 #define TDESKTOP_REQUESTED_ALPHA_VERSION (0ULL)
 
-#ifdef TDESKTOP_OFFICIAL_TARGET
+#ifdef TDESKTOP_ALLOW_CLOSED_ALPHA
 #define TDESKTOP_ALPHA_VERSION TDESKTOP_REQUESTED_ALPHA_VERSION
-#else // TDESKTOP_OFFICIAL_TARGET
+#else // TDESKTOP_ALLOW_CLOSED_ALPHA
 #define TDESKTOP_ALPHA_VERSION (0ULL)
-#endif // TDESKTOP_OFFICIAL_TARGET
+#endif // TDESKTOP_ALLOW_CLOSED_ALPHA
 
-constexpr auto AppVersion = 1009001;
-constexpr auto AppVersionStr = "1.9.1";
-constexpr auto AppBetaVersion = true;
+constexpr auto AppVersion = 1009003;
+constexpr auto AppVersionStr = "1.9.3";
+constexpr auto AppBetaVersion = false;
 constexpr auto AppAlphaVersion = TDESKTOP_ALPHA_VERSION;
 constexpr auto AppKotatoVersion = 1001002;
 constexpr auto AppKotatoVersionStr = "1.1.2";
diff --git a/Telegram/SourceFiles/data/data_auto_download.cpp b/Telegram/SourceFiles/data/data_auto_download.cpp
index 45d32a0b0..98ab58775 100644
--- a/Telegram/SourceFiles/data/data_auto_download.cpp
+++ b/Telegram/SourceFiles/data/data_auto_download.cpp
@@ -20,7 +20,9 @@ namespace AutoDownload {
 namespace {
 
 constexpr auto kDefaultMaxSize = 8 * 1024 * 1024;
-constexpr auto kVersion = char(1);
+constexpr auto kDefaultAutoPlaySize = 50 * 1024 * 1024;
+constexpr auto kVersion1 = char(1);
+constexpr auto kVersion = char(2);
 
 template <typename Enum>
 auto enums_view(int from, int till) {
@@ -38,13 +40,16 @@ auto enums_view(int till) {
 void SetDefaultsForSource(Full &data, Source source) {
 	data.setBytesLimit(source, Type::Photo, kDefaultMaxSize);
 	data.setBytesLimit(source, Type::VoiceMessage, kDefaultMaxSize);
-	data.setBytesLimit(source, Type::VideoMessage, kDefaultMaxSize);
-	data.setBytesLimit(source, Type::GIF, kDefaultMaxSize);
+	data.setBytesLimit(
+		source,
+		Type::AutoPlayVideoMessage,
+		kDefaultAutoPlaySize);
+	data.setBytesLimit(source, Type::AutoPlayGIF, kDefaultAutoPlaySize);
 	const auto channelsFileLimit = (source == Source::Channel)
 		? 0
 		: kDefaultMaxSize;
 	data.setBytesLimit(source, Type::File, channelsFileLimit);
-	data.setBytesLimit(source, Type::Video, channelsFileLimit);
+	data.setBytesLimit(source, Type::AutoPlayVideo, kDefaultAutoPlaySize);
 	data.setBytesLimit(source, Type::Music, channelsFileLimit);
 }
 
@@ -69,19 +74,12 @@ Source SourceFromPeer(not_null<PeerData*> peer) {
 	}
 }
 
-Type TypeFromDocument(not_null<DocumentData*> document) {
-	if (document->isSong()) {
-		return Type::Music;
-	} else if (document->isVoiceMessage()) {
-		return Type::VoiceMessage;
-	} else if (document->isVideoMessage()) {
-		return Type::VideoMessage;
-	} else if (document->isAnimation()) {
-		return Type::GIF;
-	} else if (document->isVideoFile()) {
-		return Type::Video;
-	}
-	return Type::File;
+Type AutoPlayTypeFromDocument(not_null<DocumentData*> document) {
+	return document->isVideoFile()
+		? Type::AutoPlayVideo
+		: document->isVideoMessage()
+		? Type::AutoPlayVideoMessage
+		: Type::AutoPlayGIF;
 }
 
 } // namespace
@@ -183,9 +181,7 @@ void Full::setBytesLimit(Source source, Type type, int bytesLimit) {
 }
 
 bool Full::shouldDownload(Source source, Type type, int fileSize) const {
-	if (type == Type::Video
-		|| type == Type::Music
-		|| type == Type::VoiceMessage) {
+	if (ranges::find(kStreamedTypes, type) != end(kStreamedTypes)) {
 		// With streaming we disable autodownload and hide them in Settings.
 		return false;
 	}
@@ -225,7 +221,7 @@ bool Full::setFromSerialized(const QByteArray &serialized) {
 	stream >> version;
 	if (stream.status() != QDataStream::Ok) {
 		return false;
-	} else if (version != kVersion) {
+	} else if (version != kVersion && version != kVersion1) {
 		return false;
 	}
 	auto temp = Full();
@@ -238,6 +234,15 @@ bool Full::setFromSerialized(const QByteArray &serialized) {
 			}
 		}
 	}
+	if (version == kVersion1) {
+		for (const auto source : enums_view<Source>(kSourcesCount)) {
+			for (const auto type : kAutoPlayTypes) {
+				temp.setBytesLimit(source, type, std::max(
+					temp.bytesLimit(source, type),
+					kDefaultAutoPlaySize));
+			}
+		}
+	}
 	_data = temp._data;
 	return true;
 }
@@ -254,15 +259,24 @@ Full Full::FullDisabled() {
 
 bool Should(
 		const Full &data,
-		not_null<PeerData*> peer,
+		Source source,
 		not_null<DocumentData*> document) {
 	if (document->sticker()) {
 		return true;
+	} else if (document->isVoiceMessage()
+		|| document->isVideoMessage()
+		|| document->isSong()
+		|| document->isVideoFile()) {
+		return false;
 	}
-	return data.shouldDownload(
-		SourceFromPeer(peer),
-		TypeFromDocument(document),
-		document->size);
+	return data.shouldDownload(source, Type::File, document->size);
+}
+
+bool Should(
+		const Full &data,
+		not_null<PeerData*> peer,
+		not_null<DocumentData*> document) {
+	return Should(data, SourceFromPeer(peer), document);
 }
 
 bool Should(
@@ -271,11 +285,10 @@ bool Should(
 	if (document->sticker()) {
 		return true;
 	}
-	const auto type = TypeFromDocument(document);
 	const auto size = document->size;
-	return data.shouldDownload(Source::User, type, size)
-		|| data.shouldDownload(Source::Group, type, size)
-		|| data.shouldDownload(Source::Channel, type, size);
+	return Should(data, Source::User, document)
+		|| Should(data, Source::Group, document)
+		|| Should(data, Source::Channel, document);
 }
 
 bool Should(
@@ -288,5 +301,25 @@ bool Should(
 		image->bytesSize());
 }
 
+bool ShouldAutoPlay(
+		const Full &data,
+		not_null<PeerData*> peer,
+		not_null<DocumentData*> document) {
+	return data.shouldDownload(
+		SourceFromPeer(peer),
+		AutoPlayTypeFromDocument(document),
+		document->size);
+}
+
+Full WithDisabledAutoPlay(const Full &data) {
+	auto result = data;
+	for (const auto source : enums_view<Source>(kSourcesCount)) {
+		for (const auto type : kAutoPlayTypes) {
+			result.setBytesLimit(source, type, 0);
+		}
+	}
+	return result;
+}
+
 } // namespace AutoDownload
 } // namespace Data
diff --git a/Telegram/SourceFiles/data/data_auto_download.h b/Telegram/SourceFiles/data/data_auto_download.h
index 4143cf82e..7da31d8bd 100644
--- a/Telegram/SourceFiles/data/data_auto_download.h
+++ b/Telegram/SourceFiles/data/data_auto_download.h
@@ -27,13 +27,24 @@ enum class Source {
 constexpr auto kSourcesCount = 3;
 
 enum class Type {
-	Photo        = 0x00,
-	Video        = 0x01,
-	VoiceMessage = 0x02,
-	VideoMessage = 0x03,
-	Music        = 0x04,
-	GIF          = 0x05,
-	File         = 0x06,
+	Photo                = 0x00,
+	AutoPlayVideo        = 0x01,
+	VoiceMessage         = 0x02,
+	AutoPlayVideoMessage = 0x03,
+	Music                = 0x04,
+	AutoPlayGIF          = 0x05,
+	File                 = 0x06,
+};
+
+inline constexpr auto kAutoPlayTypes = {
+	Type::AutoPlayVideo,
+	Type::AutoPlayVideoMessage,
+	Type::AutoPlayGIF,
+};
+
+inline constexpr auto kStreamedTypes = {
+	Type::VoiceMessage,
+	Type::Music,
 };
 
 constexpr auto kTypesCount = 7;
@@ -77,34 +88,44 @@ class Full {
 public:
 	void setBytesLimit(Source source, Type type, int bytesLimit);
 
-	bool shouldDownload(Source source, Type type, int fileSize) const;
-	int bytesLimit(Source source, Type type) const;
+	[[nodiscard]] bool shouldDownload(
+		Source source,
+		Type type,
+		int fileSize) const;
+	[[nodiscard]] int bytesLimit(Source source, Type type) const;
 
-	QByteArray serialize() const;
+	[[nodiscard]] QByteArray serialize() const;
 	bool setFromSerialized(const QByteArray &serialized);
 
-	static Full FullDisabled();
+	[[nodiscard]] static Full FullDisabled();
 
 private:
-	const Set &set(Source source) const;
-	Set &set(Source source);
-	const Set &setOrDefault(Source source, Type type) const;
+	[[nodiscard]] const Set &set(Source source) const;
+	[[nodiscard]] Set &set(Source source);
+	[[nodiscard]] const Set &setOrDefault(Source source, Type type) const;
 
 	std::array<Set, kSourcesCount> _data;
 
 };
 
-bool Should(
+[[nodiscard]] bool Should(
 	const Full &data,
 	not_null<PeerData*> peer,
 	not_null<DocumentData*> document);
-bool Should(
+[[nodiscard]] bool Should(
 	const Full &data,
 	not_null<DocumentData*> document);
-bool Should(
+[[nodiscard]] bool Should(
 	const Full &data,
 	not_null<PeerData*> peer,
 	not_null<Images::Source*> image);
 
+[[nodiscard]] bool ShouldAutoPlay(
+	const Full &data,
+	not_null<PeerData*> peer,
+	not_null<DocumentData*> document);
+
+[[nodiscard]] Full WithDisabledAutoPlay(const Full &data);
+
 } // namespace AutoDownload
 } // namespace Data
diff --git a/Telegram/SourceFiles/data/data_channel.cpp b/Telegram/SourceFiles/data/data_channel.cpp
index e72cf0ff0..d002653af 100644
--- a/Telegram/SourceFiles/data/data_channel.cpp
+++ b/Telegram/SourceFiles/data/data_channel.cpp
@@ -360,13 +360,14 @@ QString ChannelData::adminRank(not_null<UserData*> user) const {
 		: QString();
 }
 
-QString ChannelData::unavailableReason() const {
-	return _unavailableReason;
+auto ChannelData::unavailableReasons() const
+-> const std::vector<Data::UnavailableReason> & {
+	return _unavailableReasons;
 }
 
-void ChannelData::setUnavailableReason(const QString &text) {
-	if (_unavailableReason != text) {
-		_unavailableReason = text;
+void ChannelData::setUnavailableReasons(std::vector<Data::UnavailableReason> &&reasons) {
+	if (_unavailableReasons != reasons) {
+		_unavailableReasons = std::move(reasons);
 		Notify::peerUpdatedDelayed(
 			this,
 			Notify::PeerUpdate::Flag::UnavailableReasonChanged);
diff --git a/Telegram/SourceFiles/data/data_channel.h b/Telegram/SourceFiles/data/data_channel.h
index 855cc03a7..6f71e6e7d 100644
--- a/Telegram/SourceFiles/data/data_channel.h
+++ b/Telegram/SourceFiles/data/data_channel.h
@@ -369,8 +369,8 @@ public:
 		return _ptsWaiter.waitingForShortPoll();
 	}
 
-	[[nodiscard]] QString unavailableReason() const override;
-	void setUnavailableReason(const QString &reason);
+	void setUnavailableReasons(
+		std::vector<Data::UnavailableReason> &&reason);
 
 	[[nodiscard]] MsgId availableMinId() const {
 		return _availableMinId;
@@ -413,6 +413,8 @@ public:
 	TimeId inviteDate = 0;
 
 private:
+	auto unavailableReasons() const
+		-> const std::vector<Data::UnavailableReason> & override;
 	bool canEditLastAdmin(not_null<UserData*> user) const;
 
 	Flags _flags = Flags(MTPDchannel_ClientFlag::f_forbidden | 0);
@@ -432,7 +434,7 @@ private:
 	RestrictionFlags _restrictions;
 	TimeId _restrictedUntil;
 
-	QString _unavailableReason;
+	std::vector<Data::UnavailableReason> _unavailableReasons;
 	QString _inviteLink;
 	ChannelData *_linkedChat = nullptr;
 
diff --git a/Telegram/SourceFiles/data/data_document.cpp b/Telegram/SourceFiles/data/data_document.cpp
index f23a484b0..7aeb0d124 100644
--- a/Telegram/SourceFiles/data/data_document.cpp
+++ b/Telegram/SourceFiles/data/data_document.cpp
@@ -8,6 +8,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "data/data_document.h"
 
 #include "data/data_session.h"
+#include "data/data_streaming.h"
 #include "data/data_document_good_thumbnail.h"
 #include "lang/lang_keys.h"
 #include "inline_bots/inline_bot_layout_item.h"
@@ -21,6 +22,8 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "media/streaming/media_streaming_loader_local.h"
 #include "storage/localstorage.h"
 #include "storage/streamed_file_downloader.h"
+#include "storage/file_download_mtproto.h"
+#include "storage/file_download_web.h"
 #include "platform/platform_specific.h"
 #include "history/history.h"
 #include "history/history_item.h"
@@ -547,9 +550,7 @@ void DocumentData::setattributes(
 		}
 	}
 	validateGoodThumbnail();
-	if (isAudioFile()
-		|| (isAnimation() && !isVideoMessage())
-		|| isVoiceMessage()) {
+	if (isAudioFile() || isAnimation() || isVoiceMessage()) {
 		setMaybeSupportsStreaming(true);
 	}
 }
@@ -586,8 +587,9 @@ bool DocumentData::checkWallPaperProperties() {
 		|| !dimensions.height()
 		|| dimensions.width() > Storage::kMaxWallPaperDimension
 		|| dimensions.height() > Storage::kMaxWallPaperDimension
-		|| size > Storage::kMaxWallPaperInMemory) {
-		return false;
+		|| size > Storage::kMaxWallPaperInMemory
+		|| mimeString() == qstr("application/x-tgwallpattern")) {
+		return false; // #TODO themes support svg patterns
 	}
 	type = WallPaperDocument;
 	validateGoodThumbnail();
@@ -815,7 +817,6 @@ void DocumentData::destroyLoader() const {
 	if (cancelled()) {
 		loader->cancel();
 	}
-	loader->stop();
 }
 
 bool DocumentData::loading() const {
@@ -932,7 +933,7 @@ void DocumentData::save(
 		}
 	} else {
 		status = FileReady;
-		auto reader = owner().documentStreamedReader(this, origin, true);
+		auto reader = owner().streaming().sharedReader(this, origin, true);
 		if (reader) {
 			_loader = std::make_unique<Storage::StreamedFileDownloader>(
 				id,
@@ -1294,7 +1295,7 @@ bool DocumentData::useStreamingLoader() const {
 
 bool DocumentData::canBeStreamed() const {
 	// For now video messages are not streamed.
-	return hasRemoteLocation() && supportsStreaming() && !isVideoMessage();
+	return hasRemoteLocation() && supportsStreaming();
 }
 
 bool DocumentData::canBePlayed() const {
@@ -1672,22 +1673,24 @@ bool IsExecutableName(const QString &filepath) {
 		const auto joined =
 #ifdef Q_OS_MAC
 			qsl("\
-action app bin command csh osx workflow terminal url caction mpkg pkg xhtm \
-webarchive");
+applescript action app bin command csh osx workflow terminal url caction \
+mpkg pkg scpt scptd xhtm webarchive");
 #elif defined Q_OS_LINUX // Q_OS_MAC
-			qsl("bin csh deb desktop ksh out pet pkg pup rpm run shar slp");
+			qsl("bin csh deb desktop ksh out pet pkg pup rpm run sh shar \
+slp zsh");
 #else // Q_OS_MAC || Q_OS_LINUX
 			qsl("\
-ad ade adp app application appref-ms asp asx bas bat bin cer cfg chi chm \
-cmd cnt com cpl crt csh der diagcab dll drv eml exe fon fxp gadget grp hlp \
-hpj hta htt inf ini ins inx isp isu its jar jnlp job js jse ksh lnk local \
-mad maf mag mam manifest maq mar mas mat mau mav maw mcf mda mdb mde mdt \
-mdw mdz mht mhtml mmc mof msc msg msh msh1 msh2 msh1xml msh2xml mshxml msi \
-msp mst ops osd paf pcd pif pl plg prf prg ps1 ps2 ps1xml ps2xml psc1 psc2 \
-pst py py3 pyc pyd pyo pyw pywz pyz reg rgs scf scr sct search-ms \
-settingcontent-ms shb shs slk sys tmp u3p url vb vbe vbp vbs vbscript vdx \
-vsmacros vsd vsdm vsdx vss vssm vssx vst vstm vstx vsw vsx vtx website ws \
-wsc wsf wsh xbap xll xnk");
+ad ade adp app application appref-ms asp asx bas bat bin cdxml cer cfg chi \
+chm cmd cnt com cpl crt csh der diagcab dll drv eml exe fon fxp gadget grp \
+hlp hpj hta htt inf ini ins inx isp isu its jar jnlp job js jse ksh lnk \
+local lua mad maf mag mam manifest maq mar mas mat mau mav maw mcf mda mdb \
+mde mdt mdw mdz mht mhtml mjs mmc mof msc msg msh msh1 msh2 msh1xml msh2xml \
+mshxml msi msp mst ops osd paf pcd phar php php3 php4 php5 php7 phps php-s \
+pht phtml pif pl plg pm pod prf prg ps1 ps2 ps1xml ps2xml psc1 psc2 psd1 \
+psm1 pssc pst py py3 pyc pyd pyi pyo pyw pywz pyz rb reg rgs scf scr sct \
+search-ms settingcontent-ms shb shs slk sys t tmp u3p url vb vbe vbp vbs \
+vbscript vdx vsmacros vsd vsdm vsdx vss vssm vssx vst vstm vstx vsw vsx vtx \
+website ws wsc wsf wsh xbap xll xnk xs");
 #endif // !Q_OS_MAC && !Q_OS_LINUX
 		const auto list = joined.split(' ');
 		return base::flat_set<QString>(list.begin(), list.end());
diff --git a/Telegram/SourceFiles/data/data_file_origin.cpp b/Telegram/SourceFiles/data/data_file_origin.cpp
index b2932a5b9..db6133b03 100644
--- a/Telegram/SourceFiles/data/data_file_origin.cpp
+++ b/Telegram/SourceFiles/data/data_file_origin.cpp
@@ -33,9 +33,16 @@ struct FileReferenceAccumulator {
 		}, [](const MTPDdocumentEmpty &data) {
 		});
 	}
+	void push(const MTPPage &data) {
+		data.match([&](const auto &data) {
+			push(data.vphotos());
+			push(data.vdocuments());
+		});
+	}
 	void push(const MTPWallPaper &data) {
 		data.match([&](const MTPDwallPaper &data) {
 			push(data.vdocument());
+		}, [&](const MTPDwallPaperNoFile &data) {
 		});
 	}
 	void push(const MTPTheme &data) {
@@ -46,17 +53,27 @@ struct FileReferenceAccumulator {
 		}, [&](const MTPDthemeDocumentNotModified &data) {
 		});
 	}
+	void push(const MTPWebPageAttribute &data) {
+		data.match([&](const MTPDwebPageAttributeTheme &data) {
+			if (const auto documents = data.vdocuments()) {
+				push(*documents);
+			}
+		});
+	}
 	void push(const MTPWebPage &data) {
 		data.match([&](const MTPDwebPage &data) {
 			if (const auto document = data.vdocument()) {
 				push(*document);
 			}
-			if (const auto documents = data.vdocuments()) {
-				push(*documents);
+			if (const auto attributes = data.vattributes()) {
+				push(*attributes);
 			}
 			if (const auto photo = data.vphoto()) {
 				push(*photo);
 			}
+			if (const auto page = data.vcached_page()) {
+				push(*page);
+			}
 		}, [](const auto &data) {
 		});
 	}
diff --git a/Telegram/SourceFiles/data/data_media_types.cpp b/Telegram/SourceFiles/data/data_media_types.cpp
index 167d1b4d0..34939fb5d 100644
--- a/Telegram/SourceFiles/data/data_media_types.cpp
+++ b/Telegram/SourceFiles/data/data_media_types.cpp
@@ -14,7 +14,6 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "history/view/media/history_view_photo.h"
 #include "history/view/media/history_view_sticker.h"
 #include "history/view/media/history_view_gif.h"
-#include "history/view/media/history_view_video.h"
 #include "history/view/media/history_view_document.h"
 #include "history/view/media/history_view_contact.h"
 #include "history/view/media/history_view_location.h"
@@ -37,6 +36,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "data/data_web_page.h"
 #include "data/data_poll.h"
 #include "data/data_channel.h"
+#include "data/data_file_origin.h"
 #include "lang/lang_keys.h"
 #include "layout.h"
 #include "storage/file_upload.h"
@@ -774,10 +774,8 @@ std::unique_ptr<HistoryView::Media> MediaFile::createView(
 		return std::make_unique<HistoryView::UnwrappedMedia>(
 			message,
 			std::make_unique<HistoryView::Sticker>(message, _document));
-	} else if (_document->isAnimation()) {
-		return std::make_unique<HistoryView::Gif>(message, _document);
-	} else if (_document->isVideoFile()) {
-		return std::make_unique<HistoryView::Video>(
+	} else if (_document->isAnimation() || _document->isVideoFile()) {
+		return std::make_unique<HistoryView::Gif>(
 			message,
 			realParent,
 			_document);
diff --git a/Telegram/SourceFiles/data/data_peer.cpp b/Telegram/SourceFiles/data/data_peer.cpp
index 3dee18076..2f97bcead 100644
--- a/Telegram/SourceFiles/data/data_peer.cpp
+++ b/Telegram/SourceFiles/data/data_peer.cpp
@@ -21,6 +21,8 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "apiwrap.h"
 #include "boxes/confirm_box.h"
 #include "main/main_session.h"
+#include "main/main_account.h"
+#include "main/main_app_config.h"
 #include "core/application.h"
 #include "mainwindow.h"
 #include "window/window_session_controller.h"
@@ -379,6 +381,27 @@ void PeerData::setUserpicChecked(
 	}
 }
 
+auto PeerData::unavailableReasons() const
+-> const std::vector<Data::UnavailableReason> & {
+	static const auto result = std::vector<Data::UnavailableReason>();
+	return result;
+}
+
+QString PeerData::computeUnavailableReason() const {
+	const auto &list = unavailableReasons();
+	const auto &config = session().account().appConfig();
+	const auto skip = config.get<std::vector<QString>>(
+		"ignore_restriction_reasons",
+		std::vector<QString>());
+	auto &&filtered = ranges::view::all(
+		list
+	) | ranges::view::filter([&](const Data::UnavailableReason &reason) {
+		return ranges::find(skip, reason.reason) == end(skip);
+	});
+	const auto first = filtered.begin();
+	return (first != filtered.end()) ? first->text : QString();
+}
+
 bool PeerData::canPinMessages() const {
 	if (const auto user = asUser()) {
 		return user->fullFlags() & MTPDuserFull::Flag::f_can_pin_message;
diff --git a/Telegram/SourceFiles/data/data_peer.h b/Telegram/SourceFiles/data/data_peer.h
index 9d5716bb1..fcb82c2c4 100644
--- a/Telegram/SourceFiles/data/data_peer.h
+++ b/Telegram/SourceFiles/data/data_peer.h
@@ -84,6 +84,18 @@ private:
 
 };
 
+struct UnavailableReason {
+	QString reason;
+	QString text;
+
+	bool operator==(const UnavailableReason &other) const {
+		return (reason == other.reason) && (text == other.text);
+	}
+	bool operator!=(const UnavailableReason &other) const {
+		return !(*this == other);
+	}
+};
+
 } // namespace Data
 
 class PeerClickHandler : public ClickHandler {
@@ -271,9 +283,7 @@ public:
 
 	// If this string is not empty we must not allow to open the
 	// conversation and we must show this string instead.
-	[[nodiscard]] virtual QString unavailableReason() const {
-		return QString();
-	}
+	[[nodiscard]] QString computeUnavailableReason() const;
 
 	[[nodiscard]] ClickHandlerPtr createOpenLink();
 	[[nodiscard]] const ClickHandlerPtr &openLink() {
@@ -346,6 +356,8 @@ private:
 	void fillNames();
 	std::unique_ptr<Ui::EmptyUserpic> createEmptyUserpic() const;
 	void refreshEmptyUserpic() const;
+	[[nodiscard]] virtual auto unavailableReasons() const
+		-> const std::vector<Data::UnavailableReason> &;
 
 	void setUserpicChecked(
 		PhotoId photoId,
diff --git a/Telegram/SourceFiles/data/data_search_controller.cpp b/Telegram/SourceFiles/data/data_search_controller.cpp
index 01dcf7f86..243654287 100644
--- a/Telegram/SourceFiles/data/data_search_controller.cpp
+++ b/Telegram/SourceFiles/data/data_search_controller.cpp
@@ -13,6 +13,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "data/data_channel.h"
 #include "history/history.h"
 #include "history/history_item.h"
+#include "apiwrap.h"
 
 namespace Api {
 namespace {
@@ -191,6 +192,10 @@ SearchController::CacheEntry::CacheEntry(const Query &query)
 	: std::nullopt) {
 }
 
+SearchController::SearchController(not_null<Main::Session*> session)
+: _api(session->api().instance()) {
+}
+
 bool SearchController::hasInCache(const Query &query) const {
 	return query.query.isEmpty() || _cache.contains(query);
 }
@@ -361,7 +366,7 @@ void SearchController::requestMore(
 	if (!prepared) {
 		return;
 	}
-	auto requestId = request(
+	auto requestId = _api.request(
 		std::move(*prepared)
 	).done([=](const MTPmessages_Messages &result) {
 		listData->requests.remove(key);
@@ -377,11 +382,13 @@ void SearchController::requestMore(
 			parsed.fullCount);
 	}).send();
 	listData->requests.emplace(key, [=] {
-		request(requestId).cancel();
+		_api.request(requestId).cancel();
 	});
 }
 
-DelayedSearchController::DelayedSearchController() {
+DelayedSearchController::DelayedSearchController(
+	not_null<Main::Session*> session)
+: _controller(session) {
 	_timer.setCallback([this] { setQueryFast(_nextQuery); });
 }
 
diff --git a/Telegram/SourceFiles/data/data_search_controller.h b/Telegram/SourceFiles/data/data_search_controller.h
index c166d59f3..fcc2b8853 100644
--- a/Telegram/SourceFiles/data/data_search_controller.h
+++ b/Telegram/SourceFiles/data/data_search_controller.h
@@ -14,6 +14,10 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "base/value_ordering.h"
 #include "base/timer.h"
 
+namespace Main {
+class Session;
+} // namespace Main
+
 namespace Data {
 enum class LoadDirection : char;
 } // namespace Data
@@ -40,7 +44,7 @@ SearchResult ParseSearchResult(
 	Data::LoadDirection direction,
 	const MTPmessages_Messages &data);
 
-class SearchController : private MTP::Sender {
+class SearchController final {
 public:
 	using IdsList = Storage::SparseIdsList;
 	struct Query {
@@ -67,6 +71,7 @@ public:
 		std::optional<IdsList> migratedList;
 	};
 
+	explicit SearchController(not_null<Main::Session*> session);
 	void setQuery(const Query &query);
 	bool hasInCache(const Query &query) const;
 
@@ -124,6 +129,7 @@ private:
 		const Query &query,
 		Data *listData);
 
+	MTP::Sender _api;
 	Cache _cache;
 	Cache::iterator _current = _cache.end();
 
@@ -131,7 +137,7 @@ private:
 
 class DelayedSearchController {
 public:
-	DelayedSearchController();
+	explicit DelayedSearchController(not_null<Main::Session*> session);
 
 	using Query = SearchController::Query;
 	using SavedState = SearchController::SavedState;
diff --git a/Telegram/SourceFiles/data/data_session.cpp b/Telegram/SourceFiles/data/data_session.cpp
index 540979331..b965cea4e 100644
--- a/Telegram/SourceFiles/data/data_session.cpp
+++ b/Telegram/SourceFiles/data/data_session.cpp
@@ -28,8 +28,6 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "storage/storage_encrypted_file.h"
 #include "main/main_account.h"
 #include "media/player/media_player_instance.h" // instance()->play()
-#include "media/streaming/media_streaming_loader.h" // unique_ptr<Loader>
-#include "media/streaming/media_streaming_reader.h" // make_shared<Reader>
 #include "boxes/abstract_box.h"
 #include "passport/passport_form_controller.h"
 #include "window/themes/window_theme.h"
@@ -47,6 +45,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "data/data_poll.h"
 #include "data/data_scheduled_messages.h"
 #include "data/data_cloud_themes.h"
+#include "data/data_streaming.h"
 #include "base/platform/base_platform_info.h"
 #include "base/unixtime.h"
 #include "base/call_delayed.h"
@@ -101,30 +100,26 @@ void CheckForSwitchInlineButton(not_null<HistoryItem*> item) {
 
 // We should get a full restriction in "{full}: {reason}" format and we
 // need to find an "-all" tag in {full}, otherwise ignore this restriction.
-QString ExtractUnavailableReason(
+std::vector<UnavailableReason> ExtractUnavailableReasons(
 		const QVector<MTPRestrictionReason> &restrictions) {
-	auto &&texts = ranges::view::all(
+	return ranges::view::all(
 		restrictions
-	) | ranges::view::transform([](const MTPRestrictionReason &restriction) {
+	) | ranges::view::filter([](const MTPRestrictionReason &restriction) {
 		return restriction.match([&](const MTPDrestrictionReason &data) {
 			const auto platform = qs(data.vplatform());
-			return (false
+			return false
 #ifdef OS_MAC_STORE
 				|| (platform == qstr("ios"))
 #elif defined OS_WIN_STORE // OS_MAC_STORE
 				|| (platform == qstr("ms"))
 #endif // OS_MAC_STORE || OS_WIN_STORE
-				|| (platform == qstr("all")))
-				? std::make_optional(qs(data.vtext()))
-				: std::nullopt;
+				|| (platform == qstr("all"));
 		});
-	}) | ranges::view::filter([](const std::optional<QString> &value) {
-		return value.has_value();
-	}) | ranges::view::transform([](const std::optional<QString> &value) {
-		return *value;
-	});
-	const auto begin = texts.begin();
-	return (begin != texts.end()) ? *begin : nullptr;
+	}) | ranges::view::transform([](const MTPRestrictionReason &restriction) {
+		return restriction.match([&](const MTPDrestrictionReason &data) {
+			return UnavailableReason{ qs(data.vreason()), qs(data.vtext()) };
+		});
+	}) | ranges::to_vector;
 }
 
 MTPPhotoSize FindDocumentInlineThumbnail(const MTPDdocument &data) {
@@ -175,26 +170,6 @@ rpl::producer<int> PinnedDialogsCountMaxValue(
 	});
 }
 
-bool PruneDestroyedAndSet(
-		base::flat_map<
-			not_null<DocumentData*>,
-			std::weak_ptr<::Media::Streaming::Reader>> &readers,
-		not_null<DocumentData*> document,
-		const std::shared_ptr<::Media::Streaming::Reader> &reader) {
-	auto result = false;
-	for (auto i = begin(readers); i != end(readers);) {
-		if (i->first == document) {
-			(i++)->second = reader;
-			result = true;
-		} else if (i->second.lock() != nullptr) {
-			++i;
-		} else {
-			i = readers.erase(i);
-		}
-	}
-	return result;
-}
-
 } // namespace
 
 Session::Session(not_null<Main::Session*> session)
@@ -215,7 +190,8 @@ Session::Session(not_null<Main::Session*> session)
 , _unmuteByFinishedTimer([=] { unmuteByFinished(); })
 , _groups(this)
 , _scheduledMessages(std::make_unique<ScheduledMessages>(this))
-, _cloudThemes(std::make_unique<CloudThemes>(session)) {
+, _cloudThemes(std::make_unique<CloudThemes>(session))
+, _streaming(std::make_unique<Streaming>(this)) {
 	_cache->open(Local::cacheKey());
 	_bigFileCache->open(Local::cacheBigFileKey());
 
@@ -365,10 +341,10 @@ not_null<UserData*> Session::processUser(const MTPUser &data) {
 				result->inputUser = MTP_inputUser(data.vid(), MTP_long(result->accessHash()));
 			}
 			if (const auto restriction = data.vrestriction_reason()) {
-				result->setUnavailableReason(
-					ExtractUnavailableReason(restriction->v));
+				result->setUnavailableReasons(
+					ExtractUnavailableReasons(restriction->v));
 			} else {
-				result->setUnavailableReason(QString());
+				result->setUnavailableReasons({});
 			}
 		}
 		if (data.is_deleted()) {
@@ -636,10 +612,10 @@ not_null<PeerData*> Session::processChat(const MTPChat &data) {
 				channel->setVersion(data.vversion().v);
 			}
 			if (const auto restriction = data.vrestriction_reason()) {
-				channel->setUnavailableReason(
-					ExtractUnavailableReason(restriction->v));
+				channel->setUnavailableReasons(
+					ExtractUnavailableReasons(restriction->v));
 			} else {
-				channel->setUnavailableReason(QString());
+				channel->setUnavailableReasons({});
 			}
 			channel->setFlags(data.vflags().v);
 			//if (const auto feedId = data.vfeed_id()) { // #feed
@@ -1135,31 +1111,6 @@ void Session::requestDocumentViewRepaint(
 	}
 }
 
-std::shared_ptr<::Media::Streaming::Reader> Session::documentStreamedReader(
-		not_null<DocumentData*> document,
-		FileOrigin origin,
-		bool forceRemoteLoader) {
-	const auto i = _streamedReaders.find(document);
-	if (i != end(_streamedReaders)) {
-		if (auto result = i->second.lock()) {
-			if (!forceRemoteLoader || result->isRemoteLoader()) {
-				return result;
-			}
-		}
-	}
-	auto loader = document->createStreamingLoader(origin, forceRemoteLoader);
-	if (!loader) {
-		return nullptr;
-	}
-	auto result = std::make_shared<::Media::Streaming::Reader>(
-		&cacheBigFile(),
-		std::move(loader));
-	if (!PruneDestroyedAndSet(_streamedReaders, document, result)) {
-		_streamedReaders.emplace_or_assign(document, result);
-	}
-	return result;
-}
-
 void Session::requestPollViewRepaint(not_null<const PollData*> poll) {
 	if (const auto i = _pollViews.find(poll); i != _pollViews.end()) {
 		for (const auto view : i->second) {
@@ -1369,9 +1320,10 @@ void Session::unloadHeavyViewParts(
 	if (_heavyViewParts.empty()) {
 		return;
 	}
-	const auto remove = ranges::count(_heavyViewParts, delegate, [](not_null<ViewElement*> element) {
-		return element->delegate();
-	});
+	const auto remove = ranges::count(
+		_heavyViewParts,
+		delegate,
+		[](not_null<ViewElement*> element) { return element->delegate(); });
 	if (remove == _heavyViewParts.size()) {
 		for (const auto view : base::take(_heavyViewParts)) {
 			view->unloadHeavyPart();
@@ -1660,6 +1612,7 @@ bool Session::checkEntitiesAndViewsUpdate(const MTPDmessage &data) {
 		existing->indexAsNewItem();
 		existing->contributeToSlowmode(data.vdate().v);
 		requestItemTextRefresh(existing);
+		updateDependentMessages(existing);
 		if (existing->mainView()) {
 			checkSavedGif(existing);
 			return true;
@@ -2766,7 +2719,8 @@ void Session::webpageApplyFields(
 	const auto pendingTill = TimeId(0);
 	const auto photo = data.vphoto();
 	const auto document = data.vdocument();
-	const auto lookupThemeDocument = [&]() -> DocumentData* {
+	const auto lookupInAttribute = [&](
+			const MTPDwebPageAttributeTheme &data) -> DocumentData* {
 		if (const auto documents = data.vdocuments()) {
 			for (const auto &document : documents->v) {
 				const auto processed = processDocument(document);
@@ -2777,6 +2731,20 @@ void Session::webpageApplyFields(
 		}
 		return nullptr;
 	};
+	const auto lookupThemeDocument = [&]() -> DocumentData* {
+		if (const auto attributes = data.vattributes()) {
+			for (const auto &attribute : attributes->v) {
+				const auto result = attribute.match([&](
+						const MTPDwebPageAttributeTheme &data) {
+					return lookupInAttribute(data);
+				});
+				if (result) {
+					return result;
+				}
+			}
+		}
+		return nullptr;
+	};
 	webpageApplyFields(
 		page,
 		ParseWebPageType(data),
@@ -3203,25 +3171,46 @@ void Session::unregisterContactItem(
 	}
 }
 
-void Session::registerAutoplayAnimation(
-		not_null<::Media::Clip::Reader*> reader,
-		not_null<ViewElement*> view) {
-	_autoplayAnimations.emplace(reader, view);
+void Session::registerPlayingVideoFile(not_null<ViewElement*> view) {
+	if (++_playingVideoFiles[view] == 1) {
+		registerHeavyViewPart(view);
+	}
 }
 
-void Session::unregisterAutoplayAnimation(
-		not_null<::Media::Clip::Reader*> reader) {
-	_autoplayAnimations.remove(reader);
+void Session::unregisterPlayingVideoFile(not_null<ViewElement*> view) {
+	const auto i = _playingVideoFiles.find(view);
+	if (i != _playingVideoFiles.end()) {
+		if (!--i->second) {
+			_playingVideoFiles.erase(i);
+			unregisterHeavyViewPart(view);
+		}
+	} else {
+		unregisterHeavyViewPart(view);
+	}
 }
 
-void Session::stopAutoplayAnimations() {
-	for (const auto [reader, view] : base::take(_autoplayAnimations)) {
+void Session::stopPlayingVideoFiles() {
+	for (const auto &[view, count] : base::take(_playingVideoFiles)) {
 		if (const auto media = view->media()) {
 			media->stopAnimation();
 		}
 	}
 }
 
+void Session::checkPlayingVideoFiles() {
+	const auto old = base::take(_playingVideoFiles);
+	for (const auto &[view, count] : old) {
+		if (const auto media = view->media()) {
+			if (const auto left = media->checkAnimationCount()) {
+				_playingVideoFiles.emplace(view, left);
+				registerHeavyViewPart(view);
+				continue;
+			}
+		}
+		unregisterHeavyViewPart(view);
+	}
+}
+
 HistoryItem *Session::findWebPageItem(not_null<WebPageData*> page) const {
 	const auto i = _webpageItems.find(page);
 	if (i != _webpageItems.end()) {
@@ -3747,11 +3736,9 @@ void Session::setWallpapers(const QVector<MTPWallPaper> &data, int32 hash) {
 			QByteArray(),
 			"JPG")));
 	for (const auto &paper : data) {
-		paper.match([&](const MTPDwallPaper &paper) {
-			if (const auto parsed = Data::WallPaper::Create(paper)) {
-				_wallpapers.push_back(*parsed);
-			}
-		});
+		if (const auto parsed = Data::WallPaper::Create(paper)) {
+			_wallpapers.push_back(*parsed);
+		}
 	}
 	const auto defaultFound = ranges::find_if(
 		_wallpapers,
diff --git a/Telegram/SourceFiles/data/data_session.h b/Telegram/SourceFiles/data/data_session.h
index 39d22c4fd..eb21a0b0e 100644
--- a/Telegram/SourceFiles/data/data_session.h
+++ b/Telegram/SourceFiles/data/data_session.h
@@ -37,15 +37,6 @@ namespace Main {
 class Session;
 } // namespace Main
 
-namespace Media {
-namespace Clip {
-class Reader;
-} // namespace Clip
-namespace Streaming {
-class Reader;
-} // namespace Streaming
-} // namespace Media
-
 namespace Export {
 class Controller;
 namespace View {
@@ -68,6 +59,7 @@ class LocationPoint;
 class WallPaper;
 class ScheduledMessages;
 class CloudThemes;
+class Streaming;
 
 class Session final {
 public:
@@ -97,6 +89,9 @@ public:
 	[[nodiscard]] CloudThemes &cloudThemes() const {
 		return *_cloudThemes;
 	}
+	[[nodiscard]] Streaming &streaming() const {
+		return *_streaming;
+	}
 	[[nodiscard]] MsgId nextNonHistoryEntryId() {
 		return ++_nonHistoryEntryId;
 	}
@@ -435,11 +430,6 @@ public:
 	void markMediaRead(not_null<const DocumentData*> document);
 	void requestPollViewRepaint(not_null<const PollData*> poll);
 
-	std::shared_ptr<::Media::Streaming::Reader> documentStreamedReader(
-		not_null<DocumentData*> document,
-		FileOrigin origin,
-		bool forceRemoteLoader = false);
-
 	HistoryItem *addNewMessage(
 		const MTPMessage &data,
 		MTPDmessage_ClientFlags flags,
@@ -610,11 +600,11 @@ public:
 	void unregisterContactItem(
 		UserId contactId,
 		not_null<HistoryItem*> item);
-	void registerAutoplayAnimation(
-		not_null<::Media::Clip::Reader*> reader,
-		not_null<ViewElement*> view);
-	void unregisterAutoplayAnimation(
-		not_null<::Media::Clip::Reader*> reader);
+
+	void registerPlayingVideoFile(not_null<ViewElement*> view);
+	void unregisterPlayingVideoFile(not_null<ViewElement*> view);
+	void checkPlayingVideoFiles();
+	void stopPlayingVideoFiles();
 
 	HistoryItem *findWebPageItem(not_null<WebPageData*> page) const;
 	QString findContactPhone(not_null<UserData*> contact) const;
@@ -626,8 +616,6 @@ public:
 	bool hasPendingWebPageGamePollNotification() const;
 	void sendWebPageGamePollNotifications();
 
-	void stopAutoplayAnimations();
-
 	void registerItemView(not_null<ViewElement*> view);
 	void unregisterItemView(not_null<ViewElement*> view);
 
@@ -949,18 +937,12 @@ private:
 	std::unordered_map<
 		UserId,
 		base::flat_set<not_null<ViewElement*>>> _contactViews;
-	base::flat_map<
-		not_null<::Media::Clip::Reader*>,
-		not_null<ViewElement*>> _autoplayAnimations;
+	base::flat_map<not_null<ViewElement*>, int> _playingVideoFiles;
 
 	base::flat_set<not_null<WebPageData*>> _webpagesUpdated;
 	base::flat_set<not_null<GameData*>> _gamesUpdated;
 	base::flat_set<not_null<PollData*>> _pollsUpdated;
 
-	base::flat_map<
-		not_null<DocumentData*>,
-		std::weak_ptr<::Media::Streaming::Reader>> _streamedReaders;
-
 	base::flat_map<FolderId, std::unique_ptr<Folder>> _folders;
 	//rpl::variable<FeedId> _defaultFeedId = FeedId(); // #feed
 
@@ -1001,6 +983,7 @@ private:
 	Groups _groups;
 	std::unique_ptr<ScheduledMessages> _scheduledMessages;
 	std::unique_ptr<CloudThemes> _cloudThemes;
+	std::unique_ptr<Streaming> _streaming;
 	MsgId _nonHistoryEntryId = ServerMaxMsgId;
 
 	rpl::lifetime _lifetime;
diff --git a/Telegram/SourceFiles/data/data_streaming.cpp b/Telegram/SourceFiles/data/data_streaming.cpp
new file mode 100644
index 000000000..205f908c5
--- /dev/null
+++ b/Telegram/SourceFiles/data/data_streaming.cpp
@@ -0,0 +1,137 @@
+/*
+This file is part of Telegram Desktop,
+the official desktop application for the Telegram messaging service.
+
+For license and copyright information please follow this link:
+https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+*/
+#include "data/data_streaming.h"
+
+#include "data/data_document.h"
+#include "data/data_session.h"
+#include "data/data_file_origin.h"
+#include "media/streaming/media_streaming_loader.h"
+#include "media/streaming/media_streaming_reader.h"
+#include "media/streaming/media_streaming_document.h"
+
+namespace Data {
+namespace {
+
+constexpr auto kKeepAliveTimeout = 5 * crl::time(1000);
+
+template <typename Object>
+bool PruneDestroyedAndSet(
+		base::flat_map<
+			not_null<DocumentData*>,
+			std::weak_ptr<Object>> &objects,
+		not_null<DocumentData*> document,
+		const std::shared_ptr<Object> &object) {
+	auto result = false;
+	for (auto i = begin(objects); i != end(objects);) {
+		if (i->first == document) {
+			(i++)->second = object;
+			result = true;
+		} else if (i->second.lock() != nullptr) {
+			++i;
+		} else {
+			i = objects.erase(i);
+		}
+	}
+	return result;
+}
+
+} // namespace
+
+Streaming::Streaming(not_null<Session*> owner)
+: _owner(owner)
+, _keptAliveTimer([=] { clearKeptAlive(); }) {
+}
+
+Streaming::~Streaming() = default;
+
+std::shared_ptr<Streaming::Reader> Streaming::sharedReader(
+		not_null<DocumentData*> document,
+		FileOrigin origin,
+		bool forceRemoteLoader) {
+	const auto i = _readers.find(document);
+	if (i != end(_readers)) {
+		if (auto result = i->second.lock()) {
+			if (!forceRemoteLoader || result->isRemoteLoader()) {
+				return result;
+			}
+		}
+	}
+	auto loader = document->createStreamingLoader(origin, forceRemoteLoader);
+	if (!loader) {
+		return nullptr;
+	}
+	auto result = std::make_shared<Reader>(
+		&_owner->cacheBigFile(),
+		std::move(loader));
+	if (!PruneDestroyedAndSet(_readers, document, result)) {
+		_readers.emplace_or_assign(document, result);
+	}
+	return result;
+}
+
+std::shared_ptr<Streaming::Document> Streaming::sharedDocument(
+		not_null<DocumentData*> document,
+		FileOrigin origin) {
+	const auto i = _documents.find(document);
+	if (i != end(_documents)) {
+		if (auto result = i->second.lock()) {
+			return result;
+		}
+	}
+	auto reader = sharedReader(document, origin);
+	if (!reader) {
+		return nullptr;
+	}
+	auto result = std::make_shared<Document>(document, std::move(reader));
+	if (!PruneDestroyedAndSet(_documents, document, result)) {
+		_documents.emplace_or_assign(document, result);
+	}
+	return result;
+}
+
+void Streaming::keepAlive(not_null<DocumentData*> document) {
+	const auto i = _documents.find(document);
+	if (i == end(_documents)) {
+		return;
+	}
+	auto shared = i->second.lock();
+	if (!shared) {
+		return;
+	}
+	const auto till = crl::now() + kKeepAliveTimeout;
+	const auto j = _keptAlive.find(shared);
+	if (j != end(_keptAlive)) {
+		j->second = till;
+	} else {
+		_keptAlive.emplace(std::move(shared), till);
+	}
+	if (!_keptAliveTimer.isActive()) {
+		_keptAliveTimer.callOnce(kKeepAliveTimeout);
+	}
+}
+
+void Streaming::clearKeptAlive() {
+	const auto now = crl::now();
+	auto min = std::numeric_limits<crl::time>::max();
+	for (auto i = begin(_keptAlive); i != end(_keptAlive);) {
+		const auto wait = (i->second - now);
+		if (wait <= 0) {
+			i = _keptAlive.erase(i);
+		} else {
+			++i;
+			if (min > wait) {
+				min = wait;
+			}
+		}
+	}
+	if (!_keptAlive.empty()) {
+		_keptAliveTimer.callOnce(min);
+	}
+}
+
+} // namespace Data
diff --git a/Telegram/SourceFiles/data/data_streaming.h b/Telegram/SourceFiles/data/data_streaming.h
new file mode 100644
index 000000000..9f7112842
--- /dev/null
+++ b/Telegram/SourceFiles/data/data_streaming.h
@@ -0,0 +1,61 @@
+/*
+This file is part of Telegram Desktop,
+the official desktop application for the Telegram messaging service.
+
+For license and copyright information please follow this link:
+https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+*/
+#pragma once
+
+#include "base/timer.h"
+
+class DocumentData;
+
+namespace Media {
+namespace Streaming {
+class Reader;
+class Document;
+} // namespace Streaming
+} // namespace Media
+
+namespace Data {
+
+class Session;
+struct FileOrigin;
+
+class Streaming final {
+public:
+	explicit Streaming(not_null<Session*> owner);
+	Streaming(const Streaming &other) = delete;
+	Streaming &operator=(const Streaming &other) = delete;
+	~Streaming();
+
+	using Reader = ::Media::Streaming::Reader;
+	using Document = ::Media::Streaming::Document;
+
+	[[nodiscard]] std::shared_ptr<Reader> sharedReader(
+		not_null<DocumentData*> document,
+		FileOrigin origin,
+		bool forceRemoteLoader = false);
+	[[nodiscard]] std::shared_ptr<Document> sharedDocument(
+		not_null<DocumentData*> document,
+		FileOrigin origin);
+
+	void keepAlive(not_null<DocumentData*> document);
+
+private:
+	void clearKeptAlive();
+
+	const not_null<Session*> _owner;
+
+	base::flat_map<not_null<DocumentData*>, std::weak_ptr<Reader>> _readers;
+	base::flat_map<
+		not_null<DocumentData*>,
+		std::weak_ptr<Document>> _documents;
+
+	base::flat_map<std::shared_ptr<Document>, crl::time> _keptAlive;
+	base::Timer _keptAliveTimer;
+
+};
+
+} // namespace Data
diff --git a/Telegram/SourceFiles/data/data_user.cpp b/Telegram/SourceFiles/data/data_user.cpp
index d861551b5..fbb4e78f2 100644
--- a/Telegram/SourceFiles/data/data_user.cpp
+++ b/Telegram/SourceFiles/data/data_user.cpp
@@ -81,13 +81,15 @@ void UserData::setPhoto(const MTPUserProfilePhoto &photo) {
 	}
 }
 
-QString UserData::unavailableReason() const {
-	return _unavailableReason;
+auto UserData::unavailableReasons() const
+-> const std::vector<Data::UnavailableReason> & {
+	return _unavailableReasons;
 }
 
-void UserData::setUnavailableReason(const QString &text) {
-	if (_unavailableReason != text) {
-		_unavailableReason = text;
+void UserData::setUnavailableReasons(
+		std::vector<Data::UnavailableReason> &&reasons) {
+	if (_unavailableReasons != reasons) {
+		_unavailableReasons = std::move(reasons);
 		Notify::peerUpdatedDelayed(
 			this,
 			Notify::PeerUpdate::Flag::UnavailableReasonChanged);
diff --git a/Telegram/SourceFiles/data/data_user.h b/Telegram/SourceFiles/data/data_user.h
index 5a6df93d1..d58365284 100644
--- a/Telegram/SourceFiles/data/data_user.h
+++ b/Telegram/SourceFiles/data/data_user.h
@@ -207,8 +207,8 @@ public:
 
 	std::unique_ptr<BotInfo> botInfo;
 
-	QString unavailableReason() const override;
-	void setUnavailableReason(const QString &reason);
+	void setUnavailableReasons(
+		std::vector<Data::UnavailableReason> &&reasons);
 
 	int commonChatsCount() const {
 		return _commonChatsCount;
@@ -216,10 +216,13 @@ public:
 	void setCommonChatsCount(int count);
 
 private:
+	auto unavailableReasons() const
+		-> const std::vector<Data::UnavailableReason> & override;
+
 	Flags _flags;
 	FullFlags _fullFlags;
 
-	QString _unavailableReason;
+	std::vector<Data::UnavailableReason> _unavailableReasons;
 	QString _phone;
 	ContactStatus _contactStatus = ContactStatus::Unknown;
 	BlockStatus _blockStatus = BlockStatus::Unknown;
diff --git a/Telegram/SourceFiles/data/data_wall_paper.cpp b/Telegram/SourceFiles/data/data_wall_paper.cpp
index 18a497997..334ec8fbf 100644
--- a/Telegram/SourceFiles/data/data_wall_paper.cpp
+++ b/Telegram/SourceFiles/data/data_wall_paper.cpp
@@ -216,7 +216,10 @@ MTPWallPaperSettings WallPaper::mtpSettings() const {
 		(_backgroundColor
 			? MTP_int(SerializeMaybeColor(_backgroundColor))
 			: MTP_int(0)),
-		MTP_int(_intensity));
+		MTP_int(0), // second_background_color
+		MTP_int(_intensity),
+		MTP_int(0) // rotation
+	);
 }
 
 WallPaper WallPaper::withUrlParams(
@@ -309,6 +312,8 @@ WallPaper WallPaper::withoutImageData() const {
 std::optional<WallPaper> WallPaper::Create(const MTPWallPaper &data) {
 	return data.match([](const MTPDwallPaper &data) {
 		return Create(data);
+	}, [](const MTPDwallPaperNoFile &data) {
+		return std::optional<WallPaper>(); // #TODO themes
 	});
 }
 
diff --git a/Telegram/SourceFiles/dialogs/dialogs_inner_widget.cpp b/Telegram/SourceFiles/dialogs/dialogs_inner_widget.cpp
index e24d89121..79b74fdf3 100644
--- a/Telegram/SourceFiles/dialogs/dialogs_inner_widget.cpp
+++ b/Telegram/SourceFiles/dialogs/dialogs_inner_widget.cpp
@@ -2477,7 +2477,6 @@ void InnerWidget::loadPeerPhotos() {
 
 	auto yFrom = _visibleTop;
 	auto yTo = _visibleTop + (_visibleBottom - _visibleTop) * (PreloadHeightsCount + 1);
-	session().downloader().clearPriorities();
 	if (_state == WidgetState::Default) {
 		auto otherStart = shownDialogs()->size() * DialogsRowHeight();
 		if (yFrom < otherStart) {
diff --git a/Telegram/SourceFiles/dialogs/dialogs_inner_widget.h b/Telegram/SourceFiles/dialogs/dialogs_inner_widget.h
index b5b29a017..0015d4501 100644
--- a/Telegram/SourceFiles/dialogs/dialogs_inner_widget.h
+++ b/Telegram/SourceFiles/dialogs/dialogs_inner_widget.h
@@ -13,6 +13,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "ui/rp_widget.h"
 #include "base/flags.h"
 #include "base/object_ptr.h"
+#include "mtproto/mtproto_rpc_sender.h"
 
 namespace Main {
 class Session;
diff --git a/Telegram/SourceFiles/dialogs/dialogs_widget.cpp b/Telegram/SourceFiles/dialogs/dialogs_widget.cpp
index 38802a0b3..bf2124ac8 100644
--- a/Telegram/SourceFiles/dialogs/dialogs_widget.cpp
+++ b/Telegram/SourceFiles/dialogs/dialogs_widget.cpp
@@ -331,7 +331,8 @@ void Widget::updateScrollUpVisibility() {
 	}
 
 	startScrollUpButtonAnimation(
-		_scroll->scrollTop() > st::historyToDownShownAfter);
+		(_scroll->scrollTop() > st::historyToDownShownAfter)
+		&& (_scroll->scrollTop() < _scroll->scrollTopMax()));
 }
 
 void Widget::startScrollUpButtonAnimation(bool shown) {
diff --git a/Telegram/SourceFiles/dialogs/dialogs_widget.h b/Telegram/SourceFiles/dialogs/dialogs_widget.h
index 9fd8509e6..42799d2dd 100644
--- a/Telegram/SourceFiles/dialogs/dialogs_widget.h
+++ b/Telegram/SourceFiles/dialogs/dialogs_widget.h
@@ -13,6 +13,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "ui/widgets/scroll_area.h"
 #include "ui/special_buttons.h"
 #include "api/api_single_message_search.h"
+#include "mtproto/mtproto_rpc_sender.h"
 
 namespace Main {
 class Session;
diff --git a/Telegram/SourceFiles/export/data/export_data_types.cpp b/Telegram/SourceFiles/export/data/export_data_types.cpp
index 1b006d2df..768ef6a90 100644
--- a/Telegram/SourceFiles/export/data/export_data_types.cpp
+++ b/Telegram/SourceFiles/export/data/export_data_types.cpp
@@ -209,6 +209,32 @@ Utf8String FillLeft(const Utf8String &data, int length, char filler) {
 	return result;
 }
 
+bool RefreshFileReference(FileLocation &to, const FileLocation &from) {
+	if (to.dcId != from.dcId || to.data.type() != from.data.type()) {
+		return false;
+	}
+	if (to.data.type() == mtpc_inputPhotoFileLocation) {
+		const auto &toData = to.data.c_inputPhotoFileLocation();
+		const auto &fromData = from.data.c_inputPhotoFileLocation();
+		if (toData.vid().v != fromData.vid().v
+			|| toData.vthumb_size().v != fromData.vthumb_size().v) {
+			return false;
+		}
+		to = from;
+		return true;
+	} else if (to.data.type() == mtpc_inputDocumentFileLocation) {
+		const auto &toData = to.data.c_inputDocumentFileLocation();
+		const auto &fromData = from.data.c_inputDocumentFileLocation();
+		if (toData.vid().v != fromData.vid().v
+			|| toData.vthumb_size().v != fromData.vthumb_size().v) {
+			return false;
+		}
+		to = from;
+		return true;
+	}
+	return false;
+}
+
 Image ParseMaxImage(
 		const MTPDphoto &photo,
 		const QString &suggestedPath) {
diff --git a/Telegram/SourceFiles/export/data/export_data_types.h b/Telegram/SourceFiles/export/data/export_data_types.h
index 588fc2fae..ee4a14182 100644
--- a/Telegram/SourceFiles/export/data/export_data_types.h
+++ b/Telegram/SourceFiles/export/data/export_data_types.h
@@ -60,6 +60,8 @@ struct FileLocation {
 	}
 };
 
+bool RefreshFileReference(FileLocation &to, const FileLocation &from);
+
 struct File {
 	enum class SkipReason {
 		None,
@@ -526,6 +528,12 @@ struct Message {
 	const Image &thumb() const;
 };
 
+struct FileOrigin {
+	int split = 0;
+	MTPInputPeer peer;
+	int32 messageId = 0;
+};
+
 Message ParseMessage(
 	ParseMediaContext &context,
 	const MTPMessage &data,
diff --git a/Telegram/SourceFiles/export/export_api_wrap.cpp b/Telegram/SourceFiles/export/export_api_wrap.cpp
index ef8f938c6..b2fc69789 100644
--- a/Telegram/SourceFiles/export/export_api_wrap.cpp
+++ b/Telegram/SourceFiles/export/export_api_wrap.cpp
@@ -11,7 +11,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "export/data/export_data_types.h"
 #include "export/output/export_output_result.h"
 #include "export/output/export_output_file.h"
-#include "mtproto/rpc_sender.h"
+#include "mtproto/mtproto_rpc_sender.h"
 #include "base/value_ordering.h"
 #include "base/bytes.h"
 #include <set>
@@ -84,6 +84,10 @@ LocationKey ComputeLocationKey(const Data::FileLocation &value) {
 		result.type |= (8ULL << 24);
 		result.type |= (uint64(uint32(data.vlocal_id().v)) << 32);
 		result.id = data.vvolume_id().v;
+	}, [&](const MTPDinputPhotoLegacyFileLocation &data) {
+		result.type |= (9ULL << 24);
+		result.type |= (uint64(uint32(data.vlocal_id().v)) << 32);
+		result.id = data.vvolume_id().v;
 	});
 	return result;
 }
@@ -177,6 +181,7 @@ struct ApiWrap::FileProcess {
 	FnMut<void(const QString &relativePath)> done;
 
 	Data::FileLocation location;
+	Data::FileOrigin origin;
 	int offset = 0;
 	int size = 0;
 
@@ -396,6 +401,9 @@ auto ApiWrap::fileRequest(const Data::FileLocation &location, int offset) {
 		} else if (result.type() == qstr("LOCATION_INVALID")
 			|| result.type() == qstr("VERSION_INVALID")) {
 			filePartUnavailable();
+		} else if (result.code() == 400
+			&& result.type().startsWith(qstr("FILE_REFERENCE_"))) {
+			filePartRefreshReference(offset);
 		} else {
 			error(std::move(result));
 		}
@@ -692,6 +700,7 @@ void ApiWrap::requestOtherData(
 	_otherDataProcess->file.suggestedPath = suggestedPath;
 	loadFile(
 		_otherDataProcess->file,
+		Data::FileOrigin(),
 		[](FileProgress progress) { return true; },
 		[=](const QString &result) { otherDataDone(result); });
 }
@@ -776,6 +785,7 @@ void ApiWrap::loadNextUserpic() {
 		; ++_userpicsProcess->fileIndex) {
 		const auto ready = processFileLoad(
 			list[_userpicsProcess->fileIndex].image.file,
+			Data::FileOrigin(),
 			[=](FileProgress value) { return loadUserpicProgress(value); },
 			[=](const QString &path) { loadUserpicDone(path); });
 		if (!ready) {
@@ -1378,6 +1388,24 @@ void ApiWrap::loadMessagesFiles(Data::MessagesSlice &&slice) {
 	loadNextMessageFile();
 }
 
+Data::Message *ApiWrap::currentFileMessage() const {
+	Expects(_chatProcess != nullptr);
+	Expects(_chatProcess->slice.has_value());
+
+	return &_chatProcess->slice->list[_chatProcess->fileIndex];
+}
+
+Data::FileOrigin ApiWrap::currentFileMessageOrigin() const {
+	Expects(_chatProcess != nullptr);
+	Expects(_chatProcess->slice.has_value());
+
+	auto result = Data::FileOrigin();
+	result.messageId = currentFileMessage()->id;
+	result.peer = _chatProcess->info.input;
+	result.split = _chatProcess->info.splits[_chatProcess->localSplitIndex];
+	return result;
+}
+
 void ApiWrap::loadNextMessageFile() {
 	Expects(_chatProcess != nullptr);
 	Expects(_chatProcess->slice.has_value());
@@ -1394,9 +1422,10 @@ void ApiWrap::loadNextMessageFile() {
 		};
 		const auto ready = processFileLoad(
 			list[_chatProcess->fileIndex].file(),
+			currentFileMessageOrigin(),
 			fileProgress,
 			[=](const QString &path) { loadMessageFileDone(path); },
-			&list[_chatProcess->fileIndex]);
+			currentFileMessage());
 		if (!ready) {
 			return;
 		}
@@ -1405,9 +1434,10 @@ void ApiWrap::loadNextMessageFile() {
 		};
 		const auto thumbReady = processFileLoad(
 			list[_chatProcess->fileIndex].thumb().file,
+			currentFileMessageOrigin(),
 			thumbProgress,
 			[=](const QString &path) { loadMessageThumbDone(path); },
-			&list[_chatProcess->fileIndex]);
+			currentFileMessage());
 		if (!thumbReady) {
 			return;
 		}
@@ -1497,6 +1527,7 @@ void ApiWrap::finishMessages() {
 
 bool ApiWrap::processFileLoad(
 		Data::File &file,
+		const Data::FileOrigin &origin,
 		Fn<bool(FileProgress)> progress,
 		FnMut<void(QString)> done,
 		Data::Message *message) {
@@ -1508,7 +1539,7 @@ bool ApiWrap::processFileLoad(
 	} else if (!file.location && file.content.isEmpty()) {
 		file.skipReason = SkipReason::Unavailable;
 		return true;
-	} else if (writePreloadedFile(file)) {
+	} else if (writePreloadedFile(file, origin)) {
 		return !file.relativePath.isEmpty();
 	}
 
@@ -1544,11 +1575,13 @@ bool ApiWrap::processFileLoad(
 		file.skipReason = SkipReason::FileSize;
 		return true;
 	}
-	loadFile(file, std::move(progress), std::move(done));
+	loadFile(file, origin, std::move(progress), std::move(done));
 	return false;
 }
 
-bool ApiWrap::writePreloadedFile(Data::File &file) {
+bool ApiWrap::writePreloadedFile(
+		Data::File &file,
+		const Data::FileOrigin &origin) {
 	Expects(_settings != nullptr);
 
 	using namespace Output;
@@ -1557,7 +1590,7 @@ bool ApiWrap::writePreloadedFile(Data::File &file) {
 		file.relativePath = *path;
 		return true;
 	} else if (!file.content.isEmpty()) {
-		const auto process = prepareFileProcess(file);
+		const auto process = prepareFileProcess(file, origin);
 		if (const auto result = process->file.writeBlock(file.content)) {
 			file.relativePath = process->relativePath;
 			_fileCache->save(file.location, file.relativePath);
@@ -1571,13 +1604,14 @@ bool ApiWrap::writePreloadedFile(Data::File &file) {
 
 void ApiWrap::loadFile(
 		const Data::File &file,
+		const Data::FileOrigin &origin,
 		Fn<bool(FileProgress)> progress,
 		FnMut<void(QString)> done) {
 	Expects(_fileProcess == nullptr);
 	Expects(file.location.dcId != 0
 		|| file.location.data.type() == mtpc_inputTakeoutFileLocation);
 
-	_fileProcess = prepareFileProcess(file);
+	_fileProcess = prepareFileProcess(file, origin);
 	_fileProcess->progress = std::move(progress);
 	_fileProcess->done = std::move(done);
 
@@ -1594,7 +1628,9 @@ void ApiWrap::loadFile(
 	loadFilePart();
 }
 
-auto ApiWrap::prepareFileProcess(const Data::File &file) const
+auto ApiWrap::prepareFileProcess(
+	const Data::File &file,
+	const Data::FileOrigin &origin) const
 -> std::unique_ptr<FileProcess> {
 	Expects(_settings != nullptr);
 
@@ -1607,6 +1643,7 @@ auto ApiWrap::prepareFileProcess(const Data::File &file) const
 	result->relativePath = relativePath;
 	result->location = file.location;
 	result->size = file.size;
+	result->origin = origin;
 	return result;
 }
 
@@ -1701,6 +1738,87 @@ void ApiWrap::filePartDone(int offset, const MTPupload_File &result) {
 	process->done(process->relativePath);
 }
 
+void ApiWrap::filePartRefreshReference(int offset) {
+	Expects(_fileProcess != nullptr);
+
+	const auto &origin = _fileProcess->origin;
+	if (!origin.messageId) {
+		error("FILE_REFERENCE error for non-message file.");
+		return;
+	}
+	if (origin.peer.type() == mtpc_inputPeerChannel
+		|| origin.peer.type() == mtpc_inputPeerChannelFromMessage) {
+		const auto channel = (origin.peer.type() == mtpc_inputPeerChannel)
+			? MTP_inputChannel(
+				origin.peer.c_inputPeerChannel().vchannel_id(),
+				origin.peer.c_inputPeerChannel().vaccess_hash())
+			: MTP_inputChannelFromMessage(
+				origin.peer.c_inputPeerChannelFromMessage().vpeer(),
+				origin.peer.c_inputPeerChannelFromMessage().vmsg_id(),
+				origin.peer.c_inputPeerChannelFromMessage().vchannel_id());
+		mainRequest(MTPchannels_GetMessages(
+			channel,
+			MTP_vector<MTPInputMessage>(
+				1,
+				MTP_inputMessageID(MTP_int(origin.messageId)))
+		)).fail([=](const RPCError &error) {
+			filePartUnavailable();
+			return true;
+		}).done([=](const MTPmessages_Messages &result) {
+			filePartExtractReference(offset, result);
+		}).send();
+	} else {
+		splitRequest(origin.split, MTPmessages_GetMessages(
+			MTP_vector<MTPInputMessage>(
+				1,
+				MTP_inputMessageID(MTP_int(origin.messageId)))
+		)).fail([=](const RPCError &error) {
+			filePartUnavailable();
+			return true;
+		}).done([=](const MTPmessages_Messages &result) {
+			filePartExtractReference(offset, result);
+		}).send();
+	}
+}
+
+void ApiWrap::filePartExtractReference(
+		int offset,
+		const MTPmessages_Messages &result) {
+	Expects(_fileProcess != nullptr);
+
+	result.match([&](const MTPDmessages_messagesNotModified &data) {
+		error("Unexpected messagesNotModified received.");
+	}, [&](const auto &data) {
+		auto context = Data::ParseMediaContext();
+		const auto messages = Data::ParseMessagesSlice(
+			context,
+			data.vmessages(),
+			data.vusers(),
+			data.vchats(),
+			_chatProcess->info.relativePath);
+		for (const auto &message : messages.list) {
+			if (message.id == _fileProcess->origin.messageId) {
+				const auto refresh1 = Data::RefreshFileReference(
+					_fileProcess->location,
+					message.file().location);
+				const auto refresh2 = Data::RefreshFileReference(
+					_fileProcess->location,
+					message.thumb().file.location);
+				if (refresh1 || refresh2) {
+					fileRequest(
+						_fileProcess->location,
+						offset
+					).done([=](const MTPupload_File &result) {
+						filePartDone(offset, result);
+					}).send();
+					return;
+				}
+			}
+		}
+		filePartUnavailable();
+	});
+}
+
 void ApiWrap::filePartUnavailable() {
 	Expects(_fileProcess != nullptr);
 	Expects(!_fileProcess->requests.empty());
diff --git a/Telegram/SourceFiles/export/export_api_wrap.h b/Telegram/SourceFiles/export/export_api_wrap.h
index c0f28d819..0e47e9be3 100644
--- a/Telegram/SourceFiles/export/export_api_wrap.h
+++ b/Telegram/SourceFiles/export/export_api_wrap.h
@@ -7,7 +7,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 */
 #pragma once
 
-#include "mtproto/concurrent_sender.h"
+#include "mtproto/mtproto_concurrent_sender.h"
 
 namespace Export {
 namespace Data {
@@ -23,6 +23,7 @@ struct DialogsInfo;
 struct DialogInfo;
 struct MessagesSlice;
 struct Message;
+struct FileOrigin;
 } // namespace Data
 
 namespace Output {
@@ -159,21 +160,33 @@ private:
 	void finishMessagesSlice();
 	void finishMessages();
 
+	[[nodiscard]] Data::Message *currentFileMessage() const;
+	[[nodiscard]] Data::FileOrigin currentFileMessageOrigin() const;
+
 	bool processFileLoad(
 		Data::File &file,
+		const Data::FileOrigin &origin,
 		Fn<bool(FileProgress)> progress,
 		FnMut<void(QString)> done,
 		Data::Message *message = nullptr);
 	std::unique_ptr<FileProcess> prepareFileProcess(
-		const Data::File &file) const;
-	bool writePreloadedFile(Data::File &file);
+		const Data::File &file,
+		const Data::FileOrigin &origin) const;
+	bool writePreloadedFile(
+		Data::File &file,
+		const Data::FileOrigin &origin);
 	void loadFile(
 		const Data::File &file,
+		const Data::FileOrigin &origin,
 		Fn<bool(FileProgress)> progress,
 		FnMut<void(QString)> done);
 	void loadFilePart();
 	void filePartDone(int offset, const MTPupload_File &result);
 	void filePartUnavailable();
+	void filePartRefreshReference(int offset);
+	void filePartExtractReference(
+		int offset,
+		const MTPmessages_Messages &result);
 
 	template <typename Request>
 	class RequestBuilder;
diff --git a/Telegram/SourceFiles/export/export_controller.h b/Telegram/SourceFiles/export/export_controller.h
index 5dc59ad14..aa8afa9a4 100644
--- a/Telegram/SourceFiles/export/export_controller.h
+++ b/Telegram/SourceFiles/export/export_controller.h
@@ -7,9 +7,10 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 */
 #pragma once
 
-#include <crl/crl_object_on_queue.h>
 #include "base/variant.h"
-#include "mtproto/rpc_sender.h"
+#include "mtproto/mtproto_rpc_sender.h"
+
+#include <crl/crl_object_on_queue.h>
 
 namespace Export {
 
diff --git a/Telegram/SourceFiles/facades.cpp b/Telegram/SourceFiles/facades.cpp
index 211899f89..4521daf51 100644
--- a/Telegram/SourceFiles/facades.cpp
+++ b/Telegram/SourceFiles/facades.cpp
@@ -384,9 +384,9 @@ struct Data {
 	bool NotificationsDemoIsShown = false;
 
 	bool TryIPv6 = !Platform::IsWindows();
-	std::vector<ProxyData> ProxiesList;
-	ProxyData SelectedProxy;
-	ProxyData::Settings ProxySettings = ProxyData::Settings::System;
+	std::vector<MTP::ProxyData> ProxiesList;
+	MTP::ProxyData SelectedProxy;
+	MTP::ProxyData::Settings ProxySettings = MTP::ProxyData::Settings::System;
 	bool UseProxyForCalls = false;
 	base::Observable<void> ConnectionTypeChanged;
 
@@ -512,9 +512,9 @@ DefineVar(Global, Notify::ScreenCorner, NotificationsCorner);
 DefineVar(Global, bool, NotificationsDemoIsShown);
 
 DefineVar(Global, bool, TryIPv6);
-DefineVar(Global, std::vector<ProxyData>, ProxiesList);
-DefineVar(Global, ProxyData, SelectedProxy);
-DefineVar(Global, ProxyData::Settings, ProxySettings);
+DefineVar(Global, std::vector<MTP::ProxyData>, ProxiesList);
+DefineVar(Global, MTP::ProxyData, SelectedProxy);
+DefineVar(Global, MTP::ProxyData::Settings, ProxySettings);
 DefineVar(Global, bool, UseProxyForCalls);
 DefineRefVar(Global, base::Observable<void>, ConnectionTypeChanged);
 
diff --git a/Telegram/SourceFiles/facades.h b/Telegram/SourceFiles/facades.h
index 4c943d141..5514a7e1f 100644
--- a/Telegram/SourceFiles/facades.h
+++ b/Telegram/SourceFiles/facades.h
@@ -10,7 +10,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "base/type_traits.h"
 #include "base/observer.h"
 #include "base/call_delayed.h"
-#include "ui/effects/animation_value.h"
+#include "mtproto/mtproto_proxy_data.h"
 
 class History;
 
@@ -225,9 +225,9 @@ DeclareVar(Notify::ScreenCorner, NotificationsCorner);
 DeclareVar(bool, NotificationsDemoIsShown);
 
 DeclareVar(bool, TryIPv6);
-DeclareVar(std::vector<ProxyData>, ProxiesList);
-DeclareVar(ProxyData, SelectedProxy);
-DeclareVar(ProxyData::Settings, ProxySettings);
+DeclareVar(std::vector<MTP::ProxyData>, ProxiesList);
+DeclareVar(MTP::ProxyData, SelectedProxy);
+DeclareVar(MTP::ProxyData::Settings, ProxySettings);
 DeclareVar(bool, UseProxyForCalls);
 DeclareRefVar(base::Observable<void>, ConnectionTypeChanged);
 
diff --git a/Telegram/SourceFiles/ffmpeg/ffmpeg_utility.cpp b/Telegram/SourceFiles/ffmpeg/ffmpeg_utility.cpp
index 6329bbddf..a03d191ca 100644
--- a/Telegram/SourceFiles/ffmpeg/ffmpeg_utility.cpp
+++ b/Telegram/SourceFiles/ffmpeg/ffmpeg_utility.cpp
@@ -12,9 +12,9 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 
 #include <QImage>
 
-#ifdef TDESKTOP_OFFICIAL_TARGET
+#ifdef LIB_FFMPEG_USE_QT_PRIVATE_API
 #include <private/qdrawhelper_p.h>
-#endif // TDESKTOP_OFFICIAL_TARGET
+#endif // LIB_FFMPEG_USE_QT_PRIVATE_API
 
 extern "C" {
 #include <libavutil/opt.h>
@@ -51,7 +51,7 @@ void UnPremultiplyLine(uchar *dst, const uchar *src, int intsCount) {
 	[[maybe_unused]] const auto udst = reinterpret_cast<uint*>(dst);
 	const auto usrc = reinterpret_cast<const uint*>(src);
 
-#ifndef TDESKTOP_OFFICIAL_TARGET
+#ifndef LIB_FFMPEG_USE_QT_PRIVATE_API
 	for (auto i = 0; i != intsCount; ++i) {
 		udst[i] = qUnpremultiply(usrc[i]);
 	}
@@ -68,7 +68,7 @@ void PremultiplyLine(uchar *dst, const uchar *src, int intsCount) {
 	const auto udst = reinterpret_cast<uint*>(dst);
 	[[maybe_unused]] const auto usrc = reinterpret_cast<const uint*>(src);
 
-#ifndef TDESKTOP_OFFICIAL_TARGET
+#ifndef LIB_FFMPEG_USE_QT_PRIVATE_API
 	for (auto i = 0; i != intsCount; ++i) {
 		udst[i] = qPremultiply(usrc[i]);
 	}
diff --git a/Telegram/SourceFiles/history/admin_log/history_admin_log_inner.cpp b/Telegram/SourceFiles/history/admin_log/history_admin_log_inner.cpp
index 555364637..ede2c7755 100644
--- a/Telegram/SourceFiles/history/admin_log/history_admin_log_inner.cpp
+++ b/Telegram/SourceFiles/history/admin_log/history_admin_log_inner.cpp
@@ -226,6 +226,7 @@ InnerWidget::InnerWidget(
 , _controller(controller)
 , _channel(channel)
 , _history(channel->owner().history(channel))
+, _api(_channel->session().api().instance())
 , _scrollDateCheck([=] { scrollDateCheck(); })
 , _emptyText(
 		st::historyAdminLogEmptyWidth
@@ -407,7 +408,7 @@ void InnerWidget::applySearch(const QString &query) {
 
 void InnerWidget::requestAdmins() {
 	auto participantsHash = 0;
-	request(MTPchannels_GetParticipants(
+	_api.request(MTPchannels_GetParticipants(
 		_channel->inputChannel,
 		MTP_channelParticipantsAdmins(),
 		MTP_int(0),
@@ -463,8 +464,8 @@ void InnerWidget::showFilter(Fn<void(FilterValue &&filter)> callback) {
 }
 
 void InnerWidget::clearAndRequestLog() {
-	request(base::take(_preloadUpRequestId)).cancel();
-	request(base::take(_preloadDownRequestId)).cancel();
+	_api.request(base::take(_preloadUpRequestId)).cancel();
+	_api.request(base::take(_preloadDownRequestId)).cancel();
 	_filterChanged = true;
 	_upLoaded = false;
 	_downLoaded = true;
@@ -518,7 +519,7 @@ QPoint InnerWidget::tooltipPos() const {
 }
 
 bool InnerWidget::tooltipWindowActive() const {
-	return Ui::InFocusChain(window());
+	return Ui::AppInFocus() && Ui::InFocusChain(window());
 }
 
 HistoryView::Context InnerWidget::elementContext() {
@@ -635,7 +636,7 @@ void InnerWidget::preloadMore(Direction direction) {
 	auto maxId = (direction == Direction::Up) ? _minId : 0;
 	auto minId = (direction == Direction::Up) ? 0 : _maxId;
 	auto perPage = _items.empty() ? kEventsFirstPage : kEventsPerPage;
-	requestId = request(MTPchannels_GetAdminLog(
+	requestId = _api.request(MTPchannels_GetAdminLog(
 		MTP_flags(flags),
 		_channel->inputChannel,
 		MTP_string(_searchQuery),
@@ -1045,15 +1046,22 @@ void InnerWidget::showContextMenu(QContextMenuEvent *e, bool showFromTouch) {
 					cancelContextDownload(document);
 				});
 			} else {
-				if (document->loaded()
-					&& document->isGifv()
-					&& !document->session().settings().autoplayGifs()) {
-					const auto itemId = view
-						? view->data()->fullId()
-						: FullMsgId();
-					_menu->addAction(tr::lng_context_open_gif(tr::now), [=] {
-						openContextGif(itemId);
-					});
+				const auto itemId = view
+					? view->data()->fullId()
+					: FullMsgId();
+				if (const auto item = document->session().data().message(itemId)) {
+					const auto notAutoplayedGif = [&] {
+						return document->isGifv()
+							&& !Data::AutoDownload::ShouldAutoPlay(
+								document->session().settings().autoDownload(),
+								item->history()->peer,
+								document);
+					}();
+					if (notAutoplayedGif) {
+						_menu->addAction(tr::lng_context_open_gif(tr::now), [=] {
+							openContextGif(itemId);
+						});
+					}
 				}
 				if (!document->filepath(DocumentData::FilePathResolve::Checked).isEmpty()) {
 					_menu->addAction(Platform::IsMac() ? tr::lng_context_show_in_finder(tr::now) : tr::lng_context_show_in_folder(tr::now), [=] {
@@ -1217,7 +1225,7 @@ void InnerWidget::suggestRestrictUser(not_null<UserData*> user) {
 		if (base::contains(_admins, user)) {
 			editRestrictions(true, MTP_chatBannedRights(MTP_flags(0), MTP_int(0)));
 		} else {
-			request(MTPchannels_GetParticipant(
+			_api.request(MTPchannels_GetParticipant(
 				_channel->inputChannel,
 				user->inputUser
 			)).done([=](const MTPchannels_ChannelParticipant &result) {
diff --git a/Telegram/SourceFiles/history/admin_log/history_admin_log_inner.h b/Telegram/SourceFiles/history/admin_log/history_admin_log_inner.h
index f20c58382..c9405ea05 100644
--- a/Telegram/SourceFiles/history/admin_log/history_admin_log_inner.h
+++ b/Telegram/SourceFiles/history/admin_log/history_admin_log_inner.h
@@ -44,7 +44,6 @@ class InnerWidget final
 	: public Ui::RpWidget
 	, public Ui::AbstractTooltipShower
 	, public HistoryView::ElementDelegate
-	, private MTP::Sender
 	, private base::Subscriber {
 public:
 	InnerWidget(
@@ -216,9 +215,11 @@ private:
 	template <typename Method>
 	void enumerateDates(Method method);
 
-	not_null<Window::SessionController*> _controller;
-	not_null<ChannelData*> _channel;
-	not_null<History*> _history;
+	const not_null<Window::SessionController*> _controller;
+	const not_null<ChannelData*> _channel;
+	const not_null<History*> _history;
+	MTP::Sender _api;
+
 	std::vector<OwnedItem> _items;
 	std::set<uint64> _eventIds;
 	std::map<not_null<const HistoryItem*>, not_null<Element*>> _itemsByData;
diff --git a/Telegram/SourceFiles/history/admin_log/history_admin_log_section.cpp b/Telegram/SourceFiles/history/admin_log/history_admin_log_section.cpp
index 2e5ad7f76..809131b3d 100644
--- a/Telegram/SourceFiles/history/admin_log/history_admin_log_section.cpp
+++ b/Telegram/SourceFiles/history/admin_log/history_admin_log_section.cpp
@@ -97,7 +97,7 @@ object_ptr<Window::SectionWidget> SectionMemento::createWidget(
 	}
 	auto result = object_ptr<Widget>(parent, controller, _channel);
 	result->setInternalState(geometry, this);
-	return std::move(result);
+	return result;
 }
 
 FixedBar::FixedBar(
@@ -352,7 +352,9 @@ void Widget::setInternalState(const QRect &geometry, not_null<SectionMemento*> m
 void Widget::setupShortcuts() {
 	Shortcuts::Requests(
 	) | rpl::filter([=] {
-		return isActiveWindow() && !Ui::isLayerShown() && inFocusChain();
+		return Ui::AppInFocus()
+			&& Ui::InFocusChain(this)
+			&& !Ui::isLayerShown();
 	}) | rpl::start_with_next([=](not_null<Shortcuts::Request*> request) {
 		using Command = Shortcuts::Command;
 		request->check(Command::Search, 2) && request->handle([=] {
@@ -365,7 +367,7 @@ void Widget::setupShortcuts() {
 std::unique_ptr<Window::SectionMemento> Widget::createMemento() {
 	auto result = std::make_unique<SectionMemento>(channel());
 	saveState(result.get());
-	return std::move(result);
+	return result;
 }
 
 void Widget::saveState(not_null<SectionMemento*> memento) {
diff --git a/Telegram/SourceFiles/history/feed/history_feed_section.cpp b/Telegram/SourceFiles/history/feed/history_feed_section.cpp
index ceb360c09..571492247 100644
--- a/Telegram/SourceFiles/history/feed/history_feed_section.cpp
+++ b/Telegram/SourceFiles/history/feed/history_feed_section.cpp
@@ -59,7 +59,7 @@ object_ptr<Window::SectionWidget> Memento::createWidget(
 	}
 	auto result = object_ptr<Widget>(parent, controller, _feed);
 	result->setInternalState(geometry, this);
-	return std::move(result);
+	return result;
 }
 
 Widget::Widget(
@@ -456,7 +456,7 @@ ClickHandlerPtr Widget::listDateLink(not_null<Element*> view) {
 std::unique_ptr<Window::SectionMemento> Widget::createMemento() {
 	auto result = std::make_unique<Memento>(_feed);
 	saveState(result.get());
-	return std::move(result);
+	return result;
 }
 
 void Widget::saveState(not_null<Memento*> memento) {
diff --git a/Telegram/SourceFiles/history/history.cpp b/Telegram/SourceFiles/history/history.cpp
index 808cf8525..f1a2559ce 100644
--- a/Telegram/SourceFiles/history/history.cpp
+++ b/Telegram/SourceFiles/history/history.cpp
@@ -594,11 +594,6 @@ HistoryItem *History::createItem(
 		if (detachExistingItem) {
 			result->removeMainView();
 		}
-		if (message.type() == mtpc_message) {
-			result->updateSentContent(
-				result->originalText(),
-				message.c_message().vmedia());
-		}
 		return result;
 	}
 	return HistoryItem::Create(this, message, clientFlags);
diff --git a/Telegram/SourceFiles/history/history.style b/Telegram/SourceFiles/history/history.style
index 6886d84e4..544987a3c 100644
--- a/Telegram/SourceFiles/history/history.style
+++ b/Telegram/SourceFiles/history/history.style
@@ -591,6 +591,7 @@ historyGroupAboutTextSkip: 10px;
 historyGroupAboutSkip: 8px;
 
 historyVideoDownloadSize: msgFileSize;
+historyVideoMuteSize: 22px;
 historyVideoCancel: icon {{ "playlist_cancel", historyFileThumbIconFg }};
 historyVideoCancelSelected: icon {{ "playlist_cancel", historyFileThumbIconFgSelected }};
 historyVideoDownload: icon {{ "playlist_download", historyFileThumbIconFg }};
diff --git a/Telegram/SourceFiles/history/history_inner_widget.cpp b/Telegram/SourceFiles/history/history_inner_widget.cpp
index 05aa548b6..a44565285 100644
--- a/Telegram/SourceFiles/history/history_inner_widget.cpp
+++ b/Telegram/SourceFiles/history/history_inner_widget.cpp
@@ -62,7 +62,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 namespace {
 
 constexpr auto kScrollDateHideTimeout = 1000;
-constexpr auto kUnloadHeavyPartsPages = 3;
+constexpr auto kUnloadHeavyPartsPages = 1;
 
 // Helper binary search for an item in a list that is not completely
 // above the given top of the visible area or below the given bottom of the visible area
@@ -1568,8 +1568,16 @@ void HistoryInner::showContextMenu(QContextMenuEvent *e, bool showFromTouch) {
 		const auto lnkIsVideo = document->isVideoFile();
 		const auto lnkIsVoice = document->isVoiceMessage();
 		const auto lnkIsAudio = document->isAudioFile();
-		if (document->loaded() && document->isGifv()) {
-			if (!document->session().settings().autoplayGifs()) {
+		if (document->isGifv()) {
+			const auto notAutoplayedGif = [&] {
+				return item
+					&& document->isGifv()
+					&& !Data::AutoDownload::ShouldAutoPlay(
+						document->session().settings().autoDownload(),
+						item->history()->peer,
+						document);
+			}();
+			if (notAutoplayedGif) {
 				_menu->addAction(tr::lng_context_open_gif(tr::now), [=] {
 					openContextGif(itemId);
 				});
@@ -3199,7 +3207,7 @@ QPoint HistoryInner::tooltipPos() const {
 }
 
 bool HistoryInner::tooltipWindowActive() const {
-	return Ui::InFocusChain(window());
+	return Ui::AppInFocus() && Ui::InFocusChain(window());
 }
 
 void HistoryInner::onParentGeometryChanged() {
diff --git a/Telegram/SourceFiles/history/history_item_components.cpp b/Telegram/SourceFiles/history/history_item_components.cpp
index d792efbe0..430b48afc 100644
--- a/Telegram/SourceFiles/history/history_item_components.cpp
+++ b/Telegram/SourceFiles/history/history_item_components.cpp
@@ -23,6 +23,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "data/data_session.h"
 #include "data/data_user.h"
 #include "data/data_file_origin.h"
+#include "data/data_document.h"
 #include "main/main_session.h"
 #include "window/window_session_controller.h"
 #include "facades.h"
@@ -229,6 +230,7 @@ void HistoryMessageForwarded::create(const HistoryMessageVia *via) const {
 bool HistoryMessageReply::updateData(
 		not_null<HistoryMessage*> holder,
 		bool force) {
+	const auto guard = gsl::finally([&] { refreshReplyToDocument(); });
 	if (!force) {
 		if (replyToMsg || !replyToMsgId) {
 			return true;
@@ -408,6 +410,15 @@ void HistoryMessageReply::paint(
 	}
 }
 
+void HistoryMessageReply::refreshReplyToDocument() {
+	replyToDocumentId = 0;
+	if (const auto media = replyToMsg ? replyToMsg->media() : nullptr) {
+		if (const auto document = media->document()) {
+			replyToDocumentId = document->id;
+		}
+	}
+}
+
 ReplyMarkupClickHandler::ReplyMarkupClickHandler(
 	int row,
 	int column,
diff --git a/Telegram/SourceFiles/history/history_item_components.h b/Telegram/SourceFiles/history/history_item_components.h
index 5efb8a364..dca945c53 100644
--- a/Telegram/SourceFiles/history/history_item_components.h
+++ b/Telegram/SourceFiles/history/history_item_components.h
@@ -131,20 +131,23 @@ struct HistoryMessageReply : public RuntimeComponent<HistoryMessageReply, Histor
 		int w,
 		PaintFlags flags) const;
 
-	MsgId replyToId() const {
+	[[nodiscard]] MsgId replyToId() const {
 		return replyToMsgId;
 	}
-	int replyToWidth() const {
+	[[nodiscard]] int replyToWidth() const {
 		return maxReplyWidth;
 	}
-	ClickHandlerPtr replyToLink() const {
+	[[nodiscard]] ClickHandlerPtr replyToLink() const {
 		return replyToLnk;
 	}
 	void setReplyToLinkFrom(
 		not_null<HistoryMessage*> holder);
 
+	void refreshReplyToDocument();
+
 	MsgId replyToMsgId = 0;
 	HistoryItem *replyToMsg = nullptr;
+	DocumentId replyToDocumentId = 0;
 	ClickHandlerPtr replyToLnk;
 	mutable Ui::Text::String replyToName, replyToText;
 	mutable int replyToVersion = 0;
diff --git a/Telegram/SourceFiles/history/history_message.cpp b/Telegram/SourceFiles/history/history_message.cpp
index 077f7477a..0c9ee4d34 100644
--- a/Telegram/SourceFiles/history/history_message.cpp
+++ b/Telegram/SourceFiles/history/history_message.cpp
@@ -17,7 +17,8 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "history/history_location_manager.h"
 #include "history/history_service.h"
 #include "history/view/history_view_service_message.h"
-#include "history/view/history_view_context_menu.h" // For CopyPostLink().
+#include "history/view/history_view_context_menu.h" // CopyPostLink.
+#include "history/view/media/history_view_media.h" // AddTimestampLinks.
 #include "chat_helpers/stickers_emoji_pack.h"
 #include "main/main_session.h"
 #include "boxes/share_box.h"
@@ -698,7 +699,13 @@ int HistoryMessage::viewsCount() const {
 
 bool HistoryMessage::updateDependencyItem() {
 	if (const auto reply = Get<HistoryMessageReply>()) {
-		return reply->updateData(this, true);
+		const auto documentId = reply->replyToDocumentId;
+		const auto result = reply->updateData(this, true);
+		if (documentId != reply->replyToDocumentId
+			&& generateLocalEntitiesByReply()) {
+			reapplyText();
+		}
+		return result;
 	}
 	return true;
 }
@@ -895,6 +902,7 @@ void HistoryMessage::returnSavedMedia() {
 		history()->owner().groups().refreshMessage(this, true);
 	} else {
 		history()->owner().requestItemViewRefresh(this);
+		history()->owner().updateDependentMessages(this);
 	}
 }
 
@@ -1150,6 +1158,38 @@ Storage::SharedMediaTypesMask HistoryMessage::sharedMediaTypes() const {
 	return result;
 }
 
+bool HistoryMessage::generateLocalEntitiesByReply() const {
+	return !_media || _media->webpage();
+}
+
+TextWithEntities HistoryMessage::withLocalEntities(
+		const TextWithEntities &textWithEntities) const {
+	if (!generateLocalEntitiesByReply()) {
+		return textWithEntities;
+	}
+	if (const auto reply = Get<HistoryMessageReply>()) {
+		const auto document = reply->replyToDocumentId
+			? history()->owner().document(reply->replyToDocumentId).get()
+			: nullptr;
+		if (document && (document->isVideoFile() || document->isSong())) {
+			using namespace HistoryView;
+			const auto duration = document->getDuration();
+			const auto base = (duration > 0)
+				? DocumentTimestampLinkBase(
+					document,
+					reply->replyToMsg->fullId())
+				: QString();
+			if (!base.isEmpty()) {
+				return AddTimestampLinks(
+					textWithEntities,
+					duration,
+					base);
+			}
+		}
+	}
+	return textWithEntities;
+}
+
 void HistoryMessage::setText(const TextWithEntities &textWithEntities) {
 	for_const (auto &entity, textWithEntities.entities) {
 		auto type = entity.type();
@@ -1168,7 +1208,7 @@ void HistoryMessage::setText(const TextWithEntities &textWithEntities) {
 	clearIsolatedEmoji();
 	_text.setMarkedText(
 		st::messageTextStyle,
-		textWithEntities,
+		withLocalEntities(textWithEntities),
 		Ui::ItemTextOptions(this));
 	if (!textWithEntities.text.isEmpty() && _text.isEmpty()) {
 		// If server has allowed some text that we've trim-ed entirely,
@@ -1184,6 +1224,11 @@ void HistoryMessage::setText(const TextWithEntities &textWithEntities) {
 	_textHeight = 0;
 }
 
+void HistoryMessage::reapplyText() {
+	setText(originalText());
+	history()->owner().requestItemResize(this);
+}
+
 void HistoryMessage::setEmptyText() {
 	clearIsolatedEmoji();
 	_text.setMarkedText(
@@ -1309,8 +1354,13 @@ void HistoryMessage::setRealId(MsgId newId) {
 }
 
 void HistoryMessage::dependencyItemRemoved(HistoryItem *dependency) {
-	if (auto reply = Get<HistoryMessageReply>()) {
+	if (const auto reply = Get<HistoryMessageReply>()) {
+		const auto documentId = reply->replyToDocumentId;
 		reply->itemRemoved(this, dependency);
+		if (documentId != reply->replyToDocumentId
+			&& generateLocalEntitiesByReply()) {
+			reapplyText();
+		}
 	}
 }
 
diff --git a/Telegram/SourceFiles/history/history_message.h b/Telegram/SourceFiles/history/history_message.h
index c9904c160..8b783edf9 100644
--- a/Telegram/SourceFiles/history/history_message.h
+++ b/Telegram/SourceFiles/history/history_message.h
@@ -198,6 +198,10 @@ private:
 		const MTPDmessageFwdHeader &data);
 
 	void refreshMessageBadge();
+	[[nodiscard]] bool generateLocalEntitiesByReply() const;
+	[[nodiscard]] TextWithEntities withLocalEntities(
+		const TextWithEntities &textWithEntities) const;
+	void reapplyText();
 
 	Ui::Text::String _messageBadge;
 
diff --git a/Telegram/SourceFiles/history/history_widget.cpp b/Telegram/SourceFiles/history/history_widget.cpp
index 3059d87ba..e32f90974 100644
--- a/Telegram/SourceFiles/history/history_widget.cpp
+++ b/Telegram/SourceFiles/history/history_widget.cpp
@@ -40,6 +40,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "data/data_chat.h"
 #include "data/data_user.h"
 #include "data/data_scheduled_messages.h"
+#include "data/data_file_origin.h"
 #include "history/history.h"
 #include "history/history_item.h"
 #include "history/history_message.h"
@@ -575,7 +576,7 @@ HistoryWidget::HistoryWidget(
 				updateNotifyControls();
 			}
 			if (update.flags & UpdateFlag::UnavailableReasonChanged) {
-				const auto unavailable = _peer->unavailableReason();
+				const auto unavailable = _peer->computeUnavailableReason();
 				if (!unavailable.isEmpty()) {
 					controller->showBackFromStack();
 					Ui::show(Box<InformBox>(unavailable));
@@ -1514,7 +1515,9 @@ void HistoryWidget::notify_showScheduledButtonChanged() {
 void HistoryWidget::setupShortcuts() {
 	Shortcuts::Requests(
 	) | rpl::filter([=] {
-		return isActiveWindow() && !Ui::isLayerShown() && inFocusChain();
+		return Ui::AppInFocus()
+			&& Ui::InFocusChain(this)
+			&& !Ui::isLayerShown();
 	}) | rpl::start_with_next([=](not_null<Shortcuts::Request*> request) {
 		using Command = Shortcuts::Command;
 		if (_history) {
@@ -1748,9 +1751,8 @@ void HistoryWidget::showHistory(
 		cancelTypingAction();
 	}
 
-	if (!session().settings().autoplayGifs()) {
-		session().data().stopAutoplayAnimations();
-	}
+	session().data().stopPlayingVideoFiles();
+
 	clearReplyReturns();
 	clearAllLoadRequests();
 
@@ -1841,8 +1843,6 @@ void HistoryWidget::showHistory(
 	_nonEmptySelection = false;
 
 	if (_peer) {
-		session().downloader().clearPriorities();
-
 		_history = _peer->owner().history(_peer);
 		_migrated = _history->migrateFrom();
 		if (_migrated
@@ -2787,6 +2787,7 @@ void HistoryWidget::preloadHistoryIfNeeded() {
 	}
 
 	updateHistoryDownVisibility();
+	updateUnreadMentionsVisibility();
 	if (!_scrollToAnimation.animating()) {
 		preloadHistoryByScroll();
 		checkReplyReturns();
@@ -3662,8 +3663,20 @@ bool HistoryWidget::eventFilter(QObject *obj, QEvent *e) {
 		const auto k = static_cast<QKeyEvent*>(e);
 		if ((k->modifiers() & kCommonModifiers) == Qt::ControlModifier) {
 			if (k->key() == Qt::Key_Up) {
+#ifdef Q_OS_MAC
+				// Cmd + Up is used instead of Home.
+				if (!_field->textCursor().atStart()) {
+					return false;
+				}
+#endif
 				return replyToPreviousMessage();
 			} else if (k->key() == Qt::Key_Down) {
+#ifdef Q_OS_MAC
+				// Cmd + Down is used instead of End.
+				if (!_field->textCursor().atEnd()) {
+					return false;
+				}
+#endif
 				return replyToNextMessage();
 			}
 		}
@@ -5444,13 +5457,24 @@ void HistoryWidget::updateUnreadMentionsVisibility() {
 	if (showUnreadMentions) {
 		session().api().preloadEnoughUnreadMentions(_history);
 	}
-	auto unreadMentionsIsVisible = [this, showUnreadMentions] {
+	const auto unreadMentionsIsShown = [&] {
 		if (!showUnreadMentions || _firstLoadRequest) {
 			return false;
 		}
-		return (_history->getUnreadMentionsLoadedCount() > 0);
-	};
-	auto unreadMentionsIsShown = unreadMentionsIsVisible();
+		if (!_history->getUnreadMentionsLoadedCount()) {
+			return false;
+		}
+		// If we have an unheard voice message with the mention
+		// and our message is the last one, we can't see the status
+		// (delivered/read) of this message.
+		// (Except for MacBooks with the TouchPad.)
+		if (_scroll->scrollTop() == _scroll->scrollTopMax()) {
+			if (const auto lastMessage = _history->lastMessage()) {
+				return !lastMessage->from()->isSelf();
+			}
+		}
+		return true;
+	}();
 	if (unreadMentionsIsShown) {
 		_unreadMentions->setUnreadCount(_history->getUnreadMentionsCount());
 	}
diff --git a/Telegram/SourceFiles/history/view/history_view_context_menu.cpp b/Telegram/SourceFiles/history/view/history_view_context_menu.cpp
index e00b3c9b8..ec3da7b81 100644
--- a/Telegram/SourceFiles/history/view/history_view_context_menu.cpp
+++ b/Telegram/SourceFiles/history/view/history_view_context_menu.cpp
@@ -168,12 +168,19 @@ void AddDocumentActions(
 		});
 		return;
 	}
-	if (document->loaded()
-		&& document->isGifv()
-		&& !document->session().settings().autoplayGifs()) {
-		menu->addAction(tr::lng_context_open_gif(tr::now), [=] {
-			OpenGif(contextId);
-		});
+	if (const auto item = document->session().data().message(contextId)) {
+		const auto notAutoplayedGif = [&] {
+			return document->isGifv()
+				&& !Data::AutoDownload::ShouldAutoPlay(
+					document->session().settings().autoDownload(),
+					item->history()->peer,
+					document);
+		}();
+		if (notAutoplayedGif) {
+			menu->addAction(tr::lng_context_open_gif(tr::now), [=] {
+				OpenGif(contextId);
+			});
+		}
 	}
 	if (document->sticker()
 		&& document->sticker()->set.type() != mtpc_inputStickerSetEmpty) {
diff --git a/Telegram/SourceFiles/history/view/history_view_list_widget.cpp b/Telegram/SourceFiles/history/view/history_view_list_widget.cpp
index 4006f3162..4642f11db 100644
--- a/Telegram/SourceFiles/history/view/history_view_list_widget.cpp
+++ b/Telegram/SourceFiles/history/view/history_view_list_widget.cpp
@@ -1092,7 +1092,7 @@ QPoint ListWidget::tooltipPos() const {
 }
 
 bool ListWidget::tooltipWindowActive() const {
-	return Ui::InFocusChain(window());
+	return Ui::AppInFocus() && Ui::InFocusChain(window());
 }
 
 Context ListWidget::elementContext() {
diff --git a/Telegram/SourceFiles/history/view/history_view_scheduled_section.cpp b/Telegram/SourceFiles/history/view/history_view_scheduled_section.cpp
index 93e61fa71..0730b1869 100644
--- a/Telegram/SourceFiles/history/view/history_view_scheduled_section.cpp
+++ b/Telegram/SourceFiles/history/view/history_view_scheduled_section.cpp
@@ -67,7 +67,7 @@ object_ptr<Window::SectionWidget> ScheduledMemento::createWidget(
 	}
 	auto result = object_ptr<ScheduledWidget>(parent, controller, _history);
 	result->setInternalState(geometry, this);
-	return std::move(result);
+	return result;
 }
 
 ScheduledWidget::ScheduledWidget(
@@ -714,7 +714,7 @@ bool ScheduledWidget::returnTabbedSelector() {
 std::unique_ptr<Window::SectionMemento> ScheduledWidget::createMemento() {
 	auto result = std::make_unique<ScheduledMemento>(history());
 	saveState(result.get());
-	return std::move(result);
+	return result;
 }
 
 void ScheduledWidget::saveState(not_null<ScheduledMemento*> memento) {
diff --git a/Telegram/SourceFiles/history/view/media/history_view_document.cpp b/Telegram/SourceFiles/history/view/media/history_view_document.cpp
index b0a71b05d..1d6697247 100644
--- a/Telegram/SourceFiles/history/view/media/history_view_document.cpp
+++ b/Telegram/SourceFiles/history/view/media/history_view_document.cpp
@@ -21,6 +21,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "data/data_session.h"
 #include "data/data_document.h"
 #include "data/data_media_types.h"
+#include "data/data_file_origin.h"
 #include "app.h"
 #include "styles/style_history.h"
 
@@ -37,10 +38,10 @@ Document::Document(
 : File(parent, parent->data())
 , _data(document) {
 	const auto item = parent->data();
-	auto caption = createCaption(item);
+	auto caption = createCaption();
 
 	createComponents(!caption.isEmpty());
-	if (auto named = Get<HistoryDocumentNamed>()) {
+	if (const auto named = Get<HistoryDocumentNamed>()) {
 		fillNamedFromData(named);
 	}
 
@@ -48,7 +49,7 @@ Document::Document(
 
 	setStatusSize(FileStatusSizeReady);
 
-	if (auto captioned = Get<HistoryDocumentCaptioned>()) {
+	if (const auto captioned = Get<HistoryDocumentCaptioned>()) {
 		captioned->_caption = std::move(caption);
 	}
 }
@@ -214,7 +215,9 @@ void Document::draw(Painter &p, const QRect &r, TextSelection selection, crl::ti
 
 	const auto cornerDownload = downloadInCorner();
 
-	_data->automaticLoad(_realParent->fullId(), _parent->data());
+	if (!_data->canBePlayed()) {
+		_data->automaticLoad(_realParent->fullId(), _parent->data());
+	}
 	bool loaded = _data->loaded(), displayLoading = _data->displayLoading();
 	bool selected = (selection == FullSelection);
 
@@ -831,7 +834,7 @@ void Document::refreshParentId(not_null<HistoryItem*> realParent) {
 
 void Document::parentTextUpdated() {
 	auto caption = (_parent->media() == this)
-		? createCaption(_parent->data())
+		? createCaption()
 		: Ui::Text::String();
 	if (!caption.isEmpty()) {
 		AddComponents(HistoryDocumentCaptioned::Bit());
@@ -850,4 +853,17 @@ TextWithEntities Document::getCaption() const {
 	return TextWithEntities();
 }
 
+Ui::Text::String Document::createCaption() {
+	const auto timestampLinksDuration = _data->isSong()
+		? _data->getDuration()
+		: 0;
+	const auto timestampLinkBase = timestampLinksDuration
+		? DocumentTimestampLinkBase(_data, _realParent->fullId())
+		: QString();
+	return File::createCaption(
+		_parent->data(),
+		timestampLinksDuration,
+		timestampLinkBase);
+}
+
 } // namespace HistoryView
diff --git a/Telegram/SourceFiles/history/view/media/history_view_document.h b/Telegram/SourceFiles/history/view/media/history_view_document.h
index f9aeb5433..2783d9544 100644
--- a/Telegram/SourceFiles/history/view/media/history_view_document.h
+++ b/Telegram/SourceFiles/history/view/media/history_view_document.h
@@ -12,6 +12,12 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 
 struct HistoryDocumentNamed;
 
+namespace Ui {
+namespace Text {
+class String;
+} // namespace Text
+} // namespace Ui
+
 namespace HistoryView {
 
 class Document
@@ -69,6 +75,8 @@ private:
 		int realDuration = 0;
 	};
 
+	[[nodiscard]] Ui::Text::String createCaption();
+
 	QSize countOptimalSize() override;
 	QSize countCurrentSize(int newWidth) override;
 
diff --git a/Telegram/SourceFiles/history/view/media/history_view_game.h b/Telegram/SourceFiles/history/view/media/history_view_game.h
index 4df20b73d..b6e30d17a 100644
--- a/Telegram/SourceFiles/history/view/media/history_view_game.h
+++ b/Telegram/SourceFiles/history/view/media/history_view_game.h
@@ -56,6 +56,9 @@ public:
 	void stopAnimation() override {
 		if (_attach) _attach->stopAnimation();
 	}
+	int checkAnimationCount() override {
+		return _attach ? _attach->checkAnimationCount() : 0;
+	}
 
 	not_null<GameData*> game() {
 		return _data;
diff --git a/Telegram/SourceFiles/history/view/media/history_view_gif.cpp b/Telegram/SourceFiles/history/view/media/history_view_gif.cpp
index ac60117be..228539d61 100644
--- a/Telegram/SourceFiles/history/view/media/history_view_gif.cpp
+++ b/Telegram/SourceFiles/history/view/media/history_view_gif.cpp
@@ -14,6 +14,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "media/audio/media_audio.h"
 #include "media/clip/media_clip_reader.h"
 #include "media/player/media_player_instance.h"
+#include "media/streaming/media_streaming_instance.h"
 #include "media/streaming/media_streaming_player.h"
 #include "media/view/media_view_playback_progress.h"
 #include "boxes/confirm_box.h"
@@ -22,10 +23,13 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "history/history.h"
 #include "history/view/history_view_element.h"
 #include "history/view/history_view_cursor_state.h"
+#include "history/view/media/history_view_media_common.h"
 #include "window/window_session_controller.h"
 #include "core/application.h" // Application::showDocument.
 #include "ui/image/image.h"
+#include "ui/grouped_layout.h"
 #include "data/data_session.h"
+#include "data/data_streaming.h"
 #include "data/data_document.h"
 #include "data/data_file_origin.h"
 #include "app.h"
@@ -35,6 +39,7 @@ namespace HistoryView {
 namespace {
 
 constexpr auto kMaxGifForwardedBarLines = 4;
+constexpr auto kUseNonBlurredThreshold = 160;
 
 int gifMaxStatusWidth(DocumentData *document) {
 	auto result = st::normalFont->width(formatDownloadText(document->size, document->size));
@@ -44,19 +49,57 @@ int gifMaxStatusWidth(DocumentData *document) {
 
 } // namespace
 
+struct Gif::Streamed {
+	Streamed(
+		std::shared_ptr<::Media::Streaming::Document> shared,
+		Fn<void()> waitingCallback);
+	::Media::Streaming::Instance instance;
+	::Media::Streaming::FrameRequest frozenRequest;
+	QImage frozenFrame;
+	QString frozenStatusText;
+};
+
+Gif::Streamed::Streamed(
+	std::shared_ptr<::Media::Streaming::Document> shared,
+	Fn<void()> waitingCallback)
+: instance(std::move(shared), std::move(waitingCallback)) {
+}
+
 Gif::Gif(
 	not_null<Element*> parent,
+	not_null<HistoryItem*> realParent,
 	not_null<DocumentData*> document)
-: File(parent, parent->data())
+: File(parent, realParent)
 , _data(document)
-, _caption(st::minPhotoSize - st::msgPadding.left() - st::msgPadding.right()) {
-	const auto item = parent->data();
-	setDocumentLinks(_data, item);
+, _caption(st::minPhotoSize - st::msgPadding.left() - st::msgPadding.right())
+, _downloadSize(formatSizeText(_data->size)) {
+	setDocumentLinks(_data, realParent);
 
 	setStatusSize(FileStatusSizeReady);
 
-	_caption = createCaption(item);
-	_data->loadThumbnail(item->fullId());
+	refreshCaption();
+	_data->loadThumbnail(realParent->fullId());
+}
+
+Gif::~Gif() {
+	if (_streamed) {
+		_data->owner().streaming().keepAlive(_data);
+		setStreamed(nullptr);
+	}
+}
+
+QSize Gif::sizeForAspectRatio() const {
+	// We use size only for aspect ratio and we want to have it
+	// as close to the thumbnail as possible.
+	//if (!_data->dimensions.isEmpty()) {
+	//	return _data->dimensions;
+	//}
+	if (const auto thumb = _data->thumbnail()) {
+		if (!thumb->size().isEmpty()) {
+			return thumb->size();
+		}
+	}
+	return { 1, 1 };
 }
 
 QSize Gif::countOptimalSize() {
@@ -67,17 +110,13 @@ QSize Gif::countOptimalSize() {
 			_parent->skipBlockWidth(),
 			_parent->skipBlockHeight());
 	}
-	if (_gif && _gif->state() == ::Media::Clip::State::Error) {
-		if (!_gif->autoplay()) {
-			Ui::show(Box<InformBox>(tr::lng_gif_error(tr::now)));
-		}
-		setClipReader(::Media::Clip::ReaderPointer::Bad());
-	}
 
 	const auto captionWithPaddings = _caption.maxWidth()
 			+ st::msgPadding.left()
 			+ st::msgPadding.right();
-	const auto maxSize = _data->isVideoMessage()
+	const auto maxSize = _data->isVideoFile()
+		? st::maxMediaSize
+		: _data->isVideoMessage()
 		? st::maxVideoMessageSize
 		: st::maxGifSize;
 	const auto size = style::ConvertScale(videoSize());
@@ -102,7 +141,7 @@ QSize Gif::countOptimalSize() {
 	auto maxWidth = qMax(tw, st::minPhotoSize);
 	auto minHeight = qMax(th, st::minPhotoSize);
 	accumulate_max(maxWidth, _parent->infoWidth() + 2 * (st::msgDateImgDelta + st::msgDateImgPadding.x()));
-	if (!currentReader() && !activeRoundPlayer()) {
+	if (!activeCurrentStreamed()) {
 		accumulate_max(maxWidth, gifMaxStatusWidth(_data) + 2 * (st::msgDateImgDelta + st::msgDateImgPadding.x()));
 	}
 	if (_parent->hasBubble()) {
@@ -135,7 +174,9 @@ QSize Gif::countCurrentSize(int newWidth) {
 	const auto captionWithPaddings = _caption.maxWidth()
 			+ st::msgPadding.left()
 			+ st::msgPadding.right();
-	const auto maxSize = _data->isVideoMessage()
+	const auto maxSize = _data->isVideoFile()
+		? st::maxMediaSize
+		: _data->isVideoMessage()
 		? st::maxVideoMessageSize
 		: st::maxGifSize;
 	const auto size = style::ConvertScale(videoSize());
@@ -166,34 +207,7 @@ QSize Gif::countCurrentSize(int newWidth) {
 	newWidth = qMax(tw, st::minPhotoSize);
 	auto newHeight = qMax(th, st::minPhotoSize);
 	accumulate_max(newWidth, _parent->infoWidth() + 2 * st::msgDateImgDelta + st::msgDateImgPadding.x());
-	const auto reader = activeRoundPlayer() ? nullptr : currentReader();
-	if (reader) {
-		const auto own = (reader->mode() == ::Media::Clip::Reader::Mode::Gif);
-		if (own && !reader->started()) {
-			auto isRound = _data->isVideoMessage();
-			auto inWebPage = (_parent->media() != this);
-			auto roundRadius = isRound
-				? ImageRoundRadius::Ellipse
-				: inWebPage
-				? ImageRoundRadius::Small
-				: ImageRoundRadius::Large;
-			auto roundCorners = (isRound || inWebPage)
-				? RectPart::AllCorners
-				: ((isBubbleTop()
-					? (RectPart::TopLeft | RectPart::TopRight)
-					: RectPart::None)
-				| ((isBubbleBottom() && _caption.isEmpty())
-					? (RectPart::BottomLeft | RectPart::BottomRight)
-					: RectPart::None));
-			reader->start(
-				_thumbw,
-				_thumbh,
-				newWidth,
-				newHeight,
-				roundRadius,
-				roundCorners);
-		}
-	} else {
+	if (!activeCurrentStreamed()) {
 		accumulate_max(newWidth, gifMaxStatusWidth(_data) + 2 * (st::msgDateImgDelta + st::msgDateImgPadding.x()));
 	}
 	if (_parent->hasBubble()) {
@@ -232,10 +246,8 @@ QSize Gif::countCurrentSize(int newWidth) {
 }
 
 QSize Gif::videoSize() const {
-	if (const auto player = activeRoundPlayer()) {
-		return player->videoSize();
-	} else if (const auto reader = currentReader()) {
-		return QSize(reader->width(), reader->height());
+	if (const auto streamed = activeCurrentStreamed()) {
+		return streamed->player().videoSize();
 	} else if (!_data->dimensions.isEmpty()) {
 		return _data->dimensions;
 	} else if (const auto thumbnail = _data->thumbnail()) {
@@ -245,26 +257,42 @@ QSize Gif::videoSize() const {
 	}
 }
 
+bool Gif::downloadInCorner() const {
+	return _data->isVideoFile()
+		&& (_data->loading() || !autoplayEnabled())
+		&& _data->canBeStreamed()
+		&& !_data->inappPlaybackFailed()
+		&& IsServerMsgId(_parent->data()->id);
+}
+
 bool Gif::autoplayEnabled() const {
-	return history()->session().settings().autoplayGifs();
+	return Data::AutoDownload::ShouldAutoPlay(
+		_data->session().settings().autoDownload(),
+		_realParent->history()->peer,
+		_data);
 }
 
 void Gif::draw(Painter &p, const QRect &r, TextSelection selection, crl::time ms) const {
 	if (width() < st::msgPadding.left() + st::msgPadding.right() + 1) return;
 
 	const auto item = _parent->data();
-	_data->automaticLoad(_realParent->fullId(), item);
-	auto loaded = _data->loaded();
-	auto displayLoading = (item->id < 0) || _data->displayLoading();
-	auto selected = (selection == FullSelection);
-
-	if (loaded
-		&& autoplayEnabled()
-		&& !_gif
-		&& !_gif.isBad()
-		&& !activeRoundPlayer()) {
-		_parent->delegate()->elementAnimationAutoplayAsync(_parent);
+	const auto displayLoading = item->isSending() || _data->displayLoading();
+	const auto selected = (selection == FullSelection);
+	const auto autoPaused = App::wnd()->sessionController()->isGifPausedAtLeastFor(Window::GifPauseReason::Any);
+	const auto cornerDownload = downloadInCorner();
+	const auto canBePlayed = _data->canBePlayed();
+	const auto autoplay = autoplayEnabled() && canBePlayed;
+	const auto activeRoundPlaying = activeRoundStreamed();
+	const auto startPlay = autoplay
+		&& !_streamed
+		&& !activeRoundPlaying;
+	if (startPlay) {
+		const_cast<Gif*>(this)->playAnimation(true);
+	} else {
+		checkStreamedIsStarted();
 	}
+	const auto streamingMode = _streamed || activeRoundPlaying || autoplay;
+	const auto activeOwnPlaying = activeOwnStreamed();
 
 	auto paintx = 0, painty = 0, paintw = width(), painth = height();
 	bool bubble = _parent->hasBubble();
@@ -275,18 +303,30 @@ void Gif::draw(Painter &p, const QRect &r, TextSelection selection, crl::time ms
 
 	const auto isRound = _data->isVideoMessage();
 	auto displayMute = false;
-	const auto player = activeRoundPlayer();
-	const auto reader = player ? nullptr : currentReader();
-	const auto animating = player || (reader && reader->started());
-
-	if ((!animating || item->id < 0) && displayLoading) {
+	const auto streamed = activeRoundPlaying
+		? activeRoundPlaying
+		: activeOwnPlaying
+		? &activeOwnPlaying->instance
+		: nullptr;
+	const auto streamedForWaiting = activeRoundPlaying
+		? activeRoundPlaying
+		: _streamed
+		? &_streamed->instance
+		: nullptr;
+
+	if (displayLoading
+		&& (!streamedForWaiting
+			|| item->isSending()
+			|| _data->uploading()
+			|| (cornerDownload && _data->loading()))) {
 		ensureAnimation();
 		if (!_animation->radial.animating()) {
 			_animation->radial.start(dataProgress());
 		}
 	}
 	updateStatusText();
-	const auto radial = isRadialAnimation();
+	const auto radial = isRadialAnimation()
+		|| (streamedForWaiting && streamedForWaiting->waitingShown());
 
 	if (bubble) {
 		if (!_caption.isEmpty()) {
@@ -317,24 +357,39 @@ void Gif::draw(Painter &p, const QRect &r, TextSelection selection, crl::time ms
 	auto roundRadius = isRound ? ImageRoundRadius::Ellipse : inWebPage ? ImageRoundRadius::Small : ImageRoundRadius::Large;
 	auto roundCorners = (isRound || inWebPage) ? RectPart::AllCorners : ((isBubbleTop() ? (RectPart::TopLeft | RectPart::TopRight) : RectPart::None)
 		| ((isBubbleBottom() && _caption.isEmpty()) ? (RectPart::BottomLeft | RectPart::BottomRight) : RectPart::None));
-	if (animating) {
-		auto paused = App::wnd()->sessionController()->isGifPausedAtLeastFor(Window::GifPauseReason::Any);
+	if (streamed) {
+		auto paused = autoPaused;
 		if (isRound) {
-			if (player) {
+			if (activeRoundStreamed()) {
 				paused = false;
 			} else {
 				displayMute = true;
 			}
 		}
-		if (player) {
-			auto request = ::Media::Streaming::FrameRequest();
-			request.outer = QSize(usew, painth) * cIntRetinaFactor();
-			request.resize = QSize(_thumbw, _thumbh) * cIntRetinaFactor();
-			request.corners = roundCorners;
-			request.radius = roundRadius;
-			p.drawImage(rthumb, player->frame(request));
+		auto request = ::Media::Streaming::FrameRequest();
+		request.outer = QSize(usew, painth) * cIntRetinaFactor();
+		request.resize = QSize(_thumbw, _thumbh) * cIntRetinaFactor();
+		request.corners = roundCorners;
+		request.radius = roundRadius;
+		if (!activeRoundPlaying && activeOwnPlaying->instance.playerLocked()) {
+			if (activeOwnPlaying->frozenFrame.isNull()) {
+				activeOwnPlaying->frozenRequest = request;
+				activeOwnPlaying->frozenFrame = streamed->frame(request);
+				activeOwnPlaying->frozenStatusText = _statusText;
+			} else if (activeOwnPlaying->frozenRequest != request) {
+				activeOwnPlaying->frozenRequest = request;
+				activeOwnPlaying->frozenFrame = streamed->frame(request);
+			}
+			p.drawImage(rthumb, activeOwnPlaying->frozenFrame);
 		} else {
-			p.drawPixmap(rthumb.topLeft(), reader->current(_thumbw, _thumbh, usew, painth, roundRadius, roundCorners, paused ? 0 : ms));
+			if (activeOwnPlaying) {
+				activeOwnPlaying->frozenFrame = QImage();
+				activeOwnPlaying->frozenStatusText = QString();
+			}
+			p.drawImage(rthumb, streamed->frame(request));
+			if (!paused) {
+				streamed->markFrameShown();
+			}
 		}
 
 		if (const auto playback = videoPlayback()) {
@@ -369,7 +424,12 @@ void Gif::draw(Painter &p, const QRect &r, TextSelection selection, crl::time ms
 			}
 			const auto normal = _data->thumbnail();
 			if (normal && normal->loaded()) {
-				p.drawPixmap(rthumb.topLeft(), normal->pixSingle(_realParent->fullId(), _thumbw, _thumbh, usew, painth, roundRadius, roundCorners));
+				if (normal->width() >= kUseNonBlurredThreshold
+					&& normal->height() >= kUseNonBlurredThreshold) {
+					p.drawPixmap(rthumb.topLeft(), normal->pixSingle(_realParent->fullId(), _thumbw, _thumbh, usew, painth, roundRadius, roundCorners));
+				} else {
+					p.drawPixmap(rthumb.topLeft(), normal->pixBlurredSingle(_realParent->fullId(), _thumbw, _thumbh, usew, painth, roundRadius, roundCorners));
+				}
 			} else if (const auto blurred = _data->thumbnailInline()) {
 				p.drawPixmap(rthumb.topLeft(), blurred->pixBlurredSingle(_realParent->fullId(), _thumbw, _thumbh, usew, painth, roundRadius, roundCorners));
 			} else if (!isRound) {
@@ -391,8 +451,16 @@ void Gif::draw(Painter &p, const QRect &r, TextSelection selection, crl::time ms
 		App::complexOverlayRect(p, rthumb, roundRadius, roundCorners);
 	}
 
-	if (radial || (!reader && !player && (_gif.isBad() || (!loaded && !_data->loading()) || !autoplayEnabled()))) {
-		auto radialOpacity = (radial && loaded && item->id > 0) ? _animation->radial.opacity() : 1.;
+	if (radial
+		|| (!streamingMode
+			&& ((!_data->loaded() && !_data->loading()) || !autoplay))) {
+		const auto radialOpacity = (item->isSending() || _data->uploading())
+			? 1.
+			: streamedForWaiting
+			? streamedForWaiting->waitingOpacity()
+			: (radial && _data->loaded())
+			? _animation->radial.opacity()
+			: 1.;
 		auto inner = QRect(rthumb.x() + (rthumb.width() - st::msgFileSize) / 2, rthumb.y() + (rthumb.height() - st::msgFileSize) / 2, st::msgFileSize, st::msgFileSize);
 		p.setPen(Qt::NoPen);
 		if (selected) {
@@ -412,11 +480,13 @@ void Gif::draw(Painter &p, const QRect &r, TextSelection selection, crl::time ms
 		}
 
 		p.setOpacity(radialOpacity);
-		auto icon = [&]() -> const style::icon * {
-			if (_data->loaded() && !radial) {
+		const auto icon = [&]() -> const style::icon * {
+			if (streamingMode && !_data->uploading()) {
+				return nullptr;
+			} else if ((_data->loaded() || canBePlayed) && (!radial || cornerDownload)) {
 				return &(selected ? st::historyFileThumbPlaySelected : st::historyFileThumbPlay);
 			} else if (radial || _data->loading()) {
-				if (item->id > 0 || _data->uploading()) {
+				if (!item->isSending() || _data->uploading()) {
 					return &(selected ? st::historyFileThumbCancelSelected : st::historyFileThumbCancel);
 				}
 				return nullptr;
@@ -426,21 +496,28 @@ void Gif::draw(Painter &p, const QRect &r, TextSelection selection, crl::time ms
 		if (icon) {
 			icon->paintInCenter(p, inner);
 		}
+		p.setOpacity(1);
 		if (radial) {
-			p.setOpacity(1);
 			QRect rinner(inner.marginsRemoved(QMargins(st::msgFileRadialLine, st::msgFileRadialLine, st::msgFileRadialLine, st::msgFileRadialLine)));
-			_animation->radial.draw(p, rinner, st::msgFileRadialLine, selected ? st::historyFileThumbRadialFgSelected : st::historyFileThumbRadialFg);
-		}
-
-		if (!isRound && (!animating || item->id < 0)) {
-			auto statusX = paintx + st::msgDateImgDelta + st::msgDateImgPadding.x();
-			auto statusY = painty + st::msgDateImgDelta + st::msgDateImgPadding.y();
-			auto statusW = st::normalFont->width(_statusText) + 2 * st::msgDateImgPadding.x();
-			auto statusH = st::normalFont->height + 2 * st::msgDateImgPadding.y();
-			App::roundRect(p, style::rtlrect(statusX - st::msgDateImgPadding.x(), statusY - st::msgDateImgPadding.y(), statusW, statusH, width()), selected ? st::msgDateImgBgSelected : st::msgDateImgBg, selected ? DateSelectedCorners : DateCorners);
-			p.setFont(st::normalFont);
-			p.setPen(st::msgDateImgFg);
-			p.drawTextLeft(statusX, statusY, width(), _statusText, statusW - 2 * st::msgDateImgPadding.x());
+			const auto fg = selected
+				? st::historyFileThumbRadialFgSelected
+				: st::historyFileThumbRadialFg;
+			if (streamedForWaiting && !_data->uploading()) {
+				Ui::InfiniteRadialAnimation::Draw(
+					p,
+					streamedForWaiting->waitingState(),
+					rinner.topLeft(),
+					rinner.size(),
+					width(),
+					fg,
+					st::msgFileRadialLine);
+			} else if (!cornerDownload) {
+				_animation->radial.draw(
+					p,
+					rinner,
+					st::msgFileRadialLine,
+					fg);
+			}
 		}
 	}
 	if (displayMute) {
@@ -452,6 +529,10 @@ void Gif::draw(Painter &p, const QRect &r, TextSelection selection, crl::time ms
 		(selected ? st::historyVideoMessageMuteSelected : st::historyVideoMessageMute).paintInCenter(p, muteRect);
 	}
 
+	if (!isRound) {
+		drawCornerStatus(p, selected, QPoint());
+	}
+
 	if (!inWebPage && isRound) {
 		auto mediaUnread = item->hasUnreadMediaFlag();
 		auto statusW = st::normalFont->width(_statusText) + 2 * st::msgDateImgPadding.x();
@@ -553,6 +634,72 @@ void Gif::draw(Painter &p, const QRect &r, TextSelection selection, crl::time ms
 	}
 }
 
+void Gif::drawCornerStatus(Painter &p, bool selected, QPoint position) const {
+	if (!needCornerStatusDisplay()) {
+		return;
+	}
+	const auto own = activeOwnStreamed();
+	const auto text = (own && !own->frozenStatusText.isEmpty())
+		? own->frozenStatusText
+		: _statusText;
+	const auto padding = st::msgDateImgPadding;
+	const auto radial = _animation && _animation->radial.animating();
+	const auto cornerDownload = downloadInCorner() && !_data->loaded() && !_data->loadedInMediaCache();
+	const auto cornerMute = _streamed && _data->isVideoFile() && !cornerDownload;
+	const auto addLeft = cornerDownload ? (st::historyVideoDownloadSize + 2 * padding.y()) : 0;
+	const auto addRight = cornerMute ? st::historyVideoMuteSize : 0;
+	const auto downloadWidth = cornerDownload ? st::normalFont->width(_downloadSize) : 0;
+	const auto statusW = std::max(downloadWidth, st::normalFont->width(text)) + 2 * padding.x() + addLeft + addRight;
+	const auto statusH = cornerDownload ? (st::historyVideoDownloadSize + 2 * padding.y()) : (st::normalFont->height + 2 * padding.y());
+	const auto statusX = position.x() + st::msgDateImgDelta + padding.x();
+	const auto statusY = position.y() + st::msgDateImgDelta + padding.y();
+	const auto around = style::rtlrect(statusX - padding.x(), statusY - padding.y(), statusW, statusH, width());
+	const auto statusTextTop = statusY + (cornerDownload ? (((statusH - 2 * st::normalFont->height) / 3)  - padding.y()) : 0);
+	App::roundRect(p, around, selected ? st::msgDateImgBgSelected : st::msgDateImgBg, selected ? DateSelectedCorners : DateCorners);
+	p.setFont(st::normalFont);
+	p.setPen(st::msgDateImgFg);
+	p.drawTextLeft(statusX + addLeft, statusTextTop, width(), text, statusW - 2 * padding.x());
+	if (cornerDownload) {
+		const auto downloadTextTop = statusY + st::normalFont->height + (2 * (statusH - 2 * st::normalFont->height) / 3)  - padding.y();
+		p.drawTextLeft(statusX + addLeft, downloadTextTop, width(), _downloadSize, statusW - 2 * padding.x());
+		const auto inner = QRect(statusX + padding.y() - padding.x(), statusY, st::historyVideoDownloadSize, st::historyVideoDownloadSize);
+		const auto icon = [&]() -> const style::icon * {
+			if (_data->loading()) {
+				return &(selected ? st::historyVideoCancelSelected : st::historyVideoCancel);
+			}
+			return &(selected ? st::historyVideoDownloadSelected : st::historyVideoDownload);
+		}();
+		if (icon) {
+			icon->paintInCenter(p, inner);
+		}
+		if (radial) {
+			QRect rinner(inner.marginsRemoved(QMargins(st::historyVideoRadialLine, st::historyVideoRadialLine, st::historyVideoRadialLine, st::historyVideoRadialLine)));
+			_animation->radial.draw(p, rinner, st::historyVideoRadialLine, selected ? st::historyFileThumbRadialFgSelected : st::historyFileThumbRadialFg);
+		}
+	} else if (cornerMute) {
+		(selected ? st::historyVideoMessageMuteSelected : st::historyVideoMessageMute).paint(p, statusX - padding.x() - padding.y() + statusW - addRight, statusY - padding.y() + (statusH - st::historyVideoMessageMute.height()) / 2, width());
+	}
+}
+
+TextState Gif::cornerStatusTextState(
+		QPoint point,
+		StateRequest request,
+		QPoint position) const {
+	auto result = TextState(_parent);
+	if (!needCornerStatusDisplay() || !downloadInCorner() || _data->loaded()) {
+		return result;
+	}
+	const auto padding = st::msgDateImgPadding;
+	const auto addWidth = st::historyVideoDownloadSize + 2 * padding.y() - padding.x();
+	const auto statusX = position.x() + st::msgDateImgDelta + padding.x();
+	const auto statusY = position.y() + st::msgDateImgDelta + padding.y();
+	const auto inner = QRect(statusX + padding.y() - padding.x(), statusY, st::historyVideoDownloadSize, st::historyVideoDownloadSize);
+	if (inner.contains(point)) {
+		result.link = _data->loading() ? _cancell : _savel;
+	}
+	return result;
+}
+
 TextState Gif::textState(QPoint point, StateRequest request) const {
 	auto result = TextState(_parent);
 
@@ -651,17 +798,22 @@ TextState Gif::textState(QPoint point, StateRequest request) const {
 			}
 		}
 	}
-	if (QRect(usex + paintx, painty, usew, painth).contains(point)) {
-		if (_data->uploading()) {
-			result.link = _cancell;
-		} else {
-			result.link = _data->loaded()
-				? _openl :
-				_data->loading()
-				? _cancell
-				: _savel;
+	if (!isRound) {
+		if (const auto state = cornerStatusTextState(point, request, QPoint()); state.link) {
+			return state;
 		}
 	}
+	if (QRect(usex + paintx, painty, usew, painth).contains(point)) {
+		result.link = _data->uploading()
+			? _cancell
+			: !IsServerMsgId(_realParent->id)
+			? nullptr
+			: (_data->loaded() || _data->canBePlayed())
+			? _openl
+			: _data->loading()
+			? _cancell
+			: _savel;
+	}
 	if (isRound || _caption.isEmpty()) {
 		auto fullRight = usex + paintx + usew;
 		auto fullBottom = painty + painth;
@@ -705,6 +857,225 @@ TextForMimeData Gif::selectedText(TextSelection selection) const {
 	return _caption.toTextForMimeData(selection);
 }
 
+bool Gif::fullFeaturedGrouped(RectParts sides) const {
+	return (sides & RectPart::Left) && (sides & RectPart::Right);
+}
+
+QSize Gif::sizeForGrouping() const {
+	return sizeForAspectRatio();
+}
+
+void Gif::drawGrouped(
+		Painter &p,
+		const QRect &clip,
+		TextSelection selection,
+		crl::time ms,
+		const QRect &geometry,
+		RectParts sides,
+		RectParts corners,
+		not_null<uint64*> cacheKey,
+		not_null<QPixmap*> cache) const {
+	const auto item = _parent->data();
+	const auto displayLoading = (item->id < 0) || _data->displayLoading();
+	const auto selected = (selection == FullSelection);
+	const auto autoPaused = App::wnd()->sessionController()->isGifPausedAtLeastFor(Window::GifPauseReason::Any);
+	const auto fullFeatured = fullFeaturedGrouped(sides);
+	const auto cornerDownload = fullFeatured && downloadInCorner();
+	const auto canBePlayed = _data->canBePlayed();
+	const auto autoplay = fullFeatured && autoplayEnabled() && canBePlayed;
+	const auto startPlay = autoplay && !_streamed;
+	if (startPlay) {
+		const_cast<Gif*>(this)->playAnimation(true);
+	} else {
+		checkStreamedIsStarted();
+	}
+	const auto streamingMode = _streamed || autoplay;
+	const auto activeOwnPlaying = activeOwnStreamed();
+
+	auto paintx = geometry.x(), painty = geometry.y(), paintw = geometry.width(), painth = geometry.height();
+
+	auto displayMute = false;
+	const auto streamed = activeOwnPlaying
+		? &activeOwnPlaying->instance
+		: nullptr;
+	const auto streamedForWaiting = _streamed
+		? &_streamed->instance
+		: nullptr;
+
+	if (displayLoading
+		&& (!streamedForWaiting
+			|| item->isSending()
+			|| _data->uploading()
+			|| (cornerDownload && _data->loading()))) {
+		ensureAnimation();
+		if (!_animation->radial.animating()) {
+			_animation->radial.start(dataProgress());
+		}
+	}
+	updateStatusText();
+	const auto radial = isRadialAnimation()
+		|| (streamedForWaiting && streamedForWaiting->waitingShown());
+
+	const auto roundRadius = ImageRoundRadius::Large;
+
+	if (streamed) {
+		const auto paused = autoPaused;
+		auto request = ::Media::Streaming::FrameRequest();
+		const auto original = sizeForAspectRatio();
+		const auto originalWidth = style::ConvertScale(original.width());
+		const auto originalHeight = style::ConvertScale(original.height());
+		const auto pixSize = Ui::GetImageScaleSizeForGeometry(
+			{ originalWidth, originalHeight },
+			{ geometry.width(), geometry.height() });
+		request.outer = geometry.size() * cIntRetinaFactor();
+		request.resize = pixSize * cIntRetinaFactor();
+		request.corners = corners;
+		request.radius = roundRadius;
+		if (activeOwnPlaying->instance.playerLocked()) {
+			if (activeOwnPlaying->frozenFrame.isNull()) {
+				activeOwnPlaying->frozenRequest = request;
+				activeOwnPlaying->frozenFrame = streamed->frame(request);
+				activeOwnPlaying->frozenStatusText = _statusText;
+			} else if (activeOwnPlaying->frozenRequest != request) {
+				activeOwnPlaying->frozenRequest = request;
+				activeOwnPlaying->frozenFrame = streamed->frame(request);
+			}
+			p.drawImage(geometry, activeOwnPlaying->frozenFrame);
+		} else {
+			if (activeOwnPlaying) {
+				activeOwnPlaying->frozenFrame = QImage();
+				activeOwnPlaying->frozenStatusText = QString();
+			}
+			p.drawImage(geometry, streamed->frame(request));
+			if (!paused) {
+				streamed->markFrameShown();
+			}
+		}
+	} else {
+		validateGroupedCache(geometry, corners, cacheKey, cache);
+		p.drawPixmap(geometry, *cache);
+	}
+
+	if (selected) {
+		App::complexOverlayRect(p, geometry, roundRadius, corners);
+	}
+
+	if (radial
+		|| (!streamingMode
+			&& ((!_data->loaded() && !_data->loading()) || !autoplay))) {
+		const auto radialOpacity = (item->isSending() || _data->uploading())
+			? 1.
+			: streamedForWaiting
+			? streamedForWaiting->waitingOpacity()
+			: (radial && _data->loaded())
+			? _animation->radial.opacity()
+			: 1.;
+		const auto radialSize = st::historyGroupRadialSize;
+		const auto inner = QRect(
+			geometry.x() + (geometry.width() - radialSize) / 2,
+			geometry.y() + (geometry.height() - radialSize) / 2,
+			radialSize,
+			radialSize);
+		p.setPen(Qt::NoPen);
+		if (selected) {
+			p.setBrush(st::msgDateImgBgSelected);
+		} else if (isThumbAnimation()) {
+			auto over = _animation->a_thumbOver.value(1.);
+			p.setBrush(anim::brush(st::msgDateImgBg, st::msgDateImgBgOver, over));
+		} else {
+			auto over = ClickHandler::showAsActive(_data->loading() ? _cancell : _savel);
+			p.setBrush(over ? st::msgDateImgBgOver : st::msgDateImgBg);
+		}
+		p.setOpacity(radialOpacity * p.opacity());
+
+		{
+			PainterHighQualityEnabler hq(p);
+			p.drawEllipse(inner);
+		}
+
+		p.setOpacity(radialOpacity);
+		const auto icon = [&]() -> const style::icon * {
+			if (_data->waitingForAlbum()) {
+				return &(selected ? st::historyFileThumbWaitingSelected : st::historyFileThumbWaiting);
+			} else if (streamingMode && !_data->uploading()) {
+				return nullptr;
+			} else if ((_data->loaded() || canBePlayed) && (!radial || cornerDownload)) {
+				return &(selected ? st::historyFileThumbPlaySelected : st::historyFileThumbPlay);
+			} else if (radial || _data->loading()) {
+				if (!item->isSending() || _data->uploading()) {
+					return &(selected ? st::historyFileThumbCancelSelected : st::historyFileThumbCancel);
+				}
+				return nullptr;
+			}
+			return &(selected ? st::historyFileThumbDownloadSelected : st::historyFileThumbDownload);
+		}();
+		const auto previous = [&]() -> const style::icon* {
+			if (_data->waitingForAlbum()) {
+				return &(selected ? st::historyFileThumbCancelSelected : st::historyFileThumbCancel);
+			}
+			return nullptr;
+		}();
+		if (icon) {
+			if (previous && radialOpacity > 0. && radialOpacity < 1.) {
+				PaintInterpolatedIcon(p, *icon, *previous, radialOpacity, inner);
+			} else {
+				icon->paintInCenter(p, inner);
+			}
+		}
+		p.setOpacity(1);
+		if (radial) {
+			const auto line = st::historyGroupRadialLine;
+			const auto rinner = inner.marginsRemoved({ line, line, line, line });
+			const auto fg = selected
+				? st::historyFileThumbRadialFgSelected
+				: st::historyFileThumbRadialFg;
+			if (streamedForWaiting && !_data->uploading()) {
+				Ui::InfiniteRadialAnimation::Draw(
+					p,
+					streamedForWaiting->waitingState(),
+					rinner.topLeft(),
+					rinner.size(),
+					width(),
+					fg,
+					st::msgFileRadialLine);
+			} else if (!cornerDownload) {
+				_animation->radial.draw(
+					p,
+					rinner,
+					st::msgFileRadialLine,
+					fg);
+			}
+		}
+	}
+	if (fullFeatured) {
+		drawCornerStatus(p, selected, geometry.topLeft());
+	}
+}
+
+TextState Gif::getStateGrouped(
+		const QRect &geometry,
+		RectParts sides,
+		QPoint point,
+		StateRequest request) const {
+	if (!geometry.contains(point)) {
+		return {};
+	}
+	if (fullFeaturedGrouped(sides)) {
+		if (const auto state = cornerStatusTextState(point, request, geometry.topLeft()); state.link) {
+			return state;
+		}
+	}
+	return TextState(_parent, _data->uploading()
+		? _cancell
+		: !IsServerMsgId(_realParent->id)
+		? nullptr
+		: (_data->loaded() || _data->canBePlayed())
+		? _openl
+		: _data->loading()
+		? _cancell
+		: _savel);
+}
+
 bool Gif::uploading() const {
 	return _data->uploading();
 }
@@ -744,16 +1115,79 @@ bool Gif::isSeparateRoundVideo() const {
 		&& !_parent->hasBubble();
 }
 
+void Gif::validateGroupedCache(
+		const QRect &geometry,
+		RectParts corners,
+		not_null<uint64*> cacheKey,
+		not_null<QPixmap*> cache) const {
+	using Option = Images::Option;
+	const auto good = _data->goodThumbnail();
+	const auto useGood = (good && good->loaded());
+	const auto thumb = _data->thumbnail();
+	const auto useThumb = (thumb && thumb->loaded());
+	const auto image = useGood
+		? good
+		: useThumb
+		? thumb
+		: _data->thumbnailInline();
+	const auto blur = !useGood
+		&& (!useThumb
+			|| (thumb->width() < kUseNonBlurredThreshold)
+			|| (thumb->height() < kUseNonBlurredThreshold));
+	if (good && !useGood) {
+		good->load({});
+	}
+
+	const auto loadLevel = useGood ? 3 : useThumb ? 2 : image ? 1 : 0;
+	const auto width = geometry.width();
+	const auto height = geometry.height();
+	const auto options = Option::Smooth
+		| Option::RoundedLarge
+		| (blur ? Option(0) : Option::Blurred)
+		| ((corners & RectPart::TopLeft) ? Option::RoundedTopLeft : Option::None)
+		| ((corners & RectPart::TopRight) ? Option::RoundedTopRight : Option::None)
+		| ((corners & RectPart::BottomLeft) ? Option::RoundedBottomLeft : Option::None)
+		| ((corners & RectPart::BottomRight) ? Option::RoundedBottomRight : Option::None);
+	const auto key = (uint64(width) << 48)
+		| (uint64(height) << 32)
+		| (uint64(options) << 16)
+		| (uint64(loadLevel));
+	if (*cacheKey == key) {
+		return;
+	}
+
+	const auto original = sizeForAspectRatio();
+	const auto originalWidth = style::ConvertScale(original.width());
+	const auto originalHeight = style::ConvertScale(original.height());
+	const auto pixSize = Ui::GetImageScaleSizeForGeometry(
+		{ originalWidth, originalHeight },
+		{ width, height });
+	const auto pixWidth = pixSize.width() * cIntRetinaFactor();
+	const auto pixHeight = pixSize.height() * cIntRetinaFactor();
+
+	*cacheKey = key;
+	*cache = (image ? image : Image::BlankMedia().get())->pixNoCache(
+		_realParent->fullId(),
+		pixWidth,
+		pixHeight,
+		options,
+		width,
+		height);
+}
+
 void Gif::setStatusSize(int newSize) const {
-	if (_data->isVideoMessage()) {
+	if (newSize < 0) {
 		_statusSize = newSize;
-		if (newSize < 0) {
-			_statusText = formatDurationText(-newSize - 1);
-		} else {
-			_statusText = formatDurationText(_data->getDuration());
-		}
+		_statusText = formatDurationText(-newSize - 1);
+	} else if (_data->isVideoMessage()) {
+		_statusSize = newSize;
+		_statusText = formatDurationText(_data->getDuration());
 	} else {
-		File::setStatusSize(newSize, _data->size, -2, 0);
+		File::setStatusSize(
+			newSize,
+			_data->size,
+			_data->isVideoFile() ? _data->getDuration() : -2,
+			0);
 	}
 }
 
@@ -765,27 +1199,30 @@ void Gif::updateStatusText() const {
 		statusSize = FileStatusSizeFailed;
 	} else if (_data->uploading()) {
 		statusSize = _data->uploadingData->offset;
-	} else if (_data->loading()) {
+	} else if (!downloadInCorner() && _data->loading()) {
 		statusSize = _data->loadOffset();
-	} else if (_data->loaded()) {
+	} else if (_data->loaded() || _data->canBePlayed()) {
 		statusSize = FileStatusSizeLoaded;
-		if (const auto video = activeRoundPlayer()) {
-			const auto state = video->prepareLegacyState();
-			if (state.length) {
-				auto position = int64(0);
-				if (::Media::Player::IsStoppedAtEnd(state.state)) {
-					position = state.length;
-				} else if (!::Media::Player::IsStoppedOrStopping(state.state)) {
-					position = state.position;
-				}
-				statusSize = -1 - int((state.length - position) / state.frequency + 1);
-			} else {
-				statusSize = -1 - _data->getDuration();
-			}
-		}
 	} else {
 		statusSize = FileStatusSizeReady;
 	}
+	const auto round = activeRoundStreamed();
+	const auto own = activeOwnStreamed();
+	if (round || (own && own->frozenFrame.isNull() && _data->isVideoFile())) {
+		const auto streamed = round ? round : &own->instance;
+		const auto state = streamed->player().prepareLegacyState();
+		if (state.length) {
+			auto position = int64(0);
+			if (::Media::Player::IsStoppedAtEnd(state.state)) {
+				position = state.length;
+			} else if (!::Media::Player::IsStoppedOrStopping(state.state)) {
+				position = state.position;
+			}
+			statusSize = -1 - int((state.length - position) / state.frequency + 1);
+		} else {
+			statusSize = -1 - _data->getDuration();
+		}
+	}
 	if (statusSize != _statusSize) {
 		setStatusSize(statusSize);
 	}
@@ -800,14 +1237,33 @@ QString Gif::additionalInfoString() const {
 }
 
 bool Gif::isReadyForOpen() const {
-	return _data->loaded();
+	return true;
 }
 
 void Gif::parentTextUpdated() {
-	_caption = (_parent->media() == this)
-		? createCaption(_parent->data())
-		: Ui::Text::String();
-	history()->owner().requestViewResize(_parent);
+	if (_parent->media() == this) {
+		refreshCaption();
+		history()->owner().requestViewResize(_parent);
+	}
+}
+
+void Gif::refreshParentId(not_null<HistoryItem*> realParent) {
+	if (_parent->media() == this) {
+		refreshCaption();
+	}
+}
+
+void Gif::refreshCaption() {
+	const auto timestampLinksDuration = _data->isVideoFile()
+		? _data->getDuration()
+		: 0;
+	const auto timestampLinkBase = timestampLinksDuration
+		? DocumentTimestampLinkBase(_data, _realParent->fullId())
+		: QString();
+	_caption = createCaption(
+			_parent->data(),
+			timestampLinksDuration,
+			timestampLinkBase);
 }
 
 int Gif::additionalWidth(const HistoryMessageVia *via, const HistoryMessageReply *reply, const HistoryMessageForwarded *forwarded) const {
@@ -823,98 +1279,162 @@ int Gif::additionalWidth(const HistoryMessageVia *via, const HistoryMessageReply
 	return result;
 }
 
-::Media::Streaming::Player *Gif::activeRoundPlayer() const {
-	return ::Media::Player::instance()->roundVideoPlayer(_parent->data());
+::Media::Streaming::Instance *Gif::activeRoundStreamed() const {
+	return ::Media::Player::instance()->roundVideoStreamed(_parent->data());
 }
 
-::Media::Clip::Reader *Gif::currentReader() const {
-	return (_gif && _gif->ready()) ? _gif.get() : nullptr;
+Gif::Streamed *Gif::activeOwnStreamed() const {
+	return (_streamed
+		&& _streamed->instance.player().ready()
+		&& !_streamed->instance.player().videoSize().isEmpty())
+		? _streamed.get()
+		: nullptr;
 }
 
-::Media::View::PlaybackProgress *Gif::videoPlayback() const {
-	return ::Media::Player::instance()->roundVideoPlayback(_parent->data());
-}
-
-void Gif::clipCallback(::Media::Clip::Notification notification) {
-	using namespace ::Media::Clip;
-
-	const auto reader = _gif.get();
-	if (!reader) {
-		return;
+::Media::Streaming::Instance *Gif::activeCurrentStreamed() const {
+	if (const auto streamed = activeRoundStreamed()) {
+		return streamed;
+	} else if (const auto owned = activeOwnStreamed()) {
+		return &owned->instance;
 	}
-	switch (notification) {
-	case NotificationReinit: {
-		auto stopped = false;
-		if (reader->autoPausedGif()) {
-			auto amVisible = false;
-			history()->owner().queryItemVisibility().notify(
-				{ _parent->data(), &amVisible },
-				true);
-			if (!amVisible) { // Stop animation if it is not visible.
-				stopAnimation();
-				stopped = true;
-			}
-		}
-		if (!stopped) {
-			history()->owner().requestViewResize(_parent);
-		}
-	} break;
+	return nullptr;
+}
 
-	case NotificationRepaint: {
-		if (!reader->currentDisplayed()) {
-			history()->owner().requestViewRepaint(_parent);
-		}
-	} break;
-	}
+::Media::View::PlaybackProgress *Gif::videoPlayback() const {
+	return ::Media::Player::instance()->roundVideoPlayback(_parent->data());
 }
 
 void Gif::playAnimation(bool autoplay) {
 	if (_data->isVideoMessage() && !autoplay) {
 		return;
-	} else if (_gif && autoplay) {
+	} else if (_streamed && autoplay) {
 		return;
-	} else if (_gif && autoplayEnabled()) {
+	} else if ((_streamed && autoplayEnabled())
+		|| (!autoplay && _data->isVideoFile())) {
 		Core::App().showDocument(_data, _parent->data());
 		return;
 	}
-	using Mode = ::Media::Clip::Reader::Mode;
-	if (_gif) {
+	if (_streamed) {
 		stopAnimation();
-	} else if (_data->loaded(DocumentData::FilePathResolve::Checked)) {
+	} else if (_data->canBePlayed()) {
 		if (!autoplayEnabled()) {
-			history()->owner().stopAutoplayAnimations();
-		}
-		setClipReader(::Media::Clip::MakeReader(
-			_data,
-			_parent->data()->fullId(),
-			[=](auto notification) { clipCallback(notification); },
-			Mode::Gif));
-		if (_gif && autoplay) {
-			_gif->setAutoplay();
+			history()->owner().checkPlayingVideoFiles();
 		}
+		createStreamedPlayer();
 	}
 }
 
-void Gif::stopAnimation() {
-	if (_gif) {
-		clearClipReader();
-		history()->owner().requestViewResize(_parent);
-		_data->unload();
+void Gif::createStreamedPlayer() {
+	auto shared = _data->owner().streaming().sharedDocument(
+		_data,
+		_realParent->fullId());
+	if (!shared) {
+		return;
 	}
+	setStreamed(std::make_unique<Streamed>(
+		std::move(shared),
+		[=] { repaintStreamedContent(); }));
+
+	_streamed->instance.player().updates(
+	) | rpl::start_with_next_error([=](::Media::Streaming::Update &&update) {
+		handleStreamingUpdate(std::move(update));
+	}, [=](::Media::Streaming::Error &&error) {
+		handleStreamingError(std::move(error));
+	}, _streamed->instance.lifetime());
+
+	if (_streamed->instance.ready()) {
+		streamingReady(base::duplicate(_streamed->instance.info()));
+	}
+	checkStreamedIsStarted();
+}
+
+void Gif::startStreamedPlayer() const {
+	Expects(_streamed != nullptr);
+
+	auto options = ::Media::Streaming::PlaybackOptions();
+	options.audioId = AudioMsgId(_data, _realParent->fullId());
+	options.waitForMarkAsShown = true;
+	//if (!_streamed->withSound) {
+	options.mode = ::Media::Streaming::Mode::Video;
+	options.loop = true;
+	//}
+	_streamed->instance.play(options);
 }
 
-void Gif::setClipReader(::Media::Clip::ReaderPointer gif) {
-	if (_gif) {
-		history()->owner().unregisterAutoplayAnimation(_gif.get());
+void Gif::checkStreamedIsStarted() const {
+	if (!_streamed || _streamed->instance.playerLocked()) {
+		return;
+	} else if (_streamed->instance.paused()) {
+		_streamed->instance.resume();
 	}
-	_gif = std::move(gif);
-	if (_gif) {
-		history()->owner().registerAutoplayAnimation(_gif.get(), _parent);
+	if (!_streamed->instance.active() && !_streamed->instance.failed()) {
+		startStreamedPlayer();
 	}
 }
 
-Gif::~Gif() {
-	clearClipReader();
+void Gif::setStreamed(std::unique_ptr<Streamed> value) {
+	const auto removed = (_streamed && !value);
+	const auto set = (!_streamed && value);
+	if (removed) {
+		history()->owner().unregisterPlayingVideoFile(_parent);
+	}
+	_streamed = std::move(value);
+	if (set) {
+		history()->owner().registerPlayingVideoFile(_parent);
+	}
+}
+
+void Gif::handleStreamingUpdate(::Media::Streaming::Update &&update) {
+	using namespace ::Media::Streaming;
+
+	update.data.match([&](Information &update) {
+		streamingReady(std::move(update));
+	}, [&](const PreloadedVideo &update) {
+	}, [&](const UpdateVideo &update) {
+		repaintStreamedContent();
+	}, [&](const PreloadedAudio &update) {
+	}, [&](const UpdateAudio &update) {
+	}, [&](const WaitingForData &update) {
+	}, [&](MutedByOther) {
+	}, [&](Finished) {
+	});
+}
+
+void Gif::handleStreamingError(::Media::Streaming::Error &&error) {
+}
+
+void Gif::repaintStreamedContent() {
+	const auto own = activeOwnStreamed();
+	if (own && !own->frozenFrame.isNull()) {
+		return;
+	}
+	if (App::wnd()->sessionController()->isGifPausedAtLeastFor(Window::GifPauseReason::Any)
+		&& !activeRoundStreamed()) {
+		return;
+	}
+	history()->owner().requestViewRepaint(_parent);
+}
+
+void Gif::streamingReady(::Media::Streaming::Information &&info) {
+	history()->owner().requestViewResize(_parent);
+}
+
+void Gif::stopAnimation() {
+	if (_streamed) {
+		setStreamed(nullptr);
+		history()->owner().requestViewResize(_parent);
+		_data->unload();
+	}
+}
+
+int Gif::checkAnimationCount() {
+	if (!_streamed) {
+		return 0;
+	} else if (autoplayEnabled()) {
+		return 1;
+	}
+	stopAnimation();
+	return 0;
 }
 
 float64 Gif::dataProgress() const {
@@ -934,7 +1454,14 @@ bool Gif::dataLoaded() const {
 }
 
 bool Gif::needInfoDisplay() const {
-	return (_parent->data()->id < 0 || _parent->isUnderCursor());
+	return _parent->data()->isSending()
+		|| _data->uploading()
+		|| _parent->isUnderCursor();
+}
+
+bool Gif::needCornerStatusDisplay() const {
+	return _data->isVideoFile()
+		|| needInfoDisplay();
 }
 
 } // namespace HistoryView
diff --git a/Telegram/SourceFiles/history/view/media/history_view_gif.h b/Telegram/SourceFiles/history/view/media/history_view_gif.h
index 9bceaf872..141fb6bdd 100644
--- a/Telegram/SourceFiles/history/view/media/history_view_gif.h
+++ b/Telegram/SourceFiles/history/view/media/history_view_gif.h
@@ -8,11 +8,12 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #pragma once
 
 #include "history/view/media/history_view_file.h"
-#include "media/clip/media_clip_reader.h"
+#include "media/streaming/media_streaming_common.h"
 
 struct HistoryMessageVia;
 struct HistoryMessageReply;
 struct HistoryMessageForwarded;
+class Painter;
 
 namespace Media {
 namespace View {
@@ -22,17 +23,22 @@ class PlaybackProgress;
 
 namespace Media {
 namespace Streaming {
-class Player;
+class Instance;
+struct Update;
+struct Information;
+enum class Error;
 } // namespace Streaming
 } // namespace Media
 
 namespace HistoryView {
 
-class Gif : public File {
+class Gif final : public File {
 public:
 	Gif(
 		not_null<Element*> parent,
+		not_null<HistoryItem*> realParent,
 		not_null<DocumentData*> document);
+	~Gif();
 
 	void draw(Painter &p, const QRect &r, TextSelection selection, crl::time ms) const override;
 	TextState textState(QPoint point, StateRequest request) const override;
@@ -57,7 +63,26 @@ public:
 		return _data;
 	}
 
+	bool fullFeaturedGrouped(RectParts sides) const;
+	QSize sizeForGrouping() const override;
+	void drawGrouped(
+		Painter &p,
+		const QRect &clip,
+		TextSelection selection,
+		crl::time ms,
+		const QRect &geometry,
+		RectParts sides,
+		RectParts corners,
+		not_null<uint64*> cacheKey,
+		not_null<QPixmap*> cache) const override;
+	TextState getStateGrouped(
+		const QRect &geometry,
+		RectParts sides,
+		QPoint point,
+		StateRequest request) const override;
+
 	void stopAnimation() override;
+	int checkAnimationCount() override;
 
 	TextWithEntities getCaption() const override {
 		return _caption.toTextWithEntities();
@@ -75,46 +100,74 @@ public:
 
 	void parentTextUpdated() override;
 
-	~Gif();
+	void unloadHeavyPart() override {
+		stopAnimation();
+	}
+
+	void refreshParentId(not_null<HistoryItem*> realParent) override;
+
+private:
+	struct Streamed;
 
-protected:
 	float64 dataProgress() const override;
 	bool dataFinished() const override;
 	bool dataLoaded() const override;
 
-	void setClipReader(::Media::Clip::ReaderPointer gif);
-	void clearClipReader() {
-		setClipReader(::Media::Clip::ReaderPointer());
-	}
+	void refreshCaption();
 
-private:
 	[[nodiscard]] bool autoplayEnabled() const;
+
 	void playAnimation(bool autoplay) override;
 	QSize countOptimalSize() override;
 	QSize countCurrentSize(int newWidth) override;
 	QSize videoSize() const;
-	::Media::Streaming::Player *activeRoundPlayer() const;
-	::Media::Clip::Reader *currentReader() const;
+	::Media::Streaming::Instance *activeRoundStreamed() const;
+	Streamed *activeOwnStreamed() const;
+	::Media::Streaming::Instance *activeCurrentStreamed() const;
 	::Media::View::PlaybackProgress *videoPlayback() const;
-	void clipCallback(::Media::Clip::Notification notification);
 
-	bool needInfoDisplay() const;
-	int additionalWidth(
+	void createStreamedPlayer();
+	void checkStreamedIsStarted() const;
+	void startStreamedPlayer() const;
+	void setStreamed(std::unique_ptr<Streamed> value);
+	void handleStreamingUpdate(::Media::Streaming::Update &&update);
+	void handleStreamingError(::Media::Streaming::Error &&error);
+	void streamingReady(::Media::Streaming::Information &&info);
+	void repaintStreamedContent();
+
+	[[nodiscard]] bool needInfoDisplay() const;
+	[[nodiscard]] bool needCornerStatusDisplay() const;
+	[[nodiscard]] int additionalWidth(
 		const HistoryMessageVia *via,
 		const HistoryMessageReply *reply,
 		const HistoryMessageForwarded *forwarded) const;
-	int additionalWidth() const;
-	QString mediaTypeString() const;
-	bool isSeparateRoundVideo() const;
+	[[nodiscard]] int additionalWidth() const;
+	[[nodiscard]] QString mediaTypeString() const;
+	[[nodiscard]] bool isSeparateRoundVideo() const;
+
+	void validateGroupedCache(
+		const QRect &geometry,
+		RectParts corners,
+		not_null<uint64*> cacheKey,
+		not_null<QPixmap*> cache) const;
+	void setStatusSize(int newSize) const;
+	void updateStatusText() const;
+	[[nodiscard]] QSize sizeForAspectRatio() const;
+
+	[[nodiscard]] bool downloadInCorner() const;
+	void drawCornerStatus(Painter &p, bool selected, QPoint position) const;
+	[[nodiscard]] TextState cornerStatusTextState(
+		QPoint point,
+		StateRequest request,
+		QPoint position) const;
 
 	not_null<DocumentData*> _data;
 	int _thumbw = 1;
 	int _thumbh = 1;
 	Ui::Text::String _caption;
-	::Media::Clip::ReaderPointer _gif;
+	std::unique_ptr<Streamed> _streamed;
 
-	void setStatusSize(int newSize) const;
-	void updateStatusText() const;
+	QString _downloadSize;
 
 };
 
diff --git a/Telegram/SourceFiles/history/view/media/history_view_media.cpp b/Telegram/SourceFiles/history/view/media/history_view_media.cpp
index 5d2a9cc41..fac775f8b 100644
--- a/Telegram/SourceFiles/history/view/media/history_view_media.cpp
+++ b/Telegram/SourceFiles/history/view/media/history_view_media.cpp
@@ -11,10 +11,98 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "history/view/history_view_element.h"
 #include "history/view/history_view_cursor_state.h"
 #include "storage/storage_shared_media.h"
+#include "data/data_document.h"
 #include "ui/text_options.h"
 #include "styles/style_history.h"
 
 namespace HistoryView {
+namespace {
+
+[[nodiscard]] TimeId TimeFromMatch(
+		const QStringRef &hours,
+		const QStringRef &minutes1,
+		const QStringRef &minutes2,
+		const QStringRef &seconds) {
+	auto ok1 = true;
+	auto ok2 = true;
+	auto ok3 = true;
+	auto minutes = minutes1.toString();
+	minutes += minutes2;
+	const auto result = (hours.isEmpty() ? 0 : hours.toInt(&ok1)) * 3600
+		+ minutes.toInt(&ok2) * 60
+		+ seconds.toInt(&ok3);
+	return (ok1 && ok2 && ok3) ? result : -1;
+}
+
+} // namespace
+
+QString DocumentTimestampLinkBase(
+		not_null<DocumentData*> document,
+		FullMsgId context) {
+	return QString(
+		"doc%1_%2_%3"
+	).arg(document->id).arg(context.channel).arg(context.msg);
+}
+
+TextWithEntities AddTimestampLinks(
+		TextWithEntities text,
+		TimeId duration,
+		const QString &base) {
+	static const auto expression = QRegularExpression(
+		"(?<![^\\s])(?:(?:(\\d{1,2}):)?(\\d))?(\\d):(\\d\\d)(?![^\\s])");
+	const auto &string = text.text;
+	auto offset = 0;
+	while (true) {
+		const auto m = expression.match(string, offset);
+		if (!m.hasMatch()) {
+			break;
+		}
+
+		const auto from = m.capturedStart();
+		const auto till = from + m.capturedLength();
+		offset = till;
+
+		const auto time = TimeFromMatch(
+			m.capturedRef(1),
+			m.capturedRef(2),
+			m.capturedRef(3),
+			m.capturedRef(4));
+		if (time < 0 || time > duration) {
+			continue;
+		}
+
+		auto &entities = text.entities;
+		const auto i = ranges::lower_bound(
+			entities,
+			from,
+			std::less<>(),
+			&EntityInText::offset);
+		if (i != entities.end() && i->offset() < till) {
+			continue;
+		}
+
+		const auto intersects = [&](const EntityInText &entity) {
+			return entity.offset() + entity.length() > from;
+		};
+		auto j = std::make_reverse_iterator(i);
+		const auto e = std::make_reverse_iterator(entities.begin());
+		if (std::find_if(j, e, intersects) != e) {
+			continue;
+		}
+
+		entities.insert(
+			i,
+			EntityInText(
+				EntityType::CustomUrl,
+				from,
+				till - from,
+				("internal:media_timestamp?base="
+					+ base
+					+ "&t="
+					+ QString::number(time))));
+	}
+	return text;
+}
 
 Storage::SharedMediaTypesMask Media::sharedMediaTypes() const {
 	return {};
@@ -32,7 +120,12 @@ QSize Media::countCurrentSize(int newWidth) {
 	return QSize(qMin(newWidth, maxWidth()), minHeight());
 }
 
-Ui::Text::String Media::createCaption(not_null<HistoryItem*> item) const {
+Ui::Text::String Media::createCaption(
+		not_null<HistoryItem*> item,
+		TimeId timestampLinksDuration,
+		const QString &timestampLinkBase) const {
+	Expects(timestampLinksDuration >= 0);
+
 	if (item->emptyText()) {
 		return {};
 	}
@@ -42,7 +135,12 @@ Ui::Text::String Media::createCaption(not_null<HistoryItem*> item) const {
 	auto result = Ui::Text::String(minResizeWidth);
 	result.setMarkedText(
 		st::messageTextStyle,
-		item->originalText(),
+		(timestampLinksDuration
+			? AddTimestampLinks(
+				item->originalText(),
+				timestampLinksDuration,
+				timestampLinkBase)
+			: item->originalText()),
 		Ui::ItemTextOptions(item));
 	if (const auto width = _parent->skipBlockWidth()) {
 		result.updateSkipBlock(width, _parent->skipBlockHeight());
@@ -66,6 +164,7 @@ PointState Media::pointState(QPoint point) const {
 
 TextState Media::getStateGrouped(
 		const QRect &geometry,
+		RectParts sides,
 		QPoint point,
 		StateRequest request) const {
 	Unexpected("Grouping method call.");
diff --git a/Telegram/SourceFiles/history/view/media/history_view_media.h b/Telegram/SourceFiles/history/view/media/history_view_media.h
index 29a260113..96335abae 100644
--- a/Telegram/SourceFiles/history/view/media/history_view_media.h
+++ b/Telegram/SourceFiles/history/view/media/history_view_media.h
@@ -40,6 +40,14 @@ enum class MediaInBubbleState {
 	Bottom,
 };
 
+[[nodiscard]] QString DocumentTimestampLinkBase(
+	not_null<DocumentData*> document,
+	FullMsgId context);
+[[nodiscard]] TextWithEntities AddTimestampLinks(
+	TextWithEntities text,
+	TimeId duration,
+	const QString &base);
+
 class Media : public Object {
 public:
 	Media(not_null<Element*> parent) : _parent(parent) {
@@ -133,6 +141,9 @@ public:
 	}
 	virtual void clearStickerLoopPlayed() {
 	}
+	virtual int checkAnimationCount() {
+		return 0;
+	}
 
 	[[nodiscard]] virtual QSize sizeForGrouping() const {
 		Unexpected("Grouping method call.");
@@ -143,6 +154,7 @@ public:
 			TextSelection selection,
 			crl::time ms,
 			const QRect &geometry,
+			RectParts sides,
 			RectParts corners,
 			not_null<uint64*> cacheKey,
 			not_null<QPixmap*> cache) const {
@@ -150,6 +162,7 @@ public:
 	}
 	[[nodiscard]] virtual TextState getStateGrouped(
 		const QRect &geometry,
+		RectParts sides,
 		QPoint point,
 		StateRequest request) const;
 
@@ -232,8 +245,11 @@ public:
 	virtual ~Media() = default;
 
 protected:
-	QSize countCurrentSize(int newWidth) override;
-	Ui::Text::String createCaption(not_null<HistoryItem*> item) const;
+	[[nodiscard]] QSize countCurrentSize(int newWidth) override;
+	[[nodiscard]] Ui::Text::String createCaption(
+		not_null<HistoryItem*> item,
+		TimeId timestampLinksDuration = 0,
+		const QString &timestampLinkBase = QString()) const;
 
 	virtual void playAnimation(bool autoplay) {
 	}
diff --git a/Telegram/SourceFiles/history/view/media/history_view_media_common.cpp b/Telegram/SourceFiles/history/view/media/history_view_media_common.cpp
index 8d16dcee4..090d94246 100644
--- a/Telegram/SourceFiles/history/view/media/history_view_media_common.cpp
+++ b/Telegram/SourceFiles/history/view/media/history_view_media_common.cpp
@@ -15,7 +15,6 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "history/view/media/history_view_gif.h"
 #include "history/view/media/history_view_document.h"
 #include "history/view/media/history_view_sticker.h"
-#include "history/view/media/history_view_video.h"
 #include "history/view/media/history_view_theme_document.h"
 #include "styles/style_history.h"
 
@@ -73,13 +72,8 @@ std::unique_ptr<Media> CreateAttach(
 			return std::make_unique<UnwrappedMedia>(
 				parent,
 				std::make_unique<Sticker>(parent, document));
-		} else if (document->isAnimation()) {
-			return std::make_unique<Gif>(parent, document);
-		} else if (document->isVideoFile()) {
-			return std::make_unique<Video>(
-				parent,
-				parent->data(),
-				document);
+		} else if (document->isAnimation() || document->isVideoFile()) {
+			return std::make_unique<Gif>(parent, parent->data(), document);
 		} else if (document->isWallPaper() || document->isTheme()) {
 			return std::make_unique<ThemeDocument>(
 				parent,
diff --git a/Telegram/SourceFiles/history/view/media/history_view_media_grouped.cpp b/Telegram/SourceFiles/history/view/media/history_view_media_grouped.cpp
index 97c08e380..244fd5abf 100644
--- a/Telegram/SourceFiles/history/view/media/history_view_media_grouped.cpp
+++ b/Telegram/SourceFiles/history/view/media/history_view_media_grouped.cpp
@@ -171,6 +171,17 @@ void GroupedMedia::refreshParentId(
 	}
 }
 
+RectParts GroupedMedia::cornersFromSides(RectParts sides) const {
+	auto result = Ui::GetCornersFromSides(sides);
+	if (!isBubbleTop()) {
+		result &= ~(RectPart::TopLeft | RectPart::TopRight);
+	}
+	if (!isBubbleBottom() || !_caption.isEmpty()) {
+		result &= ~(RectPart::BottomLeft | RectPart::BottomRight);
+	}
+	return result;
+}
+
 void GroupedMedia::draw(
 		Painter &p,
 		const QRect &clip,
@@ -183,20 +194,14 @@ void GroupedMedia::draw(
 			: IsGroupItemSelection(selection, i)
 			? FullSelection
 			: TextSelection();
-		auto corners = Ui::GetCornersFromSides(part.sides);
-		if (!isBubbleTop()) {
-			corners &= ~(RectPart::TopLeft | RectPart::TopRight);
-		}
-		if (!isBubbleBottom() || !_caption.isEmpty()) {
-			corners &= ~(RectPart::BottomLeft | RectPart::BottomRight);
-		}
 		part.content->drawGrouped(
 			p,
 			clip,
 			partSelection,
 			ms,
 			part.geometry,
-			corners,
+			part.sides,
+			cornersFromSides(part.sides),
 			&part.cacheKey,
 			&part.cache);
 	}
@@ -232,6 +237,7 @@ TextState GroupedMedia::getPartState(
 		if (part.geometry.contains(point)) {
 			auto result = part.content->getStateGrouped(
 				part.geometry,
+				part.sides,
 				point,
 				request);
 			result.itemId = part.item->fullId();
@@ -413,6 +419,26 @@ void GroupedMedia::updateNeedBubbleState() {
 	_needBubble = computeNeedBubble();
 }
 
+void GroupedMedia::stopAnimation() {
+	for (auto &part : _parts) {
+		part.content->stopAnimation();
+	}
+}
+
+int GroupedMedia::checkAnimationCount() {
+	auto result = 0;
+	for (auto &part : _parts) {
+		result += part.content->checkAnimationCount();
+	}
+	return result;
+}
+
+void GroupedMedia::unloadHeavyPart() {
+	for (auto &part : _parts) {
+		part.content->unloadHeavyPart();
+	}
+}
+
 void GroupedMedia::parentTextUpdated() {
 	history()->owner().requestViewResize(_parent);
 }
diff --git a/Telegram/SourceFiles/history/view/media/history_view_media_grouped.h b/Telegram/SourceFiles/history/view/media/history_view_media_grouped.h
index b5cdc9478..c042f9ac4 100644
--- a/Telegram/SourceFiles/history/view/media/history_view_media_grouped.h
+++ b/Telegram/SourceFiles/history/view/media/history_view_media_grouped.h
@@ -86,6 +86,10 @@ public:
 		return true;
 	}
 
+	void stopAnimation() override;
+	int checkAnimationCount() override;
+	void unloadHeavyPart() override;
+
 	void parentTextUpdated() override;
 
 private:
@@ -121,6 +125,8 @@ private:
 		QPoint point,
 		StateRequest request) const;
 
+	[[nodiscard]] RectParts cornersFromSides(RectParts sides) const;
+
 	Ui::Text::String _caption;
 	std::vector<Part> _parts;
 	bool _needBubble = false;
diff --git a/Telegram/SourceFiles/history/view/media/history_view_photo.cpp b/Telegram/SourceFiles/history/view/media/history_view_photo.cpp
index 01d6c47e2..8e226f33a 100644
--- a/Telegram/SourceFiles/history/view/media/history_view_photo.cpp
+++ b/Telegram/SourceFiles/history/view/media/history_view_photo.cpp
@@ -370,6 +370,7 @@ void Photo::drawGrouped(
 		TextSelection selection,
 		crl::time ms,
 		const QRect &geometry,
+		RectParts sides,
 		RectParts corners,
 		not_null<uint64*> cacheKey,
 		not_null<QPixmap*> cache) const {
@@ -491,6 +492,7 @@ void Photo::drawGrouped(
 
 TextState Photo::getStateGrouped(
 		const QRect &geometry,
+		RectParts sides,
 		QPoint point,
 		StateRequest request) const {
 	if (!geometry.contains(point)) {
diff --git a/Telegram/SourceFiles/history/view/media/history_view_photo.h b/Telegram/SourceFiles/history/view/media/history_view_photo.h
index 6bb23681d..fd9295b90 100644
--- a/Telegram/SourceFiles/history/view/media/history_view_photo.h
+++ b/Telegram/SourceFiles/history/view/media/history_view_photo.h
@@ -51,11 +51,13 @@ public:
 		TextSelection selection,
 		crl::time ms,
 		const QRect &geometry,
+		RectParts sides,
 		RectParts corners,
 		not_null<uint64*> cacheKey,
 		not_null<QPixmap*> cache) const override;
 	TextState getStateGrouped(
 		const QRect &geometry,
+		RectParts sides,
 		QPoint point,
 		StateRequest request) const override;
 
diff --git a/Telegram/SourceFiles/history/view/media/history_view_poll.cpp b/Telegram/SourceFiles/history/view/media/history_view_poll.cpp
index d095ad661..afabb10c7 100644
--- a/Telegram/SourceFiles/history/view/media/history_view_poll.cpp
+++ b/Telegram/SourceFiles/history/view/media/history_view_poll.cpp
@@ -302,10 +302,12 @@ void Poll::updateTexts() {
 	const auto willStartAnimation = checkAnimationStart();
 
 	if (_question.toString() != _poll->question) {
+		auto options = Ui::WebpageTextTitleOptions();
+		options.maxw = options.maxh = 0;
 		_question.setText(
 			st::historyPollQuestionStyle,
 			_poll->question,
-			Ui::WebpageTextTitleOptions());
+			options);
 	}
 	if (_closed != _poll->closed || _subtitle.isEmpty()) {
 		_closed = _poll->closed;
diff --git a/Telegram/SourceFiles/history/view/media/history_view_sticker.cpp b/Telegram/SourceFiles/history/view/media/history_view_sticker.cpp
index abddf9047..76b210a8f 100644
--- a/Telegram/SourceFiles/history/view/media/history_view_sticker.cpp
+++ b/Telegram/SourceFiles/history/view/media/history_view_sticker.cpp
@@ -18,6 +18,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "ui/image/image.h"
 #include "ui/emoji_config.h"
 #include "main/main_session.h"
+#include "main/main_account.h"
 #include "main/main_app_config.h"
 #include "mainwindow.h" // App::wnd()->sessionController.
 #include "window/window_session_controller.h" // isGifPausedAtLeastFor.
@@ -31,7 +32,9 @@ namespace HistoryView {
 namespace {
 
 double GetEmojiStickerZoom(not_null<Main::Session*> session) {
-	return session->appConfig().get<double>("emojies_animated_zoom", 0.625);
+	return session->account().appConfig().get<double>(
+		"emojies_animated_zoom",
+		0.625);
 }
 
 } // namespace
diff --git a/Telegram/SourceFiles/history/view/media/history_view_video.cpp b/Telegram/SourceFiles/history/view/media/history_view_video.cpp
deleted file mode 100644
index bcae354fc..000000000
--- a/Telegram/SourceFiles/history/view/media/history_view_video.cpp
+++ /dev/null
@@ -1,656 +0,0 @@
-/*
-This file is part of Telegram Desktop,
-the official desktop application for the Telegram messaging service.
-
-For license and copyright information please follow this link:
-https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
-*/
-#include "history/view/media/history_view_video.h"
-
-#include "history/view/media/history_view_media_common.h"
-#include "layout.h"
-#include "history/history_item_components.h"
-#include "history/history_item.h"
-#include "history/history.h"
-#include "history/view/history_view_element.h"
-#include "history/view/history_view_cursor_state.h"
-#include "ui/image/image.h"
-#include "ui/grouped_layout.h"
-#include "data/data_session.h"
-#include "data/data_document.h"
-#include "data/data_file_origin.h"
-#include "mainwidget.h"
-#include "app.h"
-#include "styles/style_history.h"
-
-namespace HistoryView {
-
-Video::Video(
-	not_null<Element*> parent,
-	not_null<HistoryItem*> realParent,
-	not_null<DocumentData*> document)
-: File(parent, realParent)
-, _data(document)
-, _thumbw(1)
-, _caption(st::minPhotoSize - st::msgPadding.left() - st::msgPadding.right()) {
-	_caption = createCaption(realParent);
-
-	setDocumentLinks(_data, realParent);
-
-	setStatusSize(FileStatusSizeReady);
-	_downloadSize = formatSizeText(_data->size);
-
-	_data->loadThumbnail(realParent->fullId());
-}
-
-QSize Video::sizeForAspectRatio() const {
-	// We use size only for aspect ratio and we want to have it
-	// as close to the thumbnail as possible.
-	//if (!_data->dimensions.isEmpty()) {
-	//	return _data->dimensions;
-	//}
-	if (const auto thumb = _data->thumbnail()) {
-		if (!thumb->size().isEmpty()) {
-			return thumb->size();
-		}
-	}
-	return { 1, 1 };
-}
-
-QSize Video::countOptimalDimensions() const {
-	const auto captionWithPaddings = _caption.maxWidth()
-			+ st::msgPadding.left()
-			+ st::msgPadding.right();
-	auto inWebPage = (_parent->media() != this);
-	const auto desired = style::ConvertScale(_data->dimensions);
-	const auto size = desired.isEmpty() ? sizeForAspectRatio() : desired;
-	auto tw = size.width();
-	auto th = size.height();
-	if (!tw || !th) {
-		tw = th = 1;
-	} else if ((!cAdaptiveBaloons() || (captionWithPaddings <= st::maxMediaSize && !inWebPage)) && tw >= th && tw > st::maxMediaSize) {
-		th = qRound((st::maxMediaSize / float64(tw)) * th);
-		tw = st::maxMediaSize;
-	} else if (cAdaptiveBaloons() && tw >= th && captionWithPaddings > st::maxMediaSize && tw > captionWithPaddings) {
-		th = qRound((captionWithPaddings / float64(tw)) * th);
-		tw = captionWithPaddings;
-	} else if (tw < th && th > st::maxMediaSize) {
-		tw = qRound((st::maxMediaSize / float64(th)) * tw);
-		th = st::maxMediaSize;
-	} else if ((tw < st::msgVideoSize.width())
-		&& (tw * st::msgVideoSize.height()
-			>= th * st::msgVideoSize.width())) {
-		th = qRound((st::msgVideoSize.width() / float64(tw)) * th);
-		tw = st::msgVideoSize.width();
-	} else if ((th < st::msgVideoSize.height())
-		&& (tw * st::msgVideoSize.height()
-			< th * st::msgVideoSize.width())) {
-		tw = qRound((st::msgVideoSize.height() / float64(th)) * tw);
-		th = st::msgVideoSize.height();
-	}
-	return QSize(tw, th);
-}
-
-QSize Video::countOptimalSize() {
-	if (_parent->media() != this) {
-		_caption = Ui::Text::String();
-	} else if (_caption.hasSkipBlock()) {
-		_caption.updateSkipBlock(
-			_parent->skipBlockWidth(),
-			_parent->skipBlockHeight());
-	}
-
-	const auto size = countOptimalDimensions();
-	const auto tw = size.width();
-	const auto th = size.height();
-	_thumbw = qMax(tw, 1);
-	_thumbh = qMax(th, 1);
-
-	auto minWidth = qMax(st::minVideoSize, _parent->infoWidth() + 2 * (st::msgDateImgDelta + st::msgDateImgPadding.x()));
-	minWidth = qMax(minWidth, documentMaxStatusWidth(_data) + 2 * (st::msgDateImgDelta + st::msgDateImgPadding.x()));
-	auto maxWidth = qMax(_thumbw, minWidth);
-	auto minHeight = qMax(th, st::minVideoSize);
-	if (_parent->hasBubble() && !_caption.isEmpty()) {
-		if (cAdaptiveBaloons()) {
-			maxWidth = qMax(maxWidth, _caption.maxWidth() + st::msgPadding.left() + st::msgPadding.right());
-		}
-		const auto captionw = maxWidth
-			- st::msgPadding.left()
-			- st::msgPadding.right();
-		minHeight += st::mediaCaptionSkip + _caption.countHeight(captionw);
-		if (isBubbleBottom()) {
-			minHeight += st::msgPadding.bottom();
-		}
-	}
-	return { maxWidth, minHeight };
-}
-
-QSize Video::countCurrentSize(int newWidth) {
-	auto availableWidth = newWidth;
-
-	const auto size = countOptimalDimensions();
-	auto tw = size.width();
-	auto th = size.height();
-	if (newWidth < tw) {
-		th = qRound((newWidth / float64(tw)) * th);
-		tw = newWidth;
-	}
-
-	_thumbw = qMax(tw, 1);
-	_thumbh = qMax(th, 1);
-	auto minWidth = qMax(st::minPhotoSize, _parent->infoWidth() + 2 * (st::msgDateImgDelta + st::msgDateImgPadding.x()));
-	minWidth = qMax(minWidth, documentMaxStatusWidth(_data) + 2 * (st::msgDateImgDelta + st::msgDateImgPadding.x()));
-	newWidth = qMax(_thumbw, minWidth);
-	auto newHeight = qMax(th, st::minPhotoSize);
-	if (_parent->hasBubble() && !_caption.isEmpty()) {
-		if (cAdaptiveBaloons()) {
-			newWidth = qMax(newWidth, _caption.maxWidth() + st::msgPadding.left() + st::msgPadding.right());
-			newWidth = qMin(newWidth, availableWidth);
-		}
-		const auto captionw = newWidth
-			- st::msgPadding.left()
-			- st::msgPadding.right();
-		newHeight += st::mediaCaptionSkip + _caption.countHeight(captionw);
-		if (isBubbleBottom()) {
-			newHeight += st::msgPadding.bottom();
-		}
-	}
-	return { newWidth, newHeight };
-}
-
-bool Video::downloadInCorner() const {
-	return _data->canBeStreamed()
-		&& !_data->inappPlaybackFailed()
-		&& IsServerMsgId(_parent->data()->id);
-}
-
-void Video::draw(Painter &p, const QRect &r, TextSelection selection, crl::time ms) const {
-	if (width() < st::msgPadding.left() + st::msgPadding.right() + 1) return;
-
-	_data->automaticLoad(_realParent->fullId(), _parent->data());
-	bool loaded = _data->loaded(), displayLoading = _data->displayLoading();
-	bool selected = (selection == FullSelection);
-
-	auto paintx = 0, painty = 0, paintw = width(), painth = height();
-	bool bubble = _parent->hasBubble();
-	const auto cornerDownload = downloadInCorner();
-
-	int captionw = paintw - st::msgPadding.left() - st::msgPadding.right();
-
-	if (displayLoading) {
-		ensureAnimation();
-		if (!_animation->radial.animating()) {
-			_animation->radial.start(_data->progress());
-		}
-	}
-	updateStatusText();
-	const auto radial = isRadialAnimation();
-
-	if (bubble) {
-		if (!_caption.isEmpty()) {
-			painth -= st::mediaCaptionSkip + _caption.countHeight(captionw);
-			if (isBubbleBottom()) {
-				painth -= st::msgPadding.bottom();
-			}
-		}
-	} else {
-		App::roundShadow(p, 0, 0, paintw, painth, selected ? st::msgInShadowSelected : st::msgInShadow, selected ? InSelectedShadowCorners : InShadowCorners);
-	}
-
-	auto inWebPage = (_parent->media() != this);
-	auto roundRadius = inWebPage ? ImageRoundRadius::Small : ImageRoundRadius::Large;
-	auto roundCorners = inWebPage ? RectPart::AllCorners : ((isBubbleTop() ? (RectPart::TopLeft | RectPart::TopRight) : RectPart::None)
-		| ((isBubbleBottom() && _caption.isEmpty()) ? (RectPart::BottomLeft | RectPart::BottomRight) : RectPart::None));
-	QRect rthumb(style::rtlrect(paintx, painty, paintw, painth, width()));
-
-	const auto good = _data->goodThumbnail();
-	if (good && good->loaded()) {
-		p.drawPixmap(rthumb.topLeft(), good->pixSingle({}, _thumbw, _thumbh, paintw, painth, roundRadius, roundCorners));
-	} else {
-		if (good) {
-			good->load({});
-		}
-		const auto normal = _data->thumbnail();
-		if (normal && normal->loaded()) {
-			p.drawPixmap(rthumb.topLeft(), normal->pixSingle(_realParent->fullId(), _thumbw, _thumbh, paintw, painth, roundRadius, roundCorners));
-		} else if (const auto blurred = _data->thumbnailInline()) {
-			p.drawPixmap(rthumb.topLeft(), blurred->pixBlurredSingle(_realParent->fullId(), _thumbw, _thumbh, paintw, painth, roundRadius, roundCorners));
-		} else {
-			const auto roundTop = (roundCorners & RectPart::TopLeft);
-			const auto roundBottom = (roundCorners & RectPart::BottomLeft);
-			const auto margin = inWebPage
-				? st::buttonRadius
-				: st::historyMessageRadius;
-			const auto parts = roundCorners
-				| RectPart::NoTopBottom
-				| (roundTop ? RectPart::Top : RectPart::None)
-				| (roundBottom ? RectPart::Bottom : RectPart::None);
-			App::roundRect(p, rthumb.marginsAdded({ 0, roundTop ? 0 : margin, 0, roundBottom ? 0 : margin }), st::imageBg, roundRadius, parts);
-		}
-	}
-	if (selected) {
-		App::complexOverlayRect(p, rthumb, roundRadius, roundCorners);
-	}
-
-	QRect inner(rthumb.x() + (rthumb.width() - st::msgFileSize) / 2, rthumb.y() + (rthumb.height() - st::msgFileSize) / 2, st::msgFileSize, st::msgFileSize);
-	p.setPen(Qt::NoPen);
-	if (selected) {
-		p.setBrush(st::msgDateImgBgSelected);
-	} else if (isThumbAnimation()) {
-		auto over = _animation->a_thumbOver.value(1.);
-		p.setBrush(anim::brush(st::msgDateImgBg, st::msgDateImgBgOver, over));
-	} else {
-		bool over = ClickHandler::showAsActive((_data->loading() || _data->uploading()) ? _cancell : _savel);
-		p.setBrush(over ? st::msgDateImgBgOver : st::msgDateImgBg);
-	}
-
-	{
-		PainterHighQualityEnabler hq(p);
-		p.drawEllipse(inner);
-	}
-
-	const auto icon = [&]() -> const style::icon * {
-		if (!cornerDownload && (_data->loading() || _data->uploading())) {
-			return &(selected ? st::historyFileThumbCancelSelected : st::historyFileThumbCancel);
-		} else if (!IsServerMsgId(_parent->data()->id)) {
-			return nullptr;
-		} else if (loaded || _data->canBePlayed()) {
-			return &(selected ? st::historyFileThumbPlaySelected : st::historyFileThumbPlay);
-		}
-		return &(selected ? st::historyFileThumbDownloadSelected : st::historyFileThumbDownload);
-	}();
-	if (icon) {
-		icon->paintInCenter(p, inner);
-	}
-	if (radial && !cornerDownload) {
-		QRect rinner(inner.marginsRemoved(QMargins(st::msgFileRadialLine, st::msgFileRadialLine, st::msgFileRadialLine, st::msgFileRadialLine)));
-		_animation->radial.draw(p, rinner, st::msgFileRadialLine, selected ? st::historyFileThumbRadialFgSelected : st::historyFileThumbRadialFg);
-	}
-
-	drawCornerStatus(p, selected);
-
-	// date
-	if (!_caption.isEmpty()) {
-		auto outbg = _parent->hasOutLayout();
-		p.setPen(outbg ? (selected ? st::historyTextOutFgSelected : st::historyTextOutFg) : (selected ? st::historyTextInFgSelected : st::historyTextInFg));
-		_caption.draw(p, st::msgPadding.left(), painty + painth + st::mediaCaptionSkip, captionw, style::al_left, 0, -1, selection);
-	} else if (_parent->media() == this) {
-		auto fullRight = paintx + paintw, fullBottom = painty + painth;
-		_parent->drawInfo(p, fullRight, fullBottom, 2 * paintx + paintw, selected, InfoDisplayType::Image);
-		if (!bubble && _parent->displayRightAction()) {
-			auto fastShareLeft = (fullRight + st::historyFastShareLeft);
-			auto fastShareTop = (fullBottom - st::historyFastShareBottom - st::historyFastShareSize);
-			_parent->drawRightAction(p, fastShareLeft, fastShareTop, 2 * paintx + paintw);
-		}
-	}
-}
-
-void Video::drawCornerStatus(Painter &p, bool selected) const {
-	const auto padding = st::msgDateImgPadding;
-	const auto radial = _animation && _animation->radial.animating();
-	const auto cornerDownload = downloadInCorner() && !_data->loaded() && !_data->loadedInMediaCache();
-	const auto addWidth = cornerDownload ? (st::historyVideoDownloadSize + 2 * padding.y()) : 0;
-	const auto downloadWidth = cornerDownload ? st::normalFont->width(_downloadSize) : 0;
-	const auto statusW = std::max(downloadWidth, st::normalFont->width(_statusText)) + 2 * padding.x() + addWidth;
-	const auto statusH = cornerDownload ? (st::historyVideoDownloadSize + 2 * padding.y()) : (st::normalFont->height + 2 * padding.y());
-	const auto statusX = st::msgDateImgDelta + padding.x();
-	const auto statusY = st::msgDateImgDelta + padding.y();
-	const auto around = style::rtlrect(statusX - padding.x(), statusY - padding.y(), statusW, statusH, width());
-	const auto statusTextTop = statusY + (cornerDownload ? (((statusH - 2 * st::normalFont->height) / 3)  - padding.y()) : 0);
-	App::roundRect(p, around, selected ? st::msgDateImgBgSelected : st::msgDateImgBg, selected ? DateSelectedCorners : DateCorners);
-	p.setFont(st::normalFont);
-	p.setPen(st::msgDateImgFg);
-	p.drawTextLeft(statusX + addWidth, statusTextTop, width(), _statusText, statusW - 2 * padding.x());
-	if (cornerDownload) {
-		const auto downloadTextTop = statusY + st::normalFont->height + (2 * (statusH - 2 * st::normalFont->height) / 3)  - padding.y();
-		p.drawTextLeft(statusX + addWidth, downloadTextTop, width(), _downloadSize, statusW - 2 * padding.x());
-		const auto inner = QRect(statusX + padding.y() - padding.x(), statusY, st::historyVideoDownloadSize, st::historyVideoDownloadSize);
-		const auto icon = [&]() -> const style::icon * {
-			if (_data->loading()) {
-				return &(selected ? st::historyVideoCancelSelected : st::historyVideoCancel);
-			}
-			return &(selected ? st::historyVideoDownloadSelected : st::historyVideoDownload);
-		}();
-		if (icon) {
-			icon->paintInCenter(p, inner);
-		}
-		if (radial) {
-			QRect rinner(inner.marginsRemoved(QMargins(st::historyVideoRadialLine, st::historyVideoRadialLine, st::historyVideoRadialLine, st::historyVideoRadialLine)));
-			_animation->radial.draw(p, rinner, st::historyVideoRadialLine, selected ? st::historyFileThumbRadialFgSelected : st::historyFileThumbRadialFg);
-		}
-	}
-}
-
-TextState Video::cornerStatusTextState(
-		QPoint point,
-		StateRequest request) const {
-	auto result = TextState(_parent);
-	if (!downloadInCorner() || _data->loaded()) {
-		return result;
-	}
-	const auto padding = st::msgDateImgPadding;
-	const auto addWidth = st::historyVideoDownloadSize + 2 * padding.y() - padding.x();
-	const auto statusX = st::msgDateImgDelta + padding.x(), statusY = st::msgDateImgDelta + padding.y();
-	const auto inner = QRect(statusX + padding.y() - padding.x(), statusY, st::historyVideoDownloadSize, st::historyVideoDownloadSize);
-	if (inner.contains(point)) {
-		result.link = _data->loading() ? _cancell : _savel;
-	}
-	return result;
-}
-
-TextState Video::textState(QPoint point, StateRequest request) const {
-	if (width() < st::msgPadding.left() + st::msgPadding.right() + 1) {
-		return {};
-	}
-
-	auto result = TextState(_parent);
-
-	auto paintx = 0, painty = 0, paintw = width(), painth = height();
-	bool bubble = _parent->hasBubble();
-
-	if (bubble && !_caption.isEmpty()) {
-		const auto captionw = paintw
-			- st::msgPadding.left()
-			- st::msgPadding.right();
-		painth -= _caption.countHeight(captionw);
-		if (isBubbleBottom()) {
-			painth -= st::msgPadding.bottom();
-		}
-		if (QRect(st::msgPadding.left(), painth, captionw, height() - painth).contains(point)) {
-			result = TextState(_parent, _caption.getState(
-				point - QPoint(st::msgPadding.left(), painth),
-				captionw,
-				request.forText()));
-		}
-		painth -= st::mediaCaptionSkip;
-	}
-	if (const auto state = cornerStatusTextState(point, request); state.link) {
-		return state;
-	}
-	if (QRect(paintx, painty, paintw, painth).contains(point)) {
-		if (!downloadInCorner() && (_data->loading() || _data->uploading())) {
-			result.link = _cancell;
-		} else if (!IsServerMsgId(_parent->data()->id)) {
-		} else if (_data->loaded() || _data->canBePlayed()) {
-			result.link = _openl;
-		} else {
-			result.link = _savel;
-		}
-	}
-	if (_caption.isEmpty() && _parent->media() == this) {
-		auto fullRight = paintx + paintw;
-		auto fullBottom = painty + painth;
-		if (_parent->pointInTime(fullRight, fullBottom, point, InfoDisplayType::Image)) {
-			result.cursor = CursorState::Date;
-		}
-		if (!bubble && _parent->displayRightAction()) {
-			auto fastShareLeft = (fullRight + st::historyFastShareLeft);
-			auto fastShareTop = (fullBottom - st::historyFastShareBottom - st::historyFastShareSize);
-			if (QRect(fastShareLeft, fastShareTop, st::historyFastShareSize, st::historyFastShareSize).contains(point)) {
-				result.link = _parent->rightActionLink();
-			}
-		}
-	}
-	return result;
-}
-
-QSize Video::sizeForGrouping() const {
-	return sizeForAspectRatio();
-}
-
-void Video::drawGrouped(
-		Painter &p,
-		const QRect &clip,
-		TextSelection selection,
-		crl::time ms,
-		const QRect &geometry,
-		RectParts corners,
-		not_null<uint64*> cacheKey,
-		not_null<QPixmap*> cache) const {
-	_data->automaticLoad(_realParent->fullId(), _parent->data());
-
-	validateGroupedCache(geometry, corners, cacheKey, cache);
-
-	const auto selected = (selection == FullSelection);
-	const auto loaded = _data->loaded();
-	const auto displayLoading = _data->displayLoading();
-	const auto bubble = _parent->hasBubble();
-
-	if (displayLoading) {
-		ensureAnimation();
-		if (!_animation->radial.animating()) {
-			_animation->radial.start(_data->progress());
-		}
-	}
-	const auto radial = isRadialAnimation();
-
-	if (!bubble) {
-//		App::roundShadow(p, 0, 0, paintw, painth, selected ? st::msgInShadowSelected : st::msgInShadow, selected ? InSelectedShadowCorners : InShadowCorners);
-	}
-	const auto animms = _parent->delegate()->elementHighlightTime(_parent);
-	const auto realId = _realParent->id;
-	const auto mainWidget = App::main();
-	const auto highlightedRealId = mainWidget->highlightedOriginalId();
-	if (realId != highlightedRealId
-		&& animms 
-		&& animms < st::activeFadeInDuration + st::activeFadeOutDuration) {
-		const auto dt = (animms <= st::activeFadeInDuration)
-			? ((animms / float64(st::activeFadeInDuration)))
-			: (1. - (animms - st::activeFadeInDuration)
-				/ float64(st::activeFadeOutDuration));
-		const auto o = p.opacity();
-		p.setOpacity(o - dt * 0.8);
-		p.drawPixmap(geometry.topLeft(), *cache);
-		p.setOpacity(o);
-	} else {
-		p.drawPixmap(geometry.topLeft(), *cache);
-	}
-	if (selected) {
-		const auto roundRadius = ImageRoundRadius::Large;
-		App::complexOverlayRect(p, geometry, roundRadius, corners);
-	}
-
-	const auto radialOpacity = radial
-		? _animation->radial.opacity()
-		: 1.;
-	const auto backOpacity = (loaded && !_data->uploading())
-		? radialOpacity
-		: 1.;
-	const auto radialSize = st::historyGroupRadialSize;
-	const auto inner = QRect(
-		geometry.x() + (geometry.width() - radialSize) / 2,
-		geometry.y() + (geometry.height() - radialSize) / 2,
-		radialSize,
-		radialSize);
-	p.setPen(Qt::NoPen);
-	if (selected) {
-		p.setBrush(st::msgDateImgBgSelected);
-	} else if (isThumbAnimation()) {
-		auto over = _animation->a_thumbOver.value(1.);
-		p.setBrush(anim::brush(st::msgDateImgBg, st::msgDateImgBgOver, over));
-	} else {
-		auto over = ClickHandler::showAsActive(_data->loading() ? _cancell : _savel);
-		p.setBrush(over ? st::msgDateImgBgOver : st::msgDateImgBg);
-	}
-
-	p.setOpacity(backOpacity * p.opacity());
-
-	{
-		PainterHighQualityEnabler hq(p);
-		p.drawEllipse(inner);
-	}
-
-	auto icon = [&]() -> const style::icon * {
-		if (_data->waitingForAlbum()) {
-			return &(selected ? st::historyFileThumbWaitingSelected : st::historyFileThumbWaiting);
-		} else if (_data->loading() || _data->uploading()) {
-			return &(selected ? st::historyFileThumbCancelSelected : st::historyFileThumbCancel);
-		} else if (!IsServerMsgId(_realParent->id)) {
-			return nullptr;
-		} else if (loaded || _data->canBePlayed()) {
-			return &(selected ? st::historyFileThumbPlaySelected : st::historyFileThumbPlay);
-		}
-		return &(selected ? st::historyFileThumbDownloadSelected : st::historyFileThumbDownload);
-	}();
-	const auto previous = [&]() -> const style::icon* {
-		if (_data->waitingForAlbum()) {
-			return &(selected ? st::historyFileThumbCancelSelected : st::historyFileThumbCancel);
-		}
-		return nullptr;
-	}();
-	p.setOpacity(backOpacity);
-	if (icon) {
-		if (previous && radialOpacity > 0. && radialOpacity < 1.) {
-			PaintInterpolatedIcon(p, *icon, *previous, radialOpacity, inner);
-		} else {
-			icon->paintInCenter(p, inner);
-		}
-	}
-	p.setOpacity(1);
-	if (radial) {
-		const auto line = st::historyGroupRadialLine;
-		const auto rinner = inner.marginsRemoved({ line, line, line, line });
-		const auto color = selected
-			? st::historyFileThumbRadialFgSelected
-			: st::historyFileThumbRadialFg;
-		_animation->radial.draw(p, rinner, line, color);
-	}
-}
-
-TextState Video::getStateGrouped(
-		const QRect &geometry,
-		QPoint point,
-		StateRequest request) const {
-	if (!geometry.contains(point)) {
-		return {};
-	}
-	return TextState(_parent, (_data->loading() || _data->uploading())
-		? _cancell
-		: !IsServerMsgId(_realParent->id)
-		? nullptr
-		: (_data->loaded() || _data->canBePlayed())
-		? _openl
-		: _savel);
-}
-
-bool Video::uploading() const {
-	return _data->uploading();
-}
-
-float64 Video::dataProgress() const {
-	return _data->progress();
-}
-
-bool Video::dataFinished() const {
-	return !_data->loading()
-		&& (!_data->uploading() || _data->waitingForAlbum());
-}
-
-bool Video::dataLoaded() const {
-	return _data->loaded();
-}
-
-void Video::validateGroupedCache(
-		const QRect &geometry,
-		RectParts corners,
-		not_null<uint64*> cacheKey,
-		not_null<QPixmap*> cache) const {
-	using Option = Images::Option;
-	const auto good = _data->goodThumbnail();
-	const auto useGood = (good && good->loaded());
-	const auto thumb = _data->thumbnail();
-	const auto useThumb = (thumb && thumb->loaded());
-	const auto image = useGood
-		? good
-		: useThumb
-		? thumb
-		: _data->thumbnailInline();
-	if (good && !useGood) {
-		good->load({});
-	}
-
-	const auto loadLevel = useGood ? 3 : useThumb ? 2 : image ? 1 : 0;
-	const auto width = geometry.width();
-	const auto height = geometry.height();
-	const auto options = Option::Smooth
-		| Option::RoundedLarge
-		| (useGood ? Option(0) : Option::Blurred)
-		| ((corners & RectPart::TopLeft) ? Option::RoundedTopLeft : Option::None)
-		| ((corners & RectPart::TopRight) ? Option::RoundedTopRight : Option::None)
-		| ((corners & RectPart::BottomLeft) ? Option::RoundedBottomLeft : Option::None)
-		| ((corners & RectPart::BottomRight) ? Option::RoundedBottomRight : Option::None);
-	const auto key = (uint64(width) << 48)
-		| (uint64(height) << 32)
-		| (uint64(options) << 16)
-		| (uint64(loadLevel));
-	if (*cacheKey == key) {
-		return;
-	}
-
-	const auto original = sizeForAspectRatio();
-	const auto originalWidth = style::ConvertScale(original.width());
-	const auto originalHeight = style::ConvertScale(original.height());
-	const auto pixSize = Ui::GetImageScaleSizeForGeometry(
-		{ originalWidth, originalHeight },
-		{ width, height });
-	const auto pixWidth = pixSize.width() * cIntRetinaFactor();
-	const auto pixHeight = pixSize.height() * cIntRetinaFactor();
-
-	*cacheKey = key;
-	*cache = (image ? image : Image::BlankMedia().get())->pixNoCache(
-		_realParent->fullId(),
-		pixWidth,
-		pixHeight,
-		options,
-		width,
-		height);
-}
-
-void Video::setStatusSize(int newSize) const {
-	File::setStatusSize(newSize, _data->size, _data->getDuration(), 0);
-}
-
-TextForMimeData Video::selectedText(TextSelection selection) const {
-	return _caption.toTextForMimeData(selection);
-}
-
-bool Video::needsBubble() const {
-	if (!_caption.isEmpty()) {
-		return true;
-	}
-	const auto item = _parent->data();
-	return item->viaBot()
-		|| item->Has<HistoryMessageReply>()
-		|| _parent->displayForwardedFrom()
-		|| _parent->displayFromName();
-	return false;
-}
-
-void Video::parentTextUpdated() {
-	_caption = (_parent->media() == this)
-		? createCaption(_parent->data())
-		: Ui::Text::String();
-	history()->owner().requestViewResize(_parent);
-}
-
-void Video::updateStatusText() const {
-	auto showPause = false;
-	auto statusSize = 0;
-	auto realDuration = 0;
-	if (_data->status == FileDownloadFailed || _data->status == FileUploadFailed) {
-		statusSize = FileStatusSizeFailed;
-	} else if (_data->uploading()) {
-		statusSize = _data->uploadingData->offset;
-	} else if (!downloadInCorner() && _data->loading()) {
-		statusSize = _data->loadOffset();
-	} else if (_data->canBePlayed()) {
-		statusSize = FileStatusSizeLoaded;
-	} else {
-		statusSize = FileStatusSizeReady;
-	}
-	if (statusSize != _statusSize) {
-		setStatusSize(statusSize);
-	}
-}
-
-} // namespace HistoryView
diff --git a/Telegram/SourceFiles/history/view/media/history_view_video.h b/Telegram/SourceFiles/history/view/media/history_view_video.h
deleted file mode 100644
index 33b63434a..000000000
--- a/Telegram/SourceFiles/history/view/media/history_view_video.h
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
-This file is part of Telegram Desktop,
-the official desktop application for the Telegram messaging service.
-
-For license and copyright information please follow this link:
-https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
-*/
-#pragma once
-
-#include "history/view/media/history_view_file.h"
-
-namespace HistoryView {
-
-class Video : public File {
-public:
-	Video(
-		not_null<Element*> parent,
-		not_null<HistoryItem*> realParent,
-		not_null<DocumentData*> document);
-
-	void draw(Painter &p, const QRect &r, TextSelection selection, crl::time ms) const override;
-	TextState textState(QPoint point, StateRequest request) const override;
-
-	[[nodiscard]] TextSelection adjustSelection(
-			TextSelection selection,
-			TextSelectType type) const override {
-		return _caption.adjustSelection(selection, type);
-	}
-	uint16 fullSelectionLength() const override {
-		return _caption.length();
-	}
-	bool hasTextForCopy() const override {
-		return !_caption.isEmpty();
-	}
-
-	TextForMimeData selectedText(TextSelection selection) const override;
-
-	DocumentData *getDocument() const override {
-		return _data;
-	}
-
-	QSize sizeForGrouping() const override;
-	void drawGrouped(
-		Painter &p,
-		const QRect &clip,
-		TextSelection selection,
-		crl::time ms,
-		const QRect &geometry,
-		RectParts corners,
-		not_null<uint64*> cacheKey,
-		not_null<QPixmap*> cache) const override;
-	TextState getStateGrouped(
-		const QRect &geometry,
-		QPoint point,
-		StateRequest request) const override;
-
-	bool uploading() const override;
-
-	TextWithEntities getCaption() const override {
-		return _caption.toTextWithEntities();
-	}
-	bool needsBubble() const override;
-	bool customInfoLayout() const override {
-		return _caption.isEmpty();
-	}
-	bool skipBubbleTail() const override {
-		return isBubbleBottom() && _caption.isEmpty();
-	}
-
-	void parentTextUpdated() override;
-
-protected:
-	float64 dataProgress() const override;
-	bool dataFinished() const override;
-	bool dataLoaded() const override;
-
-private:
-	[[nodiscard]] QSize countOptimalSize() override;
-	[[nodiscard]] QSize countCurrentSize(int newWidth) override;
-	[[nodiscard]] QSize countOptimalDimensions() const;
-	[[nodiscard]] bool downloadInCorner() const;
-
-	void drawCornerStatus(Painter &p, bool selected) const;
-	[[nodiscard]] TextState cornerStatusTextState(
-		QPoint point,
-		StateRequest request) const;
-
-	void validateGroupedCache(
-		const QRect &geometry,
-		RectParts corners,
-		not_null<uint64*> cacheKey,
-		not_null<QPixmap*> cache) const;
-	void setStatusSize(int newSize) const;
-	void updateStatusText() const;
-	QSize sizeForAspectRatio() const;
-
-	not_null<DocumentData*> _data;
-	int _thumbw = 1;
-	int _thumbh = 1;
-	Ui::Text::String _caption;
-
-	QString _downloadSize;
-
-};
-
-} // namespace HistoryView
diff --git a/Telegram/SourceFiles/history/view/media/history_view_web_page.cpp b/Telegram/SourceFiles/history/view/media/history_view_web_page.cpp
index f3bcf257a..c41c8a14d 100644
--- a/Telegram/SourceFiles/history/view/media/history_view_web_page.cpp
+++ b/Telegram/SourceFiles/history/view/media/history_view_web_page.cpp
@@ -686,12 +686,12 @@ TextSelection WebPage::adjustSelection(TextSelection selection, TextSelectType t
 		return _siteName.adjustSelection(selection, type);
 	}
 
+	auto titlesLength = _siteName.length() + _title.length();
 	auto titleSelection = _title.adjustSelection(toTitleSelection(selection), type);
-	if ((!_siteNameLines && !_descriptionLines) || (selection.from >= _siteName.length() && selection.to <= _description.length())) {
+	if ((!_siteNameLines && !_descriptionLines) || (selection.from >= _siteName.length() && selection.to <= titlesLength)) {
 		return fromTitleSelection(titleSelection);
 	}
 
-	auto titlesLength = _siteName.length() + _title.length();
 	auto descriptionSelection = _description.adjustSelection(toDescriptionSelection(selection), type);
 	if ((!_siteNameLines && !_titleLines) || selection.from >= titlesLength) {
 		return fromDescriptionSelection(descriptionSelection);
diff --git a/Telegram/SourceFiles/history/view/media/history_view_web_page.h b/Telegram/SourceFiles/history/view/media/history_view_web_page.h
index 4b74508d5..72d5cf906 100644
--- a/Telegram/SourceFiles/history/view/media/history_view_web_page.h
+++ b/Telegram/SourceFiles/history/view/media/history_view_web_page.h
@@ -62,6 +62,9 @@ public:
 	void stopAnimation() override {
 		if (_attach) _attach->stopAnimation();
 	}
+	int checkAnimationCount() override {
+		return _attach ? _attach->checkAnimationCount() : 0;
+	}
 
 	not_null<WebPageData*> webpage() {
 		return _data;
diff --git a/Telegram/SourceFiles/info/channels/info_channels_widget.cpp b/Telegram/SourceFiles/info/channels/info_channels_widget.cpp
index d6bbd1671..3b6c115a1 100644
--- a/Telegram/SourceFiles/info/channels/info_channels_widget.cpp
+++ b/Telegram/SourceFiles/info/channels/info_channels_widget.cpp
@@ -35,7 +35,7 @@ object_ptr<ContentWidget> Memento::createWidget(
 		parent,
 		controller);
 	result->setInternalState(geometry, this);
-	return std::move(result);
+	return result;
 }
 
 void Memento::setState(std::unique_ptr<SavedState> state) {
@@ -79,7 +79,7 @@ void Widget::setInternalState(
 std::unique_ptr<ContentMemento> Widget::doCreateMemento() {
 	auto result = std::make_unique<Memento>(controller());
 	saveState(result.get());
-	return std::move(result);
+	return result;
 }
 
 void Widget::saveState(not_null<Memento*> memento) {
diff --git a/Telegram/SourceFiles/info/common_groups/info_common_groups_inner_widget.cpp b/Telegram/SourceFiles/info/common_groups/info_common_groups_inner_widget.cpp
index 47427556a..065ef7857 100644
--- a/Telegram/SourceFiles/info/common_groups/info_common_groups_inner_widget.cpp
+++ b/Telegram/SourceFiles/info/common_groups/info_common_groups_inner_widget.cpp
@@ -11,6 +11,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "info/info_controller.h"
 #include "lang/lang_keys.h"
 #include "mtproto/sender.h"
+#include "main/main_session.h"
 #include "window/window_session_controller.h"
 #include "ui/widgets/scroll_area.h"
 #include "ui/search_field_controller.h"
@@ -27,10 +28,7 @@ namespace {
 constexpr auto kCommonGroupsPerPage = 40;
 constexpr auto kCommonGroupsSearchAfter = 20;
 
-class ListController
-	: public PeerListController
-	, private base::Subscriber
-	, private MTP::Sender {
+class ListController : public PeerListController , private base::Subscriber {
 public:
 	ListController(
 		not_null<Controller*> controller,
@@ -58,6 +56,7 @@ private:
 		bool wasLoading = false;
 	};
 	const not_null<Controller*> _controller;
+	MTP::Sender _api;
 	not_null<UserData*> _user;
 	mtpRequestId _preloadRequestId = 0;
 	bool _allLoaded = false;
@@ -70,6 +69,7 @@ ListController::ListController(
 	not_null<UserData*> user)
 : PeerListController()
 , _controller(controller)
+, _api(_controller->session().api().instance())
 , _user(user) {
 	_controller->setSearchEnabledByContent(false);
 }
@@ -95,7 +95,7 @@ void ListController::loadMoreRows() {
 	if (_preloadRequestId || _allLoaded) {
 		return;
 	}
-	_preloadRequestId = request(MTPmessages_GetCommonChats(
+	_preloadRequestId = _api.request(MTPmessages_GetCommonChats(
 		_user->inputUser,
 		MTP_int(_preloadGroupId),
 		MTP_int(kCommonGroupsPerPage)
@@ -143,7 +143,7 @@ void ListController::restoreState(
 		: nullptr;
 	if (auto my = dynamic_cast<SavedState*>(typeErasedState)) {
 		if (auto requestId = base::take(_preloadRequestId)) {
-			request(requestId).cancel();
+			_api.request(requestId).cancel();
 		}
 		_allLoaded = my->allLoaded;
 		_preloadGroupId = my->preloadGroupId;
diff --git a/Telegram/SourceFiles/info/common_groups/info_common_groups_widget.cpp b/Telegram/SourceFiles/info/common_groups/info_common_groups_widget.cpp
index c74a78f1b..524e4e977 100644
--- a/Telegram/SourceFiles/info/common_groups/info_common_groups_widget.cpp
+++ b/Telegram/SourceFiles/info/common_groups/info_common_groups_widget.cpp
@@ -33,7 +33,7 @@ object_ptr<ContentWidget> Memento::createWidget(
 		controller,
 		Auth().data().user(userId()));
 	result->setInternalState(geometry, this);
-	return std::move(result);
+	return result;
 }
 
 void Memento::setListState(std::unique_ptr<PeerListState> state) {
@@ -85,7 +85,7 @@ void Widget::setInternalState(
 std::unique_ptr<ContentMemento> Widget::doCreateMemento() {
 	auto result = std::make_unique<Memento>(user()->bareId());
 	saveState(result.get());
-	return std::move(result);
+	return result;
 }
 
 void Widget::saveState(not_null<Memento*> memento) {
diff --git a/Telegram/SourceFiles/info/feed/info_feed_profile_inner_widget.cpp b/Telegram/SourceFiles/info/feed/info_feed_profile_inner_widget.cpp
index 2fee32e9b..b5f8d48c5 100644
--- a/Telegram/SourceFiles/info/feed/info_feed_profile_inner_widget.cpp
+++ b/Telegram/SourceFiles/info/feed/info_feed_profile_inner_widget.cpp
@@ -61,7 +61,7 @@ object_ptr<Ui::RpWidget> InnerWidget::setupContent(
 		_scrollToRequests.fire({ min, max });
 	}, _channels->lifetime());
 
-	return std::move(result);
+	return result;
 }
 
 int InnerWidget::countDesiredHeight() const {
diff --git a/Telegram/SourceFiles/info/feed/info_feed_profile_widget.cpp b/Telegram/SourceFiles/info/feed/info_feed_profile_widget.cpp
index bf77083ea..ec09c252c 100644
--- a/Telegram/SourceFiles/info/feed/info_feed_profile_widget.cpp
+++ b/Telegram/SourceFiles/info/feed/info_feed_profile_widget.cpp
@@ -35,7 +35,7 @@ object_ptr<ContentWidget> Memento::createWidget(
 		parent,
 		controller);
 	result->setInternalState(geometry, this);
-	return std::move(result);
+	return result;
 }
 
 void Memento::setChannelsState(std::unique_ptr<ChannelsState> state) {
@@ -99,7 +99,7 @@ void Widget::setInternalState(
 std::unique_ptr<ContentMemento> Widget::doCreateMemento() {
 	auto result = std::make_unique<Memento>(controller());
 	saveState(result.get());
-	return std::move(result);
+	return result;
 }
 
 void Widget::saveState(not_null<Memento*> memento) {
diff --git a/Telegram/SourceFiles/info/info_controller.cpp b/Telegram/SourceFiles/info/info_controller.cpp
index 68c328428..41f6951f6 100644
--- a/Telegram/SourceFiles/info/info_controller.cpp
+++ b/Telegram/SourceFiles/info/info_controller.cpp
@@ -196,7 +196,7 @@ void Controller::updateSearchControllers(
 	auto searchQuery = memento->searchFieldQuery();
 	if (isMedia) {
 		_searchController
-			= std::make_unique<Api::DelayedSearchController>();
+			= std::make_unique<Api::DelayedSearchController>(&session());
 		auto mediaMemento = dynamic_cast<Media::Memento*>(memento.get());
 		Assert(mediaMemento != nullptr);
 		_searchController->restoreState(
diff --git a/Telegram/SourceFiles/info/info_memento.cpp b/Telegram/SourceFiles/info/info_memento.cpp
index a4495b677..f7d75ef63 100644
--- a/Telegram/SourceFiles/info/info_memento.cpp
+++ b/Telegram/SourceFiles/info/info_memento.cpp
@@ -160,7 +160,7 @@ object_ptr<Window::SectionWidget> Memento::createWidget(
 		wrap,
 		this);
 	result->setGeometry(geometry);
-	return std::move(result);
+	return result;
 }
 
 object_ptr<Ui::LayerWidget> Memento::createLayer(
@@ -198,7 +198,7 @@ object_ptr<Window::SectionWidget> MoveMemento::createWidget(
 		wrap,
 		this);
 	result->setGeometry(geometry);
-	return std::move(result);
+	return result;
 }
 
 object_ptr<Ui::LayerWidget> MoveMemento::createLayer(
diff --git a/Telegram/SourceFiles/info/info_wrap_widget.cpp b/Telegram/SourceFiles/info/info_wrap_widget.cpp
index 4ef14a780..88440a5de 100644
--- a/Telegram/SourceFiles/info/info_wrap_widget.cpp
+++ b/Telegram/SourceFiles/info/info_wrap_widget.cpp
@@ -1043,7 +1043,7 @@ object_ptr<Ui::RpWidget> WrapWidget::createTopBarSurrogate(
 		});
 		result->setGeometry(_topBar->geometry());
 		result->show();
-		return std::move(result);
+		return result;
 	}
 	return nullptr;
 }
diff --git a/Telegram/SourceFiles/info/media/info_media_buttons.h b/Telegram/SourceFiles/info/media/info_media_buttons.h
index e79cac60d..56427c835 100644
--- a/Telegram/SourceFiles/info/media/info_media_buttons.h
+++ b/Telegram/SourceFiles/info/media/info_media_buttons.h
@@ -94,7 +94,7 @@ inline auto AddButton(
 		navigation->showSection(
 			Info::Memento(peer->id, Section(type)));
 	});
-	return std::move(result);
+	return result;
 };
 
 inline auto AddCommonGroupsButton(
@@ -113,8 +113,8 @@ inline auto AddCommonGroupsButton(
 		navigation->showSection(
 			Info::Memento(user->id, Section::Type::CommonGroups));
 	});
-	return std::move(result);
+	return result;
 };
 
 } // namespace Media
-} // namespace Info
\ No newline at end of file
+} // namespace Info
diff --git a/Telegram/SourceFiles/info/media/info_media_list_widget.cpp b/Telegram/SourceFiles/info/media/info_media_list_widget.cpp
index 8e63a2869..ca3aaa24b 100644
--- a/Telegram/SourceFiles/info/media/info_media_list_widget.cpp
+++ b/Telegram/SourceFiles/info/media/info_media_list_widget.cpp
@@ -13,13 +13,13 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "data/data_photo.h"
 #include "data/data_document.h"
 #include "data/data_session.h"
+#include "data/data_file_origin.h"
 #include "history/history_item.h"
 #include "history/history.h"
 #include "history/view/history_view_cursor_state.h"
 #include "window/themes/window_theme.h"
 #include "window/window_session_controller.h"
 #include "window/window_peer_menu.h"
-#include "storage/file_download.h"
 #include "ui/widgets/popup_menu.h"
 #include "ui/ui_utility.h"
 #include "ui/inactive_press.h"
@@ -574,7 +574,7 @@ void ListWidget::start() {
 		}
 	}, lifetime());
 	ObservableViewer(
-		session().downloader().taskFinished()
+		session().downloaderTaskFinished()
 	) | rpl::start_with_next([this] { update(); }, lifetime());
 	session().data().itemLayoutChanged(
 	) | rpl::start_with_next([this](auto item) {
diff --git a/Telegram/SourceFiles/info/media/info_media_widget.cpp b/Telegram/SourceFiles/info/media/info_media_widget.cpp
index ab405f56e..dece63f6f 100644
--- a/Telegram/SourceFiles/info/media/info_media_widget.cpp
+++ b/Telegram/SourceFiles/info/media/info_media_widget.cpp
@@ -65,7 +65,7 @@ object_ptr<ContentWidget> Memento::createWidget(
 		parent,
 		controller);
 	result->setInternalState(geometry, this);
-	return std::move(result);
+	return result;
 }
 
 Widget::Widget(
@@ -117,7 +117,7 @@ void Widget::setInternalState(
 std::unique_ptr<ContentMemento> Widget::doCreateMemento() {
 	auto result = std::make_unique<Memento>(controller());
 	saveState(result.get());
-	return std::move(result);
+	return result;
 }
 
 void Widget::saveState(not_null<Memento*> memento) {
diff --git a/Telegram/SourceFiles/info/members/info_members_widget.cpp b/Telegram/SourceFiles/info/members/info_members_widget.cpp
index 5e8f4e0c6..d0e9c35b0 100644
--- a/Telegram/SourceFiles/info/members/info_members_widget.cpp
+++ b/Telegram/SourceFiles/info/members/info_members_widget.cpp
@@ -38,7 +38,7 @@ object_ptr<ContentWidget> Memento::createWidget(
 		parent,
 		controller);
 	result->setInternalState(geometry, this);
-	return std::move(result);
+	return result;
 }
 
 void Memento::setState(std::unique_ptr<SavedState> state) {
@@ -82,7 +82,7 @@ void Widget::setInternalState(
 std::unique_ptr<ContentMemento> Widget::doCreateMemento() {
 	auto result = std::make_unique<Memento>(controller());
 	saveState(result.get());
-	return std::move(result);
+	return result;
 }
 
 void Widget::saveState(not_null<Memento*> memento) {
diff --git a/Telegram/SourceFiles/info/profile/info_profile_actions.cpp b/Telegram/SourceFiles/info/profile/info_profile_actions.cpp
index 3d5c912db..096162029 100644
--- a/Telegram/SourceFiles/info/profile/info_profile_actions.cpp
+++ b/Telegram/SourceFiles/info/profile/info_profile_actions.cpp
@@ -392,7 +392,7 @@ object_ptr<Ui::RpWidget> DetailsFiller::setupInfo() {
 		result,
 		st::infoIconInformation,
 		st::infoInformationIconPosition);
-	return std::move(result);
+	return result;
 }
 
 object_ptr<Ui::RpWidget> DetailsFiller::setupMuteToggle() {
@@ -413,7 +413,7 @@ object_ptr<Ui::RpWidget> DetailsFiller::setupMuteToggle() {
 		result,
 		st::infoIconNotifications,
 		st::infoNotificationsIconPosition);
-	return std::move(result);
+	return result;
 }
 
 void DetailsFiller::setupMainButtons() {
@@ -823,7 +823,7 @@ object_ptr<Ui::RpWidget> ActionsFiller::fill() {
 //		result,
 //		st::infoIconNotifications,
 //		st::infoNotificationsIconPosition);
-//	return std::move(result);
+//	return result;
 //}
 
 } // namespace
@@ -918,7 +918,7 @@ object_ptr<Ui::RpWidget> SetupChannelMembers(
 		st::infoChannelMembersIconPosition);
 	members->add(CreateSkipWidget(members));
 
-	return std::move(result);
+	return result;
 }
 // // #feed
 //object_ptr<Ui::RpWidget> SetupFeedDetails(
diff --git a/Telegram/SourceFiles/info/profile/info_profile_inner_widget.cpp b/Telegram/SourceFiles/info/profile/info_profile_inner_widget.cpp
index ce67c438a..e1eaa4b21 100644
--- a/Telegram/SourceFiles/info/profile/info_profile_inner_widget.cpp
+++ b/Telegram/SourceFiles/info/profile/info_profile_inner_widget.cpp
@@ -125,7 +125,7 @@ object_ptr<Ui::RpWidget> InnerWidget::setupContent(
 		}, _members->lifetime());
 		_cover->setOnlineCount(_members->onlineCountValue());
 	}
-	return std::move(result);
+	return result;
 }
 
 object_ptr<Ui::RpWidget> InnerWidget::setupSharedMedia(
@@ -227,7 +227,7 @@ object_ptr<Ui::RpWidget> InnerWidget::setupSharedMedia(
 	)->setAttribute(Qt::WA_TransparentForMouseEvents);
 
 	_sharedMediaWrap = result;
-	return std::move(result);
+	return result;
 }
 
 int InnerWidget::countDesiredHeight() const {
diff --git a/Telegram/SourceFiles/info/profile/info_profile_widget.cpp b/Telegram/SourceFiles/info/profile/info_profile_widget.cpp
index f2d7546ea..f8156e14c 100644
--- a/Telegram/SourceFiles/info/profile/info_profile_widget.cpp
+++ b/Telegram/SourceFiles/info/profile/info_profile_widget.cpp
@@ -38,7 +38,7 @@ object_ptr<ContentWidget> Memento::createWidget(
 		parent,
 		controller);
 	result->setInternalState(geometry, this);
-	return std::move(result);
+	return result;
 }
 
 void Memento::setMembersState(std::unique_ptr<MembersState> state) {
@@ -102,7 +102,7 @@ void Widget::setInternalState(
 std::unique_ptr<ContentMemento> Widget::doCreateMemento() {
 	auto result = std::make_unique<Memento>(controller());
 	saveState(result.get());
-	return std::move(result);
+	return result;
 }
 
 void Widget::saveState(not_null<Memento*> memento) {
diff --git a/Telegram/SourceFiles/info/settings/info_settings_widget.cpp b/Telegram/SourceFiles/info/settings/info_settings_widget.cpp
index 5b7b8818a..689164a8b 100644
--- a/Telegram/SourceFiles/info/settings/info_settings_widget.cpp
+++ b/Telegram/SourceFiles/info/settings/info_settings_widget.cpp
@@ -32,7 +32,7 @@ object_ptr<ContentWidget> Memento::createWidget(
 		parent,
 		controller);
 	result->setInternalState(geometry, this);
-	return std::move(result);
+	return result;
 }
 
 Memento::~Memento() = default;
@@ -95,7 +95,7 @@ rpl::producer<bool> Widget::desiredShadowVisibility() const {
 std::unique_ptr<ContentMemento> Widget::doCreateMemento() {
 	auto result = std::make_unique<Memento>(self(), _type);
 	saveState(result.get());
-	return std::move(result);
+	return result;
 }
 
 void Widget::saveState(not_null<Memento*> memento) {
diff --git a/Telegram/SourceFiles/inline_bots/inline_bot_layout_internal.cpp b/Telegram/SourceFiles/inline_bots/inline_bot_layout_internal.cpp
index 24a485763..960ec1078 100644
--- a/Telegram/SourceFiles/inline_bots/inline_bot_layout_internal.cpp
+++ b/Telegram/SourceFiles/inline_bots/inline_bot_layout_internal.cpp
@@ -10,6 +10,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "data/data_photo.h"
 #include "data/data_document.h"
 #include "data/data_session.h"
+#include "data/data_file_origin.h"
 #include "styles/style_overview.h"
 #include "styles/style_history.h"
 #include "styles/style_chat_helpers.h"
diff --git a/Telegram/SourceFiles/inline_bots/inline_bot_layout_item.cpp b/Telegram/SourceFiles/inline_bots/inline_bot_layout_item.cpp
index 4823a58f1..679cf6bf9 100644
--- a/Telegram/SourceFiles/inline_bots/inline_bot_layout_item.cpp
+++ b/Telegram/SourceFiles/inline_bots/inline_bot_layout_item.cpp
@@ -10,6 +10,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "data/data_photo.h"
 #include "data/data_document.h"
 #include "data/data_peer.h"
+#include "data/data_file_origin.h"
 #include "core/click_handler_types.h"
 #include "inline_bots/inline_bot_result.h"
 #include "inline_bots/inline_bot_layout_internal.h"
diff --git a/Telegram/SourceFiles/inline_bots/inline_bot_result.cpp b/Telegram/SourceFiles/inline_bots/inline_bot_result.cpp
index 0cacca7fa..f87d34734 100644
--- a/Telegram/SourceFiles/inline_bots/inline_bot_result.cpp
+++ b/Telegram/SourceFiles/inline_bots/inline_bot_result.cpp
@@ -11,6 +11,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "data/data_photo.h"
 #include "data/data_document.h"
 #include "data/data_session.h"
+#include "data/data_file_origin.h"
 #include "inline_bots/inline_bot_layout_item.h"
 #include "inline_bots/inline_bot_send_data.h"
 #include "storage/file_download.h"
diff --git a/Telegram/SourceFiles/inline_bots/inline_results_widget.cpp b/Telegram/SourceFiles/inline_bots/inline_results_widget.cpp
index 87d9e7da6..17e537944 100644
--- a/Telegram/SourceFiles/inline_bots/inline_results_widget.cpp
+++ b/Telegram/SourceFiles/inline_bots/inline_results_widget.cpp
@@ -12,7 +12,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "data/data_channel.h"
 #include "data/data_user.h"
 #include "data/data_session.h"
-#include "styles/style_chat_helpers.h"
+#include "data/data_file_origin.h"
 #include "ui/widgets/buttons.h"
 #include "ui/widgets/shadow.h"
 #include "ui/effects/ripple_animation.h"
@@ -34,6 +34,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "history/view/history_view_cursor_state.h"
 #include "facades.h"
 #include "app.h"
+#include "styles/style_chat_helpers.h"
 
 #include <QtWidgets/QApplication>
 
@@ -148,7 +149,7 @@ QPoint Inner::tooltipPos() const {
 }
 
 bool Inner::tooltipWindowActive() const {
-	return Ui::InFocusChain(window());
+	return Ui::AppInFocus() && Ui::InFocusChain(window());
 }
 
 Inner::~Inner() = default;
@@ -754,6 +755,7 @@ Widget::Widget(
 	not_null<Window::SessionController*> controller)
 : RpWidget(parent)
 , _controller(controller)
+, _api(_controller->session().api().instance())
 , _contentMaxHeight(st::emojiPanMaxHeight)
 , _contentHeight(_contentMaxHeight)
 , _scroll(this, st::inlineBotsScroll) {
@@ -1133,9 +1135,16 @@ void Widget::onInlineRequest() {
 		}
 	}
 	Notify::inlineBotRequesting(true);
-	_inlineRequestId = request(MTPmessages_GetInlineBotResults(MTP_flags(0), _inlineBot->inputUser, _inlineQueryPeer->input, MTPInputGeoPoint(), MTP_string(_inlineQuery), MTP_string(nextOffset))).done([this](const MTPmessages_BotResults &result, mtpRequestId requestId) {
+	_inlineRequestId = _api.request(MTPmessages_GetInlineBotResults(
+		MTP_flags(0),
+		_inlineBot->inputUser,
+		_inlineQueryPeer->input,
+		MTPInputGeoPoint(),
+		MTP_string(_inlineQuery),
+		MTP_string(nextOffset)
+	)).done([=](const MTPmessages_BotResults &result) {
 		inlineResultsDone(result);
-	}).fail([this](const RPCError &error) {
+	}).fail([=](const RPCError &error) {
 		// show error?
 		Notify::inlineBotRequesting(false);
 		_inlineRequestId = 0;
diff --git a/Telegram/SourceFiles/inline_bots/inline_results_widget.h b/Telegram/SourceFiles/inline_bots/inline_results_widget.h
index 2c2281e89..d17b9da4c 100644
--- a/Telegram/SourceFiles/inline_bots/inline_results_widget.h
+++ b/Telegram/SourceFiles/inline_bots/inline_results_widget.h
@@ -173,7 +173,7 @@ private:
 
 } // namespace internal
 
-class Widget : public Ui::RpWidget, private MTP::Sender {
+class Widget : public Ui::RpWidget {
 	Q_OBJECT
 
 public:
@@ -246,6 +246,7 @@ private:
 	void inlineResultsDone(const MTPmessages_BotResults &result);
 
 	not_null<Window::SessionController*> _controller;
+	MTP::Sender _api;
 
 	int _contentMaxHeight = 0;
 	int _contentHeight = 0;
diff --git a/Telegram/SourceFiles/intro/intro.style b/Telegram/SourceFiles/intro/intro.style
index fdae237d7..59ff6e7d3 100644
--- a/Telegram/SourceFiles/intro/intro.style
+++ b/Telegram/SourceFiles/intro/intro.style
@@ -74,8 +74,10 @@ introPlaneHeight: 38px;
 introHeight: 406px;
 introStepTopMin: 76px;
 introStepWidth: 380px;
-introStepHeight: 266px;
-introStepHeightAdd: 30px;
+introNextTop: 266px;
+introNextSlide: 200px;
+introStepHeight: 384px;
+introContentTopAdd: 30px;
 introStepHeightFull: 590px;
 introSlideDuration: 200;
 introCoverDuration: 200;
@@ -105,6 +107,7 @@ introPhone: InputField(introCountry) {
 	textMargins: margins(12px, 27px, 12px, 6px);
 	width: 225px;
 }
+introQrLoginLinkTop: 368px;
 introCode: introCountry;
 introName: introCountry;
 introPassword: introCountry;
@@ -160,3 +163,28 @@ introBackButton: IconButton(defaultIconButton) {
 	}
 }
 
+introQrTop: -6px;
+introQrPixel: 50px; // large enough
+introQrMaxSize: 180px;
+introQrLabelsWidth: 292px;
+introQrTitleWidth: 320px;
+introQrTitle: FlatLabel(defaultFlatLabel) {
+	textFg: introTitleFg;
+	align: align(top);
+	minWidth: introQrTitleWidth;
+	style: TextStyle(defaultTextStyle) {
+		font: font(20px semibold);
+		linkFont: font(20px semibold);
+		linkFontOver: font(20px semibold underline);
+	}
+}
+introQrErrorTop: 336px;
+introQrTitleTop: 196px;
+introQrStep: FlatLabel(defaultFlatLabel) {
+	minWidth: introQrLabelsWidth;
+}
+introQrStepsTop: 232px;
+introQrStepMargins: margins(20px, 8px, 0px, 0px);
+introQrSkipTop: 360px;
+introQrCenterSize: 44px;
+introQrPlane: icon {{ "intro_qr_plane", activeButtonFg }};
diff --git a/Telegram/SourceFiles/intro/introcode.cpp b/Telegram/SourceFiles/intro/intro_code.cpp
similarity index 85%
rename from Telegram/SourceFiles/intro/introcode.cpp
rename to Telegram/SourceFiles/intro/intro_code.cpp
index 31f1fcfd5..25e3a455a 100644
--- a/Telegram/SourceFiles/intro/introcode.cpp
+++ b/Telegram/SourceFiles/intro/intro_code.cpp
@@ -5,11 +5,11 @@ the official desktop application for the Telegram messaging service.
 For license and copyright information please follow this link:
 https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 */
-#include "intro/introcode.h"
+#include "intro/intro_code.h"
 
 #include "lang/lang_keys.h"
-#include "intro/introsignup.h"
-#include "intro/intropwdcheck.h"
+#include "intro/intro_signup.h"
+#include "intro/intro_password_check.h"
 #include "core/update_checker.h"
 #include "ui/widgets/buttons.h"
 #include "ui/widgets/labels.h"
@@ -19,6 +19,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "styles/style_intro.h"
 
 namespace Intro {
+namespace details {
 
 CodeInput::CodeInput(
 	QWidget *parent,
@@ -77,35 +78,38 @@ void CodeInput::correctValue(const QString &was, int wasCursor, QString &now, in
 CodeWidget::CodeWidget(
 	QWidget *parent,
 	not_null<Main::Account*> account,
-	not_null<Widget::Data*> data)
+	not_null<Data*> data)
 : Step(parent, account, data)
 , _noTelegramCode(this, tr::lng_code_no_telegram(tr::now), st::introLink)
 , _code(this, st::introCode, tr::lng_code_ph())
-, _callTimer(this)
+, _callTimer([=] { sendCall(); })
 , _callStatus(getData()->callStatus)
 , _callTimeout(getData()->callTimeout)
 , _callLabel(this, st::introDescription)
-, _checkRequest(this) {
+, _checkRequestTimer([=] { checkRequest(); }) {
 	subscribe(Lang::Current().updated(), [this] { refreshLang(); });
 
-	connect(_code, SIGNAL(changed()), this, SLOT(onInputChange()));
-	connect(_callTimer, SIGNAL(timeout()), this, SLOT(onSendCall()));
-	connect(_checkRequest, SIGNAL(timeout()), this, SLOT(onCheckRequest()));
-	_noTelegramCode->addClickHandler([=] { onNoTelegramCode(); });
+	connect(_code, &CodeInput::changed, [=] { codeChanged(); });
+	_noTelegramCode->addClickHandler([=] { noTelegramCode(); });
 
 	_code->setDigitsCountMax(getData()->codeLength);
-	setErrorBelowLink(true);
 
 	setTitleText(rpl::single(App::formatPhone(getData()->phone)));
 	updateDescText();
 }
 
 void CodeWidget::refreshLang() {
-	if (_noTelegramCode) _noTelegramCode->setText(tr::lng_code_no_telegram(tr::now));
+	if (_noTelegramCode) {
+		_noTelegramCode->setText(tr::lng_code_no_telegram(tr::now));
+	}
 	updateDescText();
 	updateControlsGeometry();
 }
 
+int CodeWidget::errorTop() const {
+	return contentTop() + st::introErrorBelowLinkTop;
+}
+
 void CodeWidget::updateDescText() {
 	const auto byTelegram = getData()->codeByTelegram;
 	setDescriptionText(
@@ -113,13 +117,13 @@ void CodeWidget::updateDescText() {
 			Ui::Text::RichLangValue));
 	if (getData()->codeByTelegram) {
 		_noTelegramCode->show();
-		_callTimer->stop();
+		_callTimer.cancel();
 	} else {
 		_noTelegramCode->hide();
 		_callStatus = getData()->callStatus;
 		_callTimeout = getData()->callTimeout;
-		if (_callStatus == Widget::Data::CallStatus::Waiting && !_callTimer->isActive()) {
-			_callTimer->start(1000);
+		if (_callStatus == CallStatus::Waiting && !_callTimer.isActive()) {
+			_callTimer.callEach(1000);
 		}
 	}
 	updateCallText();
@@ -131,7 +135,7 @@ void CodeWidget::updateCallText() {
 			return QString();
 		}
 		switch (_callStatus) {
-		case Widget::Data::CallStatus::Waiting: {
+		case CallStatus::Waiting: {
 			if (_callTimeout >= 3600) {
 				return tr::lng_code_call(
 					tr::now,
@@ -150,9 +154,9 @@ void CodeWidget::updateCallText() {
 					qsl("%1").arg(_callTimeout % 60, 2, 10, QChar('0')));
 			}
 		} break;
-		case Widget::Data::CallStatus::Calling:
+		case CallStatus::Calling:
 			return tr::lng_code_calling(tr::now);
-		case Widget::Data::CallStatus::Called:
+		case CallStatus::Called:
 			return tr::lng_code_called(tr::now);
 		}
 		return QString();
@@ -195,8 +199,8 @@ void CodeWidget::activate() {
 
 void CodeWidget::finished() {
 	Step::finished();
-	_checkRequest->stop();
-	_callTimer->stop();
+	_checkRequestTimer.cancel();
+	_callTimer.cancel();
 	rpcInvalidate();
 
 	cancelled();
@@ -211,10 +215,10 @@ void CodeWidget::cancelled() {
 }
 
 void CodeWidget::stopCheck() {
-	_checkRequest->stop();
+	_checkRequestTimer.cancel();
 }
 
-void CodeWidget::onCheckRequest() {
+void CodeWidget::checkRequest() {
 	auto status = MTP::state(_sentRequest);
 	if (status < 0) {
 		auto leftms = -status;
@@ -236,7 +240,7 @@ void CodeWidget::codeSubmitDone(const MTPauth_Authorization &result) {
 	result.match([&](const MTPDauth_authorization &data) {
 		if (data.vuser().type() != mtpc_user
 			|| !data.vuser().c_user().is_self()) {
-			showCodeError(rpl::single(Lang::Hard::ServerError()));
+			showError(rpl::single(Lang::Hard::ServerError()));
 			return;
 		}
 		cSetLoggedPhoneNumber(getData()->phone);
@@ -274,7 +278,7 @@ bool CodeWidget::codeSubmitFail(const RPCError &error) {
 		showCodeError(tr::lng_bad_code());
 		return true;
 	} else if (err == qstr("SESSION_PASSWORD_NEEDED")) {
-		_checkRequest->start(1000);
+		_checkRequestTimer.callEach(1000);
 		_sentRequest = MTP::send(
 			MTPaccount_GetPassword(),
 			rpcDone(&CodeWidget::gotPassword),
@@ -289,17 +293,21 @@ bool CodeWidget::codeSubmitFail(const RPCError &error) {
 	return false;
 }
 
-void CodeWidget::onInputChange() {
+void CodeWidget::codeChanged() {
 	hideError();
 	submit();
 }
 
-void CodeWidget::onSendCall() {
-	if (_callStatus == Widget::Data::CallStatus::Waiting) {
+void CodeWidget::sendCall() {
+	if (_callStatus == CallStatus::Waiting) {
 		if (--_callTimeout <= 0) {
-			_callStatus = Widget::Data::CallStatus::Calling;
-			_callTimer->stop();
-			_callRequestId = MTP::send(MTPauth_ResendCode(MTP_string(getData()->phone), MTP_bytes(getData()->phoneHash)), rpcDone(&CodeWidget::callDone));
+			_callStatus = CallStatus::Calling;
+			_callTimer.cancel();
+			_callRequestId = MTP::send(
+				MTPauth_ResendCode(
+					MTP_string(getData()->phone),
+					MTP_bytes(getData()->phoneHash)),
+				rpcDone(&CodeWidget::callDone));
 		} else {
 			getData()->callStatus = _callStatus;
 			getData()->callTimeout = _callTimeout;
@@ -313,8 +321,8 @@ void CodeWidget::callDone(const MTPauth_SentCode &v) {
 		fillSentCodeData(v.c_auth_sentCode());
 		_code->setDigitsCountMax(getData()->codeLength);
 	}
-	if (_callStatus == Widget::Data::CallStatus::Calling) {
-		_callStatus = Widget::Data::CallStatus::Called;
+	if (_callStatus == CallStatus::Calling) {
+		_callStatus = CallStatus::Called;
 		getData()->callStatus = _callStatus;
 		getData()->callTimeout = _callTimeout;
 		updateCallText();
@@ -347,7 +355,7 @@ void CodeWidget::gotPassword(const MTPaccount_Password &result) {
 	getData()->hasRecovery = d.is_has_recovery();
 	getData()->pwdHint = qs(d.vhint().value_or_empty());
 	getData()->pwdNotEmptyPassport = d.is_has_secure_values();
-	goReplace<PwdCheckWidget>();
+	goReplace<PasswordCheckWidget>();
 }
 
 void CodeWidget::submit() {
@@ -365,7 +373,7 @@ void CodeWidget::submit() {
 
 	hideError();
 
-	_checkRequest->start(1000);
+	_checkRequestTimer.callEach(1000);
 
 	_sentCode = text;
 	getData()->pwdRequest = Core::CloudPasswordCheckRequest();
@@ -381,7 +389,7 @@ void CodeWidget::submit() {
 		rpcFail(&CodeWidget::codeSubmitFail));
 }
 
-void CodeWidget::onNoTelegramCode() {
+void CodeWidget::noTelegramCode() {
 	if (_noTelegramCodeRequestId) {
 		return;
 	}
@@ -406,10 +414,10 @@ void CodeWidget::noTelegramCodeDone(const MTPauth_SentCode &result) {
 	_code->setDigitsCountMax(getData()->codeLength);
 	const auto next = d.vnext_type();
 	if (next && next->type() == mtpc_auth_codeTypeCall) {
-		getData()->callStatus = Widget::Data::CallStatus::Waiting;
+		getData()->callStatus = CallStatus::Waiting;
 		getData()->callTimeout = d.vtimeout().value_or(60);
 	} else {
-		getData()->callStatus = Widget::Data::CallStatus::Disabled;
+		getData()->callStatus = CallStatus::Disabled;
 		getData()->callTimeout = 0;
 	}
 	getData()->codeByTelegram = false;
@@ -435,4 +443,5 @@ bool CodeWidget::noTelegramCodeFail(const RPCError &error) {
 	return false;
 }
 
+} // namespace details
 } // namespace Intro
diff --git a/Telegram/SourceFiles/intro/introcode.h b/Telegram/SourceFiles/intro/intro_code.h
similarity index 81%
rename from Telegram/SourceFiles/intro/introcode.h
rename to Telegram/SourceFiles/intro/intro_code.h
index 527715035..719d8e091 100644
--- a/Telegram/SourceFiles/intro/introcode.h
+++ b/Telegram/SourceFiles/intro/intro_code.h
@@ -7,8 +7,10 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 */
 #pragma once
 
-#include "intro/introwidget.h"
+#include "intro/intro_step.h"
+#include "intro/intro_widget.h"
 #include "ui/widgets/input_fields.h"
+#include "base/timer.h"
 
 namespace Ui {
 class RoundButton;
@@ -17,6 +19,9 @@ class FlatLabel;
 } // namespace Ui
 
 namespace Intro {
+namespace details {
+
+enum class CallStatus;
 
 class CodeInput final : public Ui::MaskedInputField {
 public:
@@ -35,14 +40,12 @@ private:
 
 };
 
-class CodeWidget : public Widget::Step {
-	Q_OBJECT
-
+class CodeWidget final : public Step {
 public:
 	CodeWidget(
 		QWidget *parent,
 		not_null<Main::Account*> account,
-		not_null<Widget::Data*> data);
+		not_null<Data*> data);
 
 	bool hasBack() const override {
 		return true;
@@ -58,13 +61,14 @@ public:
 protected:
 	void resizeEvent(QResizeEvent *e) override;
 
-private slots:
-	void onNoTelegramCode();
-	void onInputChange();
-	void onSendCall();
-	void onCheckRequest();
-
 private:
+	void noTelegramCode();
+	void codeChanged();
+	void sendCall();
+	void checkRequest();
+
+	int errorTop() const override;
+
 	void updateCallText();
 	void refreshLang();
 	void updateControlsGeometry();
@@ -88,14 +92,15 @@ private:
 	QString _sentCode;
 	mtpRequestId _sentRequest = 0;
 
-	object_ptr<QTimer> _callTimer;
-	Widget::Data::CallStatus _callStatus;
+	base::Timer _callTimer;
+	CallStatus _callStatus = CallStatus();
 	int _callTimeout;
 	mtpRequestId _callRequestId = 0;
 	object_ptr<Ui::FlatLabel> _callLabel;
 
-	object_ptr<QTimer> _checkRequest;
+	base::Timer _checkRequestTimer;
 
 };
 
+} // namespace details
 } // namespace Intro
diff --git a/Telegram/SourceFiles/intro/intropwdcheck.cpp b/Telegram/SourceFiles/intro/intro_password_check.cpp
similarity index 74%
rename from Telegram/SourceFiles/intro/intropwdcheck.cpp
rename to Telegram/SourceFiles/intro/intro_password_check.cpp
index b8d31d8ab..eef08e616 100644
--- a/Telegram/SourceFiles/intro/intropwdcheck.cpp
+++ b/Telegram/SourceFiles/intro/intro_password_check.cpp
@@ -5,27 +5,31 @@ the official desktop application for the Telegram messaging service.
 For license and copyright information please follow this link:
 https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 */
-#include "intro/intropwdcheck.h"
+#include "intro/intro_password_check.h"
 
-#include "styles/style_intro.h"
-#include "styles/style_boxes.h"
+#include "intro/intro_widget.h"
 #include "core/file_utilities.h"
 #include "core/core_cloud_password.h"
 #include "boxes/confirm_box.h"
 #include "lang/lang_keys.h"
-#include "intro/introsignup.h"
+#include "intro/intro_signup.h"
 #include "ui/widgets/buttons.h"
 #include "ui/widgets/input_fields.h"
 #include "ui/widgets/labels.h"
+#include "main/main_account.h"
 #include "base/openssl_help.h"
+#include "styles/style_intro.h"
+#include "styles/style_boxes.h"
 
 namespace Intro {
+namespace details {
 
-PwdCheckWidget::PwdCheckWidget(
+PasswordCheckWidget::PasswordCheckWidget(
 	QWidget *parent,
 	not_null<Main::Account*> account,
-	not_null<Widget::Data*> data)
+	not_null<Data*> data)
 : Step(parent, account, data)
+, _api(account->mtp())
 , _request(getData()->pwdRequest)
 , _hasRecovery(getData()->hasRecovery)
 , _notEmptyPassport(getData()->pwdNotEmptyPassport)
@@ -34,21 +38,18 @@ PwdCheckWidget::PwdCheckWidget(
 , _pwdHint(this, st::introPasswordHint)
 , _codeField(this, st::introPassword, tr::lng_signin_code())
 , _toRecover(this, tr::lng_signin_recover(tr::now))
-, _toPassword(this, tr::lng_signin_try_password(tr::now))
-, _checkRequest(this) {
+, _toPassword(this, tr::lng_signin_try_password(tr::now)) {
 	Expects(!!_request);
 
-	subscribe(Lang::Current().updated(), [this] { refreshLang(); });
+	subscribe(Lang::Current().updated(), [=] { refreshLang(); });
 
-	connect(_checkRequest, SIGNAL(timeout()), this, SLOT(onCheckRequest()));
-	_toRecover->addClickHandler([=] { onToRecover(); });
-	_toPassword->addClickHandler([=] { onToPassword(); });
-	connect(_pwdField, SIGNAL(changed()), this, SLOT(onInputChange()));
-	connect(_codeField, SIGNAL(changed()), this, SLOT(onInputChange()));
+	_toRecover->addClickHandler([=] { toRecover(); });
+	_toPassword->addClickHandler([=] { toPassword(); });
+	connect(_pwdField, &Ui::PasswordInput::changed, [=] { hideError(); });
+	connect(_codeField, &Ui::InputField::changed, [=] { hideError(); });
 
 	setTitleText(tr::lng_signin_title());
 	updateDescriptionText();
-	setErrorBelowLink(true);
 
 	if (_hint.isEmpty()) {
 		_pwdHint->hide();
@@ -62,7 +63,7 @@ PwdCheckWidget::PwdCheckWidget(
 	setMouseTracking(true);
 }
 
-void PwdCheckWidget::refreshLang() {
+void PasswordCheckWidget::refreshLang() {
 	if (_toRecover) {
 		_toRecover->setText(tr::lng_signin_recover(tr::now));
 	}
@@ -77,12 +78,16 @@ void PwdCheckWidget::refreshLang() {
 	updateControlsGeometry();
 }
 
-void PwdCheckWidget::resizeEvent(QResizeEvent *e) {
+int PasswordCheckWidget::errorTop() const {
+	return contentTop() + st::introErrorBelowLinkTop;
+}
+
+void PasswordCheckWidget::resizeEvent(QResizeEvent *e) {
 	Step::resizeEvent(e);
 	updateControlsGeometry();
 }
 
-void PwdCheckWidget::updateControlsGeometry() {
+void PasswordCheckWidget::updateControlsGeometry() {
 	_pwdField->moveToLeft(contentLeft(), contentTop() + st::introPasswordTop);
 	_pwdHint->moveToLeft(contentLeft() + st::buttonRadius, contentTop() + st::introPasswordHintTop);
 	_codeField->moveToLeft(contentLeft(), contentTop() + st::introStepFieldTop);
@@ -91,7 +96,7 @@ void PwdCheckWidget::updateControlsGeometry() {
 	_toPassword->moveToLeft(contentLeft() + st::buttonRadius, linkTop);
 }
 
-void PwdCheckWidget::setInnerFocus() {
+void PasswordCheckWidget::setInnerFocus() {
 	if (_pwdField->isHidden()) {
 		_codeField->setFocusFast();
 	} else {
@@ -99,7 +104,7 @@ void PwdCheckWidget::setInnerFocus() {
 	}
 }
 
-void PwdCheckWidget::activate() {
+void PasswordCheckWidget::activate() {
 	if (_pwdField->isHidden() && _codeField->isHidden()) {
 		Step::activate();
 		_pwdField->show();
@@ -109,30 +114,12 @@ void PwdCheckWidget::activate() {
 	setInnerFocus();
 }
 
-void PwdCheckWidget::cancelled() {
-	request(base::take(_sentRequest)).cancel();
-}
-
-void PwdCheckWidget::stopCheck() {
-	_checkRequest->stop();
+void PasswordCheckWidget::cancelled() {
+	_api.request(base::take(_sentRequest)).cancel();
 }
 
-void PwdCheckWidget::onCheckRequest() {
-	auto status = MTP::state(_sentRequest);
-	if (status < 0) {
-		auto leftms = -status;
-		if (leftms >= 1000) {
-			request(base::take(_sentRequest)).cancel();
-		}
-	}
-	if (!_sentRequest && status == MTP::RequestSent) {
-		stopCheck();
-	}
-}
-
-void PwdCheckWidget::pwdSubmitDone(bool recover, const MTPauth_Authorization &result) {
+void PasswordCheckWidget::pwdSubmitDone(bool recover, const MTPauth_Authorization &result) {
 	_sentRequest = 0;
-	stopCheck();
 	if (recover) {
 		cSetPasswordRecovered(true);
 	}
@@ -144,17 +131,15 @@ void PwdCheckWidget::pwdSubmitDone(bool recover, const MTPauth_Authorization &re
 	finish(d.vuser());
 }
 
-void PwdCheckWidget::pwdSubmitFail(const RPCError &error) {
+void PasswordCheckWidget::pwdSubmitFail(const RPCError &error) {
 	if (MTP::isFloodError(error)) {
 		_sentRequest = 0;
-		stopCheck();
 		showError(tr::lng_flood_error());
 		_pwdField->showError();
 		return;
 	}
 
 	_sentRequest = 0;
-	stopCheck();
 	const auto &type = error.type();
 	if (type == qstr("PASSWORD_HASH_INVALID")
 		|| type == qstr("SRP_PASSWORD_CHANGED")) {
@@ -176,7 +161,7 @@ void PwdCheckWidget::pwdSubmitFail(const RPCError &error) {
 	}
 }
 
-void PwdCheckWidget::handleSrpIdInvalid() {
+void PasswordCheckWidget::handleSrpIdInvalid() {
 	const auto now = crl::now();
 	if (_lastSrpIdInvalidTime > 0
 		&& now - _lastSrpIdInvalidTime < Core::kHandleSrpIdInvalidTimeout) {
@@ -188,7 +173,7 @@ void PwdCheckWidget::handleSrpIdInvalid() {
 	}
 }
 
-void PwdCheckWidget::checkPasswordHash() {
+void PasswordCheckWidget::checkPasswordHash() {
 	if (_request.id) {
 		passwordChecked();
 	} else {
@@ -196,9 +181,9 @@ void PwdCheckWidget::checkPasswordHash() {
 	}
 }
 
-void PwdCheckWidget::requestPasswordData() {
-	request(base::take(_sentRequest)).cancel();
-	_sentRequest = request(
+void PasswordCheckWidget::requestPasswordData() {
+	_api.request(base::take(_sentRequest)).cancel();
+	_sentRequest = _api.request(
 		MTPaccount_GetPassword()
 	).done([=](const MTPaccount_Password &result) {
 		_sentRequest = 0;
@@ -209,7 +194,7 @@ void PwdCheckWidget::requestPasswordData() {
 	}).send();
 }
 
-void PwdCheckWidget::passwordChecked() {
+void PasswordCheckWidget::passwordChecked() {
 	if (!_request || !_request.id) {
 		return serverError();
 	}
@@ -220,7 +205,7 @@ void PwdCheckWidget::passwordChecked() {
 		return serverError();
 	}
 	_request.id = 0;
-	_sentRequest = request(
+	_sentRequest = _api.request(
 		MTPauth_CheckPassword(check.result)
 	).done([=](const MTPauth_Authorization &result) {
 		pwdSubmitDone(false, result);
@@ -229,11 +214,11 @@ void PwdCheckWidget::passwordChecked() {
 	}).send();
 }
 
-void PwdCheckWidget::serverError() {
+void PasswordCheckWidget::serverError() {
 	showError(rpl::single(Lang::Hard::ServerError()));
 }
 
-void PwdCheckWidget::codeSubmitFail(const RPCError &error) {
+void PasswordCheckWidget::codeSubmitFail(const RPCError &error) {
 	if (MTP::isFloodError(error)) {
 		showError(tr::lng_flood_error());
 		_codeField->showError();
@@ -241,7 +226,6 @@ void PwdCheckWidget::codeSubmitFail(const RPCError &error) {
 	}
 
 	_sentRequest = 0;
-	stopCheck();
 	const auto &type = error.type();
 	if (type == qstr("PASSWORD_EMPTY")
 		|| type == qstr("AUTH_KEY_UNREGISTERED")) {
@@ -250,7 +234,7 @@ void PwdCheckWidget::codeSubmitFail(const RPCError &error) {
 		recoverStartFail(error);
 	} else if (type == qstr("PASSWORD_RECOVERY_EXPIRED")) {
 		_emailPattern = QString();
-		onToPassword();
+		toPassword();
 	} else if (type == qstr("CODE_INVALID")) {
 		showError(tr::lng_signin_wrong_code());
 		_codeField->selectAll();
@@ -265,13 +249,12 @@ void PwdCheckWidget::codeSubmitFail(const RPCError &error) {
 	}
 }
 
-void PwdCheckWidget::recoverStarted(const MTPauth_PasswordRecovery &result) {
+void PasswordCheckWidget::recoverStarted(const MTPauth_PasswordRecovery &result) {
 	_emailPattern = qs(result.c_auth_passwordRecovery().vemail_pattern());
 	updateDescriptionText();
 }
 
-void PwdCheckWidget::recoverStartFail(const RPCError &error) {
-	stopCheck();
+void PasswordCheckWidget::recoverStartFail(const RPCError &error) {
 	_pwdField->show();
 	_pwdHint->show();
 	_codeField->hide();
@@ -281,10 +264,10 @@ void PwdCheckWidget::recoverStartFail(const RPCError &error) {
 	hideError();
 }
 
-void PwdCheckWidget::onToRecover() {
+void PasswordCheckWidget::toRecover() {
 	if (_hasRecovery) {
 		if (_sentRequest) {
-			request(base::take(_sentRequest)).cancel();
+			_api.request(base::take(_sentRequest)).cancel();
 		}
 		hideError();
 		_toRecover->hide();
@@ -296,7 +279,7 @@ void PwdCheckWidget::onToRecover() {
 		_codeField->setFocus();
 		updateDescriptionText();
 		if (_emailPattern.isEmpty()) {
-			request(
+			_api.request(
 				MTPauth_RequestPasswordRecovery()
 			).done([=](const MTPauth_PasswordRecovery &result) {
 				recoverStarted(result);
@@ -305,17 +288,21 @@ void PwdCheckWidget::onToRecover() {
 			}).send();
 		}
 	} else {
-		Ui::show(Box<InformBox>(tr::lng_signin_no_email_forgot(tr::now), [this] { showReset(); }));
+		Ui::show(Box<InformBox>(
+			tr::lng_signin_no_email_forgot(tr::now),
+			[=] { showReset(); }));
 	}
 }
 
-void PwdCheckWidget::onToPassword() {
-	Ui::show(Box<InformBox>(tr::lng_signin_cant_email_forgot(tr::now), [this] { showReset(); }));
+void PasswordCheckWidget::toPassword() {
+	Ui::show(Box<InformBox>(
+		tr::lng_signin_cant_email_forgot(tr::now),
+		[=] { showReset(); }));
 }
 
-void PwdCheckWidget::showReset() {
+void PasswordCheckWidget::showReset() {
 	if (_sentRequest) {
-		request(base::take(_sentRequest)).cancel();
+		_api.request(base::take(_sentRequest)).cancel();
 	}
 	_toRecover->show();
 	_toPassword->hide();
@@ -329,7 +316,7 @@ void PwdCheckWidget::showReset() {
 	update();
 }
 
-void PwdCheckWidget::updateDescriptionText() {
+void PasswordCheckWidget::updateDescriptionText() {
 	auto pwdHidden = _pwdField->isHidden();
 	auto emailPattern = _emailPattern;
 	setDescriptionText(pwdHidden
@@ -337,12 +324,10 @@ void PwdCheckWidget::updateDescriptionText() {
 		: tr::lng_signin_desc());
 }
 
-void PwdCheckWidget::onInputChange() {
-	hideError();
-}
-
-void PwdCheckWidget::submit() {
-	if (_sentRequest) return;
+void PasswordCheckWidget::submit() {
+	if (_sentRequest) {
+		return;
+	}
 	if (_pwdField->isHidden()) {
 		auto code = _codeField->getLastText().trimmed();
 		if (code.isEmpty()) {
@@ -350,7 +335,7 @@ void PwdCheckWidget::submit() {
 			return;
 		}
 		const auto send = crl::guard(this, [=] {
-			_sentRequest = request(
+			_sentRequest = _api.request(
 				MTPauth_RecoverPassword(MTP_string(code))
 			).done([=](const MTPauth_Authorization &result) {
 				pwdSubmitDone(true, result);
@@ -385,8 +370,9 @@ void PwdCheckWidget::submit() {
 	}
 }
 
-rpl::producer<QString> PwdCheckWidget::nextButtonText() const {
+rpl::producer<QString> PasswordCheckWidget::nextButtonText() const {
 	return tr::lng_intro_submit();
 }
 
+} // namespace details
 } // namespace Intro
diff --git a/Telegram/SourceFiles/intro/intropwdcheck.h b/Telegram/SourceFiles/intro/intro_password_check.h
similarity index 84%
rename from Telegram/SourceFiles/intro/intropwdcheck.h
rename to Telegram/SourceFiles/intro/intro_password_check.h
index a0fc7b555..fb16aae74 100644
--- a/Telegram/SourceFiles/intro/intropwdcheck.h
+++ b/Telegram/SourceFiles/intro/intro_password_check.h
@@ -7,8 +7,10 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 */
 #pragma once
 
-#include "intro/introwidget.h"
+#include "intro/intro_step.h"
+#include "core/core_cloud_password.h"
 #include "mtproto/sender.h"
+#include "base/timer.h"
 
 namespace Ui {
 class InputField;
@@ -18,15 +20,14 @@ class LinkButton;
 } // namespace Ui
 
 namespace Intro {
+namespace details {
 
-class PwdCheckWidget : public Widget::Step, private MTP::Sender {
-	Q_OBJECT
-
+class PasswordCheckWidget final : public Step {
 public:
-	PwdCheckWidget(
+	PasswordCheckWidget(
 		QWidget *parent,
 		not_null<Main::Account*> account,
-		not_null<Widget::Data*> data);
+		not_null<Data*> data);
 
 	void setInnerFocus() override;
 	void activate() override;
@@ -37,13 +38,12 @@ public:
 protected:
 	void resizeEvent(QResizeEvent *e) override;
 
-private slots:
-	void onToRecover();
-	void onToPassword();
-	void onInputChange();
-	void onCheckRequest();
-
 private:
+	void toRecover();
+	void toPassword();
+
+	int errorTop() const override;
+
 	void showReset();
 	void refreshLang();
 	void updateControlsGeometry();
@@ -56,13 +56,13 @@ private:
 	void recoverStarted(const MTPauth_PasswordRecovery &result);
 
 	void updateDescriptionText();
-	void stopCheck();
 	void handleSrpIdInvalid();
 	void requestPasswordData();
 	void checkPasswordHash();
 	void passwordChecked();
 	void serverError();
 
+	MTP::Sender _api;
 	Core::CloudPasswordCheckRequest _request;
 	crl::time _lastSrpIdInvalidTime = 0;
 	bytes::vector _passwordHash;
@@ -77,8 +77,7 @@ private:
 	object_ptr<Ui::LinkButton> _toPassword;
 	mtpRequestId _sentRequest = 0;
 
-	object_ptr<QTimer> _checkRequest;
-
 };
 
+} // namespace details
 } // namespace Intro
diff --git a/Telegram/SourceFiles/intro/introphone.cpp b/Telegram/SourceFiles/intro/intro_phone.cpp
similarity index 77%
rename from Telegram/SourceFiles/intro/introphone.cpp
rename to Telegram/SourceFiles/intro/intro_phone.cpp
index d9a3e2d5f..c7f70c521 100644
--- a/Telegram/SourceFiles/intro/introphone.cpp
+++ b/Telegram/SourceFiles/intro/intro_phone.cpp
@@ -5,21 +5,24 @@ the official desktop application for the Telegram messaging service.
 For license and copyright information please follow this link:
 https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 */
-#include "intro/introphone.h"
+#include "intro/intro_phone.h"
 
 #include "lang/lang_keys.h"
-#include "intro/introcode.h"
+#include "intro/intro_code.h"
+#include "intro/intro_qr.h"
 #include "styles/style_intro.h"
 #include "ui/widgets/buttons.h"
 #include "ui/widgets/labels.h"
 #include "ui/wrap/fade_wrap.h"
 #include "ui/special_fields.h"
 #include "main/main_account.h"
+#include "main/main_app_config.h"
 #include "boxes/confirm_phone_box.h"
 #include "boxes/confirm_box.h"
 #include "core/application.h"
 
 namespace Intro {
+namespace details {
 namespace {
 
 bool AllowPhoneAttempt(const QString &phone) {
@@ -34,33 +37,61 @@ bool AllowPhoneAttempt(const QString &phone) {
 PhoneWidget::PhoneWidget(
 	QWidget *parent,
 	not_null<Main::Account*> account,
-	not_null<Widget::Data*> data)
+	not_null<Data*> data)
 : Step(parent, account, data)
 , _country(this, st::introCountry)
 , _code(this, st::introCountryCode)
 , _phone(this, st::introPhone)
-, _checkRequest(this) {
+, _checkRequestTimer([=] { checkRequest(); }) {
 	connect(_phone, SIGNAL(voidBackspace(QKeyEvent*)), _code, SLOT(startErasing(QKeyEvent*)));
 	connect(_country, SIGNAL(codeChanged(const QString &)), _code, SLOT(codeSelected(const QString &)));
 	connect(_code, SIGNAL(codeChanged(const QString &)), _country, SLOT(onChooseCode(const QString &)));
 	connect(_code, SIGNAL(codeChanged(const QString &)), _phone, SLOT(onChooseCode(const QString &)));
 	connect(_country, SIGNAL(codeChanged(const QString &)), _phone, SLOT(onChooseCode(const QString &)));
 	connect(_code, SIGNAL(addedToNumber(const QString &)), _phone, SLOT(addedToNumber(const QString &)));
-	connect(_phone, SIGNAL(changed()), this, SLOT(onInputChange()));
-	connect(_code, SIGNAL(changed()), this, SLOT(onInputChange()));
-	connect(_checkRequest, SIGNAL(timeout()), this, SLOT(onCheckRequest()));
+	connect(_phone, &Ui::PhonePartInput::changed, [=] { phoneChanged(); });
+	connect(_code, &Ui::CountryCodeInput::changed, [=] { phoneChanged(); });
 
 	setTitleText(tr::lng_phone_title());
 	setDescriptionText(tr::lng_phone_desc());
-	subscribe(getData()->updated, [this] { countryChanged(); });
+	subscribe(getData()->updated, [=] { countryChanged(); });
 	setErrorCentered(true);
+	setupQrLogin();
 
 	if (!_country->onChooseCountry(getData()->country)) {
 		_country->onChooseCountry(qsl("US"));
 	}
 	_changed = false;
+}
 
-	account->destroyStaleAuthorizationKeys();
+void PhoneWidget::setupQrLogin() {
+	rpl::single(
+		rpl::empty_value()
+	) | rpl::then(
+		account().appConfig().refreshed()
+	) | rpl::map([=] {
+		return account().appConfig().get<QString>(
+			"qr_login_code",
+			"disabled");
+	}) | rpl::filter([](const QString &value) {
+		return (value != "disabled");
+	}) | rpl::take(1) | rpl::start_with_next([=] {
+		const auto qrLogin = Ui::CreateChild<Ui::LinkButton>(
+			this,
+			tr::lng_phone_to_qr(tr::now));
+		qrLogin->show();
+
+		rpl::combine(
+			sizeValue(),
+			qrLogin->widthValue()
+		) | rpl::start_with_next([=](QSize size, int qrLoginWidth) {
+			qrLogin->moveToLeft(
+				(size.width() - qrLoginWidth) / 2,
+				contentTop() + st::introQrLoginLinkTop);
+		}, qrLogin->lifetime());
+
+		qrLogin->setClickedCallback([=] { goReplace<QrWidget>(); });
+	}, lifetime());
 }
 
 void PhoneWidget::resizeEvent(QResizeEvent *e) {
@@ -69,13 +100,6 @@ void PhoneWidget::resizeEvent(QResizeEvent *e) {
 	auto phoneTop = _country->y() + _country->height() + st::introPhoneTop;
 	_code->moveToLeft(contentLeft(), phoneTop);
 	_phone->moveToLeft(contentLeft() + _country->width() - st::introPhone.width, phoneTop);
-	updateSignupGeometry();
-}
-
-void PhoneWidget::updateSignupGeometry() {
-	if (_signup) {
-		_signup->moveToLeft(contentLeft() + st::buttonRadius, contentTop() + st::introDescriptionTop);
-	}
 }
 
 void PhoneWidget::showPhoneError(rpl::producer<QString> text) {
@@ -85,10 +109,6 @@ void PhoneWidget::showPhoneError(rpl::producer<QString> text) {
 
 void PhoneWidget::hidePhoneError() {
 	hideError();
-	if (_signup) {
-		_signup->hide(anim::type::instant);
-		showDescription();
-	}
 }
 
 void PhoneWidget::countryChanged() {
@@ -97,7 +117,7 @@ void PhoneWidget::countryChanged() {
 	}
 }
 
-void PhoneWidget::onInputChange() {
+void PhoneWidget::phoneChanged() {
 	_changed = true;
 	hidePhoneError();
 }
@@ -114,7 +134,7 @@ void PhoneWidget::submit() {
 
 	hidePhoneError();
 
-	_checkRequest->start(1000);
+	_checkRequestTimer.callEach(1000);
 
 	_sentPhone = phone;
 	account().mtp()->setUserPhone(_sentPhone);
@@ -129,10 +149,10 @@ void PhoneWidget::submit() {
 }
 
 void PhoneWidget::stopCheck() {
-	_checkRequest->stop();
+	_checkRequestTimer.cancel();
 }
 
-void PhoneWidget::onCheckRequest() {
+void PhoneWidget::checkRequest() {
 	auto status = MTP::state(_sentRequest);
 	if (status < 0) {
 		auto leftms = -status;
@@ -160,10 +180,10 @@ void PhoneWidget::phoneSubmitDone(const MTPauth_SentCode &result) {
 	getData()->phoneHash = qba(d.vphone_code_hash());
 	const auto next = d.vnext_type();
 	if (next && next->type() == mtpc_auth_codeTypeCall) {
-		getData()->callStatus = Widget::Data::CallStatus::Waiting;
+		getData()->callStatus = CallStatus::Waiting;
 		getData()->callTimeout = d.vtimeout().value_or(60);
 	} else {
-		getData()->callStatus = Widget::Data::CallStatus::Disabled;
+		getData()->callStatus = CallStatus::Disabled;
 		getData()->callTimeout = 0;
 	}
 	goNext<CodeWidget>();
@@ -213,15 +233,13 @@ void PhoneWidget::setInnerFocus() {
 
 void PhoneWidget::activate() {
 	Step::activate();
-	_country->show();
-	_phone->show();
-	_code->show();
+	showChildren();
 	setInnerFocus();
 }
 
 void PhoneWidget::finished() {
 	Step::finished();
-	_checkRequest->stop();
+	_checkRequestTimer.cancel();
 	rpcInvalidate();
 
 	cancelled();
@@ -231,4 +249,5 @@ void PhoneWidget::cancelled() {
 	MTP::cancel(base::take(_sentRequest));
 }
 
+} // namespace details
 } // namespace Intro
diff --git a/Telegram/SourceFiles/intro/introphone.h b/Telegram/SourceFiles/intro/intro_phone.h
similarity index 80%
rename from Telegram/SourceFiles/intro/introphone.h
rename to Telegram/SourceFiles/intro/intro_phone.h
index 60e706345..29e6699fc 100644
--- a/Telegram/SourceFiles/intro/introphone.h
+++ b/Telegram/SourceFiles/intro/intro_phone.h
@@ -8,7 +8,8 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #pragma once
 
 #include "ui/countryinput.h"
-#include "intro/introwidget.h"
+#include "intro/intro_step.h"
+#include "base/timer.h"
 
 namespace Ui {
 class PhonePartInput;
@@ -18,15 +19,14 @@ class FlatLabel;
 } // namespace Ui
 
 namespace Intro {
+namespace details {
 
-class PhoneWidget : public Widget::Step {
-	Q_OBJECT
-
+class PhoneWidget final : public Step {
 public:
 	PhoneWidget(
 		QWidget *parent,
 		not_null<Main::Account*> account,
-		not_null<Widget::Data*> data);
+		not_null<Data*> data);
 
 	void selectCountry(const QString &country);
 
@@ -43,12 +43,10 @@ public:
 protected:
 	void resizeEvent(QResizeEvent *e) override;
 
-private slots:
-	void onInputChange();
-	void onCheckRequest();
-
 private:
-	void updateSignupGeometry();
+	void setupQrLogin();
+	void phoneChanged();
+	void checkRequest();
 	void countryChanged();
 
 	void phoneSubmitDone(const MTPauth_SentCode &result);
@@ -66,13 +64,12 @@ private:
 	object_ptr<Ui::CountryCodeInput> _code;
 	object_ptr<Ui::PhonePartInput> _phone;
 
-	object_ptr<Ui::FadeWrap<Ui::FlatLabel>> _signup = { nullptr };
-
 	QString _sentPhone;
 	mtpRequestId _sentRequest = 0;
 
-	object_ptr<QTimer> _checkRequest;
+	base::Timer _checkRequestTimer;
 
 };
 
+} // namespace details
 } // namespace Intro
diff --git a/Telegram/SourceFiles/intro/intro_qr.cpp b/Telegram/SourceFiles/intro/intro_qr.cpp
new file mode 100644
index 000000000..51294a4a4
--- /dev/null
+++ b/Telegram/SourceFiles/intro/intro_qr.cpp
@@ -0,0 +1,436 @@
+/*
+This file is part of Telegram Desktop,
+the official desktop application for the Telegram messaging service.
+
+For license and copyright information please follow this link:
+https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+*/
+#include "intro/intro_qr.h"
+
+#include "intro/intro_phone.h"
+#include "intro/intro_widget.h"
+#include "intro/intro_password_check.h"
+#include "lang/lang_keys.h"
+#include "ui/widgets/buttons.h"
+#include "ui/widgets/labels.h"
+#include "ui/wrap/fade_wrap.h"
+#include "ui/wrap/vertical_layout.h"
+#include "ui/effects/radial_animation.h"
+#include "ui/text/text_utilities.h"
+#include "ui/image/image_prepare.h"
+#include "ui/painter.h"
+#include "main/main_account.h"
+#include "boxes/confirm_box.h"
+#include "core/application.h"
+#include "core/core_cloud_password.h"
+#include "core/update_checker.h"
+#include "base/unixtime.h"
+#include "qr/qr_generate.h"
+#include "styles/style_intro.h"
+
+namespace Intro {
+namespace details {
+namespace {
+
+[[nodiscard]] QImage TelegramLogoImage() {
+	const auto size = QSize(st::introQrCenterSize, st::introQrCenterSize);
+	auto result = QImage(
+		size * style::DevicePixelRatio(),
+		QImage::Format_ARGB32_Premultiplied);
+	result.fill(Qt::transparent);
+	result.setDevicePixelRatio(style::DevicePixelRatio());
+	{
+		auto p = QPainter(&result);
+		auto hq = PainterHighQualityEnabler(p);
+		p.setBrush(st::activeButtonBg);
+		p.setPen(Qt::NoPen);
+		p.drawEllipse(QRect(QPoint(), size));
+		st::introQrPlane.paintInCenter(p, QRect(QPoint(), size));
+	}
+	return result;
+}
+
+[[nodiscard]] QImage TelegramQrExact(const Qr::Data &data, int pixel) {
+	return Qr::Generate(data, pixel, st::windowFg->c);
+}
+
+[[nodiscard]] QImage TelegramQr(const Qr::Data &data, int pixel, int max = 0) {
+	Expects(data.size > 0);
+
+	if (max > 0 && data.size * pixel > max) {
+		pixel = std::max(max / data.size, 1);
+	}
+	const auto qr = TelegramQrExact(data, pixel * style::DevicePixelRatio());
+	auto result = QImage(qr.size(), QImage::Format_ARGB32_Premultiplied);
+	result.fill(st::windowBg->c);
+	{
+		auto p = QPainter(&result);
+		p.drawImage(QRect(QPoint(), qr.size()), qr);
+	}
+	return result;
+}
+
+[[nodiscard]] not_null<Ui::RpWidget*> PrepareQrWidget(
+		not_null<QWidget*> parent,
+		rpl::producer<QByteArray> codes) {
+	struct State {
+		explicit State(Fn<void()> callback)
+		: waiting(callback, st::defaultInfiniteRadialAnimation) {
+		}
+
+		QImage previous;
+		QImage qr;
+		QImage center;
+		Ui::Animations::Simple shown;
+		Ui::InfiniteRadialAnimation waiting;
+	};
+	auto qrs = std::move(
+		codes
+	) | rpl::map([](const QByteArray &code) {
+		return Qr::Encode(code, Qr::Redundancy::Quartile);
+	});
+	auto palettes = rpl::single(
+		rpl::empty_value()
+	) | rpl::then(
+		style::PaletteChanged()
+	);
+	auto result = Ui::CreateChild<Ui::RpWidget>(parent.get());
+	const auto state = result->lifetime().make_state<State>(
+		[=] { result->update(); });
+	state->waiting.start();
+	result->resize(st::introQrMaxSize, st::introQrMaxSize);
+	rpl::combine(
+		std::move(qrs),
+		rpl::duplicate(palettes)
+	) | rpl::map([](const Qr::Data &code, const auto &) {
+		return TelegramQr(code, st::introQrPixel, st::introQrMaxSize);
+	}) | rpl::start_with_next([=](QImage &&image) {
+		state->previous = std::move(state->qr);
+		state->qr = std::move(image);
+		state->waiting.stop();
+		state->shown.stop();
+		state->shown.start(
+			[=] { result->update(); },
+			0.,
+			1.,
+			st::fadeWrapDuration);
+	}, result->lifetime());
+	std::move(
+		palettes
+	) | rpl::map([] {
+		return TelegramLogoImage();
+	}) | rpl::start_with_next([=](QImage &&image) {
+		state->center = std::move(image);
+	}, result->lifetime());
+	result->paintRequest(
+	) | rpl::start_with_next([=](QRect clip) {
+		auto p = QPainter(result);
+		const auto shown = state->qr.isNull() ? 0. : state->shown.value(1.);
+		if (!state->qr.isNull()) {
+			const auto size = state->qr.size() / cIntRetinaFactor();
+			const auto qr = QRect(
+				(result->width() - size.width()) / 2,
+				(result->height() - size.height()) / 2,
+				size.width(),
+				size.height());
+			if (shown == 1.) {
+				state->previous = QImage();
+			} else if (!state->previous.isNull()) {
+				p.drawImage(qr, state->previous);
+			}
+			p.setOpacity(shown);
+			p.drawImage(qr, state->qr);
+			p.setOpacity(1.);
+		}
+		const auto rect = QRect(
+			(result->width() - st::introQrCenterSize) / 2,
+			(result->height() - st::introQrCenterSize) / 2,
+			st::introQrCenterSize,
+			st::introQrCenterSize);
+		p.drawImage(rect, state->center);
+		if (!anim::Disabled() && state->waiting.animating()) {
+			auto hq = PainterHighQualityEnabler(p);
+			const auto line = st::radialLine;
+			const auto radial = state->waiting.computeState();
+			auto pen = st::activeButtonBg->p;
+			pen.setWidth(line);
+			pen.setCapStyle(Qt::RoundCap);
+			p.setOpacity(radial.shown * (1. - shown));
+			p.setPen(pen);
+			p.drawArc(
+				rect.marginsAdded({ line, line, line, line }),
+				radial.arcFrom,
+				radial.arcLength);
+			p.setOpacity(1.);
+		}
+	}, result->lifetime());
+	return result;
+}
+
+} // namespace
+
+QrWidget::QrWidget(
+	QWidget *parent,
+	not_null<Main::Account*> account,
+	not_null<Data*> data)
+: Step(parent, account, data)
+, _api(account->mtp())
+, _refreshTimer([=] { refreshCode(); }) {
+	setTitleText(rpl::single(QString()));
+	setDescriptionText(rpl::single(QString()));
+	setErrorCentered(true);
+
+	account->mtpUpdates(
+	) | rpl::start_with_next([=](const MTPUpdates &updates) {
+		checkForTokenUpdate(updates);
+	}, lifetime());
+
+	setupControls();
+	refreshCode();
+}
+
+int QrWidget::errorTop() const {
+	return contentTop() + st::introQrErrorTop;
+}
+
+void QrWidget::checkForTokenUpdate(const MTPUpdates &updates) {
+	updates.match([&](const MTPDupdateShort &data) {
+		checkForTokenUpdate(data.vupdate());
+	}, [&](const MTPDupdates &data) {
+		for (const auto &update : data.vupdates().v) {
+			checkForTokenUpdate(update);
+		}
+	}, [&](const MTPDupdatesCombined &data) {
+		for (const auto &update : data.vupdates().v) {
+			checkForTokenUpdate(update);
+		}
+	}, [](const auto &) {});
+}
+
+void QrWidget::checkForTokenUpdate(const MTPUpdate &update) {
+	update.match([&](const MTPDupdateLoginToken &data) {
+		if (_requestId) {
+			_forceRefresh = true;
+		} else {
+			_refreshTimer.cancel();
+			refreshCode();
+		}
+	}, [](const auto &) {});
+}
+
+void QrWidget::submit() {
+	goReplace<PhoneWidget>();
+}
+
+rpl::producer<QString> QrWidget::nextButtonText() const {
+	return rpl::single(QString());
+}
+
+void QrWidget::setupControls() {
+	const auto code = PrepareQrWidget(this, _qrCodes.events());
+	rpl::combine(
+		sizeValue(),
+		code->widthValue()
+	) | rpl::start_with_next([=](QSize size, int codeWidth) {
+		code->moveToLeft(
+			(size.width() - codeWidth) / 2,
+			contentTop() + st::introQrTop);
+	}, code->lifetime());
+
+	const auto title = Ui::CreateChild<Ui::FlatLabel>(
+		this,
+		tr::lng_intro_qr_title(),
+		st::introQrTitle);
+	rpl::combine(
+		sizeValue(),
+		title->widthValue()
+	) | rpl::start_with_next([=](QSize size, int titleWidth) {
+		title->resizeToWidth(st::introQrTitleWidth);
+		const auto oneLine = st::introQrTitle.style.font->height;
+		const auto topDelta = (title->height() - oneLine);
+		title->moveToLeft(
+			(size.width() - title->width()) / 2,
+			contentTop() + st::introQrTitleTop - topDelta);
+	}, title->lifetime());
+
+	const auto steps = Ui::CreateChild<Ui::VerticalLayout>(this);
+	const auto texts = {
+		tr::lng_intro_qr_step1,
+		tr::lng_intro_qr_step2,
+		tr::lng_intro_qr_step3,
+	};
+	auto index = 0;
+	for (const auto &text : texts) {
+		const auto label = steps->add(
+			object_ptr<Ui::FlatLabel>(
+				steps,
+				text(Ui::Text::RichLangValue),
+				st::introQrStep),
+			st::introQrStepMargins);
+		const auto number = Ui::CreateChild<Ui::FlatLabel>(
+			steps,
+			rpl::single(Ui::Text::Bold(QString::number(++index) + ".")),
+			st::defaultFlatLabel);
+		rpl::combine(
+			number->widthValue(),
+			label->positionValue()
+		) | rpl::start_with_next([=](int width, QPoint position) {
+			number->moveToLeft(
+				position.x() - width - st::normalFont->spacew,
+				position.y());
+		}, number->lifetime());
+	}
+	steps->resizeToWidth(st::introQrLabelsWidth);
+	rpl::combine(
+		sizeValue(),
+		steps->widthValue()
+	) | rpl::start_with_next([=](QSize size, int stepsWidth) {
+		steps->moveToLeft(
+			(size.width() - stepsWidth) / 2,
+			contentTop() + st::introQrStepsTop);
+	}, steps->lifetime());
+
+	const auto skip = Ui::CreateChild<Ui::LinkButton>(
+		this,
+		tr::lng_intro_qr_skip(tr::now));
+	rpl::combine(
+		sizeValue(),
+		skip->widthValue()
+	) | rpl::start_with_next([=](QSize size, int skipWidth) {
+		skip->moveToLeft(
+			(size.width() - skipWidth) / 2,
+			contentTop() + st::introQrSkipTop);
+	}, skip->lifetime());
+
+	skip->setClickedCallback([=] { submit(); });
+}
+
+void QrWidget::refreshCode() {
+	if (_requestId) {
+		return;
+	}
+	_requestId = _api.request(MTPauth_ExportLoginToken(
+		MTP_int(ApiId),
+		MTP_string(ApiHash),
+		MTP_vector<MTPint>(0)
+	)).done([=](const MTPauth_LoginToken &result) {
+		handleTokenResult(result);
+	}).fail([=](const RPCError &error) {
+		showTokenError(error);
+	}).send();
+}
+
+void QrWidget::handleTokenResult(const MTPauth_LoginToken &result) {
+	result.match([&](const MTPDauth_loginToken &data) {
+		_requestId = 0;
+		showToken(data.vtoken().v);
+
+		if (base::take(_forceRefresh)) {
+			refreshCode();
+		} else {
+			const auto left = data.vexpires().v - base::unixtime::now();
+			_refreshTimer.callOnce(std::max(left, 1) * crl::time(1000));
+		}
+	}, [&](const MTPDauth_loginTokenMigrateTo &data) {
+		importTo(data.vdc_id().v, data.vtoken().v);
+	}, [&](const MTPDauth_loginTokenSuccess &data) {
+		done(data.vauthorization());
+	});
+}
+
+void QrWidget::showTokenError(const RPCError &error) {
+	_requestId = 0;
+	if (error.type() == qstr("SESSION_PASSWORD_NEEDED")) {
+		sendCheckPasswordRequest();
+	} else if (base::take(_forceRefresh)) {
+		refreshCode();
+	} else {
+		showError(rpl::single(error.type()));
+	}
+}
+
+void QrWidget::showToken(const QByteArray &token) {
+	const auto encoded = token.toBase64(QByteArray::Base64UrlEncoding);
+	_qrCodes.fire_copy("tg://login?token=" + encoded);
+}
+
+void QrWidget::importTo(MTP::DcId dcId, const QByteArray &token) {
+	Expects(_requestId != 0);
+
+	_api.instance()->setMainDcId(dcId);
+	_requestId = _api.request(MTPauth_ImportLoginToken(
+		MTP_bytes(token)
+	)).done([=](const MTPauth_LoginToken &result) {
+		handleTokenResult(result);
+	}).fail([=](const RPCError &error) {
+		showTokenError(error);
+	}).toDC(dcId).send();
+}
+
+void QrWidget::done(const MTPauth_Authorization &authorization) {
+	authorization.match([&](const MTPDauth_authorization &data) {
+		if (data.vuser().type() != mtpc_user
+			|| !data.vuser().c_user().is_self()) {
+			showError(rpl::single(Lang::Hard::ServerError()));
+			return;
+		}
+		const auto phone = data.vuser().c_user().vphone().value_or_empty();
+		cSetLoggedPhoneNumber(phone);
+		finish(data.vuser());
+	}, [&](const MTPDauth_authorizationSignUpRequired &data) {
+		_requestId = 0;
+		LOG(("API Error: Unexpected auth.authorizationSignUpRequired."));
+		showError(rpl::single(Lang::Hard::ServerError()));
+	});
+}
+
+void QrWidget::sendCheckPasswordRequest() {
+	_requestId = _api.request(MTPaccount_GetPassword(
+	)).done([=](const MTPaccount_Password &result) {
+		result.match([&](const MTPDaccount_password &data) {
+			getData()->pwdRequest = Core::ParseCloudPasswordCheckRequest(
+				data);
+			if (!data.vcurrent_algo() || !data.vsrp_id() || !data.vsrp_B()) {
+				LOG(("API Error: No current password received on login."));
+				goReplace<QrWidget>();
+				return;
+			} else if (!getData()->pwdRequest) {
+				const auto box = std::make_shared<QPointer<Ui::BoxContent>>();
+				const auto callback = [=] {
+					Core::UpdateApplication();
+					if (*box) (*box)->closeBox();
+				};
+				*box = Ui::show(Box<ConfirmBox>(
+					tr::lng_passport_app_out_of_date(tr::now),
+					tr::lng_menu_update(tr::now),
+					callback));
+				return;
+			}
+			getData()->hasRecovery = data.is_has_recovery();
+			getData()->pwdHint = qs(data.vhint().value_or_empty());
+			getData()->pwdNotEmptyPassport = data.is_has_secure_values();
+			goReplace<PasswordCheckWidget>();
+		});
+	}).fail([=](const RPCError &error) {
+		showTokenError(error);
+	}).send();
+}
+
+void QrWidget::activate() {
+	Step::activate();
+	showChildren();
+}
+
+void QrWidget::finished() {
+	Step::finished();
+	_refreshTimer.cancel();
+	rpcInvalidate();
+	cancelled();
+}
+
+void QrWidget::cancelled() {
+	_api.request(base::take(_requestId)).cancel();
+}
+
+} // namespace details
+} // namespace Intro
diff --git a/Telegram/SourceFiles/intro/intro_qr.h b/Telegram/SourceFiles/intro/intro_qr.h
new file mode 100644
index 000000000..aa099ca91
--- /dev/null
+++ b/Telegram/SourceFiles/intro/intro_qr.h
@@ -0,0 +1,65 @@
+/*
+This file is part of Telegram Desktop,
+the official desktop application for the Telegram messaging service.
+
+For license and copyright information please follow this link:
+https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+*/
+#pragma once
+
+#include "ui/countryinput.h"
+#include "intro/intro_step.h"
+#include "mtproto/sender.h"
+#include "base/timer.h"
+
+namespace Ui {
+class PhonePartInput;
+class CountryCodeInput;
+class RoundButton;
+class FlatLabel;
+} // namespace Ui
+
+namespace Intro {
+namespace details {
+
+class QrWidget final : public Step {
+public:
+	QrWidget(
+		QWidget *parent,
+		not_null<Main::Account*> account,
+		not_null<Data*> data);
+
+	void activate() override;
+	void finished() override;
+	void cancelled() override;
+	void submit() override;
+	rpl::producer<QString> nextButtonText() const override;
+
+	bool hasBack() const override {
+		return true;
+	}
+
+private:
+	int errorTop() const override;
+
+	void sendCheckPasswordRequest();
+	void setupControls();
+	void refreshCode();
+	void checkForTokenUpdate(const MTPUpdates &updates);
+	void checkForTokenUpdate(const MTPUpdate &update);
+	void handleTokenResult(const MTPauth_LoginToken &result);
+	void showTokenError(const RPCError &error);
+	void importTo(MTP::DcId dcId, const QByteArray &token);
+	void showToken(const QByteArray &token);
+	void done(const MTPauth_Authorization &authorization);
+
+	MTP::Sender _api;
+	rpl::event_stream<QByteArray> _qrCodes;
+	base::Timer _refreshTimer;
+	mtpRequestId _requestId = 0;
+	bool _forceRefresh = false;
+
+};
+
+} // namespace details
+} // namespace Intro
diff --git a/Telegram/SourceFiles/intro/introsignup.cpp b/Telegram/SourceFiles/intro/intro_signup.cpp
similarity index 89%
rename from Telegram/SourceFiles/intro/introsignup.cpp
rename to Telegram/SourceFiles/intro/intro_signup.cpp
index 01d71d369..e297dec66 100644
--- a/Telegram/SourceFiles/intro/introsignup.cpp
+++ b/Telegram/SourceFiles/intro/intro_signup.cpp
@@ -5,10 +5,9 @@ the official desktop application for the Telegram messaging service.
 For license and copyright information please follow this link:
 https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 */
-#include "intro/introsignup.h"
+#include "intro/intro_signup.h"
 
-#include "styles/style_intro.h"
-#include "styles/style_boxes.h"
+#include "intro/intro_widget.h"
 #include "core/file_utilities.h"
 #include "boxes/photo_crop_box.h"
 #include "boxes/confirm_box.h"
@@ -17,13 +16,16 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "ui/widgets/input_fields.h"
 #include "ui/widgets/labels.h"
 #include "ui/special_buttons.h"
+#include "styles/style_intro.h"
+#include "styles/style_boxes.h"
 
 namespace Intro {
+namespace details {
 
 SignupWidget::SignupWidget(
 	QWidget *parent,
 	not_null<Main::Account*> account,
-	not_null<Widget::Data*> data)
+	not_null<Data*> data)
 : Step(parent, account, data)
 , _photo(
 	this,
@@ -32,8 +34,7 @@ SignupWidget::SignupWidget(
 	st::defaultUserpicButton)
 , _first(this, st::introName, tr::lng_signup_firstname())
 , _last(this, st::introName, tr::lng_signup_lastname())
-, _invertOrder(langFirstNameGoesSecond())
-, _checkRequest(this) {
+, _invertOrder(langFirstNameGoesSecond()) {
 	subscribe(Lang::Current().updated(), [this] { refreshLang(); });
 	if (_invertOrder) {
 		setTabOrder(_last, _first);
@@ -41,8 +42,6 @@ SignupWidget::SignupWidget(
 		setTabOrder(_first, _last);
 	}
 
-	connect(_checkRequest, SIGNAL(timeout()), this, SLOT(onCheckRequest()));
-
 	setErrorCentered(true);
 
 	setTitleText(tr::lng_signup_title());
@@ -105,25 +104,7 @@ void SignupWidget::cancelled() {
 	MTP::cancel(base::take(_sentRequest));
 }
 
-void SignupWidget::stopCheck() {
-	_checkRequest->stop();
-}
-
-void SignupWidget::onCheckRequest() {
-	auto status = MTP::state(_sentRequest);
-	if (status < 0) {
-		auto leftms = -status;
-		if (leftms >= 1000) {
-			MTP::cancel(base::take(_sentRequest));
-		}
-	}
-	if (!_sentRequest && status == MTP::RequestSent) {
-		stopCheck();
-	}
-}
-
 void SignupWidget::nameSubmitDone(const MTPauth_Authorization &result) {
-	stopCheck();
 	auto &d = result.c_auth_authorization();
 	if (d.vuser().type() != mtpc_user || !d.vuser().c_user().is_self()) { // wtf?
 		showError(rpl::single(Lang::Hard::ServerError()));
@@ -134,7 +115,6 @@ void SignupWidget::nameSubmitDone(const MTPauth_Authorization &result) {
 
 bool SignupWidget::nameSubmitFail(const RPCError &error) {
 	if (MTP::isFloodError(error)) {
-		stopCheck();
 		showError(tr::lng_flood_error());
 		if (_invertOrder) {
 			_first->setFocus();
@@ -145,7 +125,6 @@ bool SignupWidget::nameSubmitFail(const RPCError &error) {
 	}
 	if (MTP::isDefaultHandledError(error)) return false;
 
-	stopCheck();
 	auto &err = error.type();
 	if (err == qstr("PHONE_NUMBER_FLOOD")) {
 		Ui::show(Box<InformBox>(tr::lng_error_phone_flood(tr::now)));
@@ -180,10 +159,6 @@ bool SignupWidget::nameSubmitFail(const RPCError &error) {
 	return false;
 }
 
-void SignupWidget::onInputChange() {
-	hideError();
-}
-
 void SignupWidget::submit() {
 	if (_sentRequest) {
 		return;
@@ -236,4 +211,5 @@ rpl::producer<QString> SignupWidget::nextButtonText() const {
 	return tr::lng_intro_finish();
 }
 
+} // namespace details
 } // namespace Intro
diff --git a/Telegram/SourceFiles/intro/introsignup.h b/Telegram/SourceFiles/intro/intro_signup.h
similarity index 82%
rename from Telegram/SourceFiles/intro/introsignup.h
rename to Telegram/SourceFiles/intro/intro_signup.h
index 7eadd5ae8..3867bcbbe 100644
--- a/Telegram/SourceFiles/intro/introsignup.h
+++ b/Telegram/SourceFiles/intro/intro_signup.h
@@ -7,7 +7,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 */
 #pragma once
 
-#include "intro/introwidget.h"
+#include "intro/intro_step.h"
 
 namespace Ui {
 class RoundButton;
@@ -16,15 +16,14 @@ class UserpicButton;
 } // namespace Ui
 
 namespace Intro {
+namespace details {
 
-class SignupWidget : public Widget::Step {
-	Q_OBJECT
-
+class SignupWidget final : public Step {
 public:
 	SignupWidget(
 		QWidget *parent,
 		not_null<Main::Account*> account,
-		not_null<Widget::Data*> data);
+		not_null<Data*> data);
 
 	void finishInit() override;
 	void setInnerFocus() override;
@@ -36,10 +35,6 @@ public:
 protected:
 	void resizeEvent(QResizeEvent *e) override;
 
-private slots:
-	void onInputChange();
-	void onCheckRequest();
-
 private:
 	void refreshLang();
 	void updateControlsGeometry();
@@ -47,8 +42,6 @@ private:
 	void nameSubmitDone(const MTPauth_Authorization &result);
 	bool nameSubmitFail(const RPCError &error);
 
-	void stopCheck();
-
 	object_ptr<Ui::UserpicButton> _photo;
 	object_ptr<Ui::InputField> _first;
 	object_ptr<Ui::InputField> _last;
@@ -58,8 +51,8 @@ private:
 	bool _invertOrder = false;
 
 	bool _termsAccepted = false;
-	object_ptr<QTimer> _checkRequest;
 
 };
 
+} // namespace details
 } // namespace Intro
diff --git a/Telegram/SourceFiles/intro/introstart.cpp b/Telegram/SourceFiles/intro/intro_start.cpp
similarity index 62%
rename from Telegram/SourceFiles/intro/introstart.cpp
rename to Telegram/SourceFiles/intro/intro_start.cpp
index 563a3e4fc..9f0fee57e 100644
--- a/Telegram/SourceFiles/intro/introstart.cpp
+++ b/Telegram/SourceFiles/intro/intro_start.cpp
@@ -5,19 +5,23 @@ the official desktop application for the Telegram messaging service.
 For license and copyright information please follow this link:
 https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 */
-#include "intro/introstart.h"
+#include "intro/intro_start.h"
 
 #include "lang/lang_keys.h"
-#include "intro/introphone.h"
+#include "intro/intro_qr.h"
+#include "intro/intro_phone.h"
 #include "ui/widgets/buttons.h"
 #include "ui/widgets/labels.h"
+#include "main/main_account.h"
+#include "main/main_app_config.h"
 
 namespace Intro {
+namespace details {
 
 StartWidget::StartWidget(
 	QWidget *parent,
 	not_null<Main::Account*> account,
-	not_null<Widget::Data*> data)
+	not_null<Data*> data)
 : Step(parent, account, data, true) {
 	setMouseTracking(true);
 	setTitleText(rpl::single(qsl("Kotatogram Desktop")));
@@ -26,11 +30,20 @@ StartWidget::StartWidget(
 }
 
 void StartWidget::submit() {
-	goNext<PhoneWidget>();
+	account().destroyStaleAuthorizationKeys();
+	const auto qrLogin = account().appConfig().get<QString>(
+		"qr_login_code",
+		"disabled");
+	if (qrLogin == "primary") {
+		goNext<QrWidget>();
+	} else {
+		goNext<PhoneWidget>();
+	}
 }
 
 rpl::producer<QString> StartWidget::nextButtonText() const {
 	return tr::lng_start_msgs();
 }
 
+} // namespace details
 } // namespace Intro
diff --git a/Telegram/SourceFiles/intro/introstart.h b/Telegram/SourceFiles/intro/intro_start.h
similarity index 80%
rename from Telegram/SourceFiles/intro/introstart.h
rename to Telegram/SourceFiles/intro/intro_start.h
index 9f7048f6f..4b3f072cd 100644
--- a/Telegram/SourceFiles/intro/introstart.h
+++ b/Telegram/SourceFiles/intro/intro_start.h
@@ -7,7 +7,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 */
 #pragma once
 
-#include "intro/introwidget.h"
+#include "intro/intro_step.h"
 
 namespace Ui {
 class FlatLabel;
@@ -16,17 +16,19 @@ class RoundButton;
 } // namespace Ui
 
 namespace Intro {
+namespace details {
 
-class StartWidget : public Widget::Step {
+class StartWidget : public Step {
 public:
 	StartWidget(
 		QWidget *parent,
 		not_null<Main::Account*> account,
-		not_null<Widget::Data*> data);
+		not_null<Data*> data);
 
 	void submit() override;
 	rpl::producer<QString> nextButtonText() const override;
 
 };
 
+} // namespace details
 } // namespace Intro
diff --git a/Telegram/SourceFiles/intro/intro_step.cpp b/Telegram/SourceFiles/intro/intro_step.cpp
new file mode 100644
index 000000000..0ad9d7da5
--- /dev/null
+++ b/Telegram/SourceFiles/intro/intro_step.cpp
@@ -0,0 +1,515 @@
+/*
+This file is part of Telegram Desktop,
+the official desktop application for the Telegram messaging service.
+
+For license and copyright information please follow this link:
+https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+*/
+#include "intro/intro_step.h"
+
+#include "intro/intro_widget.h"
+#include "storage/localstorage.h"
+#include "lang/lang_keys.h"
+#include "lang/lang_cloud_manager.h"
+#include "main/main_account.h"
+#include "apiwrap.h"
+#include "mainwindow.h"
+#include "boxes/confirm_box.h"
+#include "ui/text/text_utilities.h"
+#include "ui/widgets/labels.h"
+#include "ui/wrap/fade_wrap.h"
+#include "ui/effects/slide_animation.h"
+#include "data/data_user.h"
+#include "data/data_auto_download.h"
+#include "window/themes/window_theme.h"
+#include "facades.h"
+#include "app.h"
+#include "styles/style_intro.h"
+#include "styles/style_window.h"
+
+namespace Intro {
+namespace details {
+namespace {
+
+void PrepareSupportMode() {
+	using ::Data::AutoDownload::Full;
+
+	anim::SetDisabled(true);
+	Local::writeSettings();
+
+	Global::SetDesktopNotify(false);
+	Global::SetSoundNotify(false);
+	Auth().settings().autoDownload() = Full::FullDisabled();
+	Local::writeUserSettings();
+}
+
+} // namespace
+
+Step::CoverAnimation::~CoverAnimation() = default;
+
+Step::Step(
+	QWidget *parent,
+	not_null<Main::Account*> account,
+	not_null<Data*> data,
+	bool hasCover)
+: RpWidget(parent)
+, _account(account)
+, _data(data)
+, _hasCover(hasCover)
+, _title(this, _hasCover ? st::introCoverTitle : st::introTitle)
+, _description(
+	this,
+	object_ptr<Ui::FlatLabel>(
+		this,
+		_hasCover
+			? st::introCoverDescription
+			: st::introDescription)) {
+	hide();
+	subscribe(Window::Theme::Background(), [this](
+			const Window::Theme::BackgroundUpdate &update) {
+		if (update.paletteChanged()) {
+			if (!_coverMask.isNull()) {
+				_coverMask = QPixmap();
+				prepareCoverMask();
+			}
+		}
+	});
+
+	_errorText.value(
+	) | rpl::start_with_next([=](const QString &text) {
+		refreshError(text);
+	}, lifetime());
+
+	_titleText.value(
+	) | rpl::start_with_next([=](const QString &text) {
+		_title->setText(text);
+		updateLabelsPosition();
+	}, lifetime());
+
+	_descriptionText.value(
+	) | rpl::start_with_next([=](const TextWithEntities &text) {
+		_description->entity()->setMarkedText(text);
+		updateLabelsPosition();
+	}, lifetime());
+}
+
+Step::~Step() = default;
+
+rpl::producer<QString> Step::nextButtonText() const {
+	return tr::lng_intro_next();
+}
+
+void Step::goBack() {
+	if (_goCallback) {
+		_goCallback(nullptr, Direction::Back);
+	}
+}
+
+void Step::goNext(Step *step) {
+	if (_goCallback) {
+		_goCallback(step, Direction::Forward);
+	}
+}
+
+void Step::goReplace(Step *step) {
+	if (_goCallback) {
+		_goCallback(step, Direction::Replace);
+	}
+}
+
+void Step::finish(const MTPUser &user, QImage &&photo) {
+	if (user.type() != mtpc_user
+		|| !user.c_user().is_self()
+		|| !user.c_user().vid().v) {
+		// No idea what to do here.
+		// We could've reset intro and MTP, but this really should not happen.
+		Ui::show(Box<InformBox>("Internal error: bad user.is_self() after sign in."));
+		return;
+	}
+
+	// Save the default language if we've suggested some other and user ignored it.
+	const auto currentId = Lang::Current().id();
+	const auto defaultId = Lang::DefaultLanguageId();
+	const auto suggested = Lang::CurrentCloudManager().suggestedLanguage();
+	if (currentId.isEmpty() && !suggested.isEmpty() && suggested != defaultId) {
+		Lang::Current().switchToId(Lang::DefaultLanguage());
+		Local::writeLangPack();
+	}
+
+	const auto account = _account;
+	const auto weak = base::make_weak(account.get());
+	account->createSession(user);
+	Local::writeMtpData();
+	App::wnd()->setupMain();
+
+	// "this" is already deleted here by creating the main widget.
+	if (weak && account->sessionExists()) {
+		auto &session = account->session();
+		if (!photo.isNull()) {
+			session.api().uploadPeerPhoto(session.user(), std::move(photo));
+		}
+		if (session.supportMode()) {
+			PrepareSupportMode();
+		}
+	}
+}
+
+void Step::paintEvent(QPaintEvent *e) {
+	Painter p(this);
+	paintAnimated(p, e->rect());
+}
+
+void Step::resizeEvent(QResizeEvent *e) {
+	updateLabelsPosition();
+}
+
+void Step::updateLabelsPosition() {
+	Ui::SendPendingMoveResizeEvents(_description->entity());
+	if (hasCover()) {
+		_title->moveToLeft((width() - _title->width()) / 2, contentTop() + st::introCoverTitleTop);
+		_description->moveToLeft((width() - _description->width()) / 2, contentTop() + st::introCoverDescriptionTop);
+	} else {
+		_title->moveToLeft(contentLeft() + st::buttonRadius, contentTop() + st::introTitleTop);
+		_description->resizeToWidth(st::introDescription.minWidth);
+		_description->moveToLeft(contentLeft() + st::buttonRadius, contentTop() + st::introDescriptionTop);
+	}
+	if (_error) {
+		if (_errorCentered) {
+			_error->entity()->resizeToWidth(width());
+		}
+		Ui::SendPendingMoveResizeEvents(_error->entity());
+		auto errorLeft = _errorCentered ? 0 : (contentLeft() + st::buttonRadius);
+		_error->moveToLeft(errorLeft, errorTop());
+	}
+}
+
+int Step::errorTop() const {
+	return contentTop() + st::introErrorTop;
+}
+
+void Step::setTitleText(rpl::producer<QString> titleText) {
+	_titleText = std::move(titleText);
+}
+
+void Step::setDescriptionText(
+		rpl::producer<QString> descriptionText) {
+	setDescriptionText(
+		std::move(descriptionText) | Ui::Text::ToWithEntities());
+}
+
+void Step::setDescriptionText(
+		rpl::producer<TextWithEntities> richDescriptionText) {
+	_descriptionText = std::move(richDescriptionText);
+}
+
+void Step::showFinished() {
+	_a_show.stop();
+	_coverAnimation = CoverAnimation();
+	_slideAnimation.reset();
+	prepareCoverMask();
+	activate();
+}
+
+bool Step::paintAnimated(Painter &p, QRect clip) {
+	if (_slideAnimation) {
+		_slideAnimation->paintFrame(p, (width() - st::introStepWidth) / 2, contentTop(), width());
+		if (!_slideAnimation->animating()) {
+			showFinished();
+			return false;
+		}
+		return true;
+	}
+
+	auto dt = _a_show.value(1.);
+	if (!_a_show.animating()) {
+		if (hasCover()) {
+			paintCover(p, 0);
+		}
+		if (_coverAnimation.title) {
+			showFinished();
+		}
+		if (!QRect(0, contentTop(), width(), st::introStepHeight).intersects(clip)) {
+			return true;
+		}
+		return false;
+	}
+	if (!_coverAnimation.clipping.isEmpty()) {
+		p.setClipRect(_coverAnimation.clipping);
+	}
+
+	auto progress = (hasCover() ? anim::easeOutCirc(1., dt) : anim::linear(1., dt));
+	auto arrivingAlpha = progress;
+	auto departingAlpha = 1. - progress;
+	auto showCoverMethod = progress;
+	auto hideCoverMethod = progress;
+	auto coverTop = (hasCover() ? anim::interpolate(-st::introCoverHeight, 0, showCoverMethod) : anim::interpolate(0, -st::introCoverHeight, hideCoverMethod));
+
+	paintCover(p, coverTop);
+
+	auto positionReady = hasCover() ? showCoverMethod : hideCoverMethod;
+	_coverAnimation.title->paintFrame(p, positionReady, departingAlpha, arrivingAlpha);
+	_coverAnimation.description->paintFrame(p, positionReady, departingAlpha, arrivingAlpha);
+
+	paintContentSnapshot(p, _coverAnimation.contentSnapshotWas, departingAlpha, showCoverMethod);
+	paintContentSnapshot(p, _coverAnimation.contentSnapshotNow, arrivingAlpha, 1. - hideCoverMethod);
+
+	return true;
+}
+
+void Step::fillSentCodeData(const MTPDauth_sentCode &data) {
+	const auto &type = data.vtype();
+	switch (type.type()) {
+	case mtpc_auth_sentCodeTypeApp: {
+		getData()->codeByTelegram = true;
+		getData()->codeLength = type.c_auth_sentCodeTypeApp().vlength().v;
+	} break;
+	case mtpc_auth_sentCodeTypeSms: {
+		getData()->codeByTelegram = false;
+		getData()->codeLength = type.c_auth_sentCodeTypeSms().vlength().v;
+	} break;
+	case mtpc_auth_sentCodeTypeCall: {
+		getData()->codeByTelegram = false;
+		getData()->codeLength = type.c_auth_sentCodeTypeCall().vlength().v;
+	} break;
+	case mtpc_auth_sentCodeTypeFlashCall: LOG(("Error: should not be flashcall!")); break;
+	}
+}
+
+void Step::showDescription() {
+	_description->show(anim::type::normal);
+}
+
+void Step::hideDescription() {
+	_description->hide(anim::type::normal);
+}
+
+void Step::paintContentSnapshot(Painter &p, const QPixmap &snapshot, float64 alpha, float64 howMuchHidden) {
+	if (!snapshot.isNull()) {
+		auto contentTop = anim::interpolate(height() - (snapshot.height() / cIntRetinaFactor()), height(), howMuchHidden);
+		if (contentTop < height()) {
+			p.setOpacity(alpha);
+			p.drawPixmap(QPoint(contentLeft(), contentTop), snapshot, QRect(0, 0, snapshot.width(), (height() - contentTop) * cIntRetinaFactor()));
+		}
+	}
+}
+
+void Step::prepareCoverMask() {
+	if (!_coverMask.isNull()) return;
+
+	auto maskWidth = cIntRetinaFactor();
+	auto maskHeight = st::introCoverHeight * cIntRetinaFactor();
+	auto mask = QImage(maskWidth, maskHeight, QImage::Format_ARGB32_Premultiplied);
+	auto maskInts = reinterpret_cast<uint32*>(mask.bits());
+	Assert(mask.depth() == (sizeof(uint32) << 3));
+	auto maskIntsPerLineAdded = (mask.bytesPerLine() >> 2) - maskWidth;
+	Assert(maskIntsPerLineAdded >= 0);
+	auto realHeight = static_cast<float64>(maskHeight - 1);
+	for (auto y = 0; y != maskHeight; ++y) {
+		auto color = anim::color(st::introCoverTopBg, st::introCoverBottomBg, y / realHeight);
+		auto colorInt = anim::getPremultiplied(color);
+		for (auto x = 0; x != maskWidth; ++x) {
+			*maskInts++ = colorInt;
+		}
+		maskInts += maskIntsPerLineAdded;
+	}
+	_coverMask = App::pixmapFromImageInPlace(std::move(mask));
+}
+
+void Step::paintCover(Painter &p, int top) {
+	auto coverHeight = top + st::introCoverHeight;
+	if (coverHeight > 0) {
+		p.drawPixmap(QRect(0, 0, width(), coverHeight), _coverMask, QRect(0, -top * cIntRetinaFactor(), _coverMask.width(), coverHeight * cIntRetinaFactor()));
+	}
+
+	auto left = 0;
+	auto right = 0;
+	if (width() < st::introCoverMaxWidth) {
+		auto iconsMaxSkip = st::introCoverMaxWidth - st::introCoverLeft.width() - st::introCoverRight.width();
+		auto iconsSkip = st::introCoverIconsMinSkip + (iconsMaxSkip - st::introCoverIconsMinSkip) * (width() - st::introStepWidth) / (st::introCoverMaxWidth - st::introStepWidth);
+		auto outside = iconsSkip + st::introCoverLeft.width() + st::introCoverRight.width() - width();
+		left = -outside / 2;
+		right = -outside - left;
+	}
+	if (top < 0) {
+		auto shown = float64(coverHeight) / st::introCoverHeight;
+		auto leftShown = qRound(shown * (left + st::introCoverLeft.width()));
+		left = leftShown - st::introCoverLeft.width();
+		auto rightShown = qRound(shown * (right + st::introCoverRight.width()));
+		right = rightShown - st::introCoverRight.width();
+	}
+	st::introCoverLeft.paint(p, left, coverHeight - st::introCoverLeft.height(), width());
+	st::introCoverRight.paint(p, width() - right - st::introCoverRight.width(), coverHeight - st::introCoverRight.height(), width());
+
+	auto planeLeft = (width() - st::introCoverIcon.width()) / 2 - st::introCoverIconLeft;
+	auto planeTop = top + st::introCoverIconTop;
+	if (top < 0 && !_hasCover) {
+		auto deltaLeft = -qRound(float64(st::introPlaneWidth / st::introPlaneHeight) * top);
+//		auto deltaTop = top;
+		planeLeft += deltaLeft;
+	//	planeTop += top;
+	}
+	st::introCoverIcon.paint(p, planeLeft, planeTop, width());
+}
+
+int Step::contentLeft() const {
+	return (width() - st::introNextButton.width) / 2;
+}
+
+int Step::contentTop() const {
+	auto result = (height() - st::introHeight) / 2;
+	accumulate_max(result, st::introStepTopMin);
+	if (_hasCover) {
+		const auto currentHeightFull = result + st::introNextTop + st::introContentTopAdd;
+		auto added = 1. - snap(float64(currentHeightFull - st::windowMinHeight) / (st::introStepHeightFull - st::windowMinHeight), 0., 1.);
+		result += qRound(added * st::introContentTopAdd);
+	}
+	return result;
+}
+
+void Step::setErrorCentered(bool centered) {
+	_errorCentered = centered;
+	_error.destroy();
+}
+
+void Step::showError(rpl::producer<QString> text) {
+	_errorText = std::move(text);
+}
+
+void Step::refreshError(const QString &text) {
+	if (text.isEmpty()) {
+		if (_error) _error->hide(anim::type::normal);
+	} else {
+		if (!_error) {
+			_error.create(
+				this,
+				object_ptr<Ui::FlatLabel>(
+					this,
+					_errorCentered
+						? st::introErrorCentered
+						: st::introError));
+			_error->hide(anim::type::instant);
+		}
+		_error->entity()->setText(text);
+		updateLabelsPosition();
+		_error->show(anim::type::normal);
+	}
+}
+
+void Step::prepareShowAnimated(Step *after) {
+	setInnerFocus();
+	if (hasCover() || after->hasCover()) {
+		_coverAnimation = prepareCoverAnimation(after);
+		prepareCoverMask();
+	} else {
+		auto leftSnapshot = after->prepareSlideAnimation();
+		auto rightSnapshot = prepareSlideAnimation();
+		_slideAnimation = std::make_unique<Ui::SlideAnimation>();
+		_slideAnimation->setSnapshots(std::move(leftSnapshot), std::move(rightSnapshot));
+		_slideAnimation->setOverflowHidden(false);
+	}
+}
+
+Step::CoverAnimation Step::prepareCoverAnimation(Step *after) {
+	Ui::SendPendingMoveResizeEvents(this);
+
+	auto result = CoverAnimation();
+	result.title = Ui::FlatLabel::CrossFade(
+		after->_title,
+		_title,
+		st::introBg);
+	result.description = Ui::FlatLabel::CrossFade(
+		after->_description->entity(),
+		_description->entity(),
+		st::introBg,
+		after->_description->pos(),
+		_description->pos());
+	result.contentSnapshotWas = after->prepareContentSnapshot();
+	result.contentSnapshotNow = prepareContentSnapshot();
+	return result;
+}
+
+QPixmap Step::prepareContentSnapshot() {
+	auto otherTop = _description->y() + _description->height();
+	auto otherRect = myrtlrect(contentLeft(), otherTop, st::introStepWidth, height() - otherTop);
+	return Ui::GrabWidget(this, otherRect);
+}
+
+QPixmap Step::prepareSlideAnimation() {
+	auto grabLeft = (width() - st::introStepWidth) / 2;
+	auto grabTop = contentTop();
+	return Ui::GrabWidget(
+		this,
+		QRect(grabLeft, grabTop, st::introStepWidth, st::introStepHeight));
+}
+
+void Step::showAnimated(Direction direction) {
+	setFocus();
+	show();
+	hideChildren();
+	if (_slideAnimation) {
+		auto slideLeft = (direction == Direction::Back);
+		_slideAnimation->start(
+			slideLeft,
+			[=] { update(0, contentTop(), width(), st::introStepHeight); },
+			st::introSlideDuration);
+	} else {
+		_a_show.start([this] { update(); }, 0., 1., st::introCoverDuration);
+	}
+}
+
+void Step::setShowAnimationClipping(QRect clipping) {
+	_coverAnimation.clipping = clipping;
+}
+
+void Step::setGoCallback(Fn<void(Step *step, Direction direction)> callback) {
+	_goCallback = std::move(callback);
+}
+
+void Step::setShowResetCallback(Fn<void()> callback) {
+	_showResetCallback = std::move(callback);
+}
+
+void Step::setShowTermsCallback(Fn<void()> callback) {
+	_showTermsCallback = std::move(callback);
+}
+
+void Step::setAcceptTermsCallback(
+		Fn<void(Fn<void()> callback)> callback) {
+	_acceptTermsCallback = std::move(callback);
+}
+
+void Step::showFast() {
+	show();
+	showFinished();
+}
+
+bool Step::animating() const {
+	return (_slideAnimation && _slideAnimation->animating())
+		|| _a_show.animating();
+}
+
+bool Step::hasCover() const {
+	return _hasCover;
+}
+
+bool Step::hasBack() const {
+	return false;
+}
+
+void Step::activate() {
+	_title->show();
+	_description->show(anim::type::instant);
+	if (!_errorText.current().isEmpty()) {
+		_error->show(anim::type::instant);
+	}
+}
+
+void Step::cancelled() {
+}
+
+void Step::finished() {
+	hide();
+}
+
+} // namespace details
+} // namespace Intro
diff --git a/Telegram/SourceFiles/intro/intro_step.h b/Telegram/SourceFiles/intro/intro_step.h
new file mode 100644
index 000000000..c51db5e42
--- /dev/null
+++ b/Telegram/SourceFiles/intro/intro_step.h
@@ -0,0 +1,195 @@
+/*
+This file is part of Telegram Desktop,
+the official desktop application for the Telegram messaging service.
+
+For license and copyright information please follow this link:
+https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+*/
+#pragma once
+
+#include "base/object_ptr.h"
+#include "mtproto/sender.h"
+#include "ui/rp_widget.h"
+#include "ui/effects/animations.h"
+
+namespace Main {
+class Account;
+} // namespace Main;
+
+namespace Ui {
+class SlideAnimation;
+class CrossFadeAnimation;
+class FlatLabel;
+template <typename Widget>
+class FadeWrap;
+} // namespace Ui
+
+namespace Intro {
+namespace details {
+
+struct Data;
+enum class Direction;
+
+class Step
+	: public Ui::RpWidget
+	, public RPCSender
+	, protected base::Subscriber {
+public:
+	Step(
+		QWidget *parent,
+		not_null<Main::Account*> account,
+		not_null<Data*> data,
+		bool hasCover = false);
+	~Step();
+
+	[[nodiscard]] Main::Account &account() const {
+		return *_account;
+	}
+
+	virtual void finishInit() {
+	}
+	virtual void setInnerFocus() {
+		setFocus();
+	}
+
+	void setGoCallback(
+		Fn<void(Step *step, Direction direction)> callback);
+	void setShowResetCallback(Fn<void()> callback);
+	void setShowTermsCallback(
+		Fn<void()> callback);
+	void setAcceptTermsCallback(
+		Fn<void(Fn<void()> callback)> callback);
+
+	void prepareShowAnimated(Step *after);
+	void showAnimated(Direction direction);
+	void showFast();
+	[[nodiscard]] bool animating() const;
+	void setShowAnimationClipping(QRect clipping);
+
+	[[nodiscard]] bool hasCover() const;
+	[[nodiscard]] virtual bool hasBack() const;
+	virtual void activate();
+	virtual void cancelled();
+	virtual void finished();
+
+	virtual void submit() = 0;
+	[[nodiscard]] virtual rpl::producer<QString> nextButtonText() const;
+
+	[[nodiscard]] int contentLeft() const;
+	[[nodiscard]] int contentTop() const;
+
+	void setErrorCentered(bool centered);
+	void showError(rpl::producer<QString> text);
+	void hideError() {
+		showError(rpl::single(QString()));
+	}
+
+protected:
+	void paintEvent(QPaintEvent *e) override;
+	void resizeEvent(QResizeEvent *e) override;
+
+	void setTitleText(rpl::producer<QString> titleText);
+	void setDescriptionText(rpl::producer<QString> descriptionText);
+	void setDescriptionText(
+		rpl::producer<TextWithEntities> richDescriptionText);
+	bool paintAnimated(Painter &p, QRect clip);
+
+	void fillSentCodeData(const MTPDauth_sentCode &type);
+
+	void showDescription();
+	void hideDescription();
+
+	[[nodiscard]] not_null<Data*> getData() const {
+		return _data;
+	}
+	void finish(const MTPUser &user, QImage &&photo = QImage());
+
+	void goBack();
+
+	template <typename StepType>
+	void goNext() {
+		goNext(new StepType(parentWidget(), _account, _data));
+	}
+
+	template <typename StepType>
+	void goReplace() {
+		goReplace(new StepType(parentWidget(), _account, _data));
+	}
+
+	void showResetButton() {
+		if (_showResetCallback) _showResetCallback();
+	}
+	void showTerms() {
+		if (_showTermsCallback) _showTermsCallback();
+	}
+	void acceptTerms(Fn<void()> callback) {
+		if (_acceptTermsCallback) {
+			_acceptTermsCallback(callback);
+		}
+	}
+
+	virtual int errorTop() const;
+
+private:
+	struct CoverAnimation {
+		CoverAnimation() = default;
+		CoverAnimation(CoverAnimation &&other) = default;
+		CoverAnimation &operator=(CoverAnimation &&other) = default;
+		~CoverAnimation();
+
+		std::unique_ptr<Ui::CrossFadeAnimation> title;
+		std::unique_ptr<Ui::CrossFadeAnimation> description;
+
+		// From content top till the next button top.
+		QPixmap contentSnapshotWas;
+		QPixmap contentSnapshotNow;
+
+		QRect clipping;
+	};
+	void updateLabelsPosition();
+	void paintContentSnapshot(
+		Painter &p,
+		const QPixmap &snapshot,
+		float64 alpha,
+		float64 howMuchHidden);
+	void refreshError(const QString &text);
+
+	void goNext(Step *step);
+	void goReplace(Step *step);
+
+	[[nodiscard]] CoverAnimation prepareCoverAnimation(Step *step);
+	[[nodiscard]] QPixmap prepareContentSnapshot();
+	[[nodiscard]] QPixmap prepareSlideAnimation();
+	void showFinished();
+
+	void prepareCoverMask();
+	void paintCover(Painter &p, int top);
+
+	const not_null<Main::Account*> _account;
+	const not_null<Data*> _data;
+
+	bool _hasCover = false;
+	Fn<void(Step *step, Direction direction)> _goCallback;
+	Fn<void()> _showResetCallback;
+	Fn<void()> _showTermsCallback;
+	Fn<void(Fn<void()> callback)> _acceptTermsCallback;
+
+	rpl::variable<QString> _titleText;
+	object_ptr<Ui::FlatLabel> _title;
+	rpl::variable<TextWithEntities> _descriptionText;
+	object_ptr<Ui::FadeWrap<Ui::FlatLabel>> _description;
+
+	bool _errorCentered = false;
+	rpl::variable<QString> _errorText;
+	object_ptr<Ui::FadeWrap<Ui::FlatLabel>> _error = { nullptr };
+
+	Ui::Animations::Simple _a_show;
+	CoverAnimation _coverAnimation;
+	std::unique_ptr<Ui::SlideAnimation> _slideAnimation;
+	QPixmap _coverMask;
+
+};
+
+
+} // namespace details
+} // namespace Intro
diff --git a/Telegram/SourceFiles/intro/intro_widget.cpp b/Telegram/SourceFiles/intro/intro_widget.cpp
new file mode 100644
index 000000000..80ad033a0
--- /dev/null
+++ b/Telegram/SourceFiles/intro/intro_widget.cpp
@@ -0,0 +1,676 @@
+/*
+This file is part of Telegram Desktop,
+the official desktop application for the Telegram messaging service.
+
+For license and copyright information please follow this link:
+https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+*/
+#include "intro/intro_widget.h"
+
+#include "intro/intro_start.h"
+#include "intro/intro_phone.h"
+#include "intro/intro_code.h"
+#include "intro/intro_signup.h"
+#include "intro/intro_password_check.h"
+#include "lang/lang_keys.h"
+#include "lang/lang_cloud_manager.h"
+#include "storage/localstorage.h"
+#include "main/main_account.h"
+#include "mainwindow.h"
+#include "boxes/confirm_box.h"
+#include "ui/text/text_utilities.h"
+#include "ui/widgets/buttons.h"
+#include "ui/widgets/labels.h"
+#include "ui/wrap/fade_wrap.h"
+#include "core/update_checker.h"
+#include "window/window_slide_animation.h"
+#include "window/window_connecting_widget.h"
+#include "base/platform/base_platform_info.h"
+#include "facades.h"
+#include "app.h"
+#include "styles/style_layers.h"
+#include "styles/style_intro.h"
+
+namespace Intro {
+namespace {
+
+using namespace ::Intro::details;
+
+} // namespace
+
+Widget::Widget(QWidget *parent, not_null<Main::Account*> account)
+: RpWidget(parent)
+, _account(account)
+, _back(this, object_ptr<Ui::IconButton>(this, st::introBackButton))
+, _settings(
+	this,
+	object_ptr<Ui::RoundButton>(
+		this,
+		tr::lng_menu_settings(),
+		st::defaultBoxButton))
+, _next(
+	this,
+	object_ptr<Ui::RoundButton>(this, nullptr, st::introNextButton))
+, _connecting(std::make_unique<Window::ConnectionState>(
+		this,
+		rpl::single(true))) {
+	appendStep(new StartWidget(this, _account, getData()));
+	fixOrder();
+
+	getData()->country = Platform::SystemCountry();
+
+	_account->mtpValue(
+	) | rpl::start_with_next([=](MTP::Instance *instance) {
+		if (instance) {
+			_api.emplace(instance);
+			createLanguageLink();
+		} else {
+			_api.reset();
+		}
+	}, lifetime());
+	subscribe(Lang::CurrentCloudManager().firstLanguageSuggestion(), [=] {
+		createLanguageLink();
+	});
+
+	_back->entity()->setClickedCallback([=] {
+		historyMove(Direction::Back);
+	});
+	_back->hide(anim::type::instant);
+
+	_next->entity()->setClickedCallback([=] { getStep()->submit(); });
+
+	_settings->entity()->setClickedCallback([] { App::wnd()->showSettings(); });
+
+	getNearestDC();
+
+	if (_changeLanguage) {
+		_changeLanguage->finishAnimating();
+	}
+
+	subscribe(Lang::Current().updated(), [this] { refreshLang(); });
+
+	show();
+	showControls();
+	getStep()->showFast();
+	setInnerFocus();
+
+	cSetPasswordRecovered(false);
+
+	if (!Core::UpdaterDisabled()) {
+		Core::UpdateChecker checker;
+		checker.start();
+		rpl::merge(
+			rpl::single(rpl::empty_value()),
+			checker.isLatest(),
+			checker.failed(),
+			checker.ready()
+		) | rpl::start_with_next([=] {
+			checkUpdateStatus();
+		}, lifetime());
+	}
+}
+
+void Widget::refreshLang() {
+	_changeLanguage.destroy();
+	createLanguageLink();
+	InvokeQueued(this, [this] { updateControlsGeometry(); });
+}
+
+void Widget::createLanguageLink() {
+	if (_changeLanguage) {
+		return;
+	}
+
+	const auto createLink = [=](
+			const QString &text,
+			const QString &languageId) {
+		_changeLanguage.create(
+			this,
+			object_ptr<Ui::LinkButton>(this, text));
+		_changeLanguage->hide(anim::type::instant);
+		_changeLanguage->entity()->setClickedCallback([=] {
+			Lang::CurrentCloudManager().switchToLanguage(languageId);
+		});
+		_changeLanguage->toggle(
+			!_resetAccount && !_terms && _nextShown,
+			anim::type::normal);
+		updateControlsGeometry();
+	};
+
+	const auto currentId = Lang::LanguageIdOrDefault(Lang::Current().id());
+	const auto defaultId = Lang::DefaultLanguageId();
+	const auto suggested = Lang::CurrentCloudManager().suggestedLanguage();
+	if (currentId != defaultId) {
+		createLink(
+			Lang::GetOriginalValue(tr::lng_switch_to_this.base),
+			defaultId);
+	} else if (!suggested.isEmpty() && suggested != currentId && _api) {
+		_api->request(MTPlangpack_GetStrings(
+			MTP_string(Lang::CloudLangPackName()),
+			MTP_string(suggested),
+			MTP_vector<MTPstring>(1, MTP_string("lng_switch_to_this"))
+		)).done([=](const MTPVector<MTPLangPackString> &result) {
+			const auto strings = Lang::Instance::ParseStrings(result);
+			const auto i = strings.find(tr::lng_switch_to_this.base);
+			if (i != strings.end()) {
+				createLink(i->second, suggested);
+			}
+		}).send();
+	}
+}
+
+void Widget::checkUpdateStatus() {
+	Expects(!Core::UpdaterDisabled());
+
+	if (Core::UpdateChecker().state() == Core::UpdateChecker::State::Ready) {
+		if (_update) return;
+		_update.create(
+			this,
+			object_ptr<Ui::RoundButton>(
+				this,
+				tr::lng_menu_update(),
+				st::defaultBoxButton));
+		if (!_a_show.animating()) {
+			_update->setVisible(true);
+		}
+		const auto stepHasCover = getStep()->hasCover();
+		_update->toggle(!stepHasCover, anim::type::instant);
+		_update->entity()->setClickedCallback([] {
+			Core::checkReadyUpdate();
+			App::restart();
+		});
+	} else {
+		if (!_update) return;
+		_update.destroy();
+	}
+	updateControlsGeometry();
+}
+
+void Widget::setInnerFocus() {
+	if (getStep()->animating()) {
+		setFocus();
+	} else {
+		getStep()->setInnerFocus();
+	}
+}
+
+void Widget::historyMove(Direction direction) {
+	Expects(_stepHistory.size() > 1);
+
+	if (getStep()->animating()) {
+		return;
+	}
+
+	auto wasStep = getStep((direction == Direction::Back) ? 0 : 1);
+	if (direction == Direction::Back) {
+		_stepHistory.pop_back();
+		wasStep->cancelled();
+	} else if (direction == Direction::Replace) {
+		_stepHistory.erase(_stepHistory.end() - 2);
+	}
+
+	if (_resetAccount) {
+		hideAndDestroy(std::exchange(_resetAccount, { nullptr }));
+	}
+	if (_terms) {
+		hideAndDestroy(std::exchange(_terms, { nullptr }));
+	}
+
+	getStep()->finishInit();
+	getStep()->prepareShowAnimated(wasStep);
+	if (wasStep->hasCover() != getStep()->hasCover()) {
+		_nextTopFrom = wasStep->contentTop() + st::introNextTop;
+		_controlsTopFrom = wasStep->hasCover() ? st::introCoverHeight : 0;
+		_coverShownAnimation.start([this] { updateControlsGeometry(); }, 0., 1., st::introCoverDuration, wasStep->hasCover() ? anim::linear : anim::easeOutCirc);
+	}
+
+	_stepLifetime.destroy();
+	if (direction == Direction::Forward || direction == Direction::Replace) {
+		wasStep->finished();
+	}
+	if (direction == Direction::Back || direction == Direction::Replace) {
+		delete base::take(wasStep);
+	}
+	_back->toggle(getStep()->hasBack(), anim::type::normal);
+
+	auto stepHasCover = getStep()->hasCover();
+	_settings->toggle(!stepHasCover, anim::type::normal);
+	if (_update) {
+		_update->toggle(!stepHasCover, anim::type::normal);
+	}
+	setupNextButton();
+	if (_resetAccount) _resetAccount->show(anim::type::normal);
+	if (_terms) _terms->show(anim::type::normal);
+	getStep()->showAnimated(direction);
+	fixOrder();
+}
+
+void Widget::hideAndDestroy(object_ptr<Ui::FadeWrap<Ui::RpWidget>> widget) {
+	const auto weak = Ui::MakeWeak(widget.data());
+	widget->hide(anim::type::normal);
+	widget->shownValue(
+	) | rpl::start_with_next([=](bool shown) {
+		if (!shown && weak) {
+			weak->deleteLater();
+		}
+	}, widget->lifetime());
+}
+
+void Widget::fixOrder() {
+	_next->raise();
+	if (_update) _update->raise();
+	if (_changeLanguage) _changeLanguage->raise();
+	_settings->raise();
+	_back->raise();
+	_connecting->raise();
+}
+
+void Widget::moveToStep(Step *step, Direction direction) {
+	appendStep(step);
+	_back->raise();
+	_settings->raise();
+	if (_update) {
+		_update->raise();
+	}
+	_connecting->raise();
+
+	historyMove(direction);
+}
+
+void Widget::appendStep(Step *step) {
+	_stepHistory.push_back(step);
+	step->setGeometry(rect());
+	step->setGoCallback([=](Step *step, Direction direction) {
+		if (direction == Direction::Back) {
+			historyMove(direction);
+		} else {
+			moveToStep(step, direction);
+		}
+	});
+	step->setShowResetCallback([=] {
+		showResetButton();
+	});
+	step->setShowTermsCallback([=]() {
+		showTerms();
+	});
+	step->setAcceptTermsCallback([=](Fn<void()> callback) {
+		acceptTerms(callback);
+	});
+}
+
+void Widget::showResetButton() {
+	if (!_resetAccount) {
+		auto entity = object_ptr<Ui::RoundButton>(
+			this,
+			tr::lng_signin_reset_account(),
+			st::introResetButton);
+		_resetAccount.create(this, std::move(entity));
+		_resetAccount->hide(anim::type::instant);
+		_resetAccount->entity()->setClickedCallback([this] { resetAccount(); });
+		updateControlsGeometry();
+	}
+	_resetAccount->show(anim::type::normal);
+	if (_changeLanguage) {
+		_changeLanguage->hide(anim::type::normal);
+	}
+}
+
+void Widget::showTerms() {
+	if (getData()->termsLock.text.text.isEmpty()) {
+		_terms.destroy();
+	} else if (!_terms) {
+		auto entity = object_ptr<Ui::FlatLabel>(
+			this,
+			tr::lng_terms_signup(
+				lt_link,
+				tr::lng_terms_signup_link() | Ui::Text::ToLink(),
+				Ui::Text::WithEntities),
+			st::introTermsLabel);
+		_terms.create(this, std::move(entity));
+		_terms->entity()->setClickHandlerFilter([=](
+				const ClickHandlerPtr &handler,
+				Qt::MouseButton button) {
+			if (button == Qt::LeftButton) {
+				showTerms(nullptr);
+			}
+			return false;
+		});
+		updateControlsGeometry();
+		_terms->hide(anim::type::instant);
+	}
+	if (_changeLanguage) {
+		_changeLanguage->toggle(
+			!_terms && !_resetAccount && _nextShown,
+			anim::type::normal);
+	}
+}
+
+void Widget::acceptTerms(Fn<void()> callback) {
+	showTerms(callback);
+}
+
+void Widget::resetAccount() {
+	if (_resetRequest || !_api) {
+		return;
+	}
+
+	Ui::show(Box<ConfirmBox>(tr::lng_signin_sure_reset(tr::now), tr::lng_signin_reset(tr::now), st::attentionBoxButton, crl::guard(this, [this] {
+		if (_resetRequest) {
+			return;
+		}
+		_resetRequest = _api->request(MTPaccount_DeleteAccount(
+			MTP_string("Forgot password")
+		)).done([=](const MTPBool &result) {
+			_resetRequest = 0;
+
+			Ui::hideLayer();
+			moveToStep(
+				new SignupWidget(this, _account, getData()),
+				Direction::Replace);
+		}).fail([=](const RPCError &error) {
+			_resetRequest = 0;
+
+			const auto &type = error.type();
+			if (type.startsWith(qstr("2FA_CONFIRM_WAIT_"))) {
+				const auto seconds = type.mid(qstr("2FA_CONFIRM_WAIT_").size()).toInt();
+				const auto days = (seconds + 59) / 86400;
+				const auto hours = ((seconds + 59) % 86400) / 3600;
+				const auto minutes = ((seconds + 59) % 3600) / 60;
+				auto when = tr::lng_signin_reset_minutes(
+					tr::now,
+					lt_count,
+					minutes);
+				if (days > 0) {
+					const auto daysCount = tr::lng_signin_reset_days(
+						tr::now,
+						lt_count,
+						days);
+					const auto hoursCount = tr::lng_signin_reset_hours(
+						tr::now,
+						lt_count,
+						hours);
+					when = tr::lng_signin_reset_in_days(
+						tr::now,
+						lt_days_count,
+						daysCount,
+						lt_hours_count,
+						hoursCount,
+						lt_minutes_count,
+						when);
+				} else if (hours > 0) {
+					const auto hoursCount = tr::lng_signin_reset_hours(
+						tr::now,
+						lt_count,
+						hours);
+					when = tr::lng_signin_reset_in_hours(
+						tr::now,
+						lt_hours_count,
+						hoursCount,
+						lt_minutes_count,
+						when);
+				}
+				Ui::show(Box<InformBox>(tr::lng_signin_reset_wait(
+					tr::now,
+					lt_phone_number,
+					App::formatPhone(getData()->phone),
+					lt_when,
+					when)));
+			} else if (type == qstr("2FA_RECENT_CONFIRM")) {
+				Ui::show(Box<InformBox>(
+					tr::lng_signin_reset_cancelled(tr::now)));
+			} else {
+				Ui::hideLayer();
+				getStep()->showError(rpl::single(Lang::Hard::ServerError()));
+			}
+		}).send();
+	})));
+}
+
+void Widget::getNearestDC() {
+	if (!_api) {
+		return;
+	}
+	_api->request(MTPhelp_GetNearestDc(
+	)).done([=](const MTPNearestDc &result) {
+		const auto &nearest = result.c_nearestDc();
+		DEBUG_LOG(("Got nearest dc, country: %1, nearest: %2, this: %3"
+			).arg(qs(nearest.vcountry())
+			).arg(nearest.vnearest_dc().v
+			).arg(nearest.vthis_dc().v));
+		_account->suggestMainDcId(nearest.vnearest_dc().v);
+		const auto nearestCountry = qs(nearest.vcountry());
+		if (getData()->country != nearestCountry) {
+			getData()->country = nearestCountry;
+			getData()->updated.notify();
+		}
+	}).send();
+}
+
+void Widget::showTerms(Fn<void()> callback) {
+	if (getData()->termsLock.text.text.isEmpty()) {
+		return;
+	}
+	const auto weak = Ui::MakeWeak(this);
+	const auto box = Ui::show(callback
+		? Box<Window::TermsBox>(
+			getData()->termsLock,
+			tr::lng_terms_agree(),
+			tr::lng_terms_decline())
+		: Box<Window::TermsBox>(
+			getData()->termsLock.text,
+			tr::lng_box_ok(),
+			nullptr));
+
+	box->setCloseByEscape(false);
+	box->setCloseByOutsideClick(false);
+
+	box->agreeClicks(
+	) | rpl::start_with_next([=] {
+		if (callback) {
+			callback();
+		}
+		if (box) {
+			box->closeBox();
+		}
+	}, box->lifetime());
+
+	box->cancelClicks(
+	) | rpl::start_with_next([=] {
+		const auto box = Ui::show(Box<Window::TermsBox>(
+			TextWithEntities{ tr::lng_terms_signup_sorry(tr::now) },
+			tr::lng_intro_finish(),
+			tr::lng_terms_decline()));
+		box->agreeClicks(
+		) | rpl::start_with_next([=] {
+			if (weak) {
+				showTerms(callback);
+			}
+		}, box->lifetime());
+		box->cancelClicks(
+		) | rpl::start_with_next([=] {
+			if (box) {
+				box->closeBox();
+			}
+		}, box->lifetime());
+	}, box->lifetime());
+}
+
+void Widget::showControls() {
+	getStep()->show();
+	setupNextButton();
+	_next->show(anim::type::instant);
+	_nextShownAnimation.stop();
+	_connecting->setForceHidden(false);
+	auto hasCover = getStep()->hasCover();
+	_settings->toggle(!hasCover, anim::type::instant);
+	if (_update) {
+		_update->toggle(!hasCover, anim::type::instant);
+	}
+	if (_changeLanguage) {
+		_changeLanguage->toggle(
+			!_resetAccount && !_terms && _nextShown,
+			anim::type::instant);
+	}
+	if (_terms) {
+		_terms->show(anim::type::instant);
+	}
+	_back->toggle(getStep()->hasBack(), anim::type::instant);
+}
+
+void Widget::setupNextButton() {
+	_next->entity()->setText(getStep()->nextButtonText(
+	) | rpl::filter([](const QString &text) {
+		return !text.isEmpty();
+	}));
+	getStep()->nextButtonText(
+	) | rpl::map([](const QString &text) {
+		return !text.isEmpty();
+	}) | rpl::filter([=](bool visible) {
+		return visible != _nextShown;
+	}) | rpl::start_with_next([=](bool visible) {
+		_next->toggle(visible, anim::type::normal);
+		_nextShown = visible;
+		if (_changeLanguage) {
+			_changeLanguage->toggle(
+				!_resetAccount && !_terms && _nextShown,
+				anim::type::normal);
+		}
+		_nextShownAnimation.start(
+			[=] { updateControlsGeometry(); },
+			_nextShown ? 0. : 1.,
+			_nextShown ? 1. : 0.,
+			st::slideDuration);
+	}, _stepLifetime);
+}
+
+void Widget::hideControls() {
+	getStep()->hide();
+	_next->hide(anim::type::instant);
+	_connecting->setForceHidden(true);
+	_settings->hide(anim::type::instant);
+	if (_update) _update->hide(anim::type::instant);
+	if (_changeLanguage) _changeLanguage->hide(anim::type::instant);
+	if (_terms) _terms->hide(anim::type::instant);
+	_back->hide(anim::type::instant);
+}
+
+void Widget::showAnimated(const QPixmap &bgAnimCache, bool back) {
+	_showBack = back;
+
+	(_showBack ? _cacheOver : _cacheUnder) = bgAnimCache;
+
+	_a_show.stop();
+	showControls();
+	(_showBack ? _cacheUnder : _cacheOver) = Ui::GrabWidget(this);
+	hideControls();
+
+	_a_show.start(
+		[=] { animationCallback(); },
+		0.,
+		1.,
+		st::slideDuration,
+		Window::SlideAnimation::transition());
+
+	show();
+}
+
+void Widget::animationCallback() {
+	update();
+	if (!_a_show.animating()) {
+		_cacheUnder = _cacheOver = QPixmap();
+
+		showControls();
+		getStep()->activate();
+	}
+}
+
+void Widget::paintEvent(QPaintEvent *e) {
+	bool trivial = (rect() == e->rect());
+	setMouseTracking(true);
+
+	QPainter p(this);
+	if (!trivial) {
+		p.setClipRect(e->rect());
+	}
+	p.fillRect(e->rect(), st::windowBg);
+	auto progress = _a_show.value(1.);
+	if (_a_show.animating()) {
+		auto coordUnder = _showBack ? anim::interpolate(-st::slideShift, 0, progress) : anim::interpolate(0, -st::slideShift, progress);
+		auto coordOver = _showBack ? anim::interpolate(0, width(), progress) : anim::interpolate(width(), 0, progress);
+		auto shadow = _showBack ? (1. - progress) : progress;
+		if (coordOver > 0) {
+			p.drawPixmap(QRect(0, 0, coordOver, height()), _cacheUnder, QRect(-coordUnder * cRetinaFactor(), 0, coordOver * cRetinaFactor(), height() * cRetinaFactor()));
+			p.setOpacity(shadow);
+			p.fillRect(0, 0, coordOver, height(), st::slideFadeOutBg);
+			p.setOpacity(1);
+		}
+		p.drawPixmap(coordOver, 0, _cacheOver);
+		p.setOpacity(shadow);
+		st::slideShadow.fill(p, QRect(coordOver - st::slideShadow.width(), 0, st::slideShadow.width(), height()));
+	}
+}
+
+void Widget::resizeEvent(QResizeEvent *e) {
+	for (const auto step : _stepHistory) {
+		step->setGeometry(rect());
+	}
+
+	updateControlsGeometry();
+}
+
+void Widget::updateControlsGeometry() {
+	auto shown = _coverShownAnimation.value(1.);
+
+	auto controlsTopTo = getStep()->hasCover() ? st::introCoverHeight : 0;
+	auto controlsTop = anim::interpolate(_controlsTopFrom, controlsTopTo, shown);
+	_settings->moveToRight(st::introSettingsSkip, controlsTop + st::introSettingsSkip);
+	if (_update) {
+		_update->moveToRight(st::introSettingsSkip + _settings->width() + st::introSettingsSkip, _settings->y());
+	}
+	_back->moveToLeft(0, controlsTop);
+
+	auto nextTopTo = getStep()->contentTop() + st::introNextTop;
+	auto nextTop = anim::interpolate(_nextTopFrom, nextTopTo, shown);
+	const auto shownAmount = _nextShownAnimation.value(_nextShown ? 1. : 0.);
+	const auto realNextTop = anim::interpolate(
+		nextTop + st::introNextSlide,
+		nextTop,
+		shownAmount);
+	_next->moveToLeft((width() - _next->width()) / 2, realNextTop);
+	getStep()->setShowAnimationClipping(shownAmount > 0
+		? QRect(0, 0, width(), realNextTop)
+		: QRect());
+	if (_changeLanguage) {
+		_changeLanguage->moveToLeft((width() - _changeLanguage->width()) / 2, _next->y() + _next->height() + _changeLanguage->height());
+	}
+	if (_resetAccount) {
+		_resetAccount->moveToLeft((width() - _resetAccount->width()) / 2, height() - st::introResetBottom - _resetAccount->height());
+	}
+	if (_terms) {
+		_terms->moveToLeft((width() - _terms->width()) / 2, height() - st::introTermsBottom - _terms->height());
+	}
+}
+
+
+void Widget::keyPressEvent(QKeyEvent *e) {
+	if (_a_show.animating() || getStep()->animating()) return;
+
+	if (e->key() == Qt::Key_Escape || e->key() == Qt::Key_Back) {
+		if (getStep()->hasBack()) {
+			historyMove(Direction::Back);
+		}
+	} else if (e->key() == Qt::Key_Enter
+		|| e->key() == Qt::Key_Return
+		|| e->key() == Qt::Key_Space) {
+		getStep()->submit();
+	}
+}
+
+Widget::~Widget() {
+	for (auto step : base::take(_stepHistory)) {
+		delete step;
+	}
+	if (App::wnd()) App::wnd()->noIntro(this);
+}
+
+} // namespace Intro
diff --git a/Telegram/SourceFiles/intro/intro_widget.h b/Telegram/SourceFiles/intro/intro_widget.h
new file mode 100644
index 000000000..b26e1f452
--- /dev/null
+++ b/Telegram/SourceFiles/intro/intro_widget.h
@@ -0,0 +1,160 @@
+/*
+This file is part of Telegram Desktop,
+the official desktop application for the Telegram messaging service.
+
+For license and copyright information please follow this link:
+https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+*/
+#pragma once
+
+#include "mtproto/sender.h"
+#include "ui/rp_widget.h"
+#include "ui/effects/animations.h"
+#include "window/window_lock_widgets.h"
+#include "core/core_cloud_password.h"
+
+namespace Main {
+class Account;
+} // namespace Main
+
+namespace Ui {
+class IconButton;
+class RoundButton;
+class LinkButton;
+class FlatLabel;
+template <typename Widget>
+class FadeWrap;
+} // namespace Ui
+
+namespace Window {
+class ConnectionState;
+} // namespace Window
+
+namespace Intro {
+namespace details {
+
+enum class CallStatus {
+	Waiting,
+	Calling,
+	Called,
+	Disabled,
+};
+
+struct Data {
+	QString country;
+	QString phone;
+	QByteArray phoneHash;
+
+	CallStatus callStatus = CallStatus::Disabled;
+	int callTimeout = 0;
+
+	int codeLength = 5;
+	bool codeByTelegram = false;
+
+	Core::CloudPasswordCheckRequest pwdRequest;
+	bool hasRecovery = false;
+	QString pwdHint;
+	bool pwdNotEmptyPassport = false;
+
+	Window::TermsLock termsLock;
+
+	base::Observable<void> updated;
+
+};
+
+enum class Direction {
+	Back,
+	Forward,
+	Replace,
+};
+
+class Step;
+
+} // namespace details
+
+class Widget : public Ui::RpWidget, private base::Subscriber {
+public:
+	Widget(QWidget *parent, not_null<Main::Account*> account);
+
+	void showAnimated(const QPixmap &bgAnimCache, bool back = false);
+
+	void setInnerFocus();
+
+	~Widget();
+
+protected:
+	void paintEvent(QPaintEvent *e) override;
+	void resizeEvent(QResizeEvent *e) override;
+	void keyPressEvent(QKeyEvent *e) override;
+
+private:
+	void refreshLang();
+	void animationCallback();
+	void createLanguageLink();
+	void checkUpdateStatus();
+	void setupNextButton();
+
+	void updateControlsGeometry();
+	[[nodiscard]] not_null<details::Data*> getData() {
+		return &_data;
+	}
+
+	void fixOrder();
+	void showControls();
+	void hideControls();
+
+	void showResetButton();
+	void resetAccount();
+
+	void showTerms();
+	void acceptTerms(Fn<void()> callback);
+	void hideAndDestroy(object_ptr<Ui::FadeWrap<Ui::RpWidget>> widget);
+
+	[[nodiscard]] details::Step *getStep(int skip = 0) const {
+		Expects(skip >= 0);
+		Expects(skip < _stepHistory.size());
+
+		return _stepHistory[_stepHistory.size() - skip - 1];
+	}
+	void historyMove(details::Direction direction);
+	void moveToStep(details::Step *step, details::Direction direction);
+	void appendStep(details::Step *step);
+
+	void getNearestDC();
+	void showTerms(Fn<void()> callback);
+
+	const not_null<Main::Account*> _account;
+	std::optional<MTP::Sender> _api;
+
+	Ui::Animations::Simple _a_show;
+	bool _showBack = false;
+	QPixmap _cacheUnder, _cacheOver;
+
+	std::vector<details::Step*> _stepHistory;
+	rpl::lifetime _stepLifetime;
+
+	details::Data _data;
+
+	Ui::Animations::Simple _coverShownAnimation;
+	int _nextTopFrom = 0;
+	int _controlsTopFrom = 0;
+
+	object_ptr<Ui::FadeWrap<Ui::IconButton>> _back;
+	object_ptr<Ui::FadeWrap<Ui::RoundButton>> _update = { nullptr };
+	object_ptr<Ui::FadeWrap<Ui::RoundButton>> _settings;
+
+	object_ptr<Ui::FadeWrap<Ui::RoundButton>> _next;
+	object_ptr<Ui::FadeWrap<Ui::LinkButton>> _changeLanguage = { nullptr };
+	object_ptr<Ui::FadeWrap<Ui::RoundButton>> _resetAccount = { nullptr };
+	object_ptr<Ui::FadeWrap<Ui::FlatLabel>> _terms = { nullptr };
+
+	std::unique_ptr<Window::ConnectionState> _connecting;
+
+	bool _nextShown = true;
+	Ui::Animations::Simple _nextShownAnimation;
+
+	mtpRequestId _resetRequest = 0;
+
+};
+
+} // namespace Intro
diff --git a/Telegram/SourceFiles/intro/introwidget.cpp b/Telegram/SourceFiles/intro/introwidget.cpp
deleted file mode 100644
index 6ffe8b060..000000000
--- a/Telegram/SourceFiles/intro/introwidget.cpp
+++ /dev/null
@@ -1,1081 +0,0 @@
-/*
-This file is part of Telegram Desktop,
-the official desktop application for the Telegram messaging service.
-
-For license and copyright information please follow this link:
-https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
-*/
-#include "intro/introwidget.h"
-
-#include "lang/lang_keys.h"
-#include "lang/lang_file_parser.h"
-#include "storage/localstorage.h"
-#include "intro/introstart.h"
-#include "intro/introphone.h"
-#include "intro/introcode.h"
-#include "intro/introsignup.h"
-#include "intro/intropwdcheck.h"
-#include "main/main_account.h"
-#include "mainwidget.h"
-#include "apiwrap.h"
-#include "mainwindow.h"
-#include "core/application.h"
-#include "boxes/confirm_box.h"
-#include "ui/text/text.h"
-#include "ui/text/text_utilities.h"
-#include "ui/widgets/buttons.h"
-#include "ui/widgets/labels.h"
-#include "ui/wrap/fade_wrap.h"
-#include "ui/effects/slide_animation.h"
-#include "core/update_checker.h"
-#include "window/window_slide_animation.h"
-#include "window/window_connecting_widget.h"
-#include "window/window_lock_widgets.h"
-#include "base/platform/base_platform_info.h"
-#include "data/data_user.h"
-#include "window/themes/window_theme.h"
-#include "lang/lang_cloud_manager.h"
-#include "main/main_session.h"
-#include "facades.h"
-#include "app.h"
-#include "styles/style_layers.h"
-#include "styles/style_intro.h"
-#include "styles/style_window.h"
-
-namespace Intro {
-namespace {
-
-void PrepareSupportMode() {
-	using Data::AutoDownload::Full;
-
-	anim::SetDisabled(true);
-	Local::writeSettings();
-
-	Global::SetDesktopNotify(false);
-	Global::SetSoundNotify(false);
-	Auth().settings().autoDownload() = Full::FullDisabled();
-	Local::writeUserSettings();
-}
-
-} // namespace
-
-Widget::Widget(QWidget *parent, not_null<Main::Account*> account)
-: RpWidget(parent)
-, _account(account)
-, _back(this, object_ptr<Ui::IconButton>(this, st::introBackButton))
-, _settings(
-	this,
-	object_ptr<Ui::RoundButton>(
-		this,
-		tr::lng_menu_settings(),
-		st::defaultBoxButton))
-, _next(this, nullptr, st::introNextButton) {
-	getData()->country = Platform::SystemCountry();
-
-	_back->entity()->setClickedCallback([this] { historyMove(Direction::Back); });
-	_back->hide(anim::type::instant);
-
-	_next->setClickedCallback([this] { getStep()->submit(); });
-
-	_settings->entity()->setClickedCallback([] { App::wnd()->showSettings(); });
-
-	getNearestDC();
-	setupConnectingWidget();
-
-	appendStep(new StartWidget(this, _account, getData()));
-	fixOrder();
-
-	subscribe(Lang::CurrentCloudManager().firstLanguageSuggestion(), [this] { createLanguageLink(); });
-	createLanguageLink();
-	if (_changeLanguage) _changeLanguage->finishAnimating();
-
-	subscribe(Lang::Current().updated(), [this] { refreshLang(); });
-
-	show();
-	showControls();
-	getStep()->showFast();
-	setInnerFocus();
-
-	cSetPasswordRecovered(false);
-
-	if (!Core::UpdaterDisabled()) {
-		Core::UpdateChecker checker;
-		checker.isLatest() | rpl::start_with_next([=] {
-			onCheckUpdateStatus();
-		}, lifetime());
-		checker.failed() | rpl::start_with_next([=] {
-			onCheckUpdateStatus();
-		}, lifetime());
-		checker.ready() | rpl::start_with_next([=] {
-			onCheckUpdateStatus();
-		}, lifetime());
-		checker.start();
-		onCheckUpdateStatus();
-	}
-}
-
-void Widget::setupConnectingWidget() {
-	_connecting = std::make_unique<Window::ConnectionState>(
-		this,
-		rpl::single(true));
-}
-
-void Widget::refreshLang() {
-	_changeLanguage.destroy();
-	createLanguageLink();
-	InvokeQueued(this, [this] { updateControlsGeometry(); });
-}
-
-void Widget::createLanguageLink() {
-	if (_changeLanguage) return;
-
-	auto createLink = [this](const QString &text, const QString &languageId) {
-		_changeLanguage.create(
-			this,
-			object_ptr<Ui::LinkButton>(this, text));
-		_changeLanguage->hide(anim::type::instant);
-		_changeLanguage->entity()->setClickedCallback([=] {
-			Lang::CurrentCloudManager().switchToLanguage(languageId);
-		});
-		_changeLanguage->toggle(
-			!_resetAccount && !_terms,
-			anim::type::normal);
-		updateControlsGeometry();
-	};
-
-	const auto currentId = Lang::LanguageIdOrDefault(Lang::Current().id());
-	const auto defaultId = Lang::DefaultLanguageId();
-	const auto suggested = Lang::CurrentCloudManager().suggestedLanguage();
-	if (currentId != defaultId) {
-		createLink(
-			Lang::GetOriginalValue(tr::lng_switch_to_this.base),
-			defaultId);
-	} else if (!suggested.isEmpty() && suggested != currentId) {
-		request(MTPlangpack_GetStrings(
-			MTP_string(Lang::CloudLangPackName()),
-			MTP_string(suggested),
-			MTP_vector<MTPstring>(1, MTP_string("lng_switch_to_this"))
-		)).done([=](const MTPVector<MTPLangPackString> &result) {
-			const auto strings = Lang::Instance::ParseStrings(result);
-			const auto i = strings.find(tr::lng_switch_to_this.base);
-			if (i != strings.end()) {
-				createLink(i->second, suggested);
-			}
-		}).send();
-	}
-}
-
-void Widget::onCheckUpdateStatus() {
-	Expects(!Core::UpdaterDisabled());
-
-	if (Core::UpdateChecker().state() == Core::UpdateChecker::State::Ready) {
-		if (_update) return;
-		_update.create(
-			this,
-			object_ptr<Ui::RoundButton>(
-				this,
-				tr::lng_menu_update(),
-				st::defaultBoxButton));
-		if (!_a_show.animating()) {
-			_update->setVisible(true);
-		}
-		const auto stepHasCover = getStep()->hasCover();
-		_update->toggle(!stepHasCover, anim::type::instant);
-		_update->entity()->setClickedCallback([] {
-			Core::checkReadyUpdate();
-			App::restart();
-		});
-	} else {
-		if (!_update) return;
-		_update.destroy();
-	}
-	updateControlsGeometry();
-}
-
-void Widget::setInnerFocus() {
-	if (getStep()->animating()) {
-		setFocus();
-	} else {
-		getStep()->setInnerFocus();
-	}
-}
-
-void Widget::historyMove(Direction direction) {
-	if (getStep()->animating()) return;
-
-	Assert(_stepHistory.size() > 1);
-
-	auto wasStep = getStep((direction == Direction::Back) ? 0 : 1);
-	if (direction == Direction::Back) {
-		_stepHistory.pop_back();
-		wasStep->cancelled();
-	} else if (direction == Direction::Replace) {
-		_stepHistory.removeAt(_stepHistory.size() - 2);
-	}
-
-	if (_resetAccount) {
-		hideAndDestroy(std::exchange(_resetAccount, { nullptr }));
-	}
-	if (_terms) {
-		hideAndDestroy(std::exchange(_terms, { nullptr }));
-	}
-
-	getStep()->finishInit();
-	getStep()->prepareShowAnimated(wasStep);
-	if (wasStep->hasCover() != getStep()->hasCover()) {
-		_nextTopFrom = wasStep->contentTop() + st::introStepHeight;
-		_controlsTopFrom = wasStep->hasCover() ? st::introCoverHeight : 0;
-		_coverShownAnimation.start([this] { updateControlsGeometry(); }, 0., 1., st::introCoverDuration, wasStep->hasCover() ? anim::linear : anim::easeOutCirc);
-	}
-
-	if (direction == Direction::Forward || direction == Direction::Replace) {
-		wasStep->finished();
-	}
-	if (direction == Direction::Back || direction == Direction::Replace) {
-		delete base::take(wasStep);
-	}
-	_back->toggle(getStep()->hasBack(), anim::type::normal);
-
-	auto stepHasCover = getStep()->hasCover();
-	_settings->toggle(!stepHasCover, anim::type::normal);
-	if (_update) {
-		_update->toggle(!stepHasCover, anim::type::normal);
-	}
-	_next->setText(getStep()->nextButtonText());
-	if (_resetAccount) _resetAccount->show(anim::type::normal);
-	if (_terms) _terms->show(anim::type::normal);
-	if (_changeLanguage) {
-		_changeLanguage->toggle(
-			!_resetAccount && !_terms,
-			anim::type::normal);
-	}
-	getStep()->showAnimated(direction);
-	fixOrder();
-}
-
-void Widget::hideAndDestroy(object_ptr<Ui::FadeWrap<Ui::RpWidget>> widget) {
-	const auto weak = Ui::MakeWeak(widget.data());
-	widget->hide(anim::type::normal);
-	widget->shownValue(
-	) | rpl::start_with_next([=](bool shown) {
-		if (!shown && weak) {
-			weak->deleteLater();
-		}
-	}, widget->lifetime());
-}
-
-void Widget::fixOrder() {
-	_next->raise();
-	if (_update) _update->raise();
-	_settings->raise();
-	_back->raise();
-	_connecting->raise();
-}
-
-void Widget::moveToStep(Step *step, Direction direction) {
-	appendStep(step);
-	_back->raise();
-	_settings->raise();
-	if (_update) {
-		_update->raise();
-	}
-	_connecting->raise();
-
-	historyMove(direction);
-}
-
-void Widget::appendStep(Step *step) {
-	_stepHistory.push_back(step);
-	step->setGeometry(calculateStepRect());
-	step->setGoCallback([=](Step *step, Direction direction) {
-		if (direction == Direction::Back) {
-			historyMove(direction);
-		} else {
-			moveToStep(step, direction);
-		}
-	});
-	step->setShowResetCallback([=] {
-		showResetButton();
-	});
-	step->setShowTermsCallback([=]() {
-		showTerms();
-	});
-	step->setAcceptTermsCallback([=](Fn<void()> callback) {
-		acceptTerms(callback);
-	});
-}
-
-void Widget::showResetButton() {
-	if (!_resetAccount) {
-		auto entity = object_ptr<Ui::RoundButton>(
-			this,
-			tr::lng_signin_reset_account(),
-			st::introResetButton);
-		_resetAccount.create(this, std::move(entity));
-		_resetAccount->hide(anim::type::instant);
-		_resetAccount->entity()->setClickedCallback([this] { resetAccount(); });
-		updateControlsGeometry();
-	}
-	_resetAccount->show(anim::type::normal);
-	if (_changeLanguage) {
-		_changeLanguage->hide(anim::type::normal);
-	}
-}
-
-void Widget::showTerms() {
-	if (getData()->termsLock.text.text.isEmpty()) {
-		_terms.destroy();
-	} else if (!_terms) {
-		auto entity = object_ptr<Ui::FlatLabel>(
-			this,
-			tr::lng_terms_signup(
-				lt_link,
-				tr::lng_terms_signup_link() | Ui::Text::ToLink(),
-				Ui::Text::WithEntities),
-			st::introTermsLabel);
-		_terms.create(this, std::move(entity));
-		_terms->entity()->setClickHandlerFilter([=](
-				const ClickHandlerPtr &handler,
-				Qt::MouseButton button) {
-			if (button == Qt::LeftButton) {
-				showTerms(nullptr);
-			}
-			return false;
-		});
-		updateControlsGeometry();
-		_terms->hide(anim::type::instant);
-	}
-	if (_changeLanguage) {
-		_changeLanguage->toggle(
-			!_terms && !_resetAccount,
-			anim::type::normal);
-	}
-}
-
-void Widget::acceptTerms(Fn<void()> callback) {
-	showTerms(callback);
-}
-
-void Widget::resetAccount() {
-	if (_resetRequest) return;
-
-	Ui::show(Box<ConfirmBox>(tr::lng_signin_sure_reset(tr::now), tr::lng_signin_reset(tr::now), st::attentionBoxButton, crl::guard(this, [this] {
-		if (_resetRequest) return;
-		_resetRequest = request(MTPaccount_DeleteAccount(MTP_string("Forgot password"))).done([this](const MTPBool &result) {
-			_resetRequest = 0;
-
-			Ui::hideLayer();
-			moveToStep(
-				new SignupWidget(this, _account, getData()),
-				Direction::Replace);
-		}).fail([this](const RPCError &error) {
-			_resetRequest = 0;
-
-			const auto &type = error.type();
-			if (type.startsWith(qstr("2FA_CONFIRM_WAIT_"))) {
-				const auto seconds = type.mid(qstr("2FA_CONFIRM_WAIT_").size()).toInt();
-				const auto days = (seconds + 59) / 86400;
-				const auto hours = ((seconds + 59) % 86400) / 3600;
-				const auto minutes = ((seconds + 59) % 3600) / 60;
-				auto when = tr::lng_signin_reset_minutes(
-					tr::now,
-					lt_count,
-					minutes);
-				if (days > 0) {
-					const auto daysCount = tr::lng_signin_reset_days(
-						tr::now,
-						lt_count,
-						days);
-					const auto hoursCount = tr::lng_signin_reset_hours(
-						tr::now,
-						lt_count,
-						hours);
-					when = tr::lng_signin_reset_in_days(
-						tr::now,
-						lt_days_count,
-						daysCount,
-						lt_hours_count,
-						hoursCount,
-						lt_minutes_count,
-						when);
-				} else if (hours > 0) {
-					const auto hoursCount = tr::lng_signin_reset_hours(
-						tr::now,
-						lt_count,
-						hours);
-					when = tr::lng_signin_reset_in_hours(
-						tr::now,
-						lt_hours_count,
-						hoursCount,
-						lt_minutes_count,
-						when);
-				}
-				Ui::show(Box<InformBox>(tr::lng_signin_reset_wait(
-					tr::now,
-					lt_phone_number,
-					App::formatPhone(getData()->phone),
-					lt_when,
-					when)));
-			} else if (type == qstr("2FA_RECENT_CONFIRM")) {
-				Ui::show(Box<InformBox>(
-					tr::lng_signin_reset_cancelled(tr::now)));
-			} else {
-				Ui::hideLayer();
-				getStep()->showError(rpl::single(Lang::Hard::ServerError()));
-			}
-		}).send();
-	})));
-}
-
-void Widget::getNearestDC() {
-	request(MTPhelp_GetNearestDc()).done([this](const MTPNearestDc &result) {
-		auto &nearest = result.c_nearestDc();
-		DEBUG_LOG(("Got nearest dc, country: %1, nearest: %2, this: %3"
-			).arg(qs(nearest.vcountry())
-			).arg(nearest.vnearest_dc().v
-			).arg(nearest.vthis_dc().v));
-		_account->suggestMainDcId(nearest.vnearest_dc().v);
-		const auto nearestCountry = qs(nearest.vcountry());
-		if (getData()->country != nearestCountry) {
-			getData()->country = nearestCountry;
-			getData()->updated.notify();
-		}
-	}).send();
-}
-
-void Widget::showTerms(Fn<void()> callback) {
-	if (getData()->termsLock.text.text.isEmpty()) {
-		return;
-	}
-	const auto weak = Ui::MakeWeak(this);
-	const auto box = Ui::show(callback
-		? Box<Window::TermsBox>(
-			getData()->termsLock,
-			tr::lng_terms_agree(),
-			tr::lng_terms_decline())
-		: Box<Window::TermsBox>(
-			getData()->termsLock.text,
-			tr::lng_box_ok(),
-			nullptr));
-
-	box->setCloseByEscape(false);
-	box->setCloseByOutsideClick(false);
-
-	box->agreeClicks(
-	) | rpl::start_with_next([=] {
-		if (callback) {
-			callback();
-		}
-		if (box) {
-			box->closeBox();
-		}
-	}, box->lifetime());
-
-	box->cancelClicks(
-	) | rpl::start_with_next([=] {
-		const auto box = Ui::show(Box<Window::TermsBox>(
-			TextWithEntities{ tr::lng_terms_signup_sorry(tr::now) },
-			tr::lng_intro_finish(),
-			tr::lng_terms_decline()));
-		box->agreeClicks(
-		) | rpl::start_with_next([=] {
-			if (weak) {
-				showTerms(callback);
-			}
-		}, box->lifetime());
-		box->cancelClicks(
-		) | rpl::start_with_next([=] {
-			if (box) {
-				box->closeBox();
-			}
-		}, box->lifetime());
-	}, box->lifetime());
-}
-
-void Widget::showControls() {
-	getStep()->show();
-	_next->show();
-	_next->setText(getStep()->nextButtonText());
-	_connecting->setForceHidden(false);
-	auto hasCover = getStep()->hasCover();
-	_settings->toggle(!hasCover, anim::type::instant);
-	if (_update) {
-		_update->toggle(!hasCover, anim::type::instant);
-	}
-	if (_changeLanguage) {
-		_changeLanguage->toggle(
-			!_resetAccount && !_terms,
-			anim::type::instant);
-	}
-	if (_terms) {
-		_terms->show(anim::type::instant);
-	}
-	_back->toggle(getStep()->hasBack(), anim::type::instant);
-}
-
-void Widget::hideControls() {
-	getStep()->hide();
-	_next->hide();
-	_connecting->setForceHidden(true);
-	_settings->hide(anim::type::instant);
-	if (_update) _update->hide(anim::type::instant);
-	if (_changeLanguage) _changeLanguage->hide(anim::type::instant);
-	if (_terms) _terms->hide(anim::type::instant);
-	_back->hide(anim::type::instant);
-}
-
-void Widget::showAnimated(const QPixmap &bgAnimCache, bool back) {
-	_showBack = back;
-
-	(_showBack ? _cacheOver : _cacheUnder) = bgAnimCache;
-
-	_a_show.stop();
-	showControls();
-	(_showBack ? _cacheUnder : _cacheOver) = Ui::GrabWidget(this);
-	hideControls();
-
-	_a_show.start([=] { animationCallback(); }, 0., 1., st::slideDuration, Window::SlideAnimation::transition());
-
-	show();
-}
-
-void Widget::animationCallback() {
-	update();
-	if (!_a_show.animating()) {
-		_cacheUnder = _cacheOver = QPixmap();
-
-		showControls();
-		getStep()->activate();
-	}
-}
-
-void Widget::paintEvent(QPaintEvent *e) {
-	bool trivial = (rect() == e->rect());
-	setMouseTracking(true);
-
-	QPainter p(this);
-	if (!trivial) {
-		p.setClipRect(e->rect());
-	}
-	p.fillRect(e->rect(), st::windowBg);
-	auto progress = _a_show.value(1.);
-	if (_a_show.animating()) {
-		auto coordUnder = _showBack ? anim::interpolate(-st::slideShift, 0, progress) : anim::interpolate(0, -st::slideShift, progress);
-		auto coordOver = _showBack ? anim::interpolate(0, width(), progress) : anim::interpolate(width(), 0, progress);
-		auto shadow = _showBack ? (1. - progress) : progress;
-		if (coordOver > 0) {
-			p.drawPixmap(QRect(0, 0, coordOver, height()), _cacheUnder, QRect(-coordUnder * cRetinaFactor(), 0, coordOver * cRetinaFactor(), height() * cRetinaFactor()));
-			p.setOpacity(shadow);
-			p.fillRect(0, 0, coordOver, height(), st::slideFadeOutBg);
-			p.setOpacity(1);
-		}
-		p.drawPixmap(coordOver, 0, _cacheOver);
-		p.setOpacity(shadow);
-		st::slideShadow.fill(p, QRect(coordOver - st::slideShadow.width(), 0, st::slideShadow.width(), height()));
-	}
-}
-
-QRect Widget::calculateStepRect() const {
-	auto stepInnerTop = (height() - st::introHeight) / 2;
-	accumulate_max(stepInnerTop, st::introStepTopMin);
-	auto nextTop = stepInnerTop + st::introStepHeight;
-	auto additionalHeight = st::introStepHeightAdd;
-	auto stepWidth = width();
-	auto stepHeight = nextTop + additionalHeight;
-	return QRect(0, 0, stepWidth, stepHeight);
-}
-
-void Widget::resizeEvent(QResizeEvent *e) {
-	auto stepRect = calculateStepRect();
-	for_const (auto step, _stepHistory) {
-		step->setGeometry(stepRect);
-	}
-
-	updateControlsGeometry();
-}
-
-void Widget::updateControlsGeometry() {
-	auto shown = _coverShownAnimation.value(1.);
-
-	auto controlsTopTo = getStep()->hasCover() ? st::introCoverHeight : 0;
-	auto controlsTop = anim::interpolate(_controlsTopFrom, controlsTopTo, shown);
-	_settings->moveToRight(st::introSettingsSkip, controlsTop + st::introSettingsSkip);
-	if (_update) {
-		_update->moveToRight(st::introSettingsSkip + _settings->width() + st::introSettingsSkip, _settings->y());
-	}
-	_back->moveToLeft(0, controlsTop);
-
-	auto nextTopTo = getStep()->contentTop() + st::introStepHeight;
-	auto nextTop = anim::interpolate(_nextTopFrom, nextTopTo, shown);
-	_next->moveToLeft((width() - _next->width()) / 2, nextTop);
-	if (_changeLanguage) {
-		_changeLanguage->moveToLeft((width() - _changeLanguage->width()) / 2, _next->y() + _next->height() + _changeLanguage->height());
-	}
-	if (_resetAccount) {
-		_resetAccount->moveToLeft((width() - _resetAccount->width()) / 2, height() - st::introResetBottom - _resetAccount->height());
-	}
-	if (_terms) {
-		_terms->moveToLeft((width() - _terms->width()) / 2, height() - st::introTermsBottom - _terms->height());
-	}
-}
-
-
-void Widget::keyPressEvent(QKeyEvent *e) {
-	if (_a_show.animating() || getStep()->animating()) return;
-
-	if (e->key() == Qt::Key_Escape || e->key() == Qt::Key_Back) {
-		if (getStep()->hasBack()) {
-			historyMove(Direction::Back);
-		}
-	} else if (e->key() == Qt::Key_Enter
-		|| e->key() == Qt::Key_Return
-		|| e->key() == Qt::Key_Space) {
-		getStep()->submit();
-	}
-}
-
-Widget::~Widget() {
-	for (auto step : base::take(_stepHistory)) {
-		delete step;
-	}
-	if (App::wnd()) App::wnd()->noIntro(this);
-}
-
-rpl::producer<QString> Widget::Step::nextButtonText() const {
-	return tr::lng_intro_next();
-}
-
-void Widget::Step::finish(const MTPUser &user, QImage &&photo) {
-	if (user.type() != mtpc_user
-		|| !user.c_user().is_self()
-		|| !user.c_user().vid().v) {
-		// No idea what to do here.
-		// We could've reset intro and MTP, but this really should not happen.
-		Ui::show(Box<InformBox>("Internal error: bad user.is_self() after sign in."));
-		return;
-	}
-
-	// Save the default language if we've suggested some other and user ignored it.
-	const auto currentId = Lang::Current().id();
-	const auto defaultId = Lang::DefaultLanguageId();
-	const auto suggested = Lang::CurrentCloudManager().suggestedLanguage();
-	if (currentId.isEmpty() && !suggested.isEmpty() && suggested != defaultId) {
-		Lang::Current().switchToId(Lang::DefaultLanguage());
-		Local::writeLangPack();
-	}
-
-	const auto account = _account;
-	const auto weak = base::make_weak(account.get());
-	account->createSession(user);
-	Local::writeMtpData();
-	App::wnd()->setupMain();
-
-	// "this" is already deleted here by creating the main widget.
-	if (weak && account->sessionExists()) {
-		auto &session = account->session();
-		if (!photo.isNull()) {
-			session.api().uploadPeerPhoto(session.user(), std::move(photo));
-		}
-		if (session.supportMode()) {
-			PrepareSupportMode();
-		}
-	}
-}
-
-void Widget::Step::paintEvent(QPaintEvent *e) {
-	Painter p(this);
-	paintAnimated(p, e->rect());
-}
-
-void Widget::Step::resizeEvent(QResizeEvent *e) {
-	updateLabelsPosition();
-}
-
-void Widget::Step::updateLabelsPosition() {
-	Ui::SendPendingMoveResizeEvents(_description->entity());
-	if (hasCover()) {
-		_title->moveToLeft((width() - _title->width()) / 2, contentTop() + st::introCoverTitleTop);
-		_description->moveToLeft((width() - _description->width()) / 2, contentTop() + st::introCoverDescriptionTop);
-	} else {
-		_title->moveToLeft(contentLeft() + st::buttonRadius, contentTop() + st::introTitleTop);
-		_description->resizeToWidth(st::introDescription.minWidth);
-		_description->moveToLeft(contentLeft() + st::buttonRadius, contentTop() + st::introDescriptionTop);
-	}
-	if (_error) {
-		if (_errorCentered) {
-			_error->entity()->resizeToWidth(width());
-		}
-		Ui::SendPendingMoveResizeEvents(_error->entity());
-		auto errorLeft = _errorCentered ? 0 : (contentLeft() + st::buttonRadius);
-		auto errorTop = contentTop() + (_errorBelowLink ? st::introErrorBelowLinkTop : st::introErrorTop);
-		_error->moveToLeft(errorLeft, errorTop);
-	}
-}
-
-void Widget::Step::setTitleText(rpl::producer<QString> titleText) {
-	_titleText = std::move(titleText);
-}
-
-void Widget::Step::setDescriptionText(
-		rpl::producer<QString> descriptionText) {
-	setDescriptionText(
-		std::move(descriptionText) | Ui::Text::ToWithEntities());
-}
-
-void Widget::Step::setDescriptionText(
-		rpl::producer<TextWithEntities> richDescriptionText) {
-	_descriptionText = std::move(richDescriptionText);
-}
-
-void Widget::Step::showFinished() {
-	_a_show.stop();
-	_coverAnimation = CoverAnimation();
-	_slideAnimation.reset();
-	prepareCoverMask();
-	activate();
-}
-
-bool Widget::Step::paintAnimated(Painter &p, QRect clip) {
-	if (_slideAnimation) {
-		_slideAnimation->paintFrame(p, (width() - st::introStepWidth) / 2, contentTop(), width());
-		if (!_slideAnimation->animating()) {
-			showFinished();
-			return false;
-		}
-		return true;
-	}
-
-	auto dt = _a_show.value(1.);
-	if (!_a_show.animating()) {
-		if (hasCover()) {
-			paintCover(p, 0);
-		}
-		if (_coverAnimation.title) {
-			showFinished();
-		}
-		if (!QRect(0, contentTop(), width(), st::introStepHeight).intersects(clip)) {
-			return true;
-		}
-		return false;
-	}
-
-	auto progress = (hasCover() ? anim::easeOutCirc(1., dt) : anim::linear(1., dt));
-	auto arrivingAlpha = progress;
-	auto departingAlpha = 1. - progress;
-	auto showCoverMethod = progress;
-	auto hideCoverMethod = progress;
-	auto coverTop = (hasCover() ? anim::interpolate(-st::introCoverHeight, 0, showCoverMethod) : anim::interpolate(0, -st::introCoverHeight, hideCoverMethod));
-
-	paintCover(p, coverTop);
-
-	auto positionReady = hasCover() ? showCoverMethod : hideCoverMethod;
-	_coverAnimation.title->paintFrame(p, positionReady, departingAlpha, arrivingAlpha);
-	_coverAnimation.description->paintFrame(p, positionReady, departingAlpha, arrivingAlpha);
-
-	paintContentSnapshot(p, _coverAnimation.contentSnapshotWas, departingAlpha, showCoverMethod);
-	paintContentSnapshot(p, _coverAnimation.contentSnapshotNow, arrivingAlpha, 1. - hideCoverMethod);
-
-	return true;
-}
-
-void Widget::Step::fillSentCodeData(const MTPDauth_sentCode &data) {
-	const auto &type = data.vtype();
-	switch (type.type()) {
-	case mtpc_auth_sentCodeTypeApp: {
-		getData()->codeByTelegram = true;
-		getData()->codeLength = type.c_auth_sentCodeTypeApp().vlength().v;
-	} break;
-	case mtpc_auth_sentCodeTypeSms: {
-		getData()->codeByTelegram = false;
-		getData()->codeLength = type.c_auth_sentCodeTypeSms().vlength().v;
-	} break;
-	case mtpc_auth_sentCodeTypeCall: {
-		getData()->codeByTelegram = false;
-		getData()->codeLength = type.c_auth_sentCodeTypeCall().vlength().v;
-	} break;
-	case mtpc_auth_sentCodeTypeFlashCall: LOG(("Error: should not be flashcall!")); break;
-	}
-}
-
-void Widget::Step::showDescription() {
-	_description->show(anim::type::normal);
-}
-
-void Widget::Step::hideDescription() {
-	_description->hide(anim::type::normal);
-}
-
-void Widget::Step::paintContentSnapshot(Painter &p, const QPixmap &snapshot, float64 alpha, float64 howMuchHidden) {
-	if (!snapshot.isNull()) {
-		auto contentTop = anim::interpolate(height() - (snapshot.height() / cIntRetinaFactor()), height(), howMuchHidden);
-		if (contentTop < height()) {
-			p.setOpacity(alpha);
-			p.drawPixmap(QPoint(contentLeft(), contentTop), snapshot, QRect(0, 0, snapshot.width(), (height() - contentTop) * cIntRetinaFactor()));
-		}
-	}
-}
-
-void Widget::Step::prepareCoverMask() {
-	if (!_coverMask.isNull()) return;
-
-	auto maskWidth = cIntRetinaFactor();
-	auto maskHeight = st::introCoverHeight * cIntRetinaFactor();
-	auto mask = QImage(maskWidth, maskHeight, QImage::Format_ARGB32_Premultiplied);
-	auto maskInts = reinterpret_cast<uint32*>(mask.bits());
-	Assert(mask.depth() == (sizeof(uint32) << 3));
-	auto maskIntsPerLineAdded = (mask.bytesPerLine() >> 2) - maskWidth;
-	Assert(maskIntsPerLineAdded >= 0);
-	auto realHeight = static_cast<float64>(maskHeight - 1);
-	for (auto y = 0; y != maskHeight; ++y) {
-		auto color = anim::color(st::introCoverTopBg, st::introCoverBottomBg, y / realHeight);
-		auto colorInt = anim::getPremultiplied(color);
-		for (auto x = 0; x != maskWidth; ++x) {
-			*maskInts++ = colorInt;
-		}
-		maskInts += maskIntsPerLineAdded;
-	}
-	_coverMask = App::pixmapFromImageInPlace(std::move(mask));
-}
-
-void Widget::Step::paintCover(Painter &p, int top) {
-	auto coverHeight = top + st::introCoverHeight;
-	if (coverHeight > 0) {
-		p.drawPixmap(QRect(0, 0, width(), coverHeight), _coverMask, QRect(0, -top * cIntRetinaFactor(), _coverMask.width(), coverHeight * cIntRetinaFactor()));
-	}
-
-	auto left = 0;
-	auto right = 0;
-	if (width() < st::introCoverMaxWidth) {
-		auto iconsMaxSkip = st::introCoverMaxWidth - st::introCoverLeft.width() - st::introCoverRight.width();
-		auto iconsSkip = st::introCoverIconsMinSkip + (iconsMaxSkip - st::introCoverIconsMinSkip) * (width() - st::introStepWidth) / (st::introCoverMaxWidth - st::introStepWidth);
-		auto outside = iconsSkip + st::introCoverLeft.width() + st::introCoverRight.width() - width();
-		left = -outside / 2;
-		right = -outside - left;
-	}
-	if (top < 0) {
-		auto shown = float64(coverHeight) / st::introCoverHeight;
-		auto leftShown = qRound(shown * (left + st::introCoverLeft.width()));
-		left = leftShown - st::introCoverLeft.width();
-		auto rightShown = qRound(shown * (right + st::introCoverRight.width()));
-		right = rightShown - st::introCoverRight.width();
-	}
-	st::introCoverLeft.paint(p, left, coverHeight - st::introCoverLeft.height(), width());
-	st::introCoverRight.paint(p, width() - right - st::introCoverRight.width(), coverHeight - st::introCoverRight.height(), width());
-
-	auto planeLeft = (width() - st::introCoverIcon.width()) / 2 - st::introCoverIconLeft;
-	auto planeTop = top + st::introCoverIconTop;
-	if (top < 0 && !_hasCover) {
-		auto deltaLeft = -qRound(float64(st::introPlaneWidth / st::introPlaneHeight) * top);
-//		auto deltaTop = top;
-		planeLeft += deltaLeft;
-	//	planeTop += top;
-	}
-	st::introCoverIcon.paint(p, planeLeft, planeTop, width());
-}
-
-int Widget::Step::contentLeft() const {
-	return (width() - st::introNextButton.width) / 2;
-}
-
-int Widget::Step::contentTop() const {
-	auto result = height() - st::introStepHeight - st::introStepHeightAdd;
-	if (_hasCover) {
-		auto added = 1. - snap(float64(height() - st::windowMinHeight) / (st::introStepHeightFull - st::windowMinHeight), 0., 1.);
-		result += qRound(added * st::introStepHeightAdd);
-	}
-	return result;
-}
-
-void Widget::Step::setErrorCentered(bool centered) {
-	_errorCentered = centered;
-	_error.destroy();
-}
-
-void Widget::Step::setErrorBelowLink(bool below) {
-	_errorBelowLink = below;
-	if (_error) {
-		updateLabelsPosition();
-	}
-}
-
-void Widget::Step::showError(rpl::producer<QString> text) {
-	_errorText = std::move(text);
-}
-
-void Widget::Step::refreshError(const QString &text) {
-	if (text.isEmpty()) {
-		if (_error) _error->hide(anim::type::normal);
-	} else {
-		if (!_error) {
-			_error.create(
-				this,
-				object_ptr<Ui::FlatLabel>(
-					this,
-					_errorCentered
-						? st::introErrorCentered
-						: st::introError));
-			_error->hide(anim::type::instant);
-		}
-		_error->entity()->setText(text);
-		updateLabelsPosition();
-		_error->show(anim::type::normal);
-	}
-}
-
-Widget::Step::Step(
-	QWidget *parent,
-	not_null<Main::Account*> account,
-	not_null<Data*> data,
-	bool hasCover)
-: RpWidget(parent)
-, _account(account)
-, _data(data)
-, _hasCover(hasCover)
-, _title(this, _hasCover ? st::introCoverTitle : st::introTitle)
-, _description(
-	this,
-	object_ptr<Ui::FlatLabel>(
-		this,
-		_hasCover
-			? st::introCoverDescription
-			: st::introDescription)) {
-	hide();
-	subscribe(Window::Theme::Background(), [this](
-			const Window::Theme::BackgroundUpdate &update) {
-		if (update.paletteChanged()) {
-			if (!_coverMask.isNull()) {
-				_coverMask = QPixmap();
-				prepareCoverMask();
-			}
-		}
-	});
-
-	_errorText.value(
-	) | rpl::start_with_next([=](const QString &text) {
-		refreshError(text);
-	}, lifetime());
-
-	_titleText.value(
-	) | rpl::start_with_next([=](const QString &text) {
-		_title->setText(text);
-		updateLabelsPosition();
-	}, lifetime());
-
-	_descriptionText.value(
-	) | rpl::start_with_next([=](const TextWithEntities &text) {
-		_description->entity()->setMarkedText(text);
-		updateLabelsPosition();
-	}, lifetime());
-}
-
-void Widget::Step::prepareShowAnimated(Step *after) {
-	setInnerFocus();
-	if (hasCover() || after->hasCover()) {
-		_coverAnimation = prepareCoverAnimation(after);
-		prepareCoverMask();
-	} else {
-		auto leftSnapshot = after->prepareSlideAnimation();
-		auto rightSnapshot = prepareSlideAnimation();
-		_slideAnimation = std::make_unique<Ui::SlideAnimation>();
-		_slideAnimation->setSnapshots(std::move(leftSnapshot), std::move(rightSnapshot));
-		_slideAnimation->setOverflowHidden(false);
-	}
-}
-
-Widget::Step::CoverAnimation Widget::Step::prepareCoverAnimation(Step *after) {
-	auto result = CoverAnimation();
-	result.title = Ui::FlatLabel::CrossFade(
-		after->_title,
-		_title,
-		st::introBg);
-	result.description = Ui::FlatLabel::CrossFade(
-		after->_description->entity(),
-		_description->entity(),
-		st::introBg,
-		after->_description->pos(),
-		_description->pos());
-	result.contentSnapshotWas = after->prepareContentSnapshot();
-	result.contentSnapshotNow = prepareContentSnapshot();
-	return result;
-}
-
-QPixmap Widget::Step::prepareContentSnapshot() {
-	auto otherTop = _description->y() + _description->height();
-	auto otherRect = myrtlrect(contentLeft(), otherTop, st::introStepWidth, height() - otherTop);
-	return Ui::GrabWidget(this, otherRect);
-}
-
-QPixmap Widget::Step::prepareSlideAnimation() {
-	auto grabLeft = (width() - st::introStepWidth) / 2;
-	auto grabTop = contentTop();
-	return Ui::GrabWidget(
-		this,
-		QRect(grabLeft, grabTop, st::introStepWidth, st::introStepHeight));
-}
-
-void Widget::Step::showAnimated(Direction direction) {
-	setFocus();
-	show();
-	hideChildren();
-	if (_slideAnimation) {
-		auto slideLeft = (direction == Direction::Back);
-		_slideAnimation->start(slideLeft, [this] { update(0, contentTop(), width(), st::introStepHeight); }, st::introSlideDuration);
-	} else {
-		_a_show.start([this] { update(); }, 0., 1., st::introCoverDuration);
-	}
-}
-
-void Widget::Step::setGoCallback(Fn<void(Step *step, Direction direction)> callback) {
-	_goCallback = std::move(callback);
-}
-
-void Widget::Step::setShowResetCallback(Fn<void()> callback) {
-	_showResetCallback = std::move(callback);
-}
-
-void Widget::Step::setShowTermsCallback(Fn<void()> callback) {
-	_showTermsCallback = std::move(callback);
-}
-
-void Widget::Step::setAcceptTermsCallback(
-		Fn<void(Fn<void()> callback)> callback) {
-	_acceptTermsCallback = std::move(callback);
-}
-
-void Widget::Step::showFast() {
-	show();
-	showFinished();
-}
-
-bool Widget::Step::animating() const {
-	return (_slideAnimation && _slideAnimation->animating()) || _a_show.animating();
-}
-
-bool Widget::Step::hasCover() const {
-	return _hasCover;
-}
-
-bool Widget::Step::hasBack() const {
-	return false;
-}
-
-void Widget::Step::activate() {
-	_title->show();
-	_description->show(anim::type::instant);
-	if (!_errorText.current().isEmpty()) {
-		_error->show(anim::type::instant);
-	}
-}
-
-void Widget::Step::cancelled() {
-}
-
-void Widget::Step::finished() {
-	hide();
-}
-
-Widget::Step::CoverAnimation::~CoverAnimation() = default;
-
-Widget::Step::~Step() = default;
-
-} // namespace Intro
diff --git a/Telegram/SourceFiles/intro/introwidget.h b/Telegram/SourceFiles/intro/introwidget.h
deleted file mode 100644
index 58d49d524..000000000
--- a/Telegram/SourceFiles/intro/introwidget.h
+++ /dev/null
@@ -1,317 +0,0 @@
-/*
-This file is part of Telegram Desktop,
-the official desktop application for the Telegram messaging service.
-
-For license and copyright information please follow this link:
-https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
-*/
-#pragma once
-
-#include "mtproto/sender.h"
-#include "ui/rp_widget.h"
-#include "ui/effects/animations.h"
-#include "window/window_lock_widgets.h"
-#include "core/core_cloud_password.h"
-
-namespace Main {
-class Account;
-} // namespace Main
-
-namespace Ui {
-class IconButton;
-class RoundButton;
-class LinkButton;
-class SlideAnimation;
-class CrossFadeAnimation;
-class FlatLabel;
-template <typename Widget>
-class FadeWrap;
-} // namespace Ui
-
-namespace Window {
-class ConnectionState;
-} // namespace Window
-
-namespace Intro {
-
-class Widget : public Ui::RpWidget, private MTP::Sender, private base::Subscriber {
-	Q_OBJECT
-
-public:
-	Widget(QWidget *parent, not_null<Main::Account*> account);
-
-	void showAnimated(const QPixmap &bgAnimCache, bool back = false);
-
-	void setInnerFocus();
-
-	~Widget();
-
-protected:
-	void paintEvent(QPaintEvent *e) override;
-	void resizeEvent(QResizeEvent *e) override;
-	void keyPressEvent(QKeyEvent *e) override;
-
-signals:
-	void countryChanged();
-
-private slots:
-	void onCheckUpdateStatus();
-
-	// Internal interface.
-public:
-	struct Data {
-		QString country;
-		QString phone;
-		QByteArray phoneHash;
-
-		enum class CallStatus {
-			Waiting,
-			Calling,
-			Called,
-			Disabled,
-		};
-		CallStatus callStatus = CallStatus::Disabled;
-		int callTimeout = 0;
-
-		int codeLength = 5;
-		bool codeByTelegram = false;
-
-		Core::CloudPasswordCheckRequest pwdRequest;
-		bool hasRecovery = false;
-		QString pwdHint;
-		bool pwdNotEmptyPassport = false;
-
-		Window::TermsLock termsLock;
-
-		base::Observable<void> updated;
-
-	};
-
-	enum class Direction {
-		Back,
-		Forward,
-		Replace,
-	};
-	class Step : public Ui::RpWidget, public RPCSender, protected base::Subscriber {
-	public:
-		Step(
-			QWidget *parent,
-			not_null<Main::Account*> account,
-			not_null<Data*> data,
-			bool hasCover = false);
-
-		Main::Account &account() const {
-			return *_account;
-		}
-
-		virtual void finishInit() {
-		}
-		virtual void setInnerFocus() {
-			setFocus();
-		}
-
-		void setGoCallback(
-			Fn<void(Step *step, Direction direction)> callback);
-		void setShowResetCallback(Fn<void()> callback);
-		void setShowTermsCallback(
-			Fn<void()> callback);
-		void setAcceptTermsCallback(
-			Fn<void(Fn<void()> callback)> callback);
-
-		void prepareShowAnimated(Step *after);
-		void showAnimated(Direction direction);
-		void showFast();
-		bool animating() const;
-
-		bool hasCover() const;
-		virtual bool hasBack() const;
-		virtual void activate();
-		virtual void cancelled();
-		virtual void finished();
-
-		virtual void submit() = 0;
-		virtual rpl::producer<QString> nextButtonText() const;
-
-		int contentLeft() const;
-		int contentTop() const;
-
-		void setErrorCentered(bool centered);
-		void setErrorBelowLink(bool below);
-		void showError(rpl::producer<QString> text);
-		void hideError() {
-			showError(rpl::single(QString()));
-		}
-
-		~Step();
-
-	protected:
-		void paintEvent(QPaintEvent *e) override;
-		void resizeEvent(QResizeEvent *e) override;
-
-		void setTitleText(rpl::producer<QString> titleText);
-		void setDescriptionText(rpl::producer<QString> descriptionText);
-		void setDescriptionText(
-			rpl::producer<TextWithEntities> richDescriptionText);
-		bool paintAnimated(Painter &p, QRect clip);
-
-		void fillSentCodeData(const MTPDauth_sentCode &type);
-
-		void showDescription();
-		void hideDescription();
-
-		not_null<Data*> getData() const {
-			return _data;
-		}
-		void finish(const MTPUser &user, QImage &&photo = QImage());
-
-		void goBack() {
-			if (_goCallback) {
-				_goCallback(nullptr, Direction::Back);
-			}
-		}
-
-		template <typename StepType>
-		void goNext() {
-			if (_goCallback) {
-				_goCallback(
-					new StepType(parentWidget(), _account, _data),
-					Direction::Forward);
-			}
-		}
-
-		template <typename StepType>
-		void goReplace() {
-			if (_goCallback) {
-				_goCallback(
-					new StepType(parentWidget(), _account, _data),
-					Direction::Replace);
-			}
-		}
-		void showResetButton() {
-			if (_showResetCallback) _showResetCallback();
-		}
-		void showTerms() {
-			if (_showTermsCallback) _showTermsCallback();
-		}
-		void acceptTerms(Fn<void()> callback) {
-			if (_acceptTermsCallback) {
-				_acceptTermsCallback(callback);
-			}
-		}
-
-	private:
-		struct CoverAnimation {
-			CoverAnimation() = default;
-			CoverAnimation(CoverAnimation &&other) = default;
-			CoverAnimation &operator=(CoverAnimation &&other) = default;
-			~CoverAnimation();
-
-			std::unique_ptr<Ui::CrossFadeAnimation> title;
-			std::unique_ptr<Ui::CrossFadeAnimation> description;
-
-			// From content top till the next button top.
-			QPixmap contentSnapshotWas;
-			QPixmap contentSnapshotNow;
-		};
-		void updateLabelsPosition();
-		void paintContentSnapshot(Painter &p, const QPixmap &snapshot, float64 alpha, float64 howMuchHidden);
-		void refreshError(const QString &text);
-
-		CoverAnimation prepareCoverAnimation(Step *step);
-		QPixmap prepareContentSnapshot();
-		QPixmap prepareSlideAnimation();
-		void showFinished();
-
-		void prepareCoverMask();
-		void paintCover(Painter &p, int top);
-
-		const not_null<Main::Account*> _account;
-		const not_null<Data*> _data;
-
-		bool _hasCover = false;
-		Fn<void(Step *step, Direction direction)> _goCallback;
-		Fn<void()> _showResetCallback;
-		Fn<void()> _showTermsCallback;
-		Fn<void(Fn<void()> callback)> _acceptTermsCallback;
-
-		rpl::variable<QString> _titleText;
-		object_ptr<Ui::FlatLabel> _title;
-		rpl::variable<TextWithEntities> _descriptionText;
-		object_ptr<Ui::FadeWrap<Ui::FlatLabel>> _description;
-
-		bool _errorCentered = false;
-		bool _errorBelowLink = false;
-		rpl::variable<QString> _errorText;
-		object_ptr<Ui::FadeWrap<Ui::FlatLabel>> _error = { nullptr };
-
-		Ui::Animations::Simple _a_show;
-		CoverAnimation _coverAnimation;
-		std::unique_ptr<Ui::SlideAnimation> _slideAnimation;
-		QPixmap _coverMask;
-
-	};
-
-private:
-	void setupConnectingWidget();
-	void refreshLang();
-	void animationCallback();
-	void createLanguageLink();
-
-	void updateControlsGeometry();
-	not_null<Data*> getData() {
-		return &_data;
-	}
-
-	void fixOrder();
-	void showControls();
-	void hideControls();
-	QRect calculateStepRect() const;
-
-	void showResetButton();
-	void resetAccount();
-
-	void showTerms();
-	void acceptTerms(Fn<void()> callback);
-	void hideAndDestroy(object_ptr<Ui::FadeWrap<Ui::RpWidget>> widget);
-
-	Step *getStep(int skip = 0) {
-		Assert(_stepHistory.size() + skip > 0);
-		return _stepHistory.at(_stepHistory.size() - skip - 1);
-	}
-	void historyMove(Direction direction);
-	void moveToStep(Step *step, Direction direction);
-	void appendStep(Step *step);
-
-	void getNearestDC();
-	void showTerms(Fn<void()> callback);
-
-	not_null<Main::Account*> _account;
-
-	Ui::Animations::Simple _a_show;
-	bool _showBack = false;
-	QPixmap _cacheUnder, _cacheOver;
-
-	QVector<Step*> _stepHistory;
-
-	Data _data;
-
-	Ui::Animations::Simple _coverShownAnimation;
-	int _nextTopFrom = 0;
-	int _controlsTopFrom = 0;
-
-	object_ptr<Ui::FadeWrap<Ui::IconButton>> _back;
-	object_ptr<Ui::FadeWrap<Ui::RoundButton>> _update = { nullptr };
-	object_ptr<Ui::FadeWrap<Ui::RoundButton>> _settings;
-
-	object_ptr<Ui::RoundButton> _next;
-	object_ptr<Ui::FadeWrap<Ui::LinkButton>> _changeLanguage = { nullptr };
-	object_ptr<Ui::FadeWrap<Ui::RoundButton>> _resetAccount = { nullptr };
-	object_ptr<Ui::FadeWrap<Ui::FlatLabel>> _terms = { nullptr };
-
-	std::unique_ptr<Window::ConnectionState> _connecting;
-
-	mtpRequestId _resetRequest = 0;
-
-};
-
-} // namespace Intro
diff --git a/Telegram/SourceFiles/lang/lang_cloud_manager.cpp b/Telegram/SourceFiles/lang/lang_cloud_manager.cpp
index e331e2101..3a0b789c3 100644
--- a/Telegram/SourceFiles/lang/lang_cloud_manager.cpp
+++ b/Telegram/SourceFiles/lang/lang_cloud_manager.cpp
@@ -13,8 +13,8 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "mtproto/mtp_instance.h"
 #include "storage/localstorage.h"
 #include "core/application.h"
-#include "apiwrap.h"
 #include "main/main_session.h"
+#include "main/main_account.h"
 #include "boxes/confirm_box.h"
 #include "ui/wrap/padding_wrap.h"
 #include "ui/widgets/labels.h"
@@ -156,11 +156,17 @@ Language ParseLanguage(const MTPLangPackLanguage &data) {
 	});
 }
 
-CloudManager::CloudManager(
-	Instance &langpack,
-	not_null<MTP::Instance*> mtproto)
-: MTP::Sender()
-, _langpack(langpack) {
+CloudManager::CloudManager(Instance &langpack)
+: _langpack(langpack) {
+	Core::App().activeAccount().mtpValue(
+	) | rpl::start_with_next([=](MTP::Instance *instance) {
+		if (instance) {
+			_api.emplace(instance);
+			resendRequests();
+		} else {
+			_api.reset();
+		}
+	}, _lifetime);
 }
 
 Pack CloudManager::packTypeFromId(const QString &id) const {
@@ -195,7 +201,10 @@ mtpRequestId CloudManager::packRequestId(Pack pack) const {
 }
 
 void CloudManager::requestLangPackDifference(Pack pack) {
-	request(base::take(packRequestId(pack))).cancel();
+	if (!_api) {
+		return;
+	}
+	_api->request(base::take(packRequestId(pack))).cancel();
 	if (_langpack.isCustom()) {
 		return;
 	}
@@ -206,7 +215,7 @@ void CloudManager::requestLangPackDifference(Pack pack) {
 		return;
 	}
 	if (version > 0) {
-		packRequestId(pack) = request(MTPlangpack_GetDifference(
+		packRequestId(pack) = _api->request(MTPlangpack_GetDifference(
 			MTP_string(CloudLangPackName()),
 			MTP_string(code),
 			MTP_int(version)
@@ -217,7 +226,7 @@ void CloudManager::requestLangPackDifference(Pack pack) {
 			packRequestId(pack) = 0;
 		}).send();
 	} else {
-		packRequestId(pack) = request(MTPlangpack_GetLangPack(
+		packRequestId(pack) = _api->request(MTPlangpack_GetLangPack(
 			MTP_string(CloudLangPackName()),
 			MTP_string(code)
 		)).done([=](const MTPLangPackDifference &result) {
@@ -284,7 +293,12 @@ void CloudManager::applyLangPackDifference(
 }
 
 void CloudManager::requestLanguageList() {
-	_languagesRequestId = request(MTPlangpack_GetLanguages(
+	if (!_api) {
+		_languagesRequestId = -1;
+		return;
+	}
+	_api->request(base::take(_languagesRequestId)).cancel();
+	_languagesRequestId = _api->request(MTPlangpack_GetLanguages(
 		MTP_string(CloudLangPackName())
 	)).done([=](const MTPVector<MTPLangPackLanguage> &result) {
 		auto languages = Languages();
@@ -402,10 +416,20 @@ void CloudManager::requestLanguageAndSwitch(
 		return;
 	}
 
-	request(_switchingToLanguageRequest).cancel();
-	_switchingToLanguageRequest = request(MTPlangpack_GetLanguage(
+	_switchingToLanguageId = id;
+	_switchingToLanguageWarning = warning;
+	sendSwitchingToLanguageRequest();
+}
+
+void CloudManager::sendSwitchingToLanguageRequest() {
+	if (!_api) {
+		_switchingToLanguageId = -1;
+		return;
+	}
+	_api->request(_switchingToLanguageRequest).cancel();
+	_switchingToLanguageRequest = _api->request(MTPlangpack_GetLanguage(
 		MTP_string(Lang::CloudLangPackName()),
-		MTP_string(id)
+		MTP_string(_switchingToLanguageId)
 	)).done([=](const MTPLangPackLanguage &result) {
 		_switchingToLanguageRequest = 0;
 		const auto language = Lang::ParseLanguage(result);
@@ -416,7 +440,7 @@ void CloudManager::requestLanguageAndSwitch(
 				performSwitchAndRestart(language);
 			}
 		};
-		if (!warning) {
+		if (!_switchingToLanguageWarning) {
 			finalize();
 			return;
 		}
@@ -438,9 +462,11 @@ void CloudManager::requestLanguageAndSwitch(
 void CloudManager::switchToLanguage(const Language &data) {
 	if (_langpack.id() == data.id && data.id != qstr("#custom")) {
 		return;
+	} else if (!_api) {
+		return;
 	}
 
-	request(_switchingToLanguageRequest).cancel();
+	_api->request(base::take(_getKeysForSwitchRequestId)).cancel();
 	if (data.id == qstr("#custom")) {
 		performSwitchToCustom();
 	} else if (canApplyWithoutRestart(data.id)) {
@@ -449,12 +475,12 @@ void CloudManager::switchToLanguage(const Language &data) {
 		QVector<MTPstring> keys;
 		keys.reserve(3);
 		keys.push_back(MTP_string("lng_sure_save_language"));
-		_switchingToLanguageRequest = request(MTPlangpack_GetStrings(
+		_getKeysForSwitchRequestId = _api->request(MTPlangpack_GetStrings(
 			MTP_string(Lang::CloudLangPackName()),
 			MTP_string(data.id),
 			MTP_vector<MTPstring>(std::move(keys))
 		)).done([=](const MTPVector<MTPLangPackString> &result) {
-			_switchingToLanguageRequest = 0;
+			_getKeysForSwitchRequestId = 0;
 			const auto values = Instance::ParseStrings(result);
 			const auto getValue = [&](ushort key) {
 				auto it = values.find(key);
@@ -473,7 +499,7 @@ void CloudManager::switchToLanguage(const Language &data) {
 					[=] { performSwitchAndRestart(data); }),
 				Ui::LayerOption::KeepOther);
 		}).fail([=](const RPCError &error) {
-			_switchingToLanguageRequest = 0;
+			_getKeysForSwitchRequestId = 0;
 		}).send();
 	}
 }
@@ -481,7 +507,7 @@ void CloudManager::switchToLanguage(const Language &data) {
 void CloudManager::performSwitchToCustom() {
 	auto filter = qsl("Language files (*.strings)");
 	auto title = qsl("Choose language .strings file");
-	FileDialog::GetOpenPath(Core::App().getFileDialogParent(), title, filter, [weak = base::make_weak(this)](const FileDialog::OpenResult &result) {
+	FileDialog::GetOpenPath(Core::App().getFileDialogParent(), title, filter, [=, weak = base::make_weak(this)](const FileDialog::OpenResult &result) {
 		if (!weak || result.paths.isEmpty()) {
 			return;
 		}
@@ -491,9 +517,13 @@ void CloudManager::performSwitchToCustom() {
 			filePath,
 			{ tr::lng_sure_save_language.base });
 		if (loader.errors().isEmpty()) {
-			weak->request(weak->_switchingToLanguageRequest).cancel();
-			if (weak->canApplyWithoutRestart(qsl("#custom"))) {
-				weak->_langpack.switchToCustomFile(filePath);
+			if (_api) {
+				_api->request(
+					base::take(_switchingToLanguageRequest)
+				).cancel();
+			}
+			if (canApplyWithoutRestart(qsl("#custom"))) {
+				_langpack.switchToCustomFile(filePath);
 			} else {
 				const auto values = loader.found();
 				const auto getValue = [&](ushort key) {
@@ -506,7 +536,7 @@ void CloudManager::performSwitchToCustom() {
 					+ "\n\n"
 					 + getValue(tr::lng_sure_save_language.base);
 				const auto change = [=] {
-					weak->_langpack.switchToCustomFile(filePath);
+					_langpack.switchToCustomFile(filePath);
 					App::restart();
 				};
 				Ui::show(
@@ -572,9 +602,25 @@ void CloudManager::switchLangPackId(const Language &data) {
 
 void CloudManager::changeIdAndReInitConnection(const Language &data) {
 	_langpack.switchToId(data);
+	if (_api) {
+		const auto mtproto = _api->instance();
+		mtproto->reInitConnection(mtproto->mainDcId());
+	}
+}
 
-	auto mtproto = requestMTP();
-	mtproto->reInitConnection(mtproto->mainDcId());
+void CloudManager::resendRequests() {
+	if (packRequestId(Pack::Base)) {
+		requestLangPackDifference(Pack::Base);
+	}
+	if (packRequestId(Pack::Current)) {
+		requestLangPackDifference(Pack::Current);
+	}
+	if (_languagesRequestId) {
+		requestLanguageList();
+	}
+	if (_switchingToLanguageRequest) {
+		sendSwitchingToLanguageRequest();
+	}
 }
 
 CloudManager &CurrentCloudManager() {
diff --git a/Telegram/SourceFiles/lang/lang_cloud_manager.h b/Telegram/SourceFiles/lang/lang_cloud_manager.h
index f95b4854a..d8b53deb8 100644
--- a/Telegram/SourceFiles/lang/lang_cloud_manager.h
+++ b/Telegram/SourceFiles/lang/lang_cloud_manager.h
@@ -22,9 +22,9 @@ struct Language;
 
 Language ParseLanguage(const MTPLangPackLanguage &data);
 
-class CloudManager : public base::has_weak_ptr, private MTP::Sender, private base::Subscriber {
+class CloudManager : public base::has_weak_ptr, private base::Subscriber {
 public:
-	CloudManager(Instance &langpack, not_null<MTP::Instance*> mtproto);
+	explicit CloudManager(Instance &langpack);
 
 	using Languages = std::vector<Language>;
 
@@ -72,6 +72,10 @@ private:
 	void switchLangPackId(const Language &data);
 	void changeIdAndReInitConnection(const Language &data);
 
+	void sendSwitchingToLanguageRequest();
+	void resendRequests();
+
+	std::optional<MTP::Sender> _api;
 	Instance &_langpack;
 	Languages _languages;
 	base::Observable<void> _languagesChanged;
@@ -87,6 +91,12 @@ private:
 	base::Observable<void> _firstLanguageSuggestion;
 
 	mtpRequestId _switchingToLanguageRequest = 0;
+	QString _switchingToLanguageId;
+	bool _switchingToLanguageWarning = false;
+
+	mtpRequestId _getKeysForSwitchRequestId = 0;
+
+	rpl::lifetime _lifetime;
 
 };
 
diff --git a/Telegram/SourceFiles/logs.cpp b/Telegram/SourceFiles/logs.cpp
index 5a3955955..348a26213 100644
--- a/Telegram/SourceFiles/logs.cpp
+++ b/Telegram/SourceFiles/logs.cpp
@@ -8,10 +8,15 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "logs.h"
 
 #include "platform/platform_specific.h"
-#include "mtproto/connection.h"
 #include "core/crash_reports.h"
 #include "core/launcher.h"
 
+namespace {
+
+std::atomic<int> ThreadCounter/* = 0*/;
+
+} // namespace
+
 enum LogDataType {
 	LogDataMain,
 	LogDataDebug,
@@ -45,11 +50,10 @@ QString _logsFilePath(LogDataType type, const QString &postfix = QString()) {
 
 int32 LogsStartIndexChosen = -1;
 QString _logsEntryStart() {
-	static int32 index = 0;
-	QDateTime tm(QDateTime::currentDateTime());
+	static thread_local auto threadId = ThreadCounter++;
+	static auto index = 0;
 
-	auto thread = qobject_cast<MTP::internal::Thread*>(QThread::currentThread());
-	auto threadId = thread ? thread->getThreadIndex() : 0;
+	const auto tm = QDateTime::currentDateTime();
 
 	return QString("[%1 %2-%3]").arg(tm.toString("hh:mm:ss.zzz")).arg(QString("%1").arg(threadId, 2, 10, QChar('0'))).arg(++index, 7, 10, QChar('0'));
 }
diff --git a/Telegram/SourceFiles/main/main_account.cpp b/Telegram/SourceFiles/main/main_account.cpp
index c0185388c..bfc07862c 100644
--- a/Telegram/SourceFiles/main/main_account.cpp
+++ b/Telegram/SourceFiles/main/main_account.cpp
@@ -18,6 +18,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "media/audio/media_audio.h"
 #include "mainwidget.h"
 #include "observer_peer.h"
+#include "main/main_app_config.h"
 #include "main/main_session.h"
 #include "facades.h"
 
@@ -26,6 +27,7 @@ namespace Main {
 Account::Account(const QString &dataName) {
 	watchProxyChanges();
 	watchSessionChanges();
+	_appConfig = std::make_unique<AppConfig>(this);
 }
 
 Account::~Account() = default;
@@ -35,8 +37,8 @@ void Account::watchProxyChanges() {
 
 	Core::App().proxyChanges(
 	) | rpl::start_with_next([=](const ProxyChange &change) {
-		const auto key = [&](const ProxyData &proxy) {
-			return (proxy.type == ProxyData::Type::Mtproto)
+		const auto key = [&](const MTP::ProxyData &proxy) {
+			return (proxy.type == MTP::ProxyData::Type::Mtproto)
 				? std::make_pair(proxy.host, proxy.port)
 				: std::make_pair(QString(), uint32(0));
 		};
@@ -120,21 +122,6 @@ void Account::createSession(
 	Expects(_session == nullptr);
 	Expects(_sessionValue.current() == nullptr);
 
-	_mtp->setUpdatesHandler(::rpcDone([](
-		const mtpPrime *from,
-		const mtpPrime *end) {
-		if (const auto main = App::main()) {
-			return main->updateReceived(from, end);
-		}
-		return true;
-	}));
-	_mtp->setGlobalFailHandler(::rpcFail([=](const RPCError &error) {
-		if (sessionExists()) {
-			crl::on_main(&session(), [=] { logOut(); });
-		}
-		return true;
-	}));
-
 	_session = std::make_unique<Session>(this, user, std::move(settings));
 	_sessionValue = _session.get();
 
@@ -152,7 +139,6 @@ void Account::destroySession() {
 		return;
 	}
 	session().data().clear();
-	_mtp->clearGlobalHandlers();
 
 	_sessionValue = nullptr;
 	_session = nullptr;
@@ -192,6 +178,14 @@ rpl::producer<MTP::Instance*> Account::mtpChanges() const {
 	return _mtpValue.changes();
 }
 
+rpl::producer<MTPUpdates> Account::mtpUpdates() const {
+	return _mtpUpdates.events();
+}
+
+rpl::producer<> Account::mtpNewSessionCreated() const {
+	return _mtpNewSessionCreated.events();
+}
+
 void Account::setMtpMainDcId(MTP::DcId mainDcId) {
 	Expects(!_mtp);
 
@@ -344,6 +338,18 @@ void Account::startMtp() {
 	_mtp->setUserPhone(cLoggedPhoneNumber());
 	_mtpConfig.mainDcId = _mtp->mainDcId();
 
+	_mtp->setUpdatesHandler(::rpcDone([=](
+			const mtpPrime *from,
+			const mtpPrime *end) {
+		return checkForUpdates(from, end)
+			|| checkForNewSession(from, end);
+	}));
+	_mtp->setGlobalFailHandler(::rpcFail([=](const RPCError &error) {
+		if (sessionExists()) {
+			crl::on_main(&session(), [=] { logOut(); });
+		}
+		return true;
+	}));
 	_mtp->setStateChangedHandler([](MTP::ShiftedDcId dc, int32 state) {
 		if (dc == MTP::maindc()) {
 			Global::RefConnectionTypeChanged().notify();
@@ -376,15 +382,31 @@ void Account::startMtp() {
 	_mtpValue = _mtp.get();
 }
 
+bool Account::checkForUpdates(const mtpPrime *from, const mtpPrime *end) {
+	auto updates = MTPUpdates();
+	if (!updates.read(from, end)) {
+		return false;
+	}
+	_mtpUpdates.fire(std::move(updates));
+	return true;
+}
+
+bool Account::checkForNewSession(const mtpPrime *from, const mtpPrime *end) {
+	auto newSession = MTPNewSession();
+	if (!newSession.read(from, end)) {
+		return false;
+	}
+	_mtpNewSessionCreated.fire({});
+	return true;
+}
 
 void Account::logOut() {
+	if (_loggingOut) {
+		return;
+	}
+	_loggingOut = true;
 	if (_mtp) {
-		_mtp->logout(::rpcDone([=] {
-			loggedOut();
-		}), ::rpcFail([=] {
-			loggedOut();
-			return true;
-		}));
+		_mtp->logout([=] { loggedOut(); });
 	} else {
 		// We log out because we've forgotten passcode.
 		loggedOut();
@@ -399,6 +421,7 @@ void Account::forcedLogOut() {
 }
 
 void Account::loggedOut() {
+	_loggingOut = false;
 	if (Global::LocalPasscode()) {
 		Global::SetLocalPasscode(false);
 		Global::RefLocalPasscodeChanged().notify();
@@ -439,18 +462,14 @@ void Account::destroyMtpKeys(MTP::AuthKeysList &&keys) {
 		Core::App().dcOptions(),
 		MTP::Instance::Mode::KeysDestroyer,
 		std::move(destroyConfig));
-	QObject::connect(
-		_mtpForKeysDestroy.get(),
-		&MTP::Instance::allKeysDestroyed,
-		[=] { allKeysDestroyed(); });
-}
-
-void Account::allKeysDestroyed() {
-	LOG(("MTP Info: all keys scheduled for destroy are destroyed."));
-	crl::on_main(this, [=] {
-		_mtpForKeysDestroy = nullptr;
-		Local::writeMtpData();
-	});
+	_mtpForKeysDestroy->allKeysDestroyed(
+	) | rpl::start_with_next([=] {
+		LOG(("MTP Info: all keys scheduled for destroy are destroyed."));
+		crl::on_main(this, [=] {
+			_mtpForKeysDestroy = nullptr;
+			Local::writeMtpData();
+		});
+	}, _lifetime);
 }
 
 void Account::suggestMainDcId(MTP::DcId mainDcId) {
@@ -486,16 +505,16 @@ rpl::producer<> Account::configUpdates() const {
 }
 
 void Account::resetAuthorizationKeys() {
+	_mtpValue = nullptr;
 	_mtp = nullptr;
-	_mtpValue = _mtp.get();
 	startMtp();
 	Local::writeMtpData();
 }
 
 void Account::clearMtp() {
+	_mtpValue = nullptr;
 	_mtp = nullptr;
 	_mtpForKeysDestroy = nullptr;
-	_mtpValue = _mtp.get();
 }
 
 } // namespace Main
diff --git a/Telegram/SourceFiles/main/main_account.h b/Telegram/SourceFiles/main/main_account.h
index 44765995a..d4f9b58e8 100644
--- a/Telegram/SourceFiles/main/main_account.h
+++ b/Telegram/SourceFiles/main/main_account.h
@@ -7,13 +7,15 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 */
 #pragma once
 
-#include "mtproto/auth_key.h"
+#include "mtproto/mtproto_auth_key.h"
+#include "mtproto/mtp_instance.h"
 #include "base/weak_ptr.h"
 
 namespace Main {
 
 class Session;
 class Settings;
+class AppConfig;
 
 class Account final : public base::has_weak_ptr {
 public:
@@ -34,6 +36,10 @@ public:
 	void logOut();
 	void forcedLogOut();
 
+	[[nodiscard]] AppConfig &appConfig() {
+		return *_appConfig;
+	}
+
 	[[nodiscard]] bool sessionExists() const;
 	[[nodiscard]] Session &session();
 	[[nodiscard]] const Session &session() const;
@@ -55,6 +61,8 @@ public:
 		QByteArray &&selfSerialized,
 		int32 selfStreamVersion);
 	[[nodiscard]] Settings *getSessionSettings();
+	[[nodiscard]] rpl::producer<> mtpNewSessionCreated() const;
+	[[nodiscard]] rpl::producer<MTPUpdates> mtpUpdates() const;
 
 	// Serialization.
 	[[nodiscard]] QByteArray serializeMtpAuthorization() const;
@@ -75,9 +83,10 @@ private:
 		Settings &&settings);
 	void watchProxyChanges();
 	void watchSessionChanges();
+	bool checkForUpdates(const mtpPrime *from, const mtpPrime *end);
+	bool checkForNewSession(const mtpPrime *from, const mtpPrime *end);
 
 	void destroyMtpKeys(MTP::AuthKeysList &&keys);
-	void allKeysDestroyed();
 	void resetAuthorizationKeys();
 
 	void loggedOut();
@@ -85,8 +94,12 @@ private:
 	std::unique_ptr<MTP::Instance> _mtp;
 	rpl::variable<MTP::Instance*> _mtpValue;
 	std::unique_ptr<MTP::Instance> _mtpForKeysDestroy;
+	rpl::event_stream<MTPUpdates> _mtpUpdates;
+	rpl::event_stream<> _mtpNewSessionCreated;
 	rpl::event_stream<> _configUpdates;
 
+	std::unique_ptr<AppConfig> _appConfig;
+
 	std::unique_ptr<Session> _session;
 	rpl::variable<Session*> _sessionValue;
 
@@ -96,6 +109,7 @@ private:
 	std::unique_ptr<Settings> _storedSettings;
 	MTP::Instance::Config _mtpConfig;
 	MTP::AuthKeysList _mtpKeysToDestroy;
+	bool _loggingOut = false;
 
 	rpl::lifetime _lifetime;
 
diff --git a/Telegram/SourceFiles/main/main_app_config.cpp b/Telegram/SourceFiles/main/main_app_config.cpp
index 2f6d76bb1..0f09e2ea0 100644
--- a/Telegram/SourceFiles/main/main_app_config.cpp
+++ b/Telegram/SourceFiles/main/main_app_config.cpp
@@ -7,7 +7,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 */
 #include "main/main_app_config.h"
 
-#include "main/main_session.h"
+#include "main/main_account.h"
 #include "base/call_delayed.h"
 #include "apiwrap.h"
 
@@ -18,25 +18,37 @@ constexpr auto kRefreshTimeout = 3600 * crl::time(1000);
 
 } // namespace
 
-AppConfig::AppConfig(not_null<Session*> session) : _session(session) {
+AppConfig::AppConfig(not_null<Account*> account) : _account(account) {
+	account->mtpValue(
+	) | rpl::start_with_next([=](MTP::Instance *instance) {
+		if (instance) {
+			_api.emplace(instance);
+			refresh();
+		} else {
+			_api.reset();
+			_requestId = 0;
+		}
+	}, _lifetime);
 	refresh();
 }
 
 void AppConfig::refresh() {
-	if (_requestId) {
+	if (_requestId || !_api) {
 		return;
 	}
-	_requestId = _session->api().request(MTPhelp_GetAppConfig(
+	_requestId = _api->request(MTPhelp_GetAppConfig(
 	)).done([=](const MTPJSONValue &result) {
 		_requestId = 0;
 		refreshDelayed();
 		if (result.type() == mtpc_jsonObject) {
+			_data.clear();
 			for (const auto &element : result.c_jsonObject().vvalue().v) {
 				element.match([&](const MTPDjsonObjectValue &data) {
 					_data.emplace_or_assign(qs(data.vkey()), data.vvalue());
 				});
 			}
 		}
+		_refreshed.fire({});
 	}).fail([=](const RPCError &error) {
 		_requestId = 0;
 		refreshDelayed();
@@ -44,20 +56,61 @@ void AppConfig::refresh() {
 }
 
 void AppConfig::refreshDelayed() {
-	base::call_delayed(kRefreshTimeout, _session, [=] {
+	base::call_delayed(kRefreshTimeout, _account, [=] {
 		refresh();
 	});
 }
 
-double AppConfig::getDouble(const QString &key, double fallback) const {
+rpl::producer<> AppConfig::refreshed() const {
+	return _refreshed.events();
+}
+
+template <typename Extractor>
+auto AppConfig::getValue(const QString &key, Extractor &&extractor) const {
 	const auto i = _data.find(key);
-	if (i == end(_data)) {
-		return fallback;
-	}
-	return i->second.match([&](const MTPDjsonNumber &data) {
-		return data.vvalue().v;
-	}, [&](const auto &data) {
-		return fallback;
+	return extractor((i != end(_data))
+		? i->second
+		: MTPJSONValue(MTP_jsonNull()));
+}
+
+double AppConfig::getDouble(const QString &key, double fallback) const {
+	return getValue(key, [&](const MTPJSONValue &value) {
+		return value.match([&](const MTPDjsonNumber &data) {
+			return data.vvalue().v;
+		}, [&](const auto &data) {
+			return fallback;
+		});
+	});
+}
+
+QString AppConfig::getString(
+		const QString &key,
+		const QString &fallback) const {
+	return getValue(key, [&](const MTPJSONValue &value) {
+		return value.match([&](const MTPDjsonString &data) {
+			return qs(data.vvalue());
+		}, [&](const auto &data) {
+			return fallback;
+		});
+	});
+}
+
+std::vector<QString> AppConfig::getStringArray(
+		const QString &key,
+		std::vector<QString> &&fallback) const {
+	return getValue(key, [&](const MTPJSONValue &value) {
+		return value.match([&](const MTPDjsonArray &data) {
+			auto result = std::vector<QString>();
+			for (const auto &entry : data.vvalue().v) {
+				if (entry.type() != mtpc_jsonString) {
+					return std::move(fallback);
+				}
+				result.push_back(qs(entry.c_jsonString().vvalue()));
+			}
+			return result;
+		}, [&](const auto &data) {
+			return std::move(fallback);
+		});
 	});
 }
 
diff --git a/Telegram/SourceFiles/main/main_app_config.h b/Telegram/SourceFiles/main/main_app_config.h
index 25afb4e77..54afb170e 100644
--- a/Telegram/SourceFiles/main/main_app_config.h
+++ b/Telegram/SourceFiles/main/main_app_config.h
@@ -7,30 +7,55 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 */
 #pragma once
 
+#include "mtproto/sender.h"
+
 namespace Main {
 
-class Session;
+class Account;
 
 class AppConfig final {
 public:
-	explicit AppConfig(not_null<Session*> session);
+	explicit AppConfig(not_null<Account*> account);
 
 	template <typename Type>
-	Type get(const QString &key, Type fallback) const {
+	[[nodiscard]] Type get(const QString &key, Type fallback) const {
 		if constexpr (std::is_same_v<Type, double>) {
 			return getDouble(key, fallback);
+		} else if constexpr (std::is_same_v<Type, QString>) {
+			return getString(key, fallback);
+		} else if constexpr (std::is_same_v<Type, std::vector<QString>>) {
+			return getStringArray(key, std::move(fallback));
 		}
 	}
 
-private:
+	[[nodiscard]] rpl::producer<> refreshed() const;
+
 	void refresh();
-	void refreshDelayed();
 
-	double getDouble(const QString &key, double fallback) const;
+private:
+	void refreshDelayed();
 
-	not_null<Session*> _session;
+	template <typename Extractor>
+	[[nodiscard]] auto getValue(
+		const QString &key,
+		Extractor &&extractor) const;
+
+	[[nodiscard]] double getDouble(
+		const QString &key,
+		double fallback) const;
+	[[nodiscard]] QString getString(
+		const QString &key,
+		const QString &fallback) const;
+	[[nodiscard]] std::vector<QString> getStringArray(
+		const QString &key,
+		std::vector<QString> &&fallback) const;
+
+	const not_null<Account*> _account;
+	std::optional<MTP::Sender> _api;
 	mtpRequestId _requestId = 0;
 	base::flat_map<QString, MTPJSONValue> _data;
+	rpl::event_stream<> _refreshed;
+	rpl::lifetime _lifetime;
 
 };
 
diff --git a/Telegram/SourceFiles/main/main_session.cpp b/Telegram/SourceFiles/main/main_session.cpp
index fe93b0352..39fb80754 100644
--- a/Telegram/SourceFiles/main/main_session.cpp
+++ b/Telegram/SourceFiles/main/main_session.cpp
@@ -11,9 +11,9 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "core/application.h"
 #include "core/changelogs.h"
 #include "main/main_account.h"
-#include "main/main_app_config.h"
 #include "chat_helpers/stickers_emoji_pack.h"
 #include "storage/file_download.h"
+#include "storage/download_manager_mtproto.h"
 #include "storage/file_upload.h"
 #include "storage/localstorage.h"
 #include "storage/storage_facade.h"
@@ -44,9 +44,8 @@ Session::Session(
 , _saveSettingsTimer([=] { Local::writeUserSettings(); })
 , _autoLockTimer([=] { checkAutoLock(); })
 , _api(std::make_unique<ApiWrap>(this))
-, _appConfig(std::make_unique<AppConfig>(this))
 , _calls(std::make_unique<Calls::Instance>(this))
-, _downloader(std::make_unique<Storage::Downloader>(_api.get()))
+, _downloader(std::make_unique<Storage::DownloadManagerMtproto>(_api.get()))
 , _uploader(std::make_unique<Storage::Uploader>(_api.get()))
 , _storage(std::make_unique<Storage::Facade>())
 , _notifications(std::make_unique<Window::Notifications::System>(this))
@@ -204,6 +203,13 @@ Support::Templates& Session::supportTemplates() const {
 	return supportHelper().templates();
 }
 
+void Session::saveSettingsNowIfNeeded() {
+	if (_saveSettingsTimer.isActive()) {
+		_saveSettingsTimer.cancel();
+		Local::writeUserSettings();
+	}
+}
+
 } // namespace Main
 
 Main::Session &Auth() {
diff --git a/Telegram/SourceFiles/main/main_session.h b/Telegram/SourceFiles/main/main_session.h
index 91cf0c45b..10ef88afb 100644
--- a/Telegram/SourceFiles/main/main_session.h
+++ b/Telegram/SourceFiles/main/main_session.h
@@ -15,6 +15,10 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 
 class ApiWrap;
 
+namespace MTP {
+class Instance;
+} // namespace MTP
+
 namespace Support {
 class Helper;
 class Templates;
@@ -25,7 +29,7 @@ class Session;
 } // namespace Data
 
 namespace Storage {
-class Downloader;
+class DownloadManagerMtproto;
 class Uploader;
 class Facade;
 } // namespace Storage
@@ -51,7 +55,6 @@ class Changelogs;
 namespace Main {
 
 class Account;
-class AppConfig;
 
 class Session final
 	: public base::has_weak_ptr
@@ -77,7 +80,7 @@ public:
 	}
 	bool validateSelf(const MTPUser &user);
 
-	[[nodiscard]] Storage::Downloader &downloader() {
+	[[nodiscard]] Storage::DownloadManagerMtproto &downloader() {
 		return *_downloader;
 	}
 	[[nodiscard]] Storage::Uploader &uploader() {
@@ -89,9 +92,6 @@ public:
 	[[nodiscard]] Stickers::EmojiPack &emojiStickersPack() {
 		return *_emojiStickersPack;
 	}
-	[[nodiscard]] AppConfig &appConfig() {
-		return *_appConfig;
-	}
 
 	[[nodiscard]] base::Observable<void> &downloaderTaskFinished();
 
@@ -106,6 +106,7 @@ public:
 		return _settings;
 	}
 	void saveSettingsDelayed(crl::time delay = kDefaultSaveDelay);
+	void saveSettingsNowIfNeeded();
 
 	[[nodiscard]] not_null<MTP::Instance*> mtp();
 	[[nodiscard]] ApiWrap &api() {
@@ -144,9 +145,8 @@ private:
 	base::Timer _autoLockTimer;
 
 	const std::unique_ptr<ApiWrap> _api;
-	const std::unique_ptr<AppConfig> _appConfig;
 	const std::unique_ptr<Calls::Instance> _calls;
-	const std::unique_ptr<Storage::Downloader> _downloader;
+	const std::unique_ptr<Storage::DownloadManagerMtproto> _downloader;
 	const std::unique_ptr<Storage::Uploader> _uploader;
 	const std::unique_ptr<Storage::Facade> _storage;
 	const std::unique_ptr<Window::Notifications::System> _notifications;
diff --git a/Telegram/SourceFiles/main/main_settings.cpp b/Telegram/SourceFiles/main/main_settings.cpp
index 6bb4173fb..acb3c1d04 100644
--- a/Telegram/SourceFiles/main/main_settings.cpp
+++ b/Telegram/SourceFiles/main/main_settings.cpp
@@ -19,6 +19,9 @@ namespace {
 
 constexpr auto kAutoLockTimeoutLateMs = crl::time(3000);
 constexpr auto kLegacyCallsPeerToPeerNobody = 4;
+constexpr auto kVersionTag = -1;
+constexpr auto kVersion = 1;
+constexpr auto kMaxSavedPlaybackPositions = 16;
 
 } // namespace
 
@@ -45,6 +48,7 @@ QByteArray Settings::serialize() const {
 	{
 		QDataStream stream(&result, QIODevice::WriteOnly);
 		stream.setVersion(QDataStream::Qt_5_1);
+		stream << qint32(kVersionTag) << qint32(kVersion);
 		stream << static_cast<qint32>(_variables.selectorTab);
 		stream << qint32(_variables.lastSeenWarningSeen ? 1 : 0);
 		stream << qint32(_variables.tabbedSelectorSectionEnabled ? 1 : 0);
@@ -83,13 +87,17 @@ QByteArray Settings::serialize() const {
 		stream << qint32(_variables.notifyAboutPinned.current() ? 1 : 0);
 		stream << qint32(_variables.archiveInMainMenu.current() ? 1 : 0);
 		stream << qint32(_variables.skipArchiveInSearch.current() ? 1 : 0);
-		stream << qint32(_variables.autoplayGifs ? 1 : 0);
+		stream << qint32(0);// LEGACY _variables.autoplayGifs ? 1 : 0);
 		stream << qint32(_variables.loopAnimatedStickers ? 1 : 0);
 		stream << qint32(_variables.largeEmoji.current() ? 1 : 0);
 		stream << qint32(_variables.replaceEmoji.current() ? 1 : 0);
 		stream << qint32(_variables.suggestEmoji ? 1 : 0);
 		stream << qint32(_variables.suggestStickersByEmoji ? 1 : 0);
 		stream << qint32(_variables.spellcheckerEnabled.current() ? 1 : 0);
+		stream << qint32(_variables.mediaLastPlaybackPosition.size());
+		for (const auto &[id, time] : _variables.mediaLastPlaybackPosition) {
+			stream << quint64(id) << qint64(time);
+		}
 	}
 	return result;
 }
@@ -101,6 +109,8 @@ void Settings::constructFromSerialized(const QByteArray &serialized) {
 
 	QDataStream stream(serialized);
 	stream.setVersion(QDataStream::Qt_5_1);
+	qint32 versionTag = 0;
+	qint32 version = 0;
 	qint32 selectorTab = static_cast<qint32>(ChatHelpers::SelectorTab::Emoji);
 	qint32 lastSeenWarningSeen = 0;
 	qint32 tabbedSelectorSectionEnabled = 1;
@@ -130,15 +140,22 @@ void Settings::constructFromSerialized(const QByteArray &serialized) {
 	qint32 notifyAboutPinned = _variables.notifyAboutPinned.current() ? 1 : 0;
 	qint32 archiveInMainMenu = _variables.archiveInMainMenu.current() ? 1 : 0;
 	qint32 skipArchiveInSearch = _variables.skipArchiveInSearch.current() ? 1 : 0;
-	qint32 autoplayGifs = _variables.autoplayGifs ? 1 : 0;
+	qint32 autoplayGifs = 1;
 	qint32 loopAnimatedStickers = _variables.loopAnimatedStickers ? 1 : 0;
 	qint32 largeEmoji = _variables.largeEmoji.current() ? 1 : 0;
 	qint32 replaceEmoji = _variables.replaceEmoji.current() ? 1 : 0;
 	qint32 suggestEmoji = _variables.suggestEmoji ? 1 : 0;
 	qint32 suggestStickersByEmoji = _variables.suggestStickersByEmoji ? 1 : 0;
 	qint32 spellcheckerEnabled = _variables.spellcheckerEnabled.current() ? 1 : 0;
+	std::vector<std::pair<DocumentId, crl::time>> mediaLastPlaybackPosition;
 
-	stream >> selectorTab;
+	stream >> versionTag;
+	if (versionTag == kVersionTag) {
+		stream >> version;
+		stream >> selectorTab;
+	} else {
+		selectorTab = versionTag;
+	}
 	stream >> lastSeenWarningSeen;
 	if (!stream.atEnd()) {
 		stream >> tabbedSelectorSectionEnabled;
@@ -239,6 +256,18 @@ void Settings::constructFromSerialized(const QByteArray &serialized) {
 	if (!stream.atEnd()) {
 		stream >> spellcheckerEnabled;
 	}
+	if (!stream.atEnd()) {
+		auto count = qint32(0);
+		stream >> count;
+		if (stream.status() == QDataStream::Ok) {
+			for (auto i = 0; i != count; ++i) {
+				quint64 documentId;
+				qint64 time;
+				stream >> documentId >> time;
+				mediaLastPlaybackPosition.emplace_back(documentId, time);
+			}
+		}
+	}
 	if (stream.status() != QDataStream::Ok) {
 		LOG(("App Error: "
 			"Bad data for Main::Settings::constructFromSerialized()"));
@@ -248,6 +277,13 @@ void Settings::constructFromSerialized(const QByteArray &serialized) {
 		&& !_variables.autoDownload.setFromSerialized(autoDownload)) {
 		return;
 	}
+	if (!version) {
+		if (!autoplayGifs) {
+			using namespace Data::AutoDownload;
+			_variables.autoDownload = WithDisabledAutoPlay(
+				_variables.autoDownload);
+		}
+	}
 
 	auto uncheckedTab = static_cast<ChatHelpers::SelectorTab>(selectorTab);
 	switch (uncheckedTab) {
@@ -312,13 +348,13 @@ void Settings::constructFromSerialized(const QByteArray &serialized) {
 	_variables.notifyAboutPinned = (notifyAboutPinned == 1);
 	_variables.archiveInMainMenu = (archiveInMainMenu == 1);
 	_variables.skipArchiveInSearch = (skipArchiveInSearch == 1);
-	_variables.autoplayGifs = (autoplayGifs == 1);
 	_variables.loopAnimatedStickers = (loopAnimatedStickers == 1);
 	_variables.largeEmoji = (largeEmoji == 1);
 	_variables.replaceEmoji = (replaceEmoji == 1);
 	_variables.suggestEmoji = (suggestEmoji == 1);
 	_variables.suggestStickersByEmoji = (suggestStickersByEmoji == 1);
 	_variables.spellcheckerEnabled = (spellcheckerEnabled == 1);
+	_variables.mediaLastPlaybackPosition = std::move(mediaLastPlaybackPosition);
 }
 
 void Settings::setSupportChatsTimeSlice(int slice) {
@@ -413,6 +449,34 @@ rpl::producer<int> Settings::thirdColumnWidthChanges() const {
 	return _variables.thirdColumnWidth.changes();
 }
 
+void Settings::setMediaLastPlaybackPosition(DocumentId id, crl::time time) {
+	auto &map = _variables.mediaLastPlaybackPosition;
+	const auto i = ranges::find(
+		map,
+		id,
+		&std::pair<DocumentId, crl::time>::first);
+	if (i != map.end()) {
+		if (time > 0) {
+			i->second = time;
+		} else {
+			map.erase(i);
+		}
+	} else if (time > 0) {
+		if (map.size() >= kMaxSavedPlaybackPositions) {
+			map.erase(map.begin());
+		}
+		map.emplace_back(id, time);
+	}
+}
+
+crl::time Settings::mediaLastPlaybackPosition(DocumentId id) const {
+	const auto i = ranges::find(
+		_variables.mediaLastPlaybackPosition,
+		id,
+		&std::pair<DocumentId, crl::time>::first);
+	return (i != _variables.mediaLastPlaybackPosition.end()) ? i->second : 0;
+}
+
 void Settings::setArchiveCollapsed(bool collapsed) {
 	_variables.archiveCollapsed = collapsed;
 }
diff --git a/Telegram/SourceFiles/main/main_settings.h b/Telegram/SourceFiles/main/main_settings.h
index a02e6abe5..4cf55aa8c 100644
--- a/Telegram/SourceFiles/main/main_settings.h
+++ b/Telegram/SourceFiles/main/main_settings.h
@@ -153,6 +153,9 @@ public:
 		_variables.groupStickersSectionHidden.remove(peerId);
 	}
 
+	void setMediaLastPlaybackPosition(DocumentId id, crl::time time);
+	[[nodiscard]] crl::time mediaLastPlaybackPosition(DocumentId id) const;
+
 	[[nodiscard]] Data::AutoDownload::Full &autoDownload() {
 		return _variables.autoDownload;
 	}
@@ -198,12 +201,6 @@ public:
 	void setExeLaunchWarning(bool warning) {
 		_variables.exeLaunchWarning = warning;
 	}
-	[[nodiscard]] bool autoplayGifs() const {
-		return _variables.autoplayGifs;
-	}
-	void setAutoplayGifs(bool value) {
-		_variables.autoplayGifs = value;
-	}
 	[[nodiscard]] bool loopAnimatedStickers() const {
 		return _variables.loopAnimatedStickers;
 	}
@@ -277,13 +274,13 @@ private:
 		rpl::variable<bool> archiveInMainMenu = false;
 		rpl::variable<bool> notifyAboutPinned = true;
 		rpl::variable<bool> skipArchiveInSearch = false;
-		bool autoplayGifs = true;
 		bool loopAnimatedStickers = true;
 		rpl::variable<bool> largeEmoji = true;
 		rpl::variable<bool> replaceEmoji = true;
 		bool suggestEmoji = true;
 		bool suggestStickersByEmoji = true;
 		rpl::variable<bool> spellcheckerEnabled = true;
+		std::vector<std::pair<DocumentId, crl::time>> mediaLastPlaybackPosition;
 
 		static constexpr auto kDefaultSupportChatsLimitSlice
 			= 7 * 24 * 60 * 60;
diff --git a/Telegram/SourceFiles/mainwidget.cpp b/Telegram/SourceFiles/mainwidget.cpp
index 3285a54f8..255e9f35a 100644
--- a/Telegram/SourceFiles/mainwidget.cpp
+++ b/Telegram/SourceFiles/mainwidget.cpp
@@ -23,6 +23,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "data/data_chat.h"
 #include "data/data_user.h"
 #include "data/data_scheduled_messages.h"
+#include "data/data_file_origin.h"
 #include "api/api_text_entities.h"
 #include "ui/special_buttons.h"
 #include "ui/widgets/buttons.h"
@@ -93,6 +94,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "export/view/export_view_top_bar.h"
 #include "export/view/export_view_panel_controller.h"
 #include "main/main_session.h"
+#include "main/main_account.h"
 #include "support/support_helper.h"
 #include "storage/storage_facade.h"
 #include "storage/storage_shared_media.h"
@@ -430,6 +432,16 @@ MainWidget::MainWidget(
 		[this] { updateControlsGeometry(); },
 		lifetime());
 
+	session().account().mtpUpdates(
+	) | rpl::start_with_next([=](const MTPUpdates &updates) {
+		mtpUpdateReceived(updates);
+	}, lifetime());
+
+	session().account().mtpNewSessionCreated(
+	) | rpl::start_with_next([=] {
+		mtpNewSessionCreated();
+	}, lifetime());
+
 	// MSVC BUG + REGRESSION rpl::mappers::tuple :(
 	using namespace rpl::mappers;
 	_controller->activeChatValue(
@@ -1589,7 +1601,7 @@ void MainWidget::ui_showPeerHistory(
 			peerId = peer->id;
 			if (showAtMsgId > 0) showAtMsgId = -showAtMsgId;
 		}
-		const auto unavailable = peer->unavailableReason();
+		const auto unavailable = peer->computeUnavailableReason();
 		if (!unavailable.isEmpty()) {
 			if (params.activation != anim::activation::background) {
 				Ui::show(Box<InformBox>(unavailable));
@@ -3681,35 +3693,22 @@ void MainWidget::checkIdleFinish() {
 	}
 }
 
-bool MainWidget::updateReceived(const mtpPrime *from, const mtpPrime *end) {
-	if (end <= from) {
-		return false;
-	}
-
+void MainWidget::mtpNewSessionCreated() {
 	session().checkAutoLock();
+	updSeq = 0;
+	MTP_LOG(0, ("getDifference { after new_session_created }%1"
+		).arg(cTestMode() ? " TESTMODE" : ""));
+	getDifference();
+}
 
-	if (mtpTypeId(*from) == mtpc_new_session_created) {
-		MTPNewSession newSession;
-		if (!newSession.read(from, end)) {
-			return false;
-		}
-		updSeq = 0;
-		MTP_LOG(0, ("getDifference { after new_session_created }%1").arg(cTestMode() ? " TESTMODE" : ""));
-		getDifference();
-		return true;
-	}
-	MTPUpdates updates;
-	if (!updates.read(from, end)) {
-		return false;
-	}
-
+void MainWidget::mtpUpdateReceived(const MTPUpdates &updates) {
+	session().checkAutoLock();
 	_lastUpdateTime = crl::now();
 	_noUpdatesTimer.callOnce(kNoUpdatesTimeout);
 	if (!requestingDifference()
 		|| HasForceLogoutNotification(updates)) {
 		feedUpdates(updates);
 	}
-	return true;
 }
 
 void MainWidget::feedUpdates(const MTPUpdates &updates, uint64 randomId) {
diff --git a/Telegram/SourceFiles/mainwidget.h b/Telegram/SourceFiles/mainwidget.h
index 304a97dcf..eba80811f 100644
--- a/Telegram/SourceFiles/mainwidget.h
+++ b/Telegram/SourceFiles/mainwidget.h
@@ -13,6 +13,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "ui/effects/animations.h"
 #include "media/player/media_player_float.h"
 #include "data/data_pts_waiter.h"
+#include "mtproto/mtproto_rpc_sender.h"
 
 struct HistoryMessageMarkupButton;
 class MainWindow;
@@ -132,7 +133,6 @@ public:
 	void incrementSticker(DocumentData *sticker);
 
 	void activate();
-	[[nodiscard]] bool updateReceived(const mtpPrime *from, const mtpPrime *end);
 
 	void refreshDialog(Dialogs::Key key);
 	void removeDialog(Dialogs::Key key);
@@ -396,6 +396,8 @@ private:
 	bool failChannelDifference(ChannelData *channel, const RPCError &err);
 	void failDifferenceStartTimerFor(ChannelData *channel);
 
+	void mtpUpdateReceived(const MTPUpdates &updates);
+	void mtpNewSessionCreated();
 	void feedUpdateVector(
 		const MTPVector<MTPUpdate> &updates,
 		bool skipMessageIds = false);
diff --git a/Telegram/SourceFiles/mainwindow.cpp b/Telegram/SourceFiles/mainwindow.cpp
index dbb7eb5e4..8ee245274 100644
--- a/Telegram/SourceFiles/mainwindow.cpp
+++ b/Telegram/SourceFiles/mainwindow.cpp
@@ -25,7 +25,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "core/sandbox.h"
 #include "core/application.h"
 #include "main/main_session.h"
-#include "intro/introwidget.h"
+#include "intro/intro_widget.h"
 #include "main/main_account.h" // Account::sessionValue.
 #include "mainwidget.h"
 #include "boxes/confirm_box.h"
diff --git a/Telegram/SourceFiles/media/audio/media_audio_loaders.cpp b/Telegram/SourceFiles/media/audio/media_audio_loaders.cpp
index 44b3d534b..b249f277c 100644
--- a/Telegram/SourceFiles/media/audio/media_audio_loaders.cpp
+++ b/Telegram/SourceFiles/media/audio/media_audio_loaders.cpp
@@ -33,7 +33,11 @@ void Loaders::feedFromExternal(ExternalSoundPart &&part) {
 		QMutexLocker lock(&_fromExternalMutex);
 		invoke = _fromExternalQueues.empty()
 			&& _fromExternalForceToBuffer.empty();
-		_fromExternalQueues[part.audio].push_back(std::move(part.packet));
+		auto &queue = _fromExternalQueues[part.audio];
+		queue.insert(
+			end(queue),
+			std::make_move_iterator(part.packets.begin()),
+			std::make_move_iterator(part.packets.end()));
 	}
 	if (invoke) {
 		_fromExternalNotify.call();
@@ -190,7 +194,7 @@ void Loaders::loadData(AudioMsgId audio, crl::time positionMs) {
 			errAtStart = false;
 		} else if (res == Result::Wait) {
 			waiting = (samples.size() < kPlaybackBufferSize)
-				&& !l->forceToBuffer();
+				&& (!samplesCount || !l->forceToBuffer());
 			if (waiting) {
 				l->saveDecodedSamples(&samples, &samplesCount);
 			}
diff --git a/Telegram/SourceFiles/media/audio/media_child_ffmpeg_loader.h b/Telegram/SourceFiles/media/audio/media_child_ffmpeg_loader.h
index 7b9e18a8a..95fb9a320 100644
--- a/Telegram/SourceFiles/media/audio/media_child_ffmpeg_loader.h
+++ b/Telegram/SourceFiles/media/audio/media_child_ffmpeg_loader.h
@@ -22,7 +22,7 @@ struct ExternalSoundData {
 
 struct ExternalSoundPart {
 	AudioMsgId audio;
-	FFmpeg::Packet packet;
+	gsl::span<FFmpeg::Packet> packets;
 };
 
 class ChildFFMpegLoader : public AbstractAudioFFMpegLoader {
diff --git a/Telegram/SourceFiles/media/clip/media_clip_ffmpeg.cpp b/Telegram/SourceFiles/media/clip/media_clip_ffmpeg.cpp
index e4dfbe18e..68b56a388 100644
--- a/Telegram/SourceFiles/media/clip/media_clip_ffmpeg.cpp
+++ b/Telegram/SourceFiles/media/clip/media_clip_ffmpeg.cpp
@@ -490,9 +490,10 @@ FFMpegReaderImplementation::PacketResult FFMpegReaderImplementation::readPacket(
 		if (res == AVERROR_EOF) {
 			if (_audioStreamId >= 0) {
 				// queue terminating packet to audio player
+				auto empty = FFmpeg::Packet();
 				Player::mixer()->feedFromExternal({
 					_audioMsgId,
-					FFmpeg::Packet()
+					gsl::make_span(&empty, 1)
 				});
 			}
 			return PacketResult::EndOfFile;
@@ -519,7 +520,7 @@ void FFMpegReaderImplementation::processPacket(FFmpeg::Packet &&packet) {
 			// queue packet to audio player
 			Player::mixer()->feedFromExternal({
 				_audioMsgId,
-				std::move(packet)
+				gsl::make_span(&packet, 1)
 			});
 		}
 	}
diff --git a/Telegram/SourceFiles/media/player/media_player_float.cpp b/Telegram/SourceFiles/media/player/media_player_float.cpp
index 5a60d2646..c2ff6df6a 100644
--- a/Telegram/SourceFiles/media/player/media_player_float.cpp
+++ b/Telegram/SourceFiles/media/player/media_player_float.cpp
@@ -15,7 +15,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "history/history_item.h"
 #include "history/view/history_view_element.h"
 #include "media/audio/media_audio.h"
-#include "media/streaming/media_streaming_player.h"
+#include "media/streaming/media_streaming_instance.h"
 #include "media/view/media_view_playback_progress.h"
 #include "media/player/media_player_instance.h"
 #include "window/window_session_controller.h"
@@ -132,11 +132,11 @@ void Float::mouseDoubleClickEvent(QMouseEvent *e) {
 }
 
 void Float::pauseResume() {
-	if (const auto player = instance()->roundVideoPlayer(_item)) {
-		if (player->paused()) {
-			player->resume();
+	if (const auto streamed = getStreamed()) {
+		if (streamed->paused()) {
+			streamed->resume();
 		} else {
-			player->pause();
+			streamed->pause();
 		}
 	}
 }
@@ -206,8 +206,8 @@ void Float::paintEvent(QPaintEvent *e) {
 	}
 }
 
-Streaming::Player *Float::getPlayer() const {
-	return instance()->roundVideoPlayer(_item);
+Streaming::Instance *Float::getStreamed() const {
+	return instance()->roundVideoStreamed(_item);
 }
 
 View::PlaybackProgress *Float::getPlayback() const {
@@ -215,7 +215,7 @@ View::PlaybackProgress *Float::getPlayback() const {
 }
 
 bool Float::hasFrame() const {
-	return (getPlayer() != nullptr);
+	return (getStreamed() != nullptr);
 }
 
 bool Float::fillFrame() {
@@ -229,11 +229,11 @@ bool Float::fillFrame() {
 	auto frameInner = [&] {
 		return QRect(QPoint(), _frame.size() / cIntRetinaFactor());
 	};
-	if (const auto player = getPlayer()) {
+	if (const auto streamed = getStreamed()) {
 		auto request = Streaming::FrameRequest::NonStrict();
 		request.outer = request.resize = _frame.size();
 		request.radius = ImageRoundRadius::Ellipse;
-		auto frame = player->frame(request);
+		auto frame = streamed->frame(request);
 		if (!frame.isNull()) {
 			_frame.fill(Qt::transparent);
 
diff --git a/Telegram/SourceFiles/media/player/media_player_float.h b/Telegram/SourceFiles/media/player/media_player_float.h
index d71dddfda..8106f63bc 100644
--- a/Telegram/SourceFiles/media/player/media_player_float.h
+++ b/Telegram/SourceFiles/media/player/media_player_float.h
@@ -26,7 +26,7 @@ class PlaybackProgress;
 
 namespace Media {
 namespace Streaming {
-class Player;
+class Instance;
 } // namespace Streaming
 } // namespace Media
 
@@ -42,7 +42,7 @@ public:
 		Fn<void(bool visible)> toggleCallback,
 		Fn<void(bool closed)> draggedCallback);
 
-	HistoryItem *item() const {
+	[[nodiscard]] HistoryItem *item() const {
 		return _item;
 	}
 	void setOpacity(float64 opacity) {
@@ -51,17 +51,17 @@ public:
 			update();
 		}
 	}
-	float64 countOpacityByParent() const {
+	[[nodiscard]] float64 countOpacityByParent() const {
 		return outRatio();
 	}
-	bool isReady() const {
-		return (getPlayer() != nullptr);
+	[[nodiscard]] bool isReady() const {
+		return (getStreamed() != nullptr);
 	}
 	void detach();
-	bool detached() const {
+	[[nodiscard]] bool detached() const {
 		return !_item;
 	}
-	bool dragged() const {
+	[[nodiscard]] bool dragged() const {
 		return _drag;
 	}
 	void resetMouseState() {
@@ -79,14 +79,14 @@ protected:
 	void mouseDoubleClickEvent(QMouseEvent *e) override;
 
 private:
-	float64 outRatio() const;
-	Streaming::Player *getPlayer() const;
-	View::PlaybackProgress *getPlayback() const;
+	[[nodiscard]] float64 outRatio() const;
+	[[nodiscard]] Streaming::Instance *getStreamed() const;
+	[[nodiscard]] View::PlaybackProgress *getPlayback() const;
 	void repaintItem();
 	void prepareShadow();
 	bool hasFrame() const;
 	bool fillFrame();
-	QRect getInnerRect() const;
+	[[nodiscard]] QRect getInnerRect() const;
 	void finishDrag(bool closed);
 	void pauseResume();
 
diff --git a/Telegram/SourceFiles/media/player/media_player_instance.cpp b/Telegram/SourceFiles/media/player/media_player_instance.cpp
index eee1fb065..e150eb08b 100644
--- a/Telegram/SourceFiles/media/player/media_player_instance.cpp
+++ b/Telegram/SourceFiles/media/player/media_player_instance.cpp
@@ -9,10 +9,11 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 
 #include "data/data_document.h"
 #include "data/data_session.h"
+#include "data/data_streaming.h"
 #include "media/audio/media_audio.h"
 #include "media/audio/media_audio_capture.h"
+#include "media/streaming/media_streaming_instance.h"
 #include "media/streaming/media_streaming_player.h"
-#include "media/streaming/media_streaming_reader.h"
 #include "media/view/media_view_playback_progress.h"
 #include "calls/calls_instance.h"
 #include "history/history.h"
@@ -41,8 +42,22 @@ constexpr auto kIdsLimit = 32;
 // Preload next messages if we went further from current than that.
 constexpr auto kIdsPreloadAfter = 28;
 
+constexpr auto kMinLengthForSavePosition = 20 * TimeId(60); // 20 minutes.
+
 } // namespace
 
+struct Instance::Streamed {
+	Streamed(
+		AudioMsgId id,
+		std::shared_ptr<Streaming::Document> document);
+
+	AudioMsgId id;
+	Streaming::Instance instance;
+	View::PlaybackProgress progress;
+	bool clearing = false;
+	rpl::lifetime lifetime;
+};
+
 void start(not_null<Audio::Instance*> instance) {
 	Audio::Start(instance);
 	Capture::Start();
@@ -57,25 +72,29 @@ void finish(not_null<Audio::Instance*> instance) {
 	Audio::Finish(instance);
 }
 
-struct Instance::Streamed {
-	Streamed(
-		AudioMsgId id,
-		not_null<::Data::Session*> owner,
-		std::shared_ptr<Streaming::Reader> reader);
-
-	AudioMsgId id;
-	Streaming::Player player;
-	Streaming::Information info;
-	View::PlaybackProgress progress;
-	bool clearing = false;
-};
+void SaveLastPlaybackPosition(
+		not_null<DocumentData*> document,
+		const TrackState &state) {
+	const auto time = (state.position == kTimeUnknown
+		|| state.length == kTimeUnknown
+		|| state.state == State::PausedAtEnd
+		|| IsStopped(state.state))
+		? TimeId(0)
+		: (state.length >= kMinLengthForSavePosition * state.frequency)
+		? (state.position / state.frequency) * crl::time(1000)
+		: TimeId(0);
+	auto &session = document->session();
+	if (session.settings().mediaLastPlaybackPosition(document->id) != time) {
+		session.settings().setMediaLastPlaybackPosition(document->id, time);
+		session.saveSettingsDelayed();
+	}
+}
 
 Instance::Streamed::Streamed(
 	AudioMsgId id,
-	not_null<::Data::Session*> owner,
-	std::shared_ptr<Streaming::Reader> reader)
+	std::shared_ptr<Streaming::Document> document)
 : id(id)
-, player(owner, std::move(reader)) {
+, instance(std::move(document), nullptr) {
 }
 
 Instance::Data::Data(AudioMsgId::Type type, SharedMediaType overview)
@@ -175,7 +194,10 @@ void Instance::clearStreamed(not_null<Data*> data) {
 		return;
 	}
 	data->streamed->clearing = true;
-	data->streamed->player.stop();
+	SaveLastPlaybackPosition(
+		data->current.audio(),
+		data->streamed->instance.player().prepareLegacyState());
+	data->streamed->instance.stop();
 	data->isPlaying = false;
 	requestRoundVideoResize();
 	emitUpdate(data->type);
@@ -344,8 +366,8 @@ void Instance::play(AudioMsgId::Type type) {
 		if (!data->streamed || IsStopped(getState(type).state)) {
 			play(data->current);
 		} else {
-			if (data->streamed->player.active()) {
-				data->streamed->player.resume();
+			if (data->streamed->instance.active()) {
+				data->streamed->instance.resume();
 			}
 			emitUpdate(type);
 		}
@@ -361,13 +383,13 @@ void Instance::play(const AudioMsgId &audioId) {
 	if (document->isAudioFile()
 		|| document->isVoiceMessage()
 		|| document->isVideoMessage()) {
-		auto reader = document->owner().documentStreamedReader(
+		auto shared = document->owner().streaming().sharedDocument(
 			document,
 			audioId.contextId());
-		if (!reader) {
+		if (!shared) {
 			return;
 		}
-		playStreamed(audioId, std::move(reader));
+		playStreamed(audioId, std::move(shared));
 	}
 	if (document->isVoiceMessage() || document->isVideoMessage()) {
 		document->owner().markMediaRead(document);
@@ -386,7 +408,7 @@ void Instance::playPause(const AudioMsgId &audioId) {
 
 void Instance::playStreamed(
 		const AudioMsgId &audioId,
-		std::shared_ptr<Streaming::Reader> reader) {
+		std::shared_ptr<Streaming::Document> shared) {
 	Expects(audioId.audio() != nullptr);
 
 	const auto data = getData(audioId.type());
@@ -395,23 +417,17 @@ void Instance::playStreamed(
 	clearStreamed(data);
 	data->streamed = std::make_unique<Streamed>(
 		audioId,
-		&audioId.audio()->owner(),
-		std::move(reader));
+		std::move(shared));
+	data->streamed->instance.lockPlayer();
 
-	data->streamed->player.updates(
+	data->streamed->instance.player().updates(
 	) | rpl::start_with_next_error([=](Streaming::Update &&update) {
 		handleStreamingUpdate(data, std::move(update));
 	}, [=](Streaming::Error &&error) {
 		handleStreamingError(data, std::move(error));
-	}, data->streamed->player.lifetime());
-
-	data->streamed->player.fullInCache(
-	) | rpl::start_with_next([=](bool fullInCache) {
-		const auto document = data->streamed->id.audio();
-		document->setLoadedInMediaCache(fullInCache);
-	}, data->streamed->player.lifetime());
+	}, data->streamed->lifetime);
 
-	data->streamed->player.play(streamingOptions(audioId));
+	data->streamed->instance.play(streamingOptions(audioId));
 
 	emitUpdate(audioId.type());
 }
@@ -430,15 +446,23 @@ Streaming::PlaybackOptions Instance::streamingOptions(
 		? kVoicePlaybackSpeedMultiplier
 		: 1.;
 	result.audioId = audioId;
-	result.position = position;
+	if (position >= 0) {
+		result.position = position;
+	} else if (document) {
+		auto &settings = document->session().settings();
+		result.position = settings.mediaLastPlaybackPosition(document->id);
+		settings.setMediaLastPlaybackPosition(document->id, 0);
+	} else {
+		result.position = 0;
+	}
 	return result;
 }
 
 void Instance::pause(AudioMsgId::Type type) {
 	if (const auto data = getData(type)) {
 		if (data->streamed) {
-			if (data->streamed->player.active()) {
-				data->streamed->player.pause();
+			if (data->streamed->instance.active()) {
+				data->streamed->instance.pause();
 			}
 			emitUpdate(type);
 		}
@@ -459,13 +483,13 @@ void Instance::playPause(AudioMsgId::Type type) {
 		if (!data->streamed) {
 			play(data->current);
 		} else {
-			if (!data->streamed->player.active()) {
-				data->streamed->player.play(
-					streamingOptions(data->streamed->id));
-			} else if (data->streamed->player.paused()) {
-				data->streamed->player.resume();
+			auto &streamed = data->streamed->instance;
+			if (!streamed.active()) {
+				streamed.play(streamingOptions(data->streamed->id));
+			} else if (streamed.paused()) {
+				streamed.resume();
 			} else {
-				data->streamed->player.pause();
+				streamed.pause();
 			}
 			emitUpdate(type);
 		}
@@ -542,13 +566,14 @@ void Instance::startSeeking(AudioMsgId::Type type) {
 
 void Instance::finishSeeking(AudioMsgId::Type type, float64 progress) {
 	if (const auto data = getData(type)) {
-		if (data->streamed) {
-			const auto duration = data->streamed->info.audio.state.duration;
+		if (const auto streamed = data->streamed.get()) {
+			const auto &info = streamed->instance.info();
+			const auto duration = info.audio.state.duration;
 			if (duration != kTimeUnknown) {
 				const auto position = crl::time(std::round(
 					std::clamp(progress, 0., 1.) * duration));
-				data->streamed->player.play(streamingOptions(
-					data->streamed->id,
+				streamed->instance.play(streamingOptions(
+					streamed->id,
 					position));
 				emitUpdate(type);
 			}
@@ -567,7 +592,7 @@ void Instance::cancelSeeking(AudioMsgId::Type type) {
 void Instance::updateVoicePlaybackSpeed() {
 	if (const auto data = getData(AudioMsgId::Type::Voice)) {
 		if (const auto streamed = data->streamed.get()) {
-			streamed->player.setSpeed(Global::VoiceMsgPlaybackDoubled()
+			streamed->instance.setSpeed(Global::VoiceMsgPlaybackDoubled()
 				? kVoicePlaybackSpeedMultiplier
 				: 1.);
 		}
@@ -590,21 +615,21 @@ void Instance::emitUpdate(AudioMsgId::Type type) {
 TrackState Instance::getState(AudioMsgId::Type type) const {
 	if (const auto data = getData(type)) {
 		if (data->streamed) {
-			return data->streamed->player.prepareLegacyState();
+			return data->streamed->instance.player().prepareLegacyState();
 		}
 	}
 	return TrackState();
 }
 
-Streaming::Player *Instance::roundVideoPlayer(HistoryItem *item) const {
+Streaming::Instance *Instance::roundVideoStreamed(HistoryItem *item) const {
 	if (!item) {
 		return nullptr;
 	} else if (const auto data = getData(AudioMsgId::Type::Voice)) {
 		if (const auto streamed = data->streamed.get()) {
 			if (streamed->id.contextId() == item->fullId()) {
-				const auto player = &streamed->player;
+				const auto player = &streamed->instance.player();
 				if (player->ready() && !player->videoSize().isEmpty()) {
-					return player;
+					return &streamed->instance;
 				}
 			}
 		}
@@ -614,7 +639,7 @@ Streaming::Player *Instance::roundVideoPlayer(HistoryItem *item) const {
 
 View::PlaybackProgress *Instance::roundVideoPlayback(
 		HistoryItem *item) const {
-	return roundVideoPlayer(item)
+	return roundVideoStreamed(item)
 		? &getData(AudioMsgId::Type::Voice)->streamed->progress
 		: nullptr;
 }
@@ -627,8 +652,10 @@ void Instance::emitUpdate(AudioMsgId::Type type, CheckCallback check) {
 			return;
 		}
 		setCurrent(state.id);
-		if (data->streamed && !data->streamed->info.video.size.isEmpty()) {
-			data->streamed->progress.updateState(state);
+		if (const auto streamed = data->streamed.get()) {
+			if (!streamed->instance.info().video.size.isEmpty()) {
+				streamed->progress.updateState(state);
+			}
 		}
 		_updatedNotifier.fire_copy({state});
 		if (data->isPlaying && state.state == State::StoppedAtEnd) {
@@ -679,8 +706,7 @@ void Instance::handleStreamingUpdate(
 	using namespace Streaming;
 
 	update.data.match([&](Information &update) {
-		data->streamed->info = std::move(update);
-		if (!data->streamed->info.video.size.isEmpty()) {
+		if (!update.video.size.isEmpty()) {
 			data->streamed->progress.setValueChangedCallback([=](
 					float64,
 					float64) {
@@ -692,26 +718,18 @@ void Instance::handleStreamingUpdate(
 		}
 		emitUpdate(data->type);
 	}, [&](PreloadedVideo &update) {
-		data->streamed->info.video.state.receivedTill = update.till;
 		//emitUpdate(data->type, [](AudioMsgId) { return true; });
 	}, [&](UpdateVideo &update) {
-		data->streamed->info.video.state.position = update.position;
 		emitUpdate(data->type);
 	}, [&](PreloadedAudio &update) {
-		data->streamed->info.audio.state.receivedTill = update.till;
 		//emitUpdate(data->type, [](AudioMsgId) { return true; });
 	}, [&](UpdateAudio &update) {
-		data->streamed->info.audio.state.position = update.position;
 		emitUpdate(data->type);
 	}, [&](WaitingForData) {
 	}, [&](MutedByOther) {
 	}, [&](Finished) {
-		const auto finishTrack = [](Media::Streaming::TrackState &state) {
-			state.position = state.receivedTill = state.duration;
-		};
-		finishTrack(data->streamed->info.audio.state);
 		emitUpdate(data->type);
-		if (data->streamed && data->streamed->player.finished()) {
+		if (data->streamed && data->streamed->instance.player().finished()) {
 			clearStreamed(data);
 		}
 	});
@@ -720,7 +738,7 @@ void Instance::handleStreamingUpdate(
 HistoryItem *Instance::roundVideoItem() const {
 	const auto data = getData(AudioMsgId::Type::Voice);
 	return (data->streamed
-		&& !data->streamed->info.video.size.isEmpty())
+		&& !data->streamed->instance.info().video.size.isEmpty())
 		? Auth().data().message(data->streamed->id.contextId())
 		: nullptr;
 }
@@ -745,19 +763,17 @@ void Instance::handleStreamingError(
 	const auto document = data->streamed->id.audio();
 	const auto contextId = data->streamed->id.contextId();
 	if (error == Streaming::Error::NotStreamable) {
-		document->setNotSupportsStreaming();
 		DocumentSaveClickHandler::Save(
 			(contextId ? contextId : ::Data::FileOrigin()),
 			document);
 	} else if (error == Streaming::Error::OpenFailed) {
-		document->setInappPlaybackFailed();
 		DocumentSaveClickHandler::Save(
 			(contextId ? contextId : ::Data::FileOrigin()),
 			document,
 			DocumentSaveClickHandler::Mode::ToFile);
 	}
 	emitUpdate(data->type);
-	if (data->streamed && data->streamed->player.failed()) {
+	if (data->streamed && data->streamed->instance.player().failed()) {
 		clearStreamed(data);
 	}
 }
diff --git a/Telegram/SourceFiles/media/player/media_player_instance.h b/Telegram/SourceFiles/media/player/media_player_instance.h
index d55ae38be..d5472e40f 100644
--- a/Telegram/SourceFiles/media/player/media_player_instance.h
+++ b/Telegram/SourceFiles/media/player/media_player_instance.h
@@ -10,6 +10,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "data/data_shared_media.h"
 
 class AudioMsgId;
+class DocumentData;
 
 namespace Media {
 namespace Audio {
@@ -25,8 +26,8 @@ class PlaybackProgress;
 
 namespace Media {
 namespace Streaming {
-class Player;
-class Reader;
+class Document;
+class Instance;
 struct PlaybackOptions;
 struct Update;
 enum class Error;
@@ -36,13 +37,17 @@ enum class Error;
 namespace Media {
 namespace Player {
 
+class Instance;
+struct TrackState;
+
 void start(not_null<Audio::Instance*> instance);
 void finish(not_null<Audio::Instance*> instance);
 
-class Instance;
-Instance *instance();
+void SaveLastPlaybackPosition(
+	not_null<DocumentData*> document,
+	const TrackState &state);
 
-struct TrackState;
+Instance *instance();
 
 class Instance : private base::Subscriber {
 public:
@@ -80,7 +85,7 @@ public:
 	void playPause(const AudioMsgId &audioId);
 	[[nodiscard]] TrackState getState(AudioMsgId::Type type) const;
 
-	[[nodiscard]] Streaming::Player *roundVideoPlayer(
+	[[nodiscard]] Streaming::Instance *roundVideoStreamed(
 		HistoryItem *item) const;
 	[[nodiscard]] View::PlaybackProgress *roundVideoPlayback(
 		HistoryItem *item) const;
@@ -193,10 +198,10 @@ private:
 	void setupShortcuts();
 	void playStreamed(
 		const AudioMsgId &audioId,
-		std::shared_ptr<Streaming::Reader> reader);
+		std::shared_ptr<Streaming::Document> shared);
 	Streaming::PlaybackOptions streamingOptions(
 		const AudioMsgId &audioId,
-		crl::time position = 0);
+		crl::time position = -1);
 
 	// Observed notifications.
 	void handleSongUpdate(const AudioMsgId &audioId);
diff --git a/Telegram/SourceFiles/media/streaming/media_streaming_audio_track.cpp b/Telegram/SourceFiles/media/streaming/media_streaming_audio_track.cpp
index ce490ad8b..dc573c06c 100644
--- a/Telegram/SourceFiles/media/streaming/media_streaming_audio_track.cpp
+++ b/Telegram/SourceFiles/media/streaming/media_streaming_audio_track.cpp
@@ -47,14 +47,21 @@ crl::time AudioTrack::streamDuration() const {
 	return _stream.duration;
 }
 
-void AudioTrack::process(FFmpeg::Packet &&packet) {
-	if (packet.empty()) {
+void AudioTrack::process(std::vector<FFmpeg::Packet> &&packets) {
+	if (packets.empty()) {
+		return;
+	} else if (packets.front().empty()) {
+		Assert(packets.size() == 1);
 		_readTillEnd = true;
 	}
-	if (initialized()) {
-		mixerEnqueue(std::move(packet));
-	} else if (!tryReadFirstFrame(std::move(packet))) {
-		_error(Error::InvalidData);
+	for (auto i = begin(packets), e = end(packets); i != e; ++i) {
+		if (initialized()) {
+			mixerEnqueue(gsl::make_span(&*i, (e - i)));
+			break;
+		} else if (!tryReadFirstFrame(std::move(*i))) {
+			_error(Error::InvalidData);
+			break;
+		}
 	}
 }
 
@@ -148,10 +155,10 @@ void AudioTrack::callReady() {
 	base::take(_ready)({ VideoInformation(), data });
 }
 
-void AudioTrack::mixerEnqueue(FFmpeg::Packet &&packet) {
+void AudioTrack::mixerEnqueue(gsl::span<FFmpeg::Packet> packets) {
 	Media::Player::mixer()->feedFromExternal({
 		_audioId,
-		std::move(packet)
+		packets
 	});
 }
 
@@ -171,6 +178,12 @@ void AudioTrack::resume(crl::time time) {
 	Media::Player::mixer()->resume(_audioId, true);
 }
 
+void AudioTrack::stop() {
+	if (_audioId.externalPlayId()) {
+		Media::Player::mixer()->stop(_audioId);
+	}
+}
+
 void AudioTrack::setSpeed(float64 speed) {
 	_options.speed = speed;
 	Media::Player::mixer()->setSpeedFromExternal(_audioId, speed);
@@ -228,9 +241,7 @@ rpl::producer<crl::time> AudioTrack::playPosition() {
 }
 
 AudioTrack::~AudioTrack() {
-	if (_audioId.externalPlayId()) {
-		Media::Player::mixer()->stop(_audioId);
-	}
+	stop();
 }
 
 } // namespace Streaming
diff --git a/Telegram/SourceFiles/media/streaming/media_streaming_audio_track.h b/Telegram/SourceFiles/media/streaming/media_streaming_audio_track.h
index bb6f75b73..e0ecedfc0 100644
--- a/Telegram/SourceFiles/media/streaming/media_streaming_audio_track.h
+++ b/Telegram/SourceFiles/media/streaming/media_streaming_audio_track.h
@@ -28,6 +28,9 @@ public:
 	void pause(crl::time time);
 	void resume(crl::time time);
 
+	// Allow to irreversibly stop only audio track.
+	void stop();
+
 	// Called from the main thread.
 	void setSpeed(float64 speed);
 	[[nodiscard]] rpl::producer<> waitingForData() const;
@@ -43,7 +46,7 @@ public:
 	[[nodiscard]] crl::time streamDuration() const;
 
 	// Called from the same unspecified thread.
-	void process(FFmpeg::Packet &&packet);
+	void process(std::vector<FFmpeg::Packet> &&packets);
 	void waitForData();
 
 	// Called from the main thread.
@@ -56,7 +59,7 @@ private:
 	[[nodiscard]] bool fillStateFromFrame();
 	[[nodiscard]] bool processFirstFrame();
 	void mixerInit();
-	void mixerEnqueue(FFmpeg::Packet &&packet);
+	void mixerEnqueue(gsl::span<FFmpeg::Packet> packets);
 	void mixerForceToBuffer();
 	void callReady();
 
diff --git a/Telegram/SourceFiles/media/streaming/media_streaming_common.h b/Telegram/SourceFiles/media/streaming/media_streaming_common.h
index fcc748075..392b4edf9 100644
--- a/Telegram/SourceFiles/media/streaming/media_streaming_common.h
+++ b/Telegram/SourceFiles/media/streaming/media_streaming_common.h
@@ -43,7 +43,7 @@ struct PlaybackOptions {
 	float64 speed = 1.; // Valid values between 0.5 and 2.
 	AudioMsgId audioId;
 	bool syncVideoByAudio = true;
-	bool dropStaleFrames = true;
+	bool waitForMarkAsShown = false;
 	bool loop = false;
 };
 
@@ -127,19 +127,23 @@ struct FrameRequest {
 		return result;
 	}
 
-	bool empty() const {
+	[[nodiscard]] bool empty() const {
 		return resize.isEmpty();
 	}
 
-	bool operator==(const FrameRequest &other) const {
+	[[nodiscard]] bool operator==(const FrameRequest &other) const {
 		return (resize == other.resize)
 			&& (outer == other.outer)
 			&& (radius == other.radius)
 			&& (corners == other.corners);
 	}
-	bool operator!=(const FrameRequest &other) const {
+	[[nodiscard]] bool operator!=(const FrameRequest &other) const {
 		return !(*this == other);
 	}
+
+	[[nodiscard]] bool goodFor(const FrameRequest &other) const {
+		return (*this == other) || (strict && !other.strict);
+	}
 };
 
 } // namespace Streaming
diff --git a/Telegram/SourceFiles/media/streaming/media_streaming_document.cpp b/Telegram/SourceFiles/media/streaming/media_streaming_document.cpp
new file mode 100644
index 000000000..943581965
--- /dev/null
+++ b/Telegram/SourceFiles/media/streaming/media_streaming_document.cpp
@@ -0,0 +1,242 @@
+/*
+This file is part of Telegram Desktop,
+the official desktop application for the Telegram messaging service.
+
+For license and copyright information please follow this link:
+https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+*/
+#include "media/streaming/media_streaming_document.h"
+
+#include "media/streaming/media_streaming_instance.h"
+#include "data/data_session.h"
+#include "data/data_document.h"
+#include "data/data_file_origin.h"
+#include "storage/file_download.h" // Storage::kMaxFileInMemory.
+#include "styles/style_widgets.h"
+
+#include <QtCore/QBuffer>
+
+namespace Media {
+namespace Streaming {
+namespace {
+
+constexpr auto kWaitingFastDuration = crl::time(200);
+constexpr auto kWaitingShowDuration = crl::time(500);
+constexpr auto kWaitingShowDelay = crl::time(500);
+constexpr auto kGoodThumbnailQuality = 87;
+
+} // namespace
+
+Document::Document(
+	not_null<DocumentData*> document,
+	std::shared_ptr<Reader> reader)
+: _player(&document->owner(), reader)
+, _radial(
+	[=] { waitingCallback(); },
+	st::defaultInfiniteRadialAnimation)
+, _document(document) {
+	_player.updates(
+	) | rpl::start_with_next_error([=](Update &&update) {
+		handleUpdate(std::move(update));
+	}, [=](Streaming::Error &&error) {
+		handleError(std::move(error));
+	}, _player.lifetime());
+
+	_player.fullInCache(
+	) | rpl::start_with_next([=](bool fullInCache) {
+		_document->setLoadedInMediaCache(fullInCache);
+	}, _player.lifetime());
+}
+
+Player &Document::player() {
+	return _player;
+}
+
+const Player &Document::player() const {
+	return _player;
+}
+
+const Information &Document::info() const {
+	return _info;
+}
+
+void Document::play(const PlaybackOptions &options) {
+	_player.play(options);
+	_info.audio.state.position
+		= _info.video.state.position
+		= options.position;
+	waitingChange(true);
+}
+
+void Document::saveFrameToCover() {
+	auto request = Streaming::FrameRequest();
+	//request.radius = (_doc && _doc->isVideoMessage())
+	//	? ImageRoundRadius::Ellipse
+	//	: ImageRoundRadius::None;
+	_info.video.cover = _player.ready()
+		? _player.frame(request)
+		: _info.video.cover;
+}
+
+void Document::registerInstance(not_null<Instance*> instance) {
+	_instances.emplace(instance);
+}
+
+void Document::unregisterInstance(not_null<Instance*> instance) {
+	_instances.remove(instance);
+	_player.unregisterInstance(instance);
+	refreshPlayerPriority();
+}
+
+void Document::refreshPlayerPriority() {
+	if (_instances.empty()) {
+		return;
+	}
+	const auto max = ranges::max_element(
+		_instances,
+		ranges::less(),
+		&Instance::priority);
+	_player.setLoaderPriority((*max)->priority());
+}
+
+bool Document::waitingShown() const {
+	if (!_fading.animating() && !_waiting) {
+		_radial.stop(anim::type::instant);
+		return false;
+	}
+	return _radial.animating();
+}
+
+float64 Document::waitingOpacity() const {
+	return _fading.value(_waiting ? 1. : 0.);
+}
+
+Ui::RadialState Document::waitingState() const {
+	return _radial.computeState();
+}
+
+void Document::handleUpdate(Update &&update) {
+	update.data.match([&](Information &update) {
+		ready(std::move(update));
+	}, [&](const PreloadedVideo &update) {
+		_info.video.state.receivedTill = update.till;
+	}, [&](const UpdateVideo &update) {
+		_info.video.state.position = update.position;
+	}, [&](const PreloadedAudio &update) {
+		_info.audio.state.receivedTill = update.till;
+	}, [&](const UpdateAudio &update) {
+		_info.audio.state.position = update.position;
+	}, [&](const WaitingForData &update) {
+		waitingChange(update.waiting);
+	}, [&](MutedByOther) {
+	}, [&](Finished) {
+		const auto finishTrack = [](TrackState &state) {
+			state.position = state.receivedTill = state.duration;
+		};
+		finishTrack(_info.audio.state);
+		finishTrack(_info.video.state);
+	});
+}
+
+void Document::handleError(Error &&error) {
+	if (error == Error::NotStreamable) {
+		_document->setNotSupportsStreaming();
+	} else if (error == Error::OpenFailed) {
+		_document->setInappPlaybackFailed();
+	}
+	waitingChange(false);
+}
+
+void Document::ready(Information &&info) {
+	_info = std::move(info);
+	validateGoodThumbnail();
+	waitingChange(false);
+}
+
+void Document::waitingChange(bool waiting) {
+	if (_waiting == waiting) {
+		return;
+	}
+	_waiting = waiting;
+	const auto fade = [=](crl::time duration) {
+		if (!_radial.animating()) {
+			_radial.start(
+				st::defaultInfiniteRadialAnimation.sineDuration);
+		}
+		_fading.start(
+			[=] { waitingCallback(); },
+			_waiting ? 0. : 1.,
+			_waiting ? 1. : 0.,
+			duration);
+	};
+	if (waiting) {
+		if (_radial.animating()) {
+			_timer.cancel();
+			fade(kWaitingFastDuration);
+		} else {
+			_timer.callOnce(kWaitingShowDelay);
+			_timer.setCallback([=] {
+				fade(kWaitingShowDuration);
+			});
+		}
+	} else {
+		_timer.cancel();
+		if (_radial.animating()) {
+			fade(kWaitingFastDuration);
+		}
+	}
+}
+
+void Document::validateGoodThumbnail() {
+	const auto good = _document->goodThumbnail();
+	if (_info.video.cover.isNull()
+		|| (good && good->loaded())
+		|| _document->uploading()) {
+		return;
+	}
+	auto image = [&] {
+		auto result = _info.video.cover;
+		if (_info.video.rotation != 0) {
+			auto transform = QTransform();
+			transform.rotate(_info.video.rotation);
+			result = result.transformed(transform);
+		}
+		if (result.size() != _info.video.size) {
+			result = result.scaled(
+				_info.video.size,
+				Qt::IgnoreAspectRatio,
+				Qt::SmoothTransformation);
+		}
+		return result;
+	}();
+
+	auto bytes = QByteArray();
+	{
+		auto buffer = QBuffer(&bytes);
+		image.save(&buffer, "JPG", kGoodThumbnailQuality);
+	}
+	const auto length = bytes.size();
+	if (!length || length > Storage::kMaxFileInMemory) {
+		LOG(("App Error: Bad thumbnail data for saving to cache."));
+	} else if (_document->uploading()) {
+		_document->setGoodThumbnailOnUpload(
+			std::move(image),
+			std::move(bytes));
+	} else {
+		_document->owner().cache().putIfEmpty(
+			_document->goodThumbnailCacheKey(),
+			Storage::Cache::Database::TaggedValue(
+				std::move(bytes),
+				Data::kImageCacheTag));
+		_document->refreshGoodThumbnail();
+	}
+}
+
+void Document::waitingCallback() {
+	for (const auto &instance : _instances) {
+		instance->callWaitingCallback();
+	}
+}
+
+} // namespace Streaming
+} // namespace Media
diff --git a/Telegram/SourceFiles/media/streaming/media_streaming_document.h b/Telegram/SourceFiles/media/streaming/media_streaming_document.h
new file mode 100644
index 000000000..348ae18f7
--- /dev/null
+++ b/Telegram/SourceFiles/media/streaming/media_streaming_document.h
@@ -0,0 +1,71 @@
+/*
+This file is part of Telegram Desktop,
+the official desktop application for the Telegram messaging service.
+
+For license and copyright information please follow this link:
+https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+*/
+#pragma once
+
+#include "media/streaming/media_streaming_player.h"
+#include "ui/effects/radial_animation.h"
+#include "ui/effects/animations.h"
+#include "base/timer.h"
+
+class DocumentData;
+
+namespace Media {
+namespace Streaming {
+
+class Instance;
+
+class Document {
+public:
+	Document(
+		not_null<DocumentData*> document,
+		std::shared_ptr<Reader> reader);
+
+	void play(const PlaybackOptions &options);
+	void saveFrameToCover();
+
+	[[nodiscard]] Player &player();
+	[[nodiscard]] const Player &player() const;
+	[[nodiscard]] const Information &info() const;
+
+	[[nodiscard]] bool waitingShown() const;
+	[[nodiscard]] float64 waitingOpacity() const;
+	[[nodiscard]] Ui::RadialState waitingState() const;
+
+private:
+	friend class Instance;
+
+	void registerInstance(not_null<Instance*> instance);
+	void unregisterInstance(not_null<Instance*> instance);
+	void refreshPlayerPriority();
+
+	void waitingCallback();
+
+	void handleUpdate(Update &&update);
+	void handleError(Error &&error);
+
+	void ready(Information &&info);
+	void waitingChange(bool waiting);
+
+	void validateGoodThumbnail();
+
+	Player _player;
+	Information _info;
+
+	bool _waiting = false;
+	mutable Ui::InfiniteRadialAnimation _radial;
+	Ui::Animations::Simple _fading;
+	base::Timer _timer;
+	base::flat_set<not_null<Instance*>> _instances;
+
+	not_null<DocumentData*> _document;
+
+};
+
+
+} // namespace Streaming
+} // namespace Media
diff --git a/Telegram/SourceFiles/media/streaming/media_streaming_file.cpp b/Telegram/SourceFiles/media/streaming/media_streaming_file.cpp
index 2b66026b1..7f23f6095 100644
--- a/Telegram/SourceFiles/media/streaming/media_streaming_file.cpp
+++ b/Telegram/SourceFiles/media/streaming/media_streaming_file.cpp
@@ -16,6 +16,7 @@ namespace Streaming {
 namespace {
 
 constexpr auto kMaxSingleReadAmount = 8 * 1024 * 1024;
+constexpr auto kMaxQueuedPackets = 1024;
 
 } // namespace
 
@@ -27,6 +28,8 @@ File::Context::Context(
 , _size(reader->size()) {
 }
 
+File::Context::~Context() = default;
+
 int File::Context::Read(void *opaque, uint8_t *buffer, int bufferSize) {
 	return static_cast<Context*>(opaque)->read(
 		bytes::make_span(buffer, bufferSize));
@@ -52,6 +55,7 @@ int File::Context::read(bytes::span buffer) {
 
 	buffer = buffer.subspan(0, amount);
 	while (!_reader->fill(_offset, buffer, &_semaphore)) {
+		processQueuedPackets(SleepPolicy::Disallowed);
 		_delegate->fileWaitingForData();
 		_semaphore.acquire();
 		if (_interrupted) {
@@ -142,6 +146,10 @@ Stream File::Context::initStream(
 
 	result.codec = FFmpeg::MakeCodecPointer(info);
 	if (!result.codec) {
+		if (info->codecpar->codec_id == AV_CODEC_ID_MJPEG) {
+			// mp3 files contain such "video stream", just ignore it.
+			return Stream();
+		}
 		return result;
 	}
 
@@ -215,7 +223,7 @@ base::variant<FFmpeg::Packet, FFmpeg::AvErrorWrap> File::Context::readPacket() {
 	if (unroll()) {
 		return FFmpeg::AvErrorWrap();
 	} else if (!error) {
-		return std::move(result);
+		return result;
 	} else if (error.code() != AVERROR_EOF) {
 		logFatal(qstr("av_read_frame"), error);
 	}
@@ -262,6 +270,13 @@ void File::Context::start(crl::time position) {
 		return;
 	}
 
+	if (video.codec) {
+		_queuedPackets[video.index].reserve(kMaxQueuedPackets);
+	}
+	if (audio.codec) {
+		_queuedPackets[audio.index].reserve(kMaxQueuedPackets);
+	}
+
 	const auto header = _reader->headerSize();
 	if (!_delegate->fileReady(header, std::move(video), std::move(audio))) {
 		return fail(Error::OpenFailed);
@@ -285,24 +300,28 @@ void File::Context::readNextPacket() {
 	if (unroll()) {
 		return;
 	} else if (const auto packet = base::get_if<FFmpeg::Packet>(&result)) {
-		const auto more = _delegate->fileProcessPacket(std::move(*packet));
-		if (!more) {
-			do {
-				_reader->startSleep(&_semaphore);
-				_semaphore.acquire();
-				_reader->stopSleep();
-			} while (!unroll() && !_delegate->fileReadMore());
+		const auto index = packet->fields().stream_index;
+		const auto i = _queuedPackets.find(index);
+		if (i == end(_queuedPackets)) {
+			return;
+		}
+		i->second.push_back(std::move(*packet));
+		if (i->second.size() == kMaxQueuedPackets) {
+			processQueuedPackets(SleepPolicy::Allowed);
 		}
 	} else {
 		// Still trying to read by drain.
 		Assert(result.is<FFmpeg::AvErrorWrap>());
 		Assert(result.get<FFmpeg::AvErrorWrap>().code() == AVERROR_EOF);
-		handleEndOfFile();
+		processQueuedPackets(SleepPolicy::Allowed);
+		if (!finished()) {
+			handleEndOfFile();
+		}
 	}
 }
 
 void File::Context::handleEndOfFile() {
-	const auto more = _delegate->fileProcessPacket(FFmpeg::Packet());
+	_delegate->fileProcessEndOfFile();
 	if (_delegate->fileReadMore()) {
 		_readTillEnd = false;
 		auto error = FFmpeg::AvErrorWrap(av_seek_frame(
@@ -313,11 +332,27 @@ void File::Context::handleEndOfFile() {
 		if (error) {
 			logFatal(qstr("av_seek_frame"));
 		}
+
+		// If we loaded a file till the end then we think it is fully cached,
+		// assume we finished loading and don't want to keep all other
+		// download tasks throttled because of an active streaming.
+		_reader->tryRemoveLoaderAsync();
 	} else {
 		_readTillEnd = true;
 	}
 }
 
+void File::Context::processQueuedPackets(SleepPolicy policy) {
+	const auto more = _delegate->fileProcessPackets(_queuedPackets);
+	if (!more && policy == SleepPolicy::Allowed) {
+		do {
+			_reader->startSleep(&_semaphore);
+			_semaphore.acquire();
+			_reader->stopSleep();
+		} while (!unroll() && !_delegate->fileReadMore());
+	}
+}
+
 void File::Context::interrupt() {
 	_interrupted = true;
 	_semaphore.release();
@@ -344,12 +379,16 @@ void File::Context::fail(Error error) {
 	_delegate->fileError(error);
 }
 
-File::Context::~Context() = default;
-
 bool File::Context::finished() const {
 	return unroll() || _readTillEnd;
 }
 
+void File::Context::stopStreamingAsync() {
+	// If we finished loading we don't want to keep all other
+	// download tasks throttled because of an active streaming.
+	_reader->stopStreamingAsync();
+}
+
 File::File(
 	not_null<Data::Session*> owner,
 	std::shared_ptr<Reader> reader)
@@ -366,6 +405,9 @@ void File::start(not_null<FileDelegate*> delegate, crl::time position) {
 		while (!context->finished()) {
 			context->readNextPacket();
 		}
+		if (!context->interrupted()) {
+			context->stopStreamingAsync();
+		}
 	});
 }
 
@@ -388,6 +430,10 @@ bool File::isRemoteLoader() const {
 	return _reader->isRemoteLoader();
 }
 
+void File::setLoaderPriority(int priority) {
+	_reader->setLoaderPriority(priority);
+}
+
 File::~File() {
 	stop();
 }
diff --git a/Telegram/SourceFiles/media/streaming/media_streaming_file.h b/Telegram/SourceFiles/media/streaming/media_streaming_file.h
index 08f6118f8..6c059b09f 100644
--- a/Telegram/SourceFiles/media/streaming/media_streaming_file.h
+++ b/Telegram/SourceFiles/media/streaming/media_streaming_file.h
@@ -37,6 +37,7 @@ public:
 	void stop(bool stillActive = false);
 
 	[[nodiscard]] bool isRemoteLoader() const;
+	void setLoaderPriority(int priority);
 
 	~File();
 
@@ -44,6 +45,7 @@ private:
 	class Context final : public base::has_weak_ptr {
 	public:
 		Context(not_null<FileDelegate*> delegate, not_null<Reader*> reader);
+		~Context();
 
 		void start(crl::time position);
 		void readNextPacket();
@@ -54,9 +56,13 @@ private:
 		[[nodiscard]] bool failed() const;
 		[[nodiscard]] bool finished() const;
 
-		~Context();
+		void stopStreamingAsync();
 
 	private:
+		enum class SleepPolicy {
+			Allowed,
+			Disallowed,
+		};
 		static int Read(void *opaque, uint8_t *buffer, int bufferSize);
 		static int64_t Seek(void *opaque, int64_t offset, int whence);
 
@@ -81,6 +87,7 @@ private:
 		// TODO base::expected.
 		[[nodiscard]] auto readPacket()
 		-> base::variant<FFmpeg::Packet, FFmpeg::AvErrorWrap>;
+		void processQueuedPackets(SleepPolicy policy);
 
 		void handleEndOfFile();
 		void sendFullInCache(bool force = false);
@@ -88,6 +95,7 @@ private:
 		const not_null<FileDelegate*> _delegate;
 		const not_null<Reader*> _reader;
 
+		base::flat_map<int, std::vector<FFmpeg::Packet>> _queuedPackets;
 		int _offset = 0;
 		int _size = 0;
 		bool _failed = false;
diff --git a/Telegram/SourceFiles/media/streaming/media_streaming_file_delegate.h b/Telegram/SourceFiles/media/streaming/media_streaming_file_delegate.h
index 9b001b2de..2c832b10f 100644
--- a/Telegram/SourceFiles/media/streaming/media_streaming_file_delegate.h
+++ b/Telegram/SourceFiles/media/streaming/media_streaming_file_delegate.h
@@ -27,11 +27,12 @@ public:
 	virtual void fileWaitingForData() = 0;
 	virtual void fileFullInCache(bool fullInCache) = 0;
 
+	virtual void fileProcessEndOfFile() = 0;
 	// Return true if reading and processing more packets is desired.
 	// Return false if sleeping until 'wake()' is called is desired.
-	// Return true after the EOF packet if looping is desired.
-	[[nodiscard]] virtual bool fileProcessPacket(
-		FFmpeg::Packet &&packet) = 0;
+	[[nodiscard]] virtual bool fileProcessPackets(
+		base::flat_map<int, std::vector<FFmpeg::Packet>> &packets) = 0;
+	// Also returns true after fileProcessEndOfFile() if looping is desired.
 	[[nodiscard]] virtual bool fileReadMore() = 0;
 };
 
diff --git a/Telegram/SourceFiles/media/streaming/media_streaming_instance.cpp b/Telegram/SourceFiles/media/streaming/media_streaming_instance.cpp
new file mode 100644
index 000000000..78902dbc2
--- /dev/null
+++ b/Telegram/SourceFiles/media/streaming/media_streaming_instance.cpp
@@ -0,0 +1,210 @@
+/*
+This file is part of Telegram Desktop,
+the official desktop application for the Telegram messaging service.
+
+For license and copyright information please follow this link:
+https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+*/
+#include "media/streaming/media_streaming_instance.h"
+
+#include "media/streaming/media_streaming_document.h"
+#include "data/data_file_origin.h"
+#include "data/data_document.h"
+#include "data/data_session.h"
+#include "data/data_streaming.h"
+
+namespace Media {
+namespace Streaming {
+
+Instance::Instance(
+	std::shared_ptr<Document> shared,
+	Fn<void()> waitingCallback)
+: _shared(std::move(shared))
+, _waitingCallback(std::move(waitingCallback)) {
+	if (_shared) {
+		_shared->registerInstance(this);
+	}
+}
+
+Instance::Instance(
+	not_null<DocumentData*> document,
+	Data::FileOrigin origin,
+	Fn<void()> waitingCallback)
+: Instance(
+	document->owner().streaming().sharedDocument(document, origin),
+	std::move(waitingCallback)) {
+}
+
+Instance::~Instance() {
+	if (_shared) {
+		unlockPlayer();
+		_shared->unregisterInstance(this);
+	}
+}
+
+bool Instance::valid() const {
+	return (_shared != nullptr);
+}
+
+const Player &Instance::player() const {
+	Expects(_shared != nullptr);
+
+	return _shared->player();
+}
+
+const Information &Instance::info() const {
+	Expects(_shared != nullptr);
+
+	return _shared->info();
+}
+
+void Instance::play(const PlaybackOptions &options) {
+	Expects(_shared != nullptr);
+
+	_shared->play(options);
+}
+
+void Instance::pause() {
+	Expects(_shared != nullptr);
+
+	_shared->player().pause();
+}
+
+void Instance::resume() {
+	Expects(_shared != nullptr);
+
+	_shared->player().resume();
+}
+
+void Instance::stop() {
+	Expects(_shared != nullptr);
+
+	_shared->player().stop();
+}
+
+void Instance::stopAudio() {
+	Expects(_shared != nullptr);
+
+	_shared->player().stopAudio();
+}
+
+void Instance::saveFrameToCover() {
+	Expects(_shared != nullptr);
+
+	_shared->saveFrameToCover();
+}
+
+bool Instance::active() const {
+	Expects(_shared != nullptr);
+
+	return _shared->player().active();
+}
+
+bool Instance::ready() const {
+	Expects(_shared != nullptr);
+
+	return _shared->player().ready();
+}
+
+std::optional<Error> Instance::failed() const {
+	Expects(_shared != nullptr);
+
+	return _shared->player().failed();
+}
+
+bool Instance::paused() const {
+	Expects(_shared != nullptr);
+
+	return _shared->player().paused();
+}
+
+float64 Instance::speed() const {
+	Expects(_shared != nullptr);
+
+	return _shared->player().speed();
+}
+
+void Instance::setSpeed(float64 speed) {
+	Expects(_shared != nullptr);
+
+	_shared->player().setSpeed(speed);
+}
+
+bool Instance::waitingShown() const {
+	Expects(_shared != nullptr);
+
+	return _shared->waitingShown();
+}
+
+float64 Instance::waitingOpacity() const {
+	Expects(_shared != nullptr);
+
+	return _shared->waitingOpacity();
+}
+
+Ui::RadialState Instance::waitingState() const {
+	Expects(_shared != nullptr);
+
+	return _shared->waitingState();
+}
+
+void Instance::callWaitingCallback() {
+	if (_waitingCallback) {
+		_waitingCallback();
+	}
+}
+
+QImage Instance::frame(const FrameRequest &request) const {
+	return player().frame(request, this);
+}
+
+bool Instance::markFrameShown() {
+	Expects(_shared != nullptr);
+
+	return _shared->player().markFrameShown();
+}
+
+void Instance::lockPlayer() {
+	Expects(_shared != nullptr);
+
+	if (!_playerLocked) {
+		_playerLocked = true;
+		_shared->player().lock();
+	}
+}
+
+void Instance::unlockPlayer() {
+	Expects(_shared != nullptr);
+
+	if (_playerLocked) {
+		_playerLocked = false;
+		_shared->player().unlock();
+	}
+}
+
+bool Instance::playerLocked() const {
+	Expects(_shared != nullptr);
+
+	return _shared->player().locked();
+}
+
+void Instance::setPriority(int priority) {
+	Expects(_shared != nullptr);
+
+	if (_priority == priority) {
+		return;
+	}
+	_priority = priority;
+	_shared->refreshPlayerPriority();
+}
+
+int Instance::priority() const {
+	return _priority;
+}
+
+rpl::lifetime &Instance::lifetime() {
+	return _lifetime;
+}
+
+} // namespace Streaming
+} // namespace Media
diff --git a/Telegram/SourceFiles/media/streaming/media_streaming_instance.h b/Telegram/SourceFiles/media/streaming/media_streaming_instance.h
new file mode 100644
index 000000000..b070171ff
--- /dev/null
+++ b/Telegram/SourceFiles/media/streaming/media_streaming_instance.h
@@ -0,0 +1,88 @@
+/*
+This file is part of Telegram Desktop,
+the official desktop application for the Telegram messaging service.
+
+For license and copyright information please follow this link:
+https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+*/
+#pragma once
+
+#include "media/streaming/media_streaming_common.h"
+
+class DocumentData;
+
+namespace Ui {
+struct RadialState;
+} // namespace Ui
+
+namespace Data {
+struct FileOrigin;
+} // namespace Data
+
+namespace Media {
+namespace Streaming {
+
+class Document;
+class Player;
+
+class Instance {
+public:
+	Instance(
+		std::shared_ptr<Document> shared,
+		Fn<void()> waitingCallback);
+	Instance(
+		not_null<DocumentData*> document,
+		Data::FileOrigin origin,
+		Fn<void()> waitingCallback);
+	~Instance();
+
+	[[nodiscard]] bool valid() const;
+
+	[[nodiscard]] const Player &player() const;
+	[[nodiscard]] const Information &info() const;
+
+	void play(const PlaybackOptions &options);
+	void pause();
+	void resume();
+	void stop();
+	void stopAudio();
+	void saveFrameToCover();
+
+	[[nodiscard]] bool active() const;
+	[[nodiscard]] bool ready() const;
+	[[nodiscard]] std::optional<Error> failed() const;
+
+	[[nodiscard]] bool paused() const;
+
+	[[nodiscard]] float64 speed() const;
+	void setSpeed(float64 speed); // 0.5 <= speed <= 2.
+
+	[[nodiscard]] bool waitingShown() const;
+	[[nodiscard]] float64 waitingOpacity() const;
+	[[nodiscard]] Ui::RadialState waitingState() const;
+
+	void callWaitingCallback();
+
+	[[nodiscard]] QImage frame(const FrameRequest &request) const;
+	bool markFrameShown();
+
+	void lockPlayer();
+	void unlockPlayer();
+	[[nodiscard]] bool playerLocked() const;
+
+	void setPriority(int priority);
+	[[nodiscard]] int priority() const;
+
+	[[nodiscard]] rpl::lifetime &lifetime();
+
+private:
+	const std::shared_ptr<Document> _shared;
+	Fn<void()> _waitingCallback;
+	int _priority = 1;
+	bool _playerLocked = false;
+	rpl::lifetime _lifetime;
+
+};
+
+} // namespace Streaming
+} // namespace Media
diff --git a/Telegram/SourceFiles/media/streaming/media_streaming_loader.cpp b/Telegram/SourceFiles/media/streaming/media_streaming_loader.cpp
index a84c6b39c..c8bb54871 100644
--- a/Telegram/SourceFiles/media/streaming/media_streaming_loader.cpp
+++ b/Telegram/SourceFiles/media/streaming/media_streaming_loader.cpp
@@ -50,6 +50,10 @@ bool PriorityQueue::remove(int value) {
 	return true;
 }
 
+bool PriorityQueue::empty() const {
+	return _data.empty();
+}
+
 std::optional<int> PriorityQueue::front() const {
 	return _data.empty()
 		? std::nullopt
@@ -82,7 +86,7 @@ void PriorityQueue::clear() {
 	_data.clear();
 }
 
-void PriorityQueue::increasePriority() {
+void PriorityQueue::resetPriorities() {
 	++_priority;
 }
 
diff --git a/Telegram/SourceFiles/media/streaming/media_streaming_loader.h b/Telegram/SourceFiles/media/streaming/media_streaming_loader.h
index df476872b..5ccdae833 100644
--- a/Telegram/SourceFiles/media/streaming/media_streaming_loader.h
+++ b/Telegram/SourceFiles/media/streaming/media_streaming_loader.h
@@ -33,14 +33,18 @@ public:
 
 	virtual void load(int offset) = 0;
 	virtual void cancel(int offset) = 0;
-	virtual void increasePriority() = 0;
+	virtual void resetPriorities() = 0;
+	virtual void setPriority(int priority) = 0;
 	virtual void stop() = 0;
 
+	// Remove from queue if no requests are in progress.
+	virtual void tryRemoveFromQueue() = 0;
+
 	// Parts will be sent from the main thread.
 	[[nodiscard]] virtual rpl::producer<LoadedPart> parts() const = 0;
 
 	virtual void attachDownloader(
-		Storage::StreamedFileDownloader *downloader) = 0;
+		not_null<Storage::StreamedFileDownloader*> downloader) = 0;
 	virtual void clearAttachedDownloader() = 0;
 
 	virtual ~Loader() = default;
@@ -51,10 +55,11 @@ class PriorityQueue {
 public:
 	bool add(int value);
 	bool remove(int value);
-	void increasePriority();
-	std::optional<int> front() const;
-	std::optional<int> take();
-	base::flat_set<int> takeInRange(int from, int till);
+	void resetPriorities();
+	[[nodiscard]] bool empty() const;
+	[[nodiscard]] std::optional<int> front() const;
+	[[nodiscard]] std::optional<int> take();
+	[[nodiscard]] base::flat_set<int> takeInRange(int from, int till);
 	void clear();
 
 private:
diff --git a/Telegram/SourceFiles/media/streaming/media_streaming_loader_local.cpp b/Telegram/SourceFiles/media/streaming/media_streaming_loader_local.cpp
index f5620c1c8..dd8d937b3 100644
--- a/Telegram/SourceFiles/media/streaming/media_streaming_loader_local.cpp
+++ b/Telegram/SourceFiles/media/streaming/media_streaming_loader_local.cpp
@@ -68,18 +68,24 @@ void LoaderLocal::fail() {
 void LoaderLocal::cancel(int offset) {
 }
 
-void LoaderLocal::increasePriority() {
+void LoaderLocal::resetPriorities() {
+}
+
+void LoaderLocal::setPriority(int priority) {
 }
 
 void LoaderLocal::stop() {
 }
 
+void LoaderLocal::tryRemoveFromQueue() {
+}
+
 rpl::producer<LoadedPart> LoaderLocal::parts() const {
 	return _parts.events();
 }
 
 void LoaderLocal::attachDownloader(
-		Storage::StreamedFileDownloader *downloader) {
+		not_null<Storage::StreamedFileDownloader*> downloader) {
 	Unexpected("Downloader attached to a local streaming loader.");
 }
 
diff --git a/Telegram/SourceFiles/media/streaming/media_streaming_loader_local.h b/Telegram/SourceFiles/media/streaming/media_streaming_loader_local.h
index d741b18fc..fccd53495 100644
--- a/Telegram/SourceFiles/media/streaming/media_streaming_loader_local.h
+++ b/Telegram/SourceFiles/media/streaming/media_streaming_loader_local.h
@@ -26,14 +26,17 @@ public:
 
 	void load(int offset) override;
 	void cancel(int offset) override;
-	void increasePriority() override;
+	void resetPriorities() override;
+	void setPriority(int priority) override;
 	void stop() override;
 
+	void tryRemoveFromQueue() override;
+
 	// Parts will be sent from the main thread.
 	[[nodiscard]] rpl::producer<LoadedPart> parts() const override;
 
 	void attachDownloader(
-		Storage::StreamedFileDownloader *downloader) override;
+		not_null<Storage::StreamedFileDownloader*> downloader) override;
 	void clearAttachedDownloader() override;
 
 private:
diff --git a/Telegram/SourceFiles/media/streaming/media_streaming_loader_mtproto.cpp b/Telegram/SourceFiles/media/streaming/media_streaming_loader_mtproto.cpp
index ced2d5b1d..555665643 100644
--- a/Telegram/SourceFiles/media/streaming/media_streaming_loader_mtproto.cpp
+++ b/Telegram/SourceFiles/media/streaming/media_streaming_loader_mtproto.cpp
@@ -21,25 +21,17 @@ constexpr auto kMaxConcurrentRequests = 4;
 } // namespace
 
 LoaderMtproto::LoaderMtproto(
-	not_null<Storage::Downloader*> owner,
+	not_null<Storage::DownloadManagerMtproto*> owner,
 	const StorageFileLocation &location,
 	int size,
 	Data::FileOrigin origin)
-: _owner(owner)
-, _location(location)
-, _dcId(location.dcId())
+: DownloadMtprotoTask(owner, location, origin)
 , _size(size)
-, _origin(origin) {
-}
-
-LoaderMtproto::~LoaderMtproto() {
-	for (const auto [index, amount] : _amountByDcIndex) {
-		changeRequestedAmount(index, -amount);
-	}
+, _api(api().instance()) {
 }
 
 std::optional<Storage::Cache::Key> LoaderMtproto::baseCacheKey() const {
-	return _location.bigFileBaseCacheKey();
+	return location().data.get<StorageFileLocation>().bigFileBaseCacheKey();
 }
 
 int LoaderMtproto::size() const {
@@ -56,21 +48,31 @@ void LoaderMtproto::load(int offset) {
 				return;
 			}
 		}
-		if (_requests.contains(offset)) {
+		if (haveSentRequestForOffset(offset)) {
 			return;
 		} else if (_requested.add(offset)) {
-			sendNext();
+			addToQueueWithPriority();
 		}
 	});
 }
 
+void LoaderMtproto::addToQueueWithPriority() {
+	addToQueue(_priority);
+}
+
 void LoaderMtproto::stop() {
 	crl::on_main(this, [=] {
-		ranges::for_each(
-			base::take(_requests),
-			_sender.requestCanceller(),
-			&base::flat_map<int, mtpRequestId>::value_type::second);
+		cancelAllRequests();
 		_requested.clear();
+		removeFromQueue();
+	});
+}
+
+void LoaderMtproto::tryRemoveFromQueue() {
+	crl::on_main(this, [=] {
+		if (_requested.empty() && !haveSentRequests()) {
+			removeFromQueue();
+		}
 	});
 }
 
@@ -81,16 +83,18 @@ void LoaderMtproto::cancel(int offset) {
 }
 
 void LoaderMtproto::cancelForOffset(int offset) {
-	if (const auto requestId = _requests.take(offset)) {
-		_sender.request(*requestId).cancel();
-		sendNext();
+	if (haveSentRequestForOffset(offset)) {
+		cancelRequestForOffset(offset);
+		if (!_requested.empty()) {
+			addToQueueWithPriority();
+		}
 	} else {
 		_requested.remove(offset);
 	}
 }
 
 void LoaderMtproto::attachDownloader(
-		Storage::StreamedFileDownloader *downloader) {
+		not_null<Storage::StreamedFileDownloader*> downloader) {
 	_downloader = downloader;
 }
 
@@ -98,102 +102,40 @@ void LoaderMtproto::clearAttachedDownloader() {
 	_downloader = nullptr;
 }
 
-void LoaderMtproto::increasePriority() {
+void LoaderMtproto::resetPriorities() {
 	crl::on_main(this, [=] {
-		_requested.increasePriority();
+		_requested.resetPriorities();
 	});
 }
 
-void LoaderMtproto::changeRequestedAmount(int index, int amount) {
-	_owner->requestedAmountIncrement(_dcId, index, amount);
-	_amountByDcIndex[index] += amount;
-}
-
-void LoaderMtproto::sendNext() {
-	if (_requests.size() >= kMaxConcurrentRequests) {
+void LoaderMtproto::setPriority(int priority) {
+	if (_priority == priority) {
 		return;
 	}
-	const auto offset = _requested.take().value_or(-1);
-	if (offset < 0) {
-		return;
+	_priority = priority;
+	if (haveSentRequests()) {
+		addToQueueWithPriority();
 	}
+}
 
-	const auto index = _owner->chooseDcIndexForRequest(_dcId);
-	changeRequestedAmount(index, kPartSize);
-
-	const auto usedFileReference = _location.fileReference();
-	const auto id = _sender.request(MTPupload_GetFile(
-		MTP_flags(0),
-		_location.tl(Auth().userId()),
-		MTP_int(offset),
-		MTP_int(kPartSize)
-	)).done([=](const MTPupload_File &result) {
-		changeRequestedAmount(index, -kPartSize);
-		requestDone(offset, result);
-	}).fail([=](const RPCError &error) {
-		changeRequestedAmount(index, -kPartSize);
-		requestFailed(offset, error, usedFileReference);
-	}).toDC(
-		MTP::downloadDcId(_dcId, index)
-	).send();
-	_requests.emplace(offset, id);
-
-	sendNext();
-}
-
-void LoaderMtproto::requestDone(int offset, const MTPupload_File &result) {
-	result.match([&](const MTPDupload_file &data) {
-		_requests.erase(offset);
-		sendNext();
-		_parts.fire({ offset, data.vbytes().v });
-	}, [&](const MTPDupload_fileCdnRedirect &data) {
-		changeCdnParams(
-			offset,
-			data.vdc_id().v,
-			data.vfile_token().v,
-			data.vencryption_key().v,
-			data.vencryption_iv().v,
-			data.vfile_hashes().v);
-	});
+bool LoaderMtproto::readyToRequest() const {
+	return !_requested.empty();
 }
 
-void LoaderMtproto::changeCdnParams(
-		int offset,
-		MTP::DcId dcId,
-		const QByteArray &token,
-		const QByteArray &encryptionKey,
-		const QByteArray &encryptionIV,
-		const QVector<MTPFileHash> &hashes) {
-	// #TODO streaming later cdn
-	_parts.fire({ LoadedPart::kFailedOffset });
+int LoaderMtproto::takeNextRequestOffset() {
+	const auto offset = _requested.take();
+
+	Ensures(offset.has_value());
+	return *offset;
 }
 
-void LoaderMtproto::requestFailed(
-		int offset,
-		const RPCError &error,
-		const QByteArray &usedFileReference) {
-	const auto &type = error.type();
-	const auto fail = [=] {
-		_parts.fire({ LoadedPart::kFailedOffset });
-	};
-	if (error.code() != 400 || !type.startsWith(qstr("FILE_REFERENCE_"))) {
-		return fail();
-	}
-	const auto callback = [=](const Data::UpdatedFileReferences &updated) {
-		_location.refreshFileReference(updated);
-		if (_location.fileReference() == usedFileReference) {
-			fail();
-		} else if (!_requests.take(offset)) {
-			// Request with such offset was already cancelled.
-			return;
-		} else {
-			_requested.add(offset);
-			sendNext();
-		}
-	};
-	_owner->api().refreshFileReference(
-		_origin,
-		crl::guard(this, callback));
+bool LoaderMtproto::feedPart(int offset, const QByteArray &bytes) {
+	_parts.fire({ offset, bytes });
+	return true;
+}
+
+void LoaderMtproto::cancelOnFail() {
+	_parts.fire({ LoadedPart::kFailedOffset });
 }
 
 rpl::producer<LoadedPart> LoaderMtproto::parts() const {
diff --git a/Telegram/SourceFiles/media/streaming/media_streaming_loader_mtproto.h b/Telegram/SourceFiles/media/streaming/media_streaming_loader_mtproto.h
index 755e63dd9..4d4c33fa3 100644
--- a/Telegram/SourceFiles/media/streaming/media_streaming_loader_mtproto.h
+++ b/Telegram/SourceFiles/media/streaming/media_streaming_loader_mtproto.h
@@ -10,22 +10,18 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "media/streaming/media_streaming_loader.h"
 #include "mtproto/sender.h"
 #include "data/data_file_origin.h"
-
-namespace Storage {
-class Downloader;
-} // namespace Storage
+#include "storage/download_manager_mtproto.h"
 
 namespace Media {
 namespace Streaming {
 
-class LoaderMtproto : public Loader, public base::has_weak_ptr {
+class LoaderMtproto : public Loader, public Storage::DownloadMtprotoTask {
 public:
 	LoaderMtproto(
-		not_null<Storage::Downloader*> owner,
+		not_null<Storage::DownloadManagerMtproto*> owner,
 		const StorageFileLocation &location,
 		int size,
 		Data::FileOrigin origin);
-	~LoaderMtproto();
 
 	[[nodiscard]] auto baseCacheKey() const
 	-> std::optional<Storage::Cache::Key> override;
@@ -33,48 +29,34 @@ public:
 
 	void load(int offset) override;
 	void cancel(int offset) override;
-	void increasePriority() override;
+	void resetPriorities() override;
+	void setPriority(int priority) override;
 	void stop() override;
 
+	void tryRemoveFromQueue() override;
+
 	// Parts will be sent from the main thread.
 	[[nodiscard]] rpl::producer<LoadedPart> parts() const override;
 
 	void attachDownloader(
-		Storage::StreamedFileDownloader *downloader) override;
+		not_null<Storage::StreamedFileDownloader*> downloader) override;
 	void clearAttachedDownloader() override;
 
 private:
-	void sendNext();
-
-	void requestDone(int offset, const MTPupload_File &result);
-	void requestFailed(
-		int offset,
-		const RPCError &error,
-		const QByteArray &usedFileReference);
-	void changeCdnParams(
-		int offset,
-		MTP::DcId dcId,
-		const QByteArray &token,
-		const QByteArray &encryptionKey,
-		const QByteArray &encryptionIV,
-		const QVector<MTPFileHash> &hashes);
-	void cancelForOffset(int offset);
-	void changeRequestedAmount(int index, int amount);
+	bool readyToRequest() const override;
+	int takeNextRequestOffset() override;
+	bool feedPart(int offset, const QByteArray &bytes) override;
+	void cancelOnFail() override;
 
-	const not_null<Storage::Downloader*> _owner;
-
-	// _location can be changed with an updated file_reference.
-	StorageFileLocation _location;
-	MTP::DcId _dcId = 0;
+	void cancelForOffset(int offset);
+	void addToQueueWithPriority();
 
 	const int _size = 0;
-	const Data::FileOrigin _origin;
+	int _priority = 0;
 
-	MTP::Sender _sender;
+	MTP::Sender _api;
 
 	PriorityQueue _requested;
-	base::flat_map<int, mtpRequestId> _requests;
-	base::flat_map<int, int> _amountByDcIndex;
 	rpl::event_stream<LoadedPart> _parts;
 
 	Storage::StreamedFileDownloader *_downloader = nullptr;
diff --git a/Telegram/SourceFiles/media/streaming/media_streaming_player.cpp b/Telegram/SourceFiles/media/streaming/media_streaming_player.cpp
index a39b18aff..9d38e5281 100644
--- a/Telegram/SourceFiles/media/streaming/media_streaming_player.cpp
+++ b/Telegram/SourceFiles/media/streaming/media_streaming_player.cpp
@@ -101,7 +101,6 @@ void Player::checkNextFrameRender() {
 		}
 	} else {
 		_renderFrameTimer.cancel();
-		_nextFrameTime = kTimeUnknown;
 		renderFrame(now);
 	}
 }
@@ -110,6 +109,7 @@ void Player::checkNextFrameAvailability() {
 	Expects(_video != nullptr);
 
 	_nextFrameTime = _video->nextFrameDisplayTime();
+	Assert(_nextFrameTime != kFrameDisplayTimeAlreadyDone);
 	if (_nextFrameTime != kTimeUnknown) {
 		checkNextFrameRender();
 	}
@@ -117,13 +117,36 @@ void Player::checkNextFrameAvailability() {
 
 void Player::renderFrame(crl::time now) {
 	Expects(_video != nullptr);
+	Expects(_nextFrameTime != kTimeUnknown);
+	Expects(_nextFrameTime != kFrameDisplayTimeAlreadyDone);
 
 	const auto position = _video->markFrameDisplayed(now);
-	Assert(position != kTimeUnknown);
+	if (_options.waitForMarkAsShown) {
+		_currentFrameTime = _nextFrameTime;
+		_nextFrameTime = kFrameDisplayTimeAlreadyDone;
+	} else {
+		_video->markFrameShown();
+		_nextFrameTime = kTimeUnknown;
+	}
 
+	Assert(position != kTimeUnknown);
 	videoPlayedTill(position);
 }
 
+bool Player::markFrameShown() {
+	Expects(_video != nullptr);
+
+	if (_nextFrameTime == kFrameDisplayTimeAlreadyDone) {
+		_nextFrameTime = kTimeUnknown;
+		_video->addTimelineDelay(crl::now() - _currentFrameTime);
+	}
+	return _video->markFrameShown();
+}
+
+void Player::setLoaderPriority(int priority) {
+	_file->setLoaderPriority(priority);
+}
+
 template <typename Track>
 void Player::trackReceivedTill(
 		const Track &track,
@@ -324,56 +347,83 @@ void Player::fileWaitingForData() {
 	}
 }
 
-bool Player::fileProcessPacket(FFmpeg::Packet &&packet) {
+bool Player::fileProcessPackets(
+		base::flat_map<int, std::vector<FFmpeg::Packet>> &packets) {
 	_waitingForData = false;
-
-	const auto &native = packet.fields();
-	const auto index = native.stream_index;
-	if (packet.empty()) {
-		_readTillEnd = true;
-		setDurationByPackets();
-		if (_audio) {
-			const auto till = _loopingShift + computeAudioDuration();
+	auto audioTill = kTimeUnknown;
+	auto videoTill = kTimeUnknown;
+	for (auto &[index, list] : packets) {
+		if (list.empty()) {
+			continue;
+		}
+		if (_audio && _audio->streamIndex() == index) {
+			//for (const auto &packet : list) {
+			//	// Maybe it is enough to count by list.back()?.. hope so.
+			//	accumulate_max(
+			//		_durationByLastAudioPacket,
+			//		durationByPacket(*_audio, packet));
+			//}
+			accumulate_max(
+				_durationByLastAudioPacket,
+				durationByPacket(*_audio, list.back()));
+			const auto till = _loopingShift + std::clamp(
+				FFmpeg::PacketPosition(
+					list.back(),
+					_audio->streamTimeBase()),
+				crl::time(0),
+				computeAudioDuration() - 1);
 			crl::on_main(&_sessionGuard, [=] {
 				audioReceivedTill(till);
 			});
-			_audio->process(FFmpeg::Packet());
-		}
-		if (_video) {
-			const auto till = _loopingShift + computeVideoDuration();
+			_audio->process(base::take(list));
+		} else if (_video && _video->streamIndex() == index) {
+			//for (const auto &packet : list) {
+			//	// Maybe it is enough to count by list.back()?.. hope so.
+			//	accumulate_max(
+			//		_durationByLastVideoPacket,
+			//		durationByPacket(*_video, packet));
+			//}
+			accumulate_max(
+				_durationByLastVideoPacket,
+				durationByPacket(*_video, list.back()));
+			const auto till = _loopingShift + std::clamp(
+				FFmpeg::PacketPosition(
+					list.back(),
+					_video->streamTimeBase()),
+				crl::time(0),
+				computeVideoDuration() - 1);
 			crl::on_main(&_sessionGuard, [=] {
 				videoReceivedTill(till);
 			});
-			_video->process(FFmpeg::Packet());
+			_video->process(base::take(list));
 		}
-	} else if (_audio && _audio->streamIndex() == native.stream_index) {
-		accumulate_max(
-			_durationByLastAudioPacket,
-			durationByPacket(*_audio, packet));
-
-		const auto till = _loopingShift + std::clamp(
-			FFmpeg::PacketPosition(packet, _audio->streamTimeBase()),
-			crl::time(0),
-			computeAudioDuration() - 1);
+	}
+	return fileReadMore();
+}
+
+void Player::fileProcessEndOfFile() {
+	_waitingForData = false;
+	_readTillEnd = true;
+	setDurationByPackets();
+	const auto generateEmptyQueue = [] {
+		auto result = std::vector<FFmpeg::Packet>();
+		result.emplace_back();
+		return result;
+	};
+	if (_audio) {
+		const auto till = _loopingShift + computeAudioDuration();
 		crl::on_main(&_sessionGuard, [=] {
 			audioReceivedTill(till);
 		});
-		_audio->process(std::move(packet));
-	} else if (_video && _video->streamIndex() == native.stream_index) {
-		accumulate_max(
-			_durationByLastVideoPacket,
-			durationByPacket(*_video, packet));
-
-		const auto till = _loopingShift + std::clamp(
-			FFmpeg::PacketPosition(packet, _video->streamTimeBase()),
-			crl::time(0),
-			computeVideoDuration() - 1);
+		_audio->process(generateEmptyQueue());
+	}
+	if (_video) {
+		const auto till = _loopingShift + computeVideoDuration();
 		crl::on_main(&_sessionGuard, [=] {
 			videoReceivedTill(till);
 		});
-		_video->process(std::move(packet));
+		_video->process(generateEmptyQueue());
 	}
-	return fileReadMore();
 }
 
 bool Player::fileReadMore() {
@@ -448,6 +498,11 @@ void Player::provideStartInformation() {
 	} else {
 		_stage = Stage::Ready;
 
+		if (_audio && _audioFinished) {
+			// Audio was stopped before it was ready.
+			_audio->stop();
+		}
+
 		// Don't keep the reference to the video cover.
 		auto copy = _information;
 		_information.video.cover = QImage();
@@ -559,6 +614,18 @@ void Player::stop() {
 	stop(false);
 }
 
+void Player::stopAudio() {
+	if (!_video) {
+		stop();
+	} else if (_audio) {
+		_audioFinished = true;
+		if (_information.audio.state.duration != kTimeUnknown) {
+			// Audio is ready.
+			_audio->stop();
+		}
+	}
+}
+
 void Player::updatePausedState() {
 	const auto paused = _pausedByUser || _pausedByWaitingForData;
 	if (_paused == paused) {
@@ -647,7 +714,7 @@ void Player::start() {
 		_updates.fire({ WaitingForData{ true } });
 	}, _sessionLifetime);
 
-	if (guard && _audio) {
+	if (guard && _audio && !_audioFinished) {
 		_audio->playPosition(
 		) | rpl::start_with_next_done([=](crl::time position) {
 			audioPlayedTill(position);
@@ -682,7 +749,13 @@ void Player::start() {
 		}, _sessionLifetime);
 	}
 	if (guard && _audio) {
-		trackSendReceivedTill(*_audio, _information.audio.state);
+		if (_audioFinished) {
+			if (!_video || _videoFinished) {
+				_updates.fire({ Finished() });
+			}
+		} else {
+			trackSendReceivedTill(*_audio, _information.audio.state);
+		}
 	}
 	if (guard && _video) {
 		trackSendReceivedTill(*_video, _information.video.state);
@@ -690,7 +763,9 @@ void Player::start() {
 }
 
 void Player::checkVideoStep() {
-	if (_nextFrameTime != kTimeUnknown) {
+	if (_nextFrameTime == kFrameDisplayTimeAlreadyDone) {
+		return;
+	} else if (_nextFrameTime != kTimeUnknown) {
 		checkNextFrameRender();
 	} else {
 		checkNextFrameAvailability();
@@ -736,7 +811,7 @@ bool Player::buffering() const {
 }
 
 bool Player::paused() const {
-	return _pausedByUser;
+	return _pausedByUser && active();
 }
 
 bool Player::finished() const {
@@ -767,6 +842,15 @@ void Player::setSpeed(float64 speed) {
 	}
 }
 
+void Player::setWaitForMarkAsShown(bool wait) {
+	if (_options.waitForMarkAsShown != wait) {
+		_options.waitForMarkAsShown = wait;
+		if (_video) {
+			_video->setWaitForMarkAsShown(wait);
+		}
+	}
+}
+
 bool Player::active() const {
 	return (_stage != Stage::Uninitialized) && !finished() && !failed();
 }
@@ -788,10 +872,18 @@ QSize Player::videoSize() const {
 	return _information.video.size;
 }
 
-QImage Player::frame(const FrameRequest &request) const {
+QImage Player::frame(
+		const FrameRequest &request,
+		const Instance *instance) const {
 	Expects(_video != nullptr);
 
-	return _video->frame(request);
+	return _video->frame(request, instance);
+}
+
+void Player::unregisterInstance(not_null<const Instance*> instance) {
+	if (_video) {
+		_video->unregisterInstance(instance);
+	}
 }
 
 Media::Player::TrackState Player::prepareLegacyState() const {
@@ -854,6 +946,24 @@ crl::time Player::getCurrentReceivedTill(crl::time duration) const {
 		: result;
 }
 
+void Player::lock() {
+	++_locks;
+}
+
+void Player::unlock() {
+	Expects(_locks > 0);
+
+	--_locks;
+	if (!_locks) {
+		stopAudio();
+		setWaitForMarkAsShown(true);
+	}
+}
+
+bool Player::locked() const {
+	return (_locks > 0);
+}
+
 rpl::lifetime &Player::lifetime() {
 	return _lifetime;
 }
diff --git a/Telegram/SourceFiles/media/streaming/media_streaming_player.h b/Telegram/SourceFiles/media/streaming/media_streaming_player.h
index 0261bfa7d..28e6d3ab1 100644
--- a/Telegram/SourceFiles/media/streaming/media_streaming_player.h
+++ b/Telegram/SourceFiles/media/streaming/media_streaming_player.h
@@ -29,6 +29,7 @@ class Reader;
 class File;
 class AudioTrack;
 class VideoTrack;
+class Instance;
 
 class Player final : private FileDelegate {
 public:
@@ -44,11 +45,15 @@ public:
 	void resume();
 	void stop();
 
+	// Allow to irreversibly stop only audio track.
+	void stopAudio();
+
 	[[nodiscard]] bool active() const;
 	[[nodiscard]] bool ready() const;
 
 	[[nodiscard]] float64 speed() const;
 	void setSpeed(float64 speed); // 0.5 <= speed <= 2.
+	void setWaitForMarkAsShown(bool wait);
 
 	[[nodiscard]] bool playing() const;
 	[[nodiscard]] bool buffering() const;
@@ -60,10 +65,20 @@ public:
 	[[nodiscard]] rpl::producer<bool> fullInCache() const;
 
 	[[nodiscard]] QSize videoSize() const;
-	[[nodiscard]] QImage frame(const FrameRequest &request) const;
+	[[nodiscard]] QImage frame(
+		const FrameRequest &request,
+		const Instance *instance = nullptr) const;
+	void unregisterInstance(not_null<const Instance*> instance);
+	bool markFrameShown();
+
+	void setLoaderPriority(int priority);
 
 	[[nodiscard]] Media::Player::TrackState prepareLegacyState() const;
 
+	void lock();
+	void unlock();
+	[[nodiscard]] bool locked() const;
+
 	[[nodiscard]] rpl::lifetime &lifetime();
 
 	~Player();
@@ -84,7 +99,9 @@ private:
 	void fileError(Error error) override;
 	void fileWaitingForData() override;
 	void fileFullInCache(bool fullInCache) override;
-	bool fileProcessPacket(FFmpeg::Packet &&packet) override;
+	bool fileProcessPackets(
+		base::flat_map<int, std::vector<FFmpeg::Packet>> &packets) override;
+	void fileProcessEndOfFile() override;
 	bool fileReadMore() override;
 
 	// Called from the main thread.
@@ -175,6 +192,7 @@ private:
 
 	crl::time _startedTime = kTimeUnknown;
 	crl::time _pausedTime = kTimeUnknown;
+	crl::time _currentFrameTime = kTimeUnknown;
 	crl::time _nextFrameTime = kTimeUnknown;
 	base::Timer _renderFrameTimer;
 	rpl::event_stream<Update, Error> _updates;
@@ -188,6 +206,8 @@ private:
 	int _durationByLastAudioPacket = 0;
 	int _durationByLastVideoPacket = 0;
 
+	int _locks = 0;
+
 	rpl::lifetime _lifetime;
 	rpl::lifetime _sessionLifetime;
 
diff --git a/Telegram/SourceFiles/media/streaming/media_streaming_reader.cpp b/Telegram/SourceFiles/media/streaming/media_streaming_reader.cpp
index 79bdfcdd1..365d1270b 100644
--- a/Telegram/SourceFiles/media/streaming/media_streaming_reader.cpp
+++ b/Telegram/SourceFiles/media/streaming/media_streaming_reader.cpp
@@ -886,16 +886,32 @@ void Reader::stopSleep() {
 	_sleeping.store(nullptr, std::memory_order_release);
 }
 
+void Reader::stopStreamingAsync() {
+	_stopStreamingAsync = true;
+	crl::on_main(this, [=] {
+		if (_stopStreamingAsync) {
+			stopStreaming(false);
+		}
+	});
+}
+
+void Reader::tryRemoveLoaderAsync() {
+	_loader->tryRemoveFromQueue();
+}
+
 void Reader::startStreaming() {
 	_streamingActive = true;
+	refreshLoaderPriority();
 }
 
 void Reader::stopStreaming(bool stillActive) {
 	Expects(_sleeping == nullptr);
 
+	_stopStreamingAsync = false;
 	_waiting.store(nullptr, std::memory_order_release);
 	if (!stillActive) {
 		_streamingActive = false;
+		refreshLoaderPriority();
 		_loadingOffsets.clear();
 		processDownloaderRequests();
 	}
@@ -906,7 +922,7 @@ rpl::producer<LoadedPart> Reader::partsForDownloader() const {
 }
 
 void Reader::loadForDownloader(
-		Storage::StreamedFileDownloader *downloader,
+		not_null<Storage::StreamedFileDownloader*> downloader,
 		int offset) {
 	if (_attachedDownloader != downloader) {
 		if (_attachedDownloader) {
@@ -931,7 +947,7 @@ void Reader::doneForDownloader(int offset) {
 }
 
 void Reader::cancelForDownloader(
-		Storage::StreamedFileDownloader *downloader) {
+		not_null<Storage::StreamedFileDownloader*> downloader) {
 	if (_attachedDownloader == downloader) {
 		_downloaderOffsetRequests.take();
 		_attachedDownloader = nullptr;
@@ -1080,6 +1096,18 @@ void Reader::checkCacheResultsForDownloader() {
 	processDownloaderRequests();
 }
 
+void Reader::setLoaderPriority(int priority) {
+	if (_realPriority == priority) {
+		return;
+	}
+	_realPriority = priority;
+	refreshLoaderPriority();
+}
+
+void Reader::refreshLoaderPriority() {
+	_loader->setPriority(_streamingActive ? _realPriority : 0);
+}
+
 bool Reader::isRemoteLoader() const {
 	return _loader->baseCacheKey().has_value();
 }
@@ -1269,8 +1297,8 @@ void Reader::cancelLoadInRange(int from, int till) {
 
 void Reader::checkLoadWillBeFirst(int offset) {
 	if (_loadingOffsets.front().value_or(offset) != offset) {
-		_loadingOffsets.increasePriority();
-		_loader->increasePriority();
+		_loadingOffsets.resetPriorities();
+		_loader->resetPriorities();
 	}
 }
 
diff --git a/Telegram/SourceFiles/media/streaming/media_streaming_reader.h b/Telegram/SourceFiles/media/streaming/media_streaming_reader.h
index 7ea333987..7d1b97652 100644
--- a/Telegram/SourceFiles/media/streaming/media_streaming_reader.h
+++ b/Telegram/SourceFiles/media/streaming/media_streaming_reader.h
@@ -37,6 +37,8 @@ public:
 		not_null<Storage::Cache::Database*> cache,
 		std::unique_ptr<Loader> loader);
 
+	void setLoaderPriority(int priority);
+
 	// Any thread.
 	[[nodiscard]] int size() const;
 	[[nodiscard]] bool isRemoteLoader() const;
@@ -55,16 +57,19 @@ public:
 	void startSleep(not_null<crl::semaphore*> wake);
 	void wakeFromSleep();
 	void stopSleep();
+	void stopStreamingAsync();
+	void tryRemoveLoaderAsync();
 
 	// Main thread.
 	void startStreaming();
 	void stopStreaming(bool stillActive = false);
 	[[nodiscard]] rpl::producer<LoadedPart> partsForDownloader() const;
 	void loadForDownloader(
-		Storage::StreamedFileDownloader *downloader,
+		not_null<Storage::StreamedFileDownloader*> downloader,
 		int offset);
 	void doneForDownloader(int offset);
-	void cancelForDownloader(Storage::StreamedFileDownloader *downloader);
+	void cancelForDownloader(
+		not_null<Storage::StreamedFileDownloader*> downloader);
 
 	~Reader();
 
@@ -218,6 +223,8 @@ private:
 	void checkForDownloaderChange(int checkItemsCount);
 	void checkForDownloaderReadyOffsets();
 
+	void refreshLoaderPriority();
+
 	static std::shared_ptr<CacheHelper> InitCacheHelper(
 		std::optional<Storage::Cache::Key> baseKey);
 
@@ -228,6 +235,7 @@ private:
 	base::thread_safe_queue<LoadedPart, std::vector> _loadedParts;
 	std::atomic<crl::semaphore*> _waiting = nullptr;
 	std::atomic<crl::semaphore*> _sleeping = nullptr;
+	std::atomic<bool> _stopStreamingAsync = false;
 	PriorityQueue _loadingOffsets;
 
 	Slices _slices;
@@ -241,6 +249,7 @@ private:
 	// Main thread.
 	Storage::StreamedFileDownloader *_attachedDownloader = nullptr;
 	rpl::event_stream<LoadedPart> _partsForDownloader;
+	int _realPriority = 1;
 	bool _streamingActive = false;
 
 	// Streaming thread.
diff --git a/Telegram/SourceFiles/media/streaming/media_streaming_utility.cpp b/Telegram/SourceFiles/media/streaming/media_streaming_utility.cpp
index 48f9246b0..297475c95 100644
--- a/Telegram/SourceFiles/media/streaming/media_streaming_utility.cpp
+++ b/Telegram/SourceFiles/media/streaming/media_streaming_utility.cpp
@@ -85,9 +85,14 @@ FFmpeg::AvErrorWrap ReadNextFrame(Stream &stream) {
 	return error;
 }
 
-bool GoodForRequest(const QImage &image, const FrameRequest &request) {
+bool GoodForRequest(
+		const QImage &image,
+		int rotation,
+		const FrameRequest &request) {
 	if (request.resize.isEmpty()) {
 		return true;
+	} else if (rotation != 0) {
+		return false;
 	} else if ((request.radius != ImageRoundRadius::None)
 		&& ((request.corners & RectPart::AllCorners) != 0)) {
 		return false;
@@ -174,8 +179,95 @@ QImage ConvertFrame(
 	return storage;
 }
 
+void PaintFrameOuter(QPainter &p, const QRect &inner, QSize outer) {
+	const auto left = inner.x();
+	const auto right = outer.width() - inner.width() - left;
+	const auto top = inner.y();
+	const auto bottom = outer.height() - inner.height() - top;
+	if (left > 0) {
+		p.fillRect(0, 0, left, outer.height(), st::imageBg);
+	}
+	if (right > 0) {
+		p.fillRect(
+			outer.width() - right,
+			0,
+			right,
+			outer.height(),
+			st::imageBg);
+	}
+	if (top > 0) {
+		p.fillRect(left, 0, inner.width(), top, st::imageBg);
+	}
+	if (bottom > 0) {
+		p.fillRect(
+			left,
+			outer.height() - bottom,
+			inner.width(),
+			bottom,
+			st::imageBg);
+	}
+}
+
+void PaintFrameInner(
+		QPainter &p,
+		QRect to,
+		const QImage &original,
+		int rotation) {
+	const auto rotated = [](QRect rect, int rotation) {
+		switch (rotation) {
+		case 0: return rect;
+		case 90: return QRect(
+			rect.y(),
+			-rect.x() - rect.width(),
+			rect.height(),
+			rect.width());
+		case 180: return QRect(
+			-rect.x() - rect.width(),
+			-rect.y() - rect.height(),
+			rect.width(),
+			rect.height());
+		case 270: return QRect(
+			-rect.y() - rect.height(),
+			rect.x(),
+			rect.height(),
+			rect.width());
+		}
+		Unexpected("Rotation in PaintFrameInner.");
+	};
+
+	PainterHighQualityEnabler hq(p);
+	if (rotation) {
+		p.rotate(rotation);
+	}
+	p.drawImage(rotated(to, rotation), original);
+}
+
+void PaintFrameContent(
+		QPainter &p,
+		const QImage &original,
+		int rotation,
+		const FrameRequest &request) {
+	const auto full = request.outer;
+	const auto to = QRect(
+		(full.width() - request.resize.width()) / 2,
+		(full.height() - request.resize.height()) / 2,
+		request.resize.width(),
+		request.resize.height());
+	PaintFrameOuter(p, to, full);
+	PaintFrameInner(p, to, original, rotation);
+}
+
+void ApplyFrameRounding(QImage &storage, const FrameRequest &request) {
+	if (!(request.corners & RectPart::AllCorners)
+		|| (request.radius == ImageRoundRadius::None)) {
+		return;
+	}
+	Images::prepareRound(storage, request.radius, request.corners);
+}
+
 QImage PrepareByRequest(
 		const QImage &original,
+		int rotation,
 		const FrameRequest &request,
 		QImage storage) {
 	Expects(!request.outer.isEmpty());
@@ -183,16 +275,12 @@ QImage PrepareByRequest(
 	if (!FFmpeg::GoodStorageForFrame(storage, request.outer)) {
 		storage = FFmpeg::CreateFrameStorage(request.outer);
 	}
-	{
-		Painter p(&storage);
-		PainterHighQualityEnabler hq(p);
-		p.drawImage(QRect(QPoint(), request.outer), original);
-	}
-	if ((request.corners & RectPart::AllCorners)
-		&& (request.radius != ImageRoundRadius::None)) {
-		Images::prepareRound(storage, request.radius, request.corners);
-	}
-	// #TODO streaming later full prepare support.
+
+	QPainter p(&storage);
+	PaintFrameContent(p, original, rotation, request);
+	p.end();
+
+	ApplyFrameRounding(storage, request);
 	return storage;
 }
 
diff --git a/Telegram/SourceFiles/media/streaming/media_streaming_utility.h b/Telegram/SourceFiles/media/streaming/media_streaming_utility.h
index b2b2a48a2..0b28584e2 100644
--- a/Telegram/SourceFiles/media/streaming/media_streaming_utility.h
+++ b/Telegram/SourceFiles/media/streaming/media_streaming_utility.h
@@ -51,6 +51,7 @@ struct Stream {
 
 [[nodiscard]] bool GoodForRequest(
 	const QImage &image,
+	int rotation,
 	const FrameRequest &request);
 [[nodiscard]] QImage ConvertFrame(
 	Stream &stream,
@@ -59,6 +60,7 @@ struct Stream {
 	QImage storage);
 [[nodiscard]] QImage PrepareByRequest(
 	const QImage &original,
+	int rotation,
 	const FrameRequest &request,
 	QImage storage);
 
diff --git a/Telegram/SourceFiles/media/streaming/media_streaming_video_track.cpp b/Telegram/SourceFiles/media/streaming/media_streaming_video_track.cpp
index d267f9cf9..1feaa6852 100644
--- a/Telegram/SourceFiles/media/streaming/media_streaming_video_track.cpp
+++ b/Telegram/SourceFiles/media/streaming/media_streaming_video_track.cpp
@@ -34,7 +34,7 @@ public:
 		FnMut<void(const Information &)> ready,
 		Fn<void(Error)> error);
 
-	void process(FFmpeg::Packet &&packet);
+	void process(std::vector<FFmpeg::Packet> &&packets);
 
 	[[nodisacrd]] rpl::producer<> checkNextFrame() const;
 	[[nodisacrd]] rpl::producer<> waitingForData() const;
@@ -42,9 +42,14 @@ public:
 	void pause(crl::time time);
 	void resume(crl::time time);
 	void setSpeed(float64 speed);
+	void setWaitForMarkAsShown(bool wait);
 	void interrupt();
-	void frameDisplayed();
-	void updateFrameRequest(const FrameRequest &request);
+	void frameShown();
+	void addTimelineDelay(crl::time delayed);
+	void updateFrameRequest(
+		const Instance *instance,
+		const FrameRequest &request);
+	void removeFrameRequest(const Instance *instance);
 
 private:
 	enum class FrameResult {
@@ -67,6 +72,8 @@ private:
 	void readFrames();
 	[[nodiscard]] ReadEnoughState readEnoughFrames(crl::time trackTime);
 	[[nodiscard]] FrameResult readFrame(not_null<Frame*> frame);
+	void fillRequests(not_null<Frame*> frame) const;
+	[[nodiscard]] QSize chooseOriginalResize() const;
 	void presentFrameIfNeeded();
 	void callReady();
 	[[nodiscard]] bool loopAround();
@@ -97,7 +104,7 @@ private:
 	crl::time _loopingShift = 0;
 	rpl::event_stream<> _checkNextFrame;
 	rpl::event_stream<> _waitingForData;
-	FrameRequest _request = FrameRequest::NonStrict();
+	base::flat_map<const Instance*, FrameRequest> _requests;
 
 	bool _queued = false;
 	base::ConcurrentTimer _readFramesTimer;
@@ -142,25 +149,42 @@ rpl::producer<> VideoTrackObject::waitingForData() const {
 		: _waitingForData.events();
 }
 
-void VideoTrackObject::process(FFmpeg::Packet &&packet) {
-	if (interrupted()) {
+void VideoTrackObject::process(std::vector<FFmpeg::Packet> &&packets) {
+	if (interrupted() || packets.empty()) {
 		return;
 	}
-	if (packet.empty()) {
+	if (packets.front().empty()) {
+		Assert(packets.size() == 1);
 		_readTillEnd = true;
 	} else if (!_readTillEnd) {
+		//for (const auto &packet : packets) {
+		//	// Maybe it is enough to count by list.back()?.. hope so.
+		//	accumulate_max(
+		//		_durationByLastPacket,
+		//		durationByPacket(packet));
+		//	if (interrupted()) {
+		//		return;
+		//	}
+		//}
 		accumulate_max(
 			_durationByLastPacket,
-			durationByPacket(packet));
+			durationByPacket(packets.back()));
 		if (interrupted()) {
 			return;
 		}
 	}
-	if (_shared->initialized()) {
-		_stream.queue.push_back(std::move(packet));
-		queueReadFrames();
-	} else if (!tryReadFirstFrame(std::move(packet))) {
-		fail(Error::InvalidData);
+	for (auto i = begin(packets), e = end(packets); i != e; ++i) {
+		if (_shared->initialized()) {
+			_stream.queue.insert(
+				end(_stream.queue),
+				std::make_move_iterator(i),
+				std::make_move_iterator(e));
+			queueReadFrames();
+			break;
+		} else if (!tryReadFirstFrame(std::move(*i))) {
+			fail(Error::InvalidData);
+			break;
+		}
 	}
 }
 
@@ -222,7 +246,7 @@ void VideoTrackObject::readFrames() {
 
 auto VideoTrackObject::readEnoughFrames(crl::time trackTime)
 -> ReadEnoughState {
-	const auto dropStaleFrames = _options.dropStaleFrames;
+	const auto dropStaleFrames = !_options.waitForMarkAsShown;
 	const auto state = _shared->prepareState(trackTime, dropStaleFrames);
 	return state.match([&](Shared::PrepareFrame frame) -> ReadEnoughState {
 		while (true) {
@@ -296,35 +320,69 @@ auto VideoTrackObject::readFrame(not_null<Frame*> frame) -> FrameResult {
 	return FrameResult::Done;
 }
 
+void VideoTrackObject::fillRequests(not_null<Frame*> frame) const {
+	auto i = frame->prepared.begin();
+	for (const auto &[instance, request] : _requests) {
+		while (i != frame->prepared.end() && i->first < instance) {
+			i = frame->prepared.erase(i);
+		}
+		if (i == frame->prepared.end() || i->first > instance) {
+			i = frame->prepared.emplace(instance, request).first;
+		}
+		++i;
+	}
+	while (i != frame->prepared.end()) {
+		i = frame->prepared.erase(i);
+	}
+}
+
+QSize VideoTrackObject::chooseOriginalResize() const {
+	auto chosen = QSize();
+	for (const auto &[_, request] : _requests) {
+		if (request.resize.isEmpty()) {
+			return QSize();
+		}
+		const auto byWidth = (request.resize.width() >= chosen.width());
+		const auto byHeight = (request.resize.height() >= chosen.height());
+		if (byWidth && byHeight) {
+			chosen = request.resize;
+		} else if (byWidth || byHeight) {
+			return QSize();
+		}
+	}
+	return chosen;
+}
+
 void VideoTrackObject::presentFrameIfNeeded() {
 	if (_pausedTime != kTimeUnknown || _resumedTime == kTimeUnknown) {
 		return;
 	}
-	const auto time = trackTime();
 	const auto rasterize = [&](not_null<Frame*> frame) {
 		Expects(frame->position != kFinishedPosition);
 
-		frame->request = _request;
+		fillRequests(frame);
 		frame->original = ConvertFrame(
 			_stream,
 			frame->decoded.get(),
-			frame->request.resize,
+			chooseOriginalResize(),
 			std::move(frame->original));
 		if (frame->original.isNull()) {
-			frame->prepared = QImage();
+			frame->prepared.clear();
 			fail(Error::InvalidData);
 			return;
 		}
 
-		VideoTrack::PrepareFrameByRequest(frame);
+		VideoTrack::PrepareFrameByRequests(frame, _stream.rotation);
 
 		Ensures(VideoTrack::IsRasterized(frame));
 	};
+	const auto dropStaleFrames = !_options.waitForMarkAsShown;
 	const auto presented = _shared->presentFrame(
-		time,
+		trackTime(),
 		_options.speed,
-		_options.dropStaleFrames,
+		dropStaleFrames,
 		rasterize);
+	addTimelineDelay(presented.addedWorldTimeDelay);
 	if (presented.displayPosition == kFinishedPosition) {
 		interrupt();
 		_checkNextFrame = rpl::event_stream<>();
@@ -380,19 +438,41 @@ void VideoTrackObject::setSpeed(float64 speed) {
 	_options.speed = speed;
 }
 
+void VideoTrackObject::setWaitForMarkAsShown(bool wait) {
+	if (interrupted()) {
+		return;
+	}
+	_options.waitForMarkAsShown = wait;
+}
+
 bool VideoTrackObject::interrupted() const {
 	return (_shared == nullptr);
 }
 
-void VideoTrackObject::frameDisplayed() {
+void VideoTrackObject::frameShown() {
 	if (interrupted()) {
 		return;
 	}
 	queueReadFrames();
 }
 
-void VideoTrackObject::updateFrameRequest(const FrameRequest &request) {
-	_request = request;
+void VideoTrackObject::addTimelineDelay(crl::time delayed) {
+	Expects(_syncTimePoint.valid());
+
+	if (!delayed) {
+		return;
+	}
+	_syncTimePoint.worldTime += delayed;
+}
+
+void VideoTrackObject::updateFrameRequest(
+		const Instance *instance,
+		const FrameRequest &request) {
+	_requests.emplace(instance, request);
+}
+
+void VideoTrackObject::removeFrameRequest(const Instance *instance) {
+	_requests.remove(instance);
 }
 
 bool VideoTrackObject::tryReadFirstFrame(FFmpeg::Packet &&packet) {
@@ -529,6 +609,7 @@ void VideoTrack::Shared::init(QImage &&cover, crl::time position) {
 	// But in this case we update _counter, so we set a fake displayed time.
 	_frames[0].displayed = kDisplaySkipped;
 
+	_delay = 0;
 	_counter.store(0, std::memory_order_release);
 }
 
@@ -617,23 +698,25 @@ auto VideoTrack::Shared::presentFrame(
 	const auto present = [&](int counter, int index) -> PresentFrame {
 		const auto frame = getFrame(index);
 		const auto position = frame->position;
+		const auto addedWorldTimeDelay = base::take(_delay);
 		if (position == kFinishedPosition) {
-			return { kFinishedPosition, kTimeUnknown };
+			return { kFinishedPosition, kTimeUnknown, addedWorldTimeDelay };
 		}
 		rasterize(frame);
 		if (!IsRasterized(frame)) {
 			// Error happened during frame prepare.
-			return { kTimeUnknown, kTimeUnknown };
+			return { kTimeUnknown, kTimeUnknown, addedWorldTimeDelay };
 		}
 		const auto trackLeft = position - time.trackTime;
 		frame->display = time.worldTime
+			+ addedWorldTimeDelay
 			+ crl::time(std::round(trackLeft / playbackSpeed));
 
 		// Release this frame to the main thread for rendering.
 		_counter.store(
 			(counter + 1) % (2 * kFramesCount),
 			std::memory_order_release);
-		return { position, crl::time(0) };
+		return { position, crl::time(0), addedWorldTimeDelay };
 	};
 	const auto nextCheckDelay = [&](int index) -> PresentFrame {
 		const auto frame = getFrame(index);
@@ -669,6 +752,10 @@ crl::time VideoTrack::Shared::nextFrameDisplayTime() const {
 		const auto next = (counter + 1) % (2 * kFramesCount);
 		const auto index = next / 2;
 		const auto frame = getFrame(index);
+		if (frame->displayed != kTimeUnknown) {
+			// Frame already displayed, but not yet shown.
+			return kFrameDisplayTimeAlreadyDone;
+		}
 		Assert(IsRasterized(frame));
 		Assert(frame->display != kTimeUnknown);
 
@@ -689,33 +776,88 @@ crl::time VideoTrack::Shared::nextFrameDisplayTime() const {
 }
 
 crl::time VideoTrack::Shared::markFrameDisplayed(crl::time now) {
-	const auto markAndJump = [&](int counter) {
+	const auto mark = [&](int counter) {
 		const auto next = (counter + 1) % (2 * kFramesCount);
 		const auto index = next / 2;
 		const auto frame = getFrame(index);
 		Assert(frame->position != kTimeUnknown);
-		Assert(frame->displayed == kTimeUnknown);
-
-		frame->displayed = now;
-		_counter.store(
-			next,
-			std::memory_order_release);
+		if (frame->displayed == kTimeUnknown) {
+			frame->displayed = now;
+		}
 		return frame->position;
 	};
 
 	switch (counter()) {
 	case 0: Unexpected("Value 0 in VideoTrack::Shared::markFrameDisplayed.");
-	case 1: return markAndJump(1);
+	case 1: return mark(1);
 	case 2: Unexpected("Value 2 in VideoTrack::Shared::markFrameDisplayed.");
-	case 3: return markAndJump(3);
+	case 3: return mark(3);
 	case 4: Unexpected("Value 4 in VideoTrack::Shared::markFrameDisplayed.");
-	case 5: return markAndJump(5);
+	case 5: return mark(5);
 	case 6: Unexpected("Value 6 in VideoTrack::Shared::markFrameDisplayed.");
-	case 7: return markAndJump(7);
+	case 7: return mark(7);
 	}
 	Unexpected("Counter value in VideoTrack::Shared::markFrameDisplayed.");
 }
 
+void VideoTrack::Shared::addTimelineDelay(crl::time delayed) {
+	if (!delayed) {
+		return;
+	}
+	const auto recountCurrentFrame = [&](int counter) {
+		_delay += delayed;
+		//const auto next = (counter + 1) % (2 * kFramesCount);
+		//const auto index = next / 2;
+		//const auto frame = getFrame(index);
+		//if (frame->displayed != kTimeUnknown) {
+		//	// Frame already displayed.
+		//	return;
+		//}
+		//Assert(IsRasterized(frame));
+		//Assert(frame->display != kTimeUnknown);
+		//frame->display = countFrameDisplayTime(frame->index);
+	};
+
+	switch (counter()) {
+	case 0: Unexpected("Value 0 in VideoTrack::Shared::addTimelineDelay.");
+	case 1: return recountCurrentFrame(1);
+	case 2: Unexpected("Value 2 in VideoTrack::Shared::addTimelineDelay.");
+	case 3: return recountCurrentFrame(3);
+	case 4: Unexpected("Value 4 in VideoTrack::Shared::addTimelineDelay.");
+	case 5: return recountCurrentFrame(5);
+	case 6: Unexpected("Value 6 in VideoTrack::Shared::addTimelineDelay.");
+	case 7: return recountCurrentFrame(7);
+	}
+	Unexpected("Counter value in VideoTrack::Shared::addTimelineDelay.");
+}
+
+bool VideoTrack::Shared::markFrameShown() {
+	const auto jump = [&](int counter) {
+		const auto next = (counter + 1) % (2 * kFramesCount);
+		const auto index = next / 2;
+		const auto frame = getFrame(index);
+		if (frame->displayed == kTimeUnknown) {
+			return false;
+		}
+		_counter.store(
+			next,
+			std::memory_order_release);
+		return true;
+	};
+
+	switch (counter()) {
+	case 0: return false;
+	case 1: return jump(1);
+	case 2: return false;
+	case 3: return jump(3);
+	case 4: return false;
+	case 5: return jump(5);
+	case 6: return false;
+	case 7: return jump(7);
+	}
+	Unexpected("Counter value in VideoTrack::Shared::markFrameShown.");
+}
+
 not_null<VideoTrack::Frame*> VideoTrack::Shared::frameForPaint() {
 	const auto result = getFrame(counter() / 2);
 	Assert(!result->original.isNull());
@@ -734,7 +876,7 @@ VideoTrack::VideoTrack(
 : _streamIndex(stream.index)
 , _streamTimeBase(stream.timeBase)
 , _streamDuration(stream.duration)
-//, _streamRotation(stream.rotation)
+, _streamRotation(stream.rotation)
 //, _streamAspect(stream.aspect)
 , _shared(std::make_unique<Shared>())
 , _wrapped(
@@ -758,11 +900,11 @@ crl::time VideoTrack::streamDuration() const {
 	return _streamDuration;
 }
 
-void VideoTrack::process(FFmpeg::Packet &&packet) {
+void VideoTrack::process(std::vector<FFmpeg::Packet> &&packets) {
 	_wrapped.with([
-		packet = std::move(packet)
+		packets = std::move(packets)
 	](Implementation &unwrapped) mutable {
-		unwrapped.process(std::move(packet));
+		unwrapped.process(std::move(packets));
 	});
 }
 
@@ -787,47 +929,119 @@ void VideoTrack::setSpeed(float64 speed) {
 	});
 }
 
+void VideoTrack::setWaitForMarkAsShown(bool wait) {
+	_wrapped.with([=](Implementation &unwrapped) {
+		unwrapped.setWaitForMarkAsShown(wait);
+	});
+}
+
 crl::time VideoTrack::nextFrameDisplayTime() const {
 	return _shared->nextFrameDisplayTime();
 }
 
 crl::time VideoTrack::markFrameDisplayed(crl::time now) {
 	const auto result = _shared->markFrameDisplayed(now);
-	_wrapped.with([](Implementation &unwrapped) {
-		unwrapped.frameDisplayed();
-	});
 
 	Ensures(result != kTimeUnknown);
 	return result;
 }
 
-QImage VideoTrack::frame(const FrameRequest &request) {
+void VideoTrack::addTimelineDelay(crl::time delayed) {
+	_shared->addTimelineDelay(delayed);
+	//if (!delayed) {
+	//	return;
+	//}
+	//_wrapped.with([=](Implementation &unwrapped) mutable {
+	//	unwrapped.addTimelineDelay(delayed);
+	//});
+}
+
+bool VideoTrack::markFrameShown() {
+	if (!_shared->markFrameShown()) {
+		return false;
+	}
+	_wrapped.with([](Implementation &unwrapped) {
+		unwrapped.frameShown();
+	});
+	return true;
+}
+
+QImage VideoTrack::frame(
+		const FrameRequest &request,
+		const Instance *instance) {
 	const auto frame = _shared->frameForPaint();
-	const auto changed = (frame->request != request)
-		&& (request.strict || !frame->request.strict);
+	const auto i = frame->prepared.find(instance);
+	const auto none = (i == frame->prepared.end());
+	const auto preparedFor = frame->prepared.empty()
+		? FrameRequest::NonStrict()
+		: (none ? frame->prepared.begin() : i)->second.request;
+	const auto changed = !preparedFor.goodFor(request);
+	const auto useRequest = changed ? request : preparedFor;
 	if (changed) {
-		frame->request = request;
 		_wrapped.with([=](Implementation &unwrapped) {
-			unwrapped.updateFrameRequest(request);
+			unwrapped.updateFrameRequest(instance, useRequest);
 		});
 	}
-	return PrepareFrameByRequest(frame, !changed);
+	if (GoodForRequest(frame->original, _streamRotation, useRequest)) {
+		return frame->original;
+	} else if (changed || none || i->second.image.isNull()) {
+		const auto j = none
+			? frame->prepared.emplace(instance, useRequest).first
+			: i;
+		if (changed && !none) {
+			i->second.request = useRequest;
+		}
+		if (frame->prepared.size() > 1) {
+			for (auto &[alreadyInstance, prepared] : frame->prepared) {
+				if (alreadyInstance != instance
+					&& prepared.request == useRequest
+					&& !prepared.image.isNull()) {
+					return prepared.image;
+				}
+			}
+		}
+		j->second.image = PrepareByRequest(
+			frame->original,
+			_streamRotation,
+			useRequest,
+			std::move(j->second.image));
+		return j->second.image;
+	}
+	return i->second.image;
+}
+
+void VideoTrack::unregisterInstance(not_null<const Instance*> instance) {
+	_wrapped.with([=](Implementation &unwrapped) {
+		unwrapped.removeFrameRequest(instance);
+	});
 }
 
-QImage VideoTrack::PrepareFrameByRequest(
+void VideoTrack::PrepareFrameByRequests(
 		not_null<Frame*> frame,
-		bool useExistingPrepared) {
+		int rotation) {
 	Expects(!frame->original.isNull());
 
-	if (GoodForRequest(frame->original, frame->request)) {
-		return frame->original;
-	} else if (frame->prepared.isNull() || !useExistingPrepared) {
-		frame->prepared = PrepareByRequest(
-			frame->original,
-			frame->request,
-			std::move(frame->prepared));
+	const auto begin = frame->prepared.begin();
+	const auto end = frame->prepared.end();
+	for (auto i = begin; i != end; ++i) {
+		auto &prepared = i->second;
+		if (!GoodForRequest(frame->original, rotation, prepared.request)) {
+			auto j = begin;
+			for (; j != i; ++j) {
+				if (j->second.request == prepared.request) {
+					prepared.image = QImage();
+					break;
+				}
+			}
+			if (j == i) {
+				prepared.image = PrepareByRequest(
+					frame->original,
+					rotation,
+					prepared.request,
+					std::move(prepared.image));
+			}
+		}
 	}
-	return frame->prepared;
 }
 
 bool VideoTrack::IsDecoded(not_null<const Frame*> frame) {
diff --git a/Telegram/SourceFiles/media/streaming/media_streaming_video_track.h b/Telegram/SourceFiles/media/streaming/media_streaming_video_track.h
index ff704f817..434e061ee 100644
--- a/Telegram/SourceFiles/media/streaming/media_streaming_video_track.h
+++ b/Telegram/SourceFiles/media/streaming/media_streaming_video_track.h
@@ -14,7 +14,11 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 namespace Media {
 namespace Streaming {
 
+constexpr auto kFrameDisplayTimeAlreadyDone
+	= std::numeric_limits<crl::time>::max();
+
 class VideoTrackObject;
+class Instance;
 
 class VideoTrack final {
 public:
@@ -33,7 +37,7 @@ public:
 	[[nodiscard]] crl::time streamDuration() const;
 
 	// Called from the same unspecified thread.
-	void process(FFmpeg::Packet &&packet);
+	void process(std::vector<FFmpeg::Packet> &&packets);
 	void waitForData();
 
 	// Called from the main thread.
@@ -43,12 +47,18 @@ public:
 
 	// Called from the main thread.
 	void setSpeed(float64 speed);
+	void setWaitForMarkAsShown(bool wait);
 
 	// Called from the main thread.
 	// Returns the position of the displayed frame.
 	[[nodiscard]] crl::time markFrameDisplayed(crl::time now);
+	void addTimelineDelay(crl::time delayed);
+	bool markFrameShown();
 	[[nodiscard]] crl::time nextFrameDisplayTime() const;
-	[[nodiscard]] QImage frame(const FrameRequest &request);
+	[[nodiscard]] QImage frame(
+		const FrameRequest &request,
+		const Instance *instance);
+	void unregisterInstance(not_null<const Instance*> instance);
 	[[nodiscard]] rpl::producer<> checkNextFrame() const;
 	[[nodiscard]] rpl::producer<> waitingForData() const;
 
@@ -58,6 +68,13 @@ public:
 private:
 	friend class VideoTrackObject;
 
+	struct Prepared {
+		Prepared(const FrameRequest &request) : request(request) {
+		}
+
+		FrameRequest request = FrameRequest::NonStrict();
+		QImage image;
+	};
 	struct Frame {
 		FFmpeg::FramePointer decoded = FFmpeg::MakeFramePointer();
 		QImage original;
@@ -65,8 +82,7 @@ private:
 		crl::time displayed = kTimeUnknown;
 		crl::time display = kTimeUnknown;
 
-		FrameRequest request = FrameRequest::NonStrict();
-		QImage prepared;
+		base::flat_map<const Instance*, Prepared> prepared;
 	};
 
 	class Shared {
@@ -79,6 +95,7 @@ private:
 		struct PresentFrame {
 			crl::time displayPosition = kTimeUnknown;
 			crl::time nextCheckDelay = 0;
+			crl::time addedWorldTimeDelay = 0;
 		};
 
 		// Called from the wrapped object queue.
@@ -101,6 +118,8 @@ private:
 		// Called from the main thread.
 		// Returns the position of the displayed frame.
 		[[nodiscard]] crl::time markFrameDisplayed(crl::time now);
+		void addTimelineDelay(crl::time delayed);
+		bool markFrameShown();
 		[[nodiscard]] crl::time nextFrameDisplayTime() const;
 		[[nodiscard]] not_null<Frame*> frameForPaint();
 
@@ -115,11 +134,13 @@ private:
 		static constexpr auto kFramesCount = 4;
 		std::array<Frame, kFramesCount> _frames;
 
+		// (_counter % 2) == 1 main thread can write _delay.
+		// (_counter % 2) == 0 crl::queue can read _delay.
+		crl::time _delay = kTimeUnknown;
+
 	};
 
-	static QImage PrepareFrameByRequest(
-		not_null<Frame*> frame,
-		bool useExistingPrepared = false);
+	static void PrepareFrameByRequests(not_null<Frame*> frame, int rotation);
 	[[nodiscard]] static bool IsDecoded(not_null<const Frame*> frame);
 	[[nodiscard]] static bool IsRasterized(not_null<const Frame*> frame);
 	[[nodiscard]] static bool IsStale(
@@ -129,7 +150,7 @@ private:
 	const int _streamIndex = 0;
 	const AVRational _streamTimeBase;
 	const crl::time _streamDuration = 0;
-	//const int _streamRotation = 0;
+	const int _streamRotation = 0;
 	//AVRational _streamAspect = kNormalAspect;
 	std::unique_ptr<Shared> _shared;
 
diff --git a/Telegram/SourceFiles/media/view/media_view_overlay_widget.cpp b/Telegram/SourceFiles/media/view/media_view_overlay_widget.cpp
index 79572560c..3cfce212e 100644
--- a/Telegram/SourceFiles/media/view/media_view_overlay_widget.cpp
+++ b/Telegram/SourceFiles/media/view/media_view_overlay_widget.cpp
@@ -26,16 +26,18 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "media/audio/media_audio.h"
 #include "media/view/media_view_playback_controls.h"
 #include "media/view/media_view_group_thumbs.h"
+#include "media/streaming/media_streaming_instance.h"
 #include "media/streaming/media_streaming_player.h"
-#include "media/streaming/media_streaming_reader.h"
 #include "media/player/media_player_instance.h"
 #include "history/history.h"
 #include "history/history_message.h"
+#include "history/view/media/history_view_media.h"
 #include "data/data_media_types.h"
 #include "data/data_session.h"
 #include "data/data_channel.h"
 #include "data/data_chat.h"
 #include "data/data_user.h"
+#include "data/data_file_origin.h"
 #include "window/themes/window_theme_preview.h"
 #include "window/window_peer_menu.h"
 #include "window/window_session_controller.h"
@@ -65,12 +67,10 @@ namespace Media {
 namespace View {
 namespace {
 
-constexpr auto kGoodThumbnailQuality = 87;
-constexpr auto kWaitingFastDuration = crl::time(200);
-constexpr auto kWaitingShowDuration = crl::time(500);
-constexpr auto kWaitingShowDelay = crl::time(500);
 constexpr auto kPreloadCount = 4;
 
+constexpr auto kOverlayLoaderPriority = 2;
+
 // macOS OpenGL renderer fails to render larger texture
 // even though it reports that max texture size is 16384.
 constexpr auto kMaxDisplayImageSize = 4096;
@@ -187,20 +187,15 @@ struct OverlayWidget::Collage {
 struct OverlayWidget::Streamed {
 	template <typename Callback>
 	Streamed(
-		not_null<Data::Session*> owner,
-		std::shared_ptr<Streaming::Reader> reader,
+		not_null<DocumentData*> document,
+		Data::FileOrigin origin,
 		QWidget *controlsParent,
 		not_null<PlaybackControls::Delegate*> controlsDelegate,
 		Callback &&loadingCallback);
 
-	Streaming::Player player;
-	Streaming::Information info;
+	Streaming::Instance instance;
 	PlaybackControls controls;
 
-	bool waiting = false;
-	Ui::InfiniteRadialAnimation radial;
-	Ui::Animations::Simple fading;
-	base::Timer timer;
 	QImage frameForDirectPaint;
 
 	bool withSound = false;
@@ -210,16 +205,13 @@ struct OverlayWidget::Streamed {
 
 template <typename Callback>
 OverlayWidget::Streamed::Streamed(
-	not_null<Data::Session*> owner,
-	std::shared_ptr<Streaming::Reader> reader,
+	not_null<DocumentData*> document,
+	Data::FileOrigin origin,
 	QWidget *controlsParent,
 	not_null<PlaybackControls::Delegate*> controlsDelegate,
 	Callback &&loadingCallback)
-: player(owner, std::move(reader))
-, controls(controlsParent, controlsDelegate)
-, radial(
-	std::forward<Callback>(loadingCallback),
-	st::mediaviewStreamingRadial) {
+: instance(document, origin, std::forward<Callback>(loadingCallback))
+, controls(controlsParent, controlsDelegate) {
 }
 
 OverlayWidget::OverlayWidget()
@@ -367,13 +359,13 @@ void OverlayWidget::moveToScreen(bool force) {
 }
 
 bool OverlayWidget::videoShown() const {
-	return _streamed && !_streamed->info.video.cover.isNull();
+	return _streamed && !_streamed->instance.info().video.cover.isNull();
 }
 
 QSize OverlayWidget::videoSize() const {
 	Expects(videoShown());
 
-	return _streamed->info.video.size;
+	return _streamed->instance.info().video.size;
 }
 
 bool OverlayWidget::videoIsGifv() const {
@@ -387,9 +379,9 @@ QImage OverlayWidget::videoFrame() const {
 	//request.radius = (_doc && _doc->isVideoMessage())
 	//	? ImageRoundRadius::Ellipse
 	//	: ImageRoundRadius::None;
-	return _streamed->player.ready()
-		? _streamed->player.frame(request)
-		: _streamed->info.video.cover;
+	return _streamed->instance.player().ready()
+		? _streamed->instance.frame(request)
+		: _streamed->instance.info().video.cover;
 }
 
 QImage OverlayWidget::videoFrameForDirectPaint() const {
@@ -443,7 +435,12 @@ bool OverlayWidget::documentBubbleShown() const {
 			&& _current.isNull());
 }
 
-void OverlayWidget::clearStreaming() {
+void OverlayWidget::clearStreaming(bool savePosition) {
+	if (_streamed && _doc && savePosition) {
+		Media::Player::SaveLastPlaybackPosition(
+			_doc,
+			_streamed->instance.player().prepareLegacyState());
+	}
 	_fullScreenVideo = false;
 	_streamed = nullptr;
 }
@@ -1633,10 +1630,18 @@ void OverlayWidget::refreshCaption(HistoryItem *item) {
 		}
 		return false;
 	}();
+
+	using namespace HistoryView;
 	_caption = Ui::Text::String(st::msgMinWidth);
+	const auto duration = (_streamed && !videoIsGifv())
+		? _doc->getDuration()
+		: 0;
+	const auto base = duration
+		? DocumentTimestampLinkBase(_doc, item->fullId())
+		: QString();
 	_caption.setMarkedText(
 		st::mediaviewCaptionStyle,
-		caption,
+		AddTimestampLinks(caption, duration, base),
 		Ui::ItemTextOptions(item));
 }
 
@@ -1803,7 +1808,6 @@ void OverlayWidget::displayPhoto(not_null<PhotoData*> photo, HistoryItem *item)
 
 	_zoom = 0;
 	_zoomToScreen = 0;
-	Auth().downloader().clearPriorities();
 	_blurred = true;
 	_current = QPixmap();
 	_down = OverNone;
@@ -1846,7 +1850,7 @@ void OverlayWidget::displayDocument(
 	}
 	_fullScreenVideo = false;
 	_current = QPixmap();
-	clearStreaming();
+	clearStreaming(_doc != doc);
 	destroyThemePreview();
 	_doc = doc;
 	_themeCloudData = cloud;
@@ -1854,7 +1858,6 @@ void OverlayWidget::displayDocument(
 	_radial.stop();
 
 	refreshMediaViewer();
-	refreshCaption(item);
 	if (_doc) {
 		if (_doc->sticker()) {
 			if (const auto image = _doc->getStickerLarge()) {
@@ -1866,15 +1869,15 @@ void OverlayWidget::displayDocument(
 					_doc->dimensions.height());
 			}
 		} else {
-			_doc->automaticLoad(fileOrigin(), item);
-
-			if (_doc->canBePlayed()) {
-				initStreaming();
+			if (_doc->canBePlayed() && initStreaming()) {
 			} else if (_doc->isVideoFile()) {
+				_doc->automaticLoad(fileOrigin(), item);
 				initStreamingThumbnail();
 			} else if (_doc->isTheme()) {
+				_doc->automaticLoad(fileOrigin(), item);
 				initThemePreview();
 			} else {
+				_doc->automaticLoad(fileOrigin(), item);
 				auto &location = _doc->location(true);
 				if (location.accessEnable()) {
 					const auto &path = location.name();
@@ -1886,6 +1889,7 @@ void OverlayWidget::displayDocument(
 			}
 		}
 	}
+	refreshCaption(item);
 
 	_docIconRect = QRect((width() - st::mediaviewFileIconSize) / 2, (height() - st::mediaviewFileIconSize) / 2, st::mediaviewFileIconSize, st::mediaviewFileIconSize);
 	if (documentBubbleShown()) {
@@ -1996,31 +2000,42 @@ void OverlayWidget::displayFinished() {
 	}
 }
 
-void OverlayWidget::initStreaming() {
+bool OverlayWidget::initStreaming() {
 	Expects(_doc != nullptr);
 	Expects(_doc->canBePlayed());
 
 	if (_streamed) {
-		return;
+		return true;
 	}
 	initStreamingThumbnail();
-	createStreamingObjects();
+	if (!createStreamingObjects()) {
+		_doc->setInappPlaybackFailed();
+		return false;
+	}
 
 	Core::App().updateNonIdle();
 
-	_streamed->player.updates(
+	_streamed->instance.player().updates(
 	) | rpl::start_with_next_error([=](Streaming::Update &&update) {
 		handleStreamingUpdate(std::move(update));
 	}, [=](Streaming::Error &&error) {
 		handleStreamingError(std::move(error));
-	}, _streamed->player.lifetime());
+	}, _streamed->instance.lifetime());
+
+	startStreamingPlayer();
+	return true;
+}
 
-	_streamed->player.fullInCache(
-	) | rpl::start_with_next([=](bool fullInCache) {
-		_doc->setLoadedInMediaCache(fullInCache);
-	}, _streamed->player.lifetime());
+void OverlayWidget::startStreamingPlayer() {
+	Expects(_streamed != nullptr);
 
-	restartAtSeekPosition(0);
+	if (!_streamed->withSound && _streamed->instance.player().playing()) {
+		return;
+	}
+	const auto position = _doc
+		? _doc->session().settings().mediaLastPlaybackPosition(_doc->id)
+		: 0;
+	restartAtSeekPosition(position);
 }
 
 void OverlayWidget::initStreamingThumbnail() {
@@ -2063,8 +2078,6 @@ void OverlayWidget::initStreamingThumbnail() {
 }
 
 void OverlayWidget::streamingReady(Streaming::Information &&info) {
-	_streamed->info = std::move(info);
-	validateStreamedGoodThumbnail();
 	if (videoShown()) {
 		const auto contentSize = style::ConvertScale(videoSize());
 		if (contentSize != QSize(_width, _height)) {
@@ -2075,16 +2088,21 @@ void OverlayWidget::streamingReady(Streaming::Information &&info) {
 		}
 	}
 	this->update(contentRect());
-	playbackWaitingChange(false);
 }
 
-void OverlayWidget::createStreamingObjects() {
+bool OverlayWidget::createStreamingObjects() {
 	_streamed = std::make_unique<Streamed>(
-		&_doc->owner(),
-		_doc->owner().documentStreamedReader(_doc, fileOrigin()),
+		_doc,
+		fileOrigin(),
 		this,
 		static_cast<PlaybackControls::Delegate*>(this),
 		[=] { waitingAnimationCallback(); });
+	if (!_streamed->instance.valid()) {
+		_streamed = nullptr;
+		return false;
+	}
+	_streamed->instance.setPriority(kOverlayLoaderPriority);
+	_streamed->instance.lockPlayer();
 	_streamed->withSound = _doc->isAudioFile()
 		|| _doc->isVideoFile()
 		|| _doc->isVoiceMessage()
@@ -2096,84 +2114,44 @@ void OverlayWidget::createStreamingObjects() {
 		refreshClipControllerGeometry();
 		_streamed->controls.show();
 	}
+	return true;
 }
 
 QImage OverlayWidget::transformVideoFrame(QImage frame) const {
 	Expects(videoShown());
 
-	if (_streamed->info.video.rotation != 0) {
+	if (_streamed->instance.info().video.rotation != 0) {
 		auto transform = QTransform();
-		transform.rotate(_streamed->info.video.rotation);
+		transform.rotate(_streamed->instance.info().video.rotation);
 		frame = frame.transformed(transform);
 	}
-	if (frame.size() != _streamed->info.video.size) {
+	if (frame.size() != _streamed->instance.info().video.size) {
 		frame = frame.scaled(
-			_streamed->info.video.size,
+			_streamed->instance.info().video.size,
 			Qt::IgnoreAspectRatio,
 			Qt::SmoothTransformation);
 	}
 	return frame;
 }
 
-void OverlayWidget::validateStreamedGoodThumbnail() {
-	Expects(_streamed != nullptr);
-	Expects(_doc != nullptr);
-
-	const auto good = _doc->goodThumbnail();
-	if (!videoShown() || (good && good->loaded()) || _doc->uploading()) {
-		return;
-	}
-	auto image = transformVideoFrame(_streamed->info.video.cover);
-	auto bytes = QByteArray();
-	{
-		auto buffer = QBuffer(&bytes);
-		image.save(&buffer, "JPG", kGoodThumbnailQuality);
-	}
-	const auto length = bytes.size();
-	if (!length || length > Storage::kMaxFileInMemory) {
-		LOG(("App Error: Bad thumbnail data for saving to cache."));
-	} else if (_doc->uploading()) {
-		_doc->setGoodThumbnailOnUpload(
-			std::move(image),
-			std::move(bytes));
-	} else {
-		_doc->owner().cache().putIfEmpty(
-			_doc->goodThumbnailCacheKey(),
-			Storage::Cache::Database::TaggedValue(
-				std::move(bytes),
-				Data::kImageCacheTag));
-		_doc->refreshGoodThumbnail();
-	}
-}
-
 void OverlayWidget::handleStreamingUpdate(Streaming::Update &&update) {
 	using namespace Streaming;
 
 	update.data.match([&](Information &update) {
 		streamingReady(std::move(update));
 	}, [&](const PreloadedVideo &update) {
-		_streamed->info.video.state.receivedTill = update.till;
 		updatePlaybackState();
 	}, [&](const UpdateVideo &update) {
-		_streamed->info.video.state.position = update.position;
 		this->update(contentRect());
 		Core::App().updateNonIdle();
 		updatePlaybackState();
 	}, [&](const PreloadedAudio &update) {
-		_streamed->info.audio.state.receivedTill = update.till;
 		updatePlaybackState();
 	}, [&](const UpdateAudio &update) {
-		_streamed->info.audio.state.position = update.position;
 		updatePlaybackState();
-	}, [&](const WaitingForData &update) {
-		playbackWaitingChange(update.waiting);
+	}, [&](WaitingForData) {
 	}, [&](MutedByOther) {
 	}, [&](Finished) {
-		const auto finishTrack = [](Streaming::TrackState &state) {
-			state.position = state.receivedTill = state.duration;
-		};
-		finishTrack(_streamed->info.audio.state);
-		finishTrack(_streamed->info.video.state);
 		updatePlaybackState();
 	});
 }
@@ -2187,47 +2165,10 @@ void OverlayWidget::handleStreamingError(Streaming::Error &&error) {
 	if (!_doc->canBePlayed()) {
 		redisplayContent();
 	} else {
-		playbackWaitingChange(false);
 		updatePlaybackState();
 	}
 }
 
-void OverlayWidget::playbackWaitingChange(bool waiting) {
-	Expects(_streamed != nullptr);
-
-	if (_streamed->waiting == waiting) {
-		return;
-	}
-	_streamed->waiting = waiting;
-	const auto fade = [=](crl::time duration) {
-		if (!_streamed->radial.animating()) {
-			_streamed->radial.start(
-				st::defaultInfiniteRadialAnimation.sineDuration);
-		}
-		_streamed->fading.start(
-			[=] { update(radialRect()); },
-			_streamed->waiting ? 0. : 1.,
-			_streamed->waiting ? 1. : 0.,
-			duration);
-	};
-	if (waiting) {
-		if (_streamed->radial.animating()) {
-			_streamed->timer.cancel();
-			fade(kWaitingFastDuration);
-		} else {
-			_streamed->timer.callOnce(kWaitingShowDelay);
-			_streamed->timer.setCallback([=] {
-				fade(kWaitingShowDuration);
-			});
-		}
-	} else {
-		_streamed->timer.cancel();
-		if (_streamed->radial.animating()) {
-			fade(kWaitingFastDuration);
-		}
-	}
-}
-
 void OverlayWidget::initThemePreview() {
 	using namespace Window::Theme;
 
@@ -2365,18 +2306,20 @@ void OverlayWidget::playbackPauseResume() {
 	Expects(_streamed != nullptr);
 
 	_streamed->resumeOnCallEnd = false;
-	if (_streamed->player.failed()) {
+	if (_streamed->instance.player().failed()) {
 		clearStreaming();
-		initStreaming();
-	} else if (_streamed->player.finished()) {
+		if (!_doc->canBePlayed() || !initStreaming()) {
+			redisplayContent();
+		}
+	} else if (_streamed->instance.player().finished()) {
 		_streamingStartPaused = false;
 		restartAtSeekPosition(0);
-	} else if (_streamed->player.paused()) {
-		_streamed->player.resume();
+	} else if (_streamed->instance.player().paused()) {
+		_streamed->instance.resume();
 		updatePlaybackState();
 		playbackPauseMusic();
 	} else {
-		_streamed->player.pause();
+		_streamed->instance.pause();
 		updatePlaybackState();
 	}
 }
@@ -2386,7 +2329,7 @@ void OverlayWidget::restartAtSeekPosition(crl::time position) {
 	Expects(_doc != nullptr);
 
 	if (videoShown()) {
-		_streamed->info.video.cover = videoFrame();
+		_streamed->instance.saveFrameToCover();
 		_current = Images::PixmapFast(transformVideoFrame(videoFrame()));
 		update(contentRect());
 	}
@@ -2397,25 +2340,22 @@ void OverlayWidget::restartAtSeekPosition(crl::time position) {
 		options.mode = Streaming::Mode::Video;
 		options.loop = true;
 	}
-	_streamed->player.play(options);
+	_streamed->instance.play(options);
 	if (_streamingStartPaused) {
-		_streamed->player.pause();
+		_streamed->instance.pause();
 	} else {
 		playbackPauseMusic();
 	}
 	_streamed->pausedBySeek = false;
 
-	_streamed->info.audio.state.position
-		= _streamed->info.video.state.position
-		= position;
 	updatePlaybackState();
-	playbackWaitingChange(true);
 }
 
 void OverlayWidget::playbackControlsSeekProgress(crl::time position) {
 	Expects(_streamed != nullptr);
 
-	if (!_streamed->player.paused() && !_streamed->player.finished()) {
+	if (!_streamed->instance.player().paused()
+		&& !_streamed->instance.player().finished()) {
 		_streamed->pausedBySeek = true;
 		playbackControlsPause();
 	}
@@ -2425,7 +2365,7 @@ void OverlayWidget::playbackControlsSeekFinished(crl::time position) {
 	Expects(_streamed != nullptr);
 
 	_streamingStartPaused = !_streamed->pausedBySeek
-		&& !_streamed->player.finished();
+		&& !_streamed->instance.player().finished();
 	restartAtSeekPosition(position);
 }
 
@@ -2463,11 +2403,12 @@ void OverlayWidget::playbackToggleFullScreen() {
 void OverlayWidget::playbackPauseOnCall() {
 	Expects(_streamed != nullptr);
 
-	if (_streamed->player.finished() || _streamed->player.paused()) {
+	if (_streamed->instance.player().finished()
+		|| _streamed->instance.player().paused()) {
 		return;
 	}
 	_streamed->resumeOnCallEnd = true;
-	_streamed->player.pause();
+	_streamed->instance.pause();
 	updatePlaybackState();
 }
 
@@ -2476,7 +2417,7 @@ void OverlayWidget::playbackResumeOnCall() {
 
 	if (_streamed->resumeOnCallEnd) {
 		_streamed->resumeOnCallEnd = false;
-		_streamed->player.resume();
+		_streamed->instance.resume();
 		updatePlaybackState();
 		playbackPauseMusic();
 	}
@@ -2498,7 +2439,7 @@ void OverlayWidget::updatePlaybackState() {
 	if (videoIsGifv()) {
 		return;
 	}
-	const auto state = _streamed->player.prepareLegacyState();
+	const auto state = _streamed->instance.player().prepareLegacyState();
 	if (state.position != kTimeUnknown && state.length != kTimeUnknown) {
 		_streamed->controls.updatePlayback(state);
 	}
@@ -2604,7 +2545,7 @@ void OverlayWidget::paintEvent(QPaintEvent *e) {
 				}
 				float64 progress = (hidingDt >= 0) ? (hidingDt / st::mediaviewSaveMsgHiding) : (dt / st::mediaviewSaveMsgShowing);
 				_saveMsgOpacity.update(qMin(progress, 1.), anim::linear);
-                if (_saveMsgOpacity.current() > 0) {
+				if (_saveMsgOpacity.current() > 0) {
 					p.setOpacity(_saveMsgOpacity.current());
 					App::roundRect(p, _saveMsg, st::mediaviewSaveMsgBg, MediaviewSaveCorners);
 					st::mediaviewSaveMsgCheck.paint(p, _saveMsg.topLeft() + st::mediaviewSaveMsgCheckPos, width());
@@ -2616,7 +2557,7 @@ void OverlayWidget::paintEvent(QPaintEvent *e) {
 					p.setOpacity(1);
 				}
 				if (!_blurred) {
-                    auto nextFrame = (dt < st::mediaviewSaveMsgShowing || hidingDt >= 0) ? int(AnimationTimerDelta) : (st::mediaviewSaveMsgShowing + st::mediaviewSaveMsgShown + 1 - dt);
+					auto nextFrame = (dt < st::mediaviewSaveMsgShowing || hidingDt >= 0) ? int(AnimationTimerDelta) : (st::mediaviewSaveMsgShowing + st::mediaviewSaveMsgShown + 1 - dt);
 					_saveMsgUpdater.start(nextFrame);
 				}
 			} else {
@@ -2801,19 +2742,22 @@ void OverlayWidget::paintEvent(QPaintEvent *e) {
 }
 
 void OverlayWidget::checkGroupThumbsAnimation() {
-	if (_groupThumbs && (!_streamed || _streamed->player.ready())) {
+	if (_groupThumbs
+		&& (!_streamed || _streamed->instance.player().ready())) {
 		_groupThumbs->checkForAnimationStart();
 	}
 }
 
 void OverlayWidget::paintTransformedVideoFrame(Painter &p) {
+	Expects(_streamed != nullptr);
+
 	const auto rect = contentRect();
 	const auto image = videoFrameForDirectPaint();
 	//if (_fullScreenVideo) {
 	//	const auto fill = rect.intersected(this->rect());
 	//	PaintImageProfile(p, image, rect, fill);
 	//} else {
-	const auto rotation = _streamed->info.video.rotation;
+	const auto rotation = _streamed->instance.info().video.rotation;
 	const auto rotated = [](QRect rect, int rotation) {
 		switch (rotation) {
 		case 0: return rect;
@@ -2845,6 +2789,9 @@ void OverlayWidget::paintTransformedVideoFrame(Painter &p) {
 	if (rotation) {
 		p.restore();
 	}
+	if (_streamed->instance.player().ready()) {
+		_streamed->instance.markFrameShown();
+	}
 	//}
 }
 
@@ -2853,13 +2800,7 @@ void OverlayWidget::paintRadialLoading(
 		bool radial,
 		float64 radialOpacity) {
 	if (_streamed) {
-		if (!_streamed->radial.animating()) {
-			return;
-		}
-		if (!_streamed->fading.animating() && !_streamed->waiting) {
-			if (!_streamed->waiting) {
-				_streamed->radial.stop(anim::type::instant);
-			}
+		if (!_streamed->instance.waitingShown()) {
 			return;
 		}
 	} else if (!radial && (!_doc || _doc->loaded())) {
@@ -2912,9 +2853,16 @@ void OverlayWidget::paintRadialLoadingContent(
 
 	if (_streamed) {
 		paintBg(
-			_streamed->fading.value(_streamed->waiting ? 1. : 0.),
+			_streamed->instance.waitingOpacity(),
 			st::radialBg);
-		_streamed->radial.draw(p, arc.topLeft(), arc.size(), width());
+		Ui::InfiniteRadialAnimation::Draw(
+			p,
+			_streamed->instance.waitingState(),
+			arc.topLeft(),
+			arc.size(),
+			width(),
+			st::radialFg,
+			st::radialLine);
 		return;
 	}
 	if (_photo) {
@@ -3288,7 +3236,9 @@ void OverlayWidget::preloadData(int delta) {
 				image->load(fileOrigin());
 			} else {
 				(*document)->loadThumbnail(fileOrigin());
-				(*document)->automaticLoad(fileOrigin(), entity.item);
+				if (!(*document)->canBePlayed()) {
+					(*document)->automaticLoad(fileOrigin(), entity.item);
+				}
 			}
 		}
 	}
diff --git a/Telegram/SourceFiles/media/view/media_view_overlay_widget.h b/Telegram/SourceFiles/media/view/media_view_overlay_widget.h
index 7c3152a13..b76fdfc0d 100644
--- a/Telegram/SourceFiles/media/view/media_view_overlay_widget.h
+++ b/Telegram/SourceFiles/media/view/media_view_overlay_widget.h
@@ -178,7 +178,6 @@ private:
 	void playbackPauseOnCall();
 	void playbackResumeOnCall();
 	void playbackPauseMusic();
-	void playbackWaitingChange(bool waiting);
 
 	void updateOver(QPoint mpos);
 	void moveToScreen(bool force = false);
@@ -259,13 +258,13 @@ private:
 	void refreshClipControllerGeometry();
 	void refreshCaptionGeometry();
 
-	void initStreaming();
+	[[nodiscard]] bool initStreaming();
+	void startStreamingPlayer();
 	void initStreamingThumbnail();
 	void streamingReady(Streaming::Information &&info);
-	void createStreamingObjects();
+	[[nodiscard]] bool createStreamingObjects();
 	void handleStreamingUpdate(Streaming::Update &&update);
 	void handleStreamingError(Streaming::Error &&error);
-	void validateStreamedGoodThumbnail();
 
 	void initThemePreview();
 	void destroyThemePreview();
@@ -325,7 +324,7 @@ private:
 	[[nodiscard]] bool documentContentShown() const;
 	[[nodiscard]] bool documentBubbleShown() const;
 	void paintTransformedVideoFrame(Painter &p);
-	void clearStreaming();
+	void clearStreaming(bool savePosition = true);
 
 	QBrush _transparentBrush;
 
diff --git a/Telegram/SourceFiles/media/view/media_view_playback_progress.cpp b/Telegram/SourceFiles/media/view/media_view_playback_progress.cpp
index e09507427..d19f38f1d 100644
--- a/Telegram/SourceFiles/media/view/media_view_playback_progress.cpp
+++ b/Telegram/SourceFiles/media/view/media_view_playback_progress.cpp
@@ -66,7 +66,12 @@ void PlaybackProgress::updateState(
 	const auto animatedPosition = position + (state.frequency * kPlaybackAnimationDurationMs / 1000);
 	const auto animatedProgress = length ? qMax(float64(animatedPosition) / length, 0.) : 0.;
 	if (length != _length || position != _position || wasInLoadingState) {
-		if (auto animated = (length && _length && animatedProgress > value())) {
+		const auto animated = length
+			&& _length
+			&& (animatedProgress > value())
+			&& (position > _position)
+			&& (position < _position + state.frequency);
+		if (animated) {
 			setValue(animatedProgress, animated);
 		} else {
 			setValue(progress, animated);
diff --git a/Telegram/SourceFiles/media/view/mediaview.style b/Telegram/SourceFiles/media/view/mediaview.style
index 0f0a2c8cf..f02e0c957 100644
--- a/Telegram/SourceFiles/media/view/mediaview.style
+++ b/Telegram/SourceFiles/media/view/mediaview.style
@@ -188,11 +188,6 @@ mediaviewGroupWidthMax: 160px;
 mediaviewGroupSkip: 3px;
 mediaviewGroupSkipCurrent: 12px;
 
-mediaviewStreamingRadial: InfiniteRadialAnimation(defaultInfiniteRadialAnimation) {
-	color: radialFg;
-	thickness: radialLine;
-}
-
 themePreviewSize: size(903px, 584px);
 themePreviewBg: windowBg;
 themePreviewOverlayOpacity: 0.8;
diff --git a/Telegram/SourceFiles/mtproto/auth_key.cpp b/Telegram/SourceFiles/mtproto/auth_key.cpp
deleted file mode 100644
index b9ef48800..000000000
--- a/Telegram/SourceFiles/mtproto/auth_key.cpp
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
-This file is part of Telegram Desktop,
-the official desktop application for the Telegram messaging service.
-
-For license and copyright information please follow this link:
-https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
-*/
-#include "mtproto/auth_key.h"
-
-extern "C" {
-#include <openssl/aes.h>
-#include <openssl/modes.h>
-} // extern "C"
-
-namespace MTP {
-
-void AuthKey::prepareAES_oldmtp(const MTPint128 &msgKey, MTPint256 &aesKey, MTPint256 &aesIV, bool send) const {
-	uint32 x = send ? 0 : 8;
-
-	uchar data_a[16 + 32], sha1_a[20];
-	memcpy(data_a, &msgKey, 16);
-	memcpy(data_a + 16, _key.data() + x, 32);
-	hashSha1(data_a, 16 + 32, sha1_a);
-
-	uchar data_b[16 + 16 + 16], sha1_b[20];
-	memcpy(data_b, _key.data() + 32 + x, 16);
-	memcpy(data_b + 16, &msgKey, 16);
-	memcpy(data_b + 32, _key.data() + 48 + x, 16);
-	hashSha1(data_b, 16 + 16 + 16, sha1_b);
-
-	uchar data_c[32 + 16], sha1_c[20];
-	memcpy(data_c, _key.data() + 64 + x, 32);
-	memcpy(data_c + 32, &msgKey, 16);
-	hashSha1(data_c, 32 + 16, sha1_c);
-
-	uchar data_d[16 + 32], sha1_d[20];
-	memcpy(data_d, &msgKey, 16);
-	memcpy(data_d + 16, _key.data() + 96 + x, 32);
-	hashSha1(data_d, 16 + 32, sha1_d);
-
-	auto key = reinterpret_cast<uchar*>(&aesKey);
-	auto iv = reinterpret_cast<uchar*>(&aesIV);
-	memcpy(key, sha1_a, 8);
-	memcpy(key + 8, sha1_b + 8, 12);
-	memcpy(key + 8 + 12, sha1_c + 4, 12);
-	memcpy(iv, sha1_a + 8, 12);
-	memcpy(iv + 12, sha1_b, 8);
-	memcpy(iv + 12 + 8, sha1_c + 16, 4);
-	memcpy(iv + 12 + 8 + 4, sha1_d, 8);
-}
-
-void AuthKey::prepareAES(const MTPint128 &msgKey, MTPint256 &aesKey, MTPint256 &aesIV, bool send) const {
-	uint32 x = send ? 0 : 8;
-
-	uchar data_a[16 + 36], sha256_a[32];
-	memcpy(data_a, &msgKey, 16);
-	memcpy(data_a + 16, _key.data() + x, 36);
-	hashSha256(data_a, 16 + 36, sha256_a);
-
-	uchar data_b[36 + 16], sha256_b[32];
-	memcpy(data_b, _key.data() + 40 + x, 36);
-	memcpy(data_b + 36, &msgKey, 16);
-	hashSha256(data_b, 36 + 16, sha256_b);
-
-	auto key = reinterpret_cast<uchar*>(&aesKey);
-	auto iv = reinterpret_cast<uchar*>(&aesIV);
-	memcpy(key, sha256_a, 8);
-	memcpy(key + 8, sha256_b + 8, 16);
-	memcpy(key + 8 + 16, sha256_a + 24, 8);
-	memcpy(iv, sha256_b, 8);
-	memcpy(iv + 8, sha256_a + 8, 16);
-	memcpy(iv + 8 + 16, sha256_b + 24, 8);
-}
-
-void aesIgeEncryptRaw(const void *src, void *dst, uint32 len, const void *key, const void *iv) {
-	uchar aes_key[32], aes_iv[32];
-	memcpy(aes_key, key, 32);
-	memcpy(aes_iv, iv, 32);
-
-	AES_KEY aes;
-	AES_set_encrypt_key(aes_key, 256, &aes);
-	AES_ige_encrypt(static_cast<const uchar*>(src), static_cast<uchar*>(dst), len, &aes, aes_iv, AES_ENCRYPT);
-}
-
-void aesIgeDecryptRaw(const void *src, void *dst, uint32 len, const void *key, const void *iv) {
-	uchar aes_key[32], aes_iv[32];
-	memcpy(aes_key, key, 32);
-	memcpy(aes_iv, iv, 32);
-
-	AES_KEY aes;
-	AES_set_decrypt_key(aes_key, 256, &aes);
-	AES_ige_encrypt(static_cast<const uchar*>(src), static_cast<uchar*>(dst), len, &aes, aes_iv, AES_DECRYPT);
-}
-
-void aesCtrEncrypt(bytes::span data, const void *key, CTRState *state) {
-	AES_KEY aes;
-	AES_set_encrypt_key(static_cast<const uchar*>(key), 256, &aes);
-
-	static_assert(CTRState::IvecSize == AES_BLOCK_SIZE, "Wrong size of ctr ivec!");
-	static_assert(CTRState::EcountSize == AES_BLOCK_SIZE, "Wrong size of ctr ecount!");
-
-	CRYPTO_ctr128_encrypt(
-		reinterpret_cast<const uchar*>(data.data()),
-		reinterpret_cast<uchar*>(data.data()),
-		data.size(),
-		&aes,
-		state->ivec,
-		state->ecount,
-		&state->num,
-		(block128_f)AES_encrypt);
-}
-
-} // namespace MTP
diff --git a/Telegram/SourceFiles/mtproto/config_loader.cpp b/Telegram/SourceFiles/mtproto/config_loader.cpp
index 7abc822cc..fc847c855 100644
--- a/Telegram/SourceFiles/mtproto/config_loader.cpp
+++ b/Telegram/SourceFiles/mtproto/config_loader.cpp
@@ -7,13 +7,14 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 */
 #include "mtproto/config_loader.h"
 
+#include "mtproto/special_config_request.h"
+#include "mtproto/facade.h"
 #include "mtproto/dc_options.h"
 #include "mtproto/mtp_instance.h"
-#include "mtproto/special_config_request.h"
 #include "facades.h"
 
 namespace MTP {
-namespace internal {
+namespace details {
 namespace {
 
 constexpr auto kEnumerateDcTimeout = 8000; // 8 seconds timeout for help_getConfig to work (then move to other dc)
@@ -214,5 +215,5 @@ void ConfigLoader::specialConfigLoaded(const MTPConfig &result) {
 	_instance->dcOptions()->setFromList(data.vdc_options());
 }
 
-} // namespace internal
+} // namespace details
 } // namespace MTP
diff --git a/Telegram/SourceFiles/mtproto/config_loader.h b/Telegram/SourceFiles/mtproto/config_loader.h
index 923dc2e25..39b7bc214 100644
--- a/Telegram/SourceFiles/mtproto/config_loader.h
+++ b/Telegram/SourceFiles/mtproto/config_loader.h
@@ -10,14 +10,15 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "base/timer.h"
 #include "base/weak_ptr.h"
 #include "base/bytes.h"
-#include "mtproto/rpc_sender.h"
+#include "mtproto/mtproto_rpc_sender.h"
 
 namespace MTP {
 
-class SpecialConfigRequest;
 class Instance;
 
-namespace internal {
+namespace details {
+
+class SpecialConfigRequest;
 
 class ConfigLoader : public base::has_weak_ptr {
 public:
@@ -76,5 +77,5 @@ inline bool operator==(const ConfigLoader::SpecialEndpoint &a, const ConfigLoade
 	return (a.dcId == b.dcId) && (a.ip == b.ip) && (a.port == b.port);
 }
 
-} // namespace internal
+} // namespace details
 } // namespace MTP
diff --git a/Telegram/SourceFiles/mtproto/connection.cpp b/Telegram/SourceFiles/mtproto/connection.cpp
deleted file mode 100644
index 84410bc5a..000000000
--- a/Telegram/SourceFiles/mtproto/connection.cpp
+++ /dev/null
@@ -1,3342 +0,0 @@
-/*
-This file is part of Telegram Desktop,
-the official desktop application for the Telegram messaging service.
-
-For license and copyright information please follow this link:
-https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
-*/
-#include "mtproto/connection.h"
-
-#include "mtproto/session.h"
-#include "mtproto/rsa_public_key.h"
-#include "mtproto/rpc_sender.h"
-#include "mtproto/dc_options.h"
-#include "mtproto/connection_abstract.h"
-#include "zlib.h"
-#include "core/application.h"
-#include "core/launcher.h"
-#include "lang/lang_keys.h"
-#include "base/openssl_help.h"
-#include "base/qthelp_url.h"
-#include "base/unixtime.h"
-
-extern "C" {
-#include <openssl/bn.h>
-#include <openssl/err.h>
-#include <openssl/aes.h>
-#include <openssl/sha.h>
-#include <openssl/md5.h>
-#include <openssl/rand.h>
-} // extern "C"
-
-#ifdef small
-#undef small
-#endif // small
-
-namespace MTP {
-namespace internal {
-namespace {
-
-constexpr auto kRecreateKeyId = AuthKey::KeyId(0xFFFFFFFFFFFFFFFFULL);
-constexpr auto kIntSize = static_cast<int>(sizeof(mtpPrime));
-constexpr auto kMaxModExpSize = 256;
-constexpr auto kWaitForBetterTimeout = crl::time(2000);
-constexpr auto kMinConnectedTimeout = crl::time(1000);
-constexpr auto kMaxConnectedTimeout = crl::time(8000);
-constexpr auto kMinReceiveTimeout = crl::time(4000);
-constexpr auto kMaxReceiveTimeout = crl::time(64000);
-constexpr auto kMarkConnectionOldTimeout = crl::time(192000);
-constexpr auto kPingDelayDisconnect = 60;
-constexpr auto kPingSendAfter = crl::time(30000);
-constexpr auto kPingSendAfterForce = crl::time(45000);
-constexpr auto kTestModeDcIdShift = 10000;
-
-// If we can't connect for this time we will ask _instance to update config.
-constexpr auto kRequestConfigTimeout = crl::time(8000);
-
-// Don't try to handle messages larger than this size.
-constexpr auto kMaxMessageLength = 16 * 1024 * 1024;
-
-QString LogIdsVector(const QVector<MTPlong> &ids) {
-	if (!ids.size()) return "[]";
-	auto idsStr = QString("[%1").arg(ids.cbegin()->v);
-	for (const auto &id : ids) {
-		idsStr += QString(", %2").arg(id.v);
-	}
-	return idsStr + "]";
-}
-
-bool IsGoodModExpFirst(
-		const openssl::BigNum &modexp,
-		const openssl::BigNum &prime) {
-	const auto diff = openssl::BigNum::Sub(prime, modexp);
-	if (modexp.failed() || prime.failed() || diff.failed()) {
-		return false;
-	}
-	constexpr auto kMinDiffBitsCount = 2048 - 64;
-	if (diff.isNegative()
-		|| diff.bitsSize() < kMinDiffBitsCount
-		|| modexp.bitsSize() < kMinDiffBitsCount
-		|| modexp.bytesSize() > kMaxModExpSize) {
-		return false;
-	}
-	return true;
-}
-
-bool IsPrimeAndGoodCheck(const openssl::BigNum &prime, int g) {
-	constexpr auto kGoodPrimeBitsCount = 2048;
-
-	if (prime.failed()
-		|| prime.isNegative()
-		|| prime.bitsSize() != kGoodPrimeBitsCount) {
-		LOG(("MTP Error: Bad prime bits count %1, expected %2."
-			).arg(prime.bitsSize()
-			).arg(kGoodPrimeBitsCount));
-		return false;
-	}
-
-	const auto context = openssl::Context();
-	if (!prime.isPrime(context)) {
-		LOG(("MTP Error: Bad prime."));
-		return false;
-	}
-
-	switch (g) {
-	case 2: {
-		const auto mod8 = prime.countModWord(8);
-		if (mod8 != 7) {
-			LOG(("BigNum PT Error: bad g value: %1, mod8: %2").arg(g).arg(mod8));
-			return false;
-		}
-	} break;
-	case 3: {
-		const auto mod3 = prime.countModWord(3);
-		if (mod3 != 2) {
-			LOG(("BigNum PT Error: bad g value: %1, mod3: %2").arg(g).arg(mod3));
-			return false;
-		}
-	} break;
-	case 4: break;
-	case 5: {
-		const auto mod5 = prime.countModWord(5);
-		if (mod5 != 1 && mod5 != 4) {
-			LOG(("BigNum PT Error: bad g value: %1, mod5: %2").arg(g).arg(mod5));
-			return false;
-		}
-	} break;
-	case 6: {
-		const auto mod24 = prime.countModWord(24);
-		if (mod24 != 19 && mod24 != 23) {
-			LOG(("BigNum PT Error: bad g value: %1, mod24: %2").arg(g).arg(mod24));
-			return false;
-		}
-	} break;
-	case 7: {
-		const auto mod7 = prime.countModWord(7);
-		if (mod7 != 3 && mod7 != 5 && mod7 != 6) {
-			LOG(("BigNum PT Error: bad g value: %1, mod7: %2").arg(g).arg(mod7));
-			return false;
-		}
-	} break;
-	default: {
-		LOG(("BigNum PT Error: bad g value: %1").arg(g));
-		return false;
-	} break;
-	}
-
-	if (!openssl::BigNum(prime).subWord(1).divWord(2).isPrime(context)) {
-		LOG(("MTP Error: Bad (prime - 1) / 2."));
-		return false;
-	}
-
-	return true;
-}
-
-bool IsPrimeAndGood(bytes::const_span primeBytes, int g) {
-	static constexpr unsigned char GoodPrime[] = {
-		0xC7, 0x1C, 0xAE, 0xB9, 0xC6, 0xB1, 0xC9, 0x04, 0x8E, 0x6C, 0x52, 0x2F, 0x70, 0xF1, 0x3F, 0x73,
-		0x98, 0x0D, 0x40, 0x23, 0x8E, 0x3E, 0x21, 0xC1, 0x49, 0x34, 0xD0, 0x37, 0x56, 0x3D, 0x93, 0x0F,
-		0x48, 0x19, 0x8A, 0x0A, 0xA7, 0xC1, 0x40, 0x58, 0x22, 0x94, 0x93, 0xD2, 0x25, 0x30, 0xF4, 0xDB,
-		0xFA, 0x33, 0x6F, 0x6E, 0x0A, 0xC9, 0x25, 0x13, 0x95, 0x43, 0xAE, 0xD4, 0x4C, 0xCE, 0x7C, 0x37,
-		0x20, 0xFD, 0x51, 0xF6, 0x94, 0x58, 0x70, 0x5A, 0xC6, 0x8C, 0xD4, 0xFE, 0x6B, 0x6B, 0x13, 0xAB,
-		0xDC, 0x97, 0x46, 0x51, 0x29, 0x69, 0x32, 0x84, 0x54, 0xF1, 0x8F, 0xAF, 0x8C, 0x59, 0x5F, 0x64,
-		0x24, 0x77, 0xFE, 0x96, 0xBB, 0x2A, 0x94, 0x1D, 0x5B, 0xCD, 0x1D, 0x4A, 0xC8, 0xCC, 0x49, 0x88,
-		0x07, 0x08, 0xFA, 0x9B, 0x37, 0x8E, 0x3C, 0x4F, 0x3A, 0x90, 0x60, 0xBE, 0xE6, 0x7C, 0xF9, 0xA4,
-		0xA4, 0xA6, 0x95, 0x81, 0x10, 0x51, 0x90, 0x7E, 0x16, 0x27, 0x53, 0xB5, 0x6B, 0x0F, 0x6B, 0x41,
-		0x0D, 0xBA, 0x74, 0xD8, 0xA8, 0x4B, 0x2A, 0x14, 0xB3, 0x14, 0x4E, 0x0E, 0xF1, 0x28, 0x47, 0x54,
-		0xFD, 0x17, 0xED, 0x95, 0x0D, 0x59, 0x65, 0xB4, 0xB9, 0xDD, 0x46, 0x58, 0x2D, 0xB1, 0x17, 0x8D,
-		0x16, 0x9C, 0x6B, 0xC4, 0x65, 0xB0, 0xD6, 0xFF, 0x9C, 0xA3, 0x92, 0x8F, 0xEF, 0x5B, 0x9A, 0xE4,
-		0xE4, 0x18, 0xFC, 0x15, 0xE8, 0x3E, 0xBE, 0xA0, 0xF8, 0x7F, 0xA9, 0xFF, 0x5E, 0xED, 0x70, 0x05,
-		0x0D, 0xED, 0x28, 0x49, 0xF4, 0x7B, 0xF9, 0x59, 0xD9, 0x56, 0x85, 0x0C, 0xE9, 0x29, 0x85, 0x1F,
-		0x0D, 0x81, 0x15, 0xF6, 0x35, 0xB1, 0x05, 0xEE, 0x2E, 0x4E, 0x15, 0xD0, 0x4B, 0x24, 0x54, 0xBF,
-		0x6F, 0x4F, 0xAD, 0xF0, 0x34, 0xB1, 0x04, 0x03, 0x11, 0x9C, 0xD8, 0xE3, 0xB9, 0x2F, 0xCC, 0x5B };
-
-	if (!bytes::compare(bytes::make_span(GoodPrime), primeBytes)) {
-		if (g == 3 || g == 4 || g == 5 || g == 7) {
-			return true;
-		}
-	}
-
-	return IsPrimeAndGoodCheck(openssl::BigNum(primeBytes), g);
-}
-
-bytes::vector CreateAuthKey(
-		bytes::const_span firstBytes,
-		bytes::const_span randomBytes,
-		bytes::const_span primeBytes) {
-	using openssl::BigNum;
-
-	const auto first = BigNum(firstBytes);
-	const auto prime = BigNum(primeBytes);
-	if (!IsGoodModExpFirst(first, prime)) {
-		LOG(("AuthKey Error: Bad first prime in CreateAuthKey()."));
-		return {};
-	}
-	return BigNum::ModExp(first, BigNum(randomBytes), prime).getBytes();
-}
-
-ModExpFirst CreateModExp(
-		int g,
-		bytes::const_span primeBytes,
-		bytes::const_span randomSeed) {
-	Expects(randomSeed.size() == ModExpFirst::kRandomPowerSize);
-
-	using namespace openssl;
-
-	BigNum prime(primeBytes);
-	auto result = ModExpFirst();
-	result.randomPower.resize(ModExpFirst::kRandomPowerSize);
-	while (true) {
-		bytes::set_random(result.randomPower);
-		for (auto i = 0; i != ModExpFirst::kRandomPowerSize; ++i) {
-			result.randomPower[i] ^= randomSeed[i];
-		}
-		const auto modexp = BigNum::ModExp(
-			BigNum(g),
-			BigNum(result.randomPower),
-			prime);
-		if (IsGoodModExpFirst(modexp, prime)) {
-			result.modexp = modexp.getBytes();
-			return result;
-		}
-	}
-}
-
-void wrapInvokeAfter(SecureRequest &to, const SecureRequest &from, const RequestMap &haveSent, int32 skipBeforeRequest = 0) {
-	const auto afterId = *(mtpMsgId*)(from->after->data() + 4);
-	const auto i = afterId ? haveSent.constFind(afterId) : haveSent.cend();
-	int32 size = to->size(), lenInInts = (tl::count_length(from) >> 2), headlen = 4, fulllen = headlen + lenInInts;
-	if (i == haveSent.constEnd()) { // no invoke after or such msg was not sent or was completed recently
-		to->resize(size + fulllen + skipBeforeRequest);
-		if (skipBeforeRequest) {
-			memcpy(to->data() + size, from->constData() + 4, headlen * sizeof(mtpPrime));
-			memcpy(to->data() + size + headlen + skipBeforeRequest, from->constData() + 4 + headlen, lenInInts * sizeof(mtpPrime));
-		} else {
-			memcpy(to->data() + size, from->constData() + 4, fulllen * sizeof(mtpPrime));
-		}
-	} else {
-		to->resize(size + fulllen + skipBeforeRequest + 3);
-		memcpy(to->data() + size, from->constData() + 4, headlen * sizeof(mtpPrime));
-		(*to)[size + 3] += 3 * sizeof(mtpPrime);
-		*((mtpTypeId*)&((*to)[size + headlen + skipBeforeRequest])) = mtpc_invokeAfterMsg;
-		memcpy(to->data() + size + headlen + skipBeforeRequest + 1, &afterId, 2 * sizeof(mtpPrime));
-		memcpy(to->data() + size + headlen + skipBeforeRequest + 3, from->constData() + 4 + headlen, lenInInts * sizeof(mtpPrime));
-		if (size + 3 != 7) (*to)[7] += 3 * sizeof(mtpPrime);
-	}
-}
-
-bool parsePQ(const QByteArray &pqStr, QByteArray &pStr, QByteArray &qStr) {
-	if (pqStr.length() > 8) return false; // more than 64 bit pq
-
-	uint64 pq = 0, p, q;
-	const uchar *pqChars = (const uchar*)pqStr.constData();
-	for (uint32 i = 0, l = pqStr.length(); i < l; ++i) {
-		pq <<= 8;
-		pq |= (uint64)pqChars[i];
-	}
-	uint64 pqSqrt = (uint64)sqrtl((long double)pq), ySqr, y;
-	while (pqSqrt * pqSqrt > pq) --pqSqrt;
-	while (pqSqrt * pqSqrt < pq) ++pqSqrt;
-	for (ySqr = pqSqrt * pqSqrt - pq; ; ++pqSqrt, ySqr = pqSqrt * pqSqrt - pq) {
-		y = (uint64)sqrtl((long double)ySqr);
-		while (y * y > ySqr) --y;
-		while (y * y < ySqr) ++y;
-		if (!ySqr || y + pqSqrt >= pq) return false;
-		if (y * y == ySqr) {
-			p = pqSqrt + y;
-			q = (pqSqrt > y) ? (pqSqrt - y) : (y - pqSqrt);
-			break;
-		}
-	}
-	if (p > q) std::swap(p, q);
-
-	pStr.resize(4);
-	uchar *pChars = (uchar*)pStr.data();
-	for (uint32 i = 0; i < 4; ++i) {
-		*(pChars + 3 - i) = (uchar)(p & 0xFF);
-		p >>= 8;
-	}
-
-	qStr.resize(4);
-	uchar *qChars = (uchar*)qStr.data();
-	for (uint32 i = 0; i < 4; ++i) {
-		*(qChars + 3 - i) = (uchar)(q & 0xFF);
-		q >>= 8;
-	}
-
-	return true;
-}
-
-} // namespace
-
-Connection::Connection(not_null<Instance*> instance) : _instance(instance) {
-}
-
-void Connection::start(SessionData *sessionData, ShiftedDcId shiftedDcId) {
-	Expects(_thread == nullptr && _private == nullptr);
-
-	_thread = std::make_unique<Thread>();
-	auto newData = std::make_unique<ConnectionPrivate>(
-		_instance,
-		_thread.get(),
-		this,
-		sessionData,
-		shiftedDcId);
-
-	// will be deleted in the thread::finished signal
-	_private = newData.release();
-	_thread->start();
-}
-
-void Connection::kill() {
-	Expects(_private != nullptr && _thread != nullptr);
-
-	_private->stop();
-	_private = nullptr;
-	_thread->quit();
-}
-
-void Connection::waitTillFinish() {
-	Expects(_private == nullptr && _thread != nullptr);
-
-	DEBUG_LOG(("Waiting for connectionThread to finish"));
-	_thread->wait();
-	_thread.reset();
-}
-
-int32 Connection::state() const {
-	Expects(_private != nullptr && _thread != nullptr);
-
-	return _private->getState();
-}
-
-QString Connection::transport() const {
-	Expects(_private != nullptr && _thread != nullptr);
-
-	return _private->transport();
-}
-
-Connection::~Connection() {
-	Expects(_private == nullptr);
-
-	if (_thread) {
-		waitTillFinish();
-	}
-}
-
-void ConnectionPrivate::appendTestConnection(
-		DcOptions::Variants::Protocol protocol,
-		const QString &ip,
-		int port,
-		const bytes::vector &protocolSecret) {
-	QWriteLocker lock(&stateConnMutex);
-
-	const auto priority = (qthelp::is_ipv6(ip) ? 0 : 1)
-		+ (protocol == DcOptions::Variants::Tcp ? 1 : 0)
-		+ (protocolSecret.empty() ? 0 : 1);
-	_testConnections.push_back({
-		AbstractConnection::Create(
-			_instance,
-			protocol,
-			thread(),
-			protocolSecret,
-			_connectionOptions->proxy),
-		priority
-	});
-	const auto weak = _testConnections.back().data.get();
-	connect(weak, &AbstractConnection::error, [=](int errorCode) {
-		onError(weak, errorCode);
-	});
-	connect(weak, &AbstractConnection::receivedSome, [=] {
-		onReceivedSome();
-	});
-	firstSentAt = 0;
-	if (_oldConnection) {
-		_oldConnection = false;
-		DEBUG_LOG(("This connection marked as not old!"));
-	}
-	_oldConnectionTimer.callOnce(kMarkConnectionOldTimeout);
-	connect(weak, &AbstractConnection::connected, [=] {
-		onConnected(weak);
-	});
-	connect(weak, &AbstractConnection::disconnected, [=] {
-		onDisconnected(weak);
-	});
-	connect(weak, &AbstractConnection::syncTimeRequest, [=] {
-		InvokeQueued(_instance, [instance = _instance] {
-			instance->syncHttpUnixtime();
-		});
-	});
-
-	InvokeQueued(_testConnections.back().data, [=] {
-		weak->connectToServer(ip, port, protocolSecret, getProtocolDcId());
-	});
-}
-
-int16 ConnectionPrivate::getProtocolDcId() const {
-	const auto dcId = BareDcId(_shiftedDcId);
-	const auto simpleDcId = isTemporaryDcId(dcId)
-		? getRealIdFromTemporaryDcId(dcId)
-		: dcId;
-	const auto testedDcId = cTestMode()
-		? (kTestModeDcIdShift + simpleDcId)
-		: simpleDcId;
-	return (_dcType == DcType::MediaDownload)
-		? -testedDcId
-		: testedDcId;
-}
-
-void ConnectionPrivate::destroyAllConnections() {
-	_waitForBetterTimer.cancel();
-	_waitForReceivedTimer.cancel();
-	_waitForConnectedTimer.cancel();
-	_testConnections.clear();
-	_connection = nullptr;
-}
-
-ConnectionPrivate::ConnectionPrivate(
-	not_null<Instance*> instance,
-	not_null<QThread*> thread,
-	not_null<Connection*> owner,
-	not_null<SessionData*> data,
-	ShiftedDcId shiftedDcId)
-: QObject(nullptr)
-, _instance(instance)
-, _state(DisconnectedState)
-, _shiftedDcId(shiftedDcId)
-, _owner(owner)
-, _retryTimer(thread, [=] { retryByTimer(); })
-, _oldConnectionTimer(thread, [=] { markConnectionOld(); })
-, _waitForConnectedTimer(thread, [=] { waitConnectedFailed(); })
-, _waitForReceivedTimer(thread, [=] { waitReceivedFailed(); })
-, _waitForBetterTimer(thread, [=] { waitBetterFailed(); })
-, _waitForReceived(kMinReceiveTimeout)
-, _waitForConnected(kMinConnectedTimeout)
-, _pingSender(thread, [=] { sendPingByTimer(); })
-, sessionData(data) {
-	Expects(_shiftedDcId != 0);
-
-	moveToThread(thread);
-
-	connect(thread, &QThread::started, this, [=] { connectToServer(); });
-	connect(thread, &QThread::finished, this, [=] { finishAndDestroy(); });
-	connect(this, SIGNAL(finished(internal::Connection*)), _instance, SLOT(connectionFinished(internal::Connection*)), Qt::QueuedConnection);
-
-	connect(sessionData->owner(), SIGNAL(authKeyCreated()), this, SLOT(updateAuthKey()), Qt::QueuedConnection);
-	connect(sessionData->owner(), SIGNAL(needToRestart()), this, SLOT(restartNow()), Qt::QueuedConnection);
-	connect(this, SIGNAL(needToReceive()), sessionData->owner(), SLOT(tryToReceive()), Qt::QueuedConnection);
-	connect(this, SIGNAL(stateChanged(qint32)), sessionData->owner(), SLOT(onConnectionStateChange(qint32)), Qt::QueuedConnection);
-	connect(sessionData->owner(), SIGNAL(needToSend()), this, SLOT(tryToSend()), Qt::QueuedConnection);
-	connect(sessionData->owner(), SIGNAL(needToPing()), this, SLOT(onPingSendForce()), Qt::QueuedConnection);
-	connect(this, SIGNAL(sessionResetDone()), sessionData->owner(), SLOT(onResetDone()), Qt::QueuedConnection);
-
-	static bool _registered = false;
-	if (!_registered) {
-		_registered = true;
-		qRegisterMetaType<QVector<quint64> >("QVector<quint64>");
-	}
-
-	connect(this, SIGNAL(needToSendAsync()), sessionData->owner(), SLOT(needToResumeAndSend()), Qt::QueuedConnection);
-	connect(this, SIGNAL(sendAnythingAsync(qint64)), sessionData->owner(), SLOT(sendAnything(qint64)), Qt::QueuedConnection);
-	connect(this, SIGNAL(sendHttpWaitAsync()), sessionData->owner(), SLOT(sendAnything()), Qt::QueuedConnection);
-	connect(this, SIGNAL(sendPongAsync(quint64,quint64)), sessionData->owner(), SLOT(sendPong(quint64,quint64)), Qt::QueuedConnection);
-	connect(this, SIGNAL(sendMsgsStateInfoAsync(quint64, QByteArray)), sessionData->owner(), SLOT(sendMsgsStateInfo(quint64,QByteArray)), Qt::QueuedConnection);
-	connect(this, SIGNAL(resendAsync(quint64,qint64,bool,bool)), sessionData->owner(), SLOT(resend(quint64,qint64,bool,bool)), Qt::QueuedConnection);
-	connect(this, SIGNAL(resendManyAsync(QVector<quint64>,qint64,bool,bool)), sessionData->owner(), SLOT(resendMany(QVector<quint64>,qint64,bool,bool)), Qt::QueuedConnection);
-	connect(this, SIGNAL(resendAllAsync()), sessionData->owner(), SLOT(resendAll()), Qt::QueuedConnection);
-}
-
-void ConnectionPrivate::onConfigLoaded() {
-	connectToServer(true);
-}
-
-void ConnectionPrivate::onCDNConfigLoaded() {
-	restart();
-}
-
-int32 ConnectionPrivate::getShiftedDcId() const {
-	return _shiftedDcId;
-}
-
-int32 ConnectionPrivate::getState() const {
-	QReadLocker lock(&stateConnMutex);
-	int32 result = _state;
-	if (_state < 0) {
-		if (_retryTimer.isActive()) {
-			result = int32(crl::now() - _retryWillFinish);
-			if (result >= 0) {
-				result = -1;
-			}
-		}
-	}
-	return result;
-}
-
-QString ConnectionPrivate::transport() const {
-	QReadLocker lock(&stateConnMutex);
-	if (!_connection || (_state < 0)) {
-		return QString();
-	}
-
-	Assert(_connectionOptions != nullptr);
-	return _connection->transport();
-}
-
-bool ConnectionPrivate::setState(int32 state, int32 ifState) {
-	if (ifState != Connection::UpdateAlways) {
-		QReadLocker lock(&stateConnMutex);
-		if (_state != ifState) return false;
-	}
-	QWriteLocker lock(&stateConnMutex);
-	if (_state == state) return false;
-	_state = state;
-	if (state < 0) {
-		_retryTimeout = -state;
-		_retryTimer.callOnce(_retryTimeout);
-		_retryWillFinish = crl::now() + _retryTimeout;
-	}
-	emit stateChanged(state);
-	return true;
-}
-
-void ConnectionPrivate::resetSession() { // recreate all msg_id and msg_seqno
-	_needSessionReset = false;
-
-	QWriteLocker locker1(sessionData->haveSentMutex());
-	QWriteLocker locker2(sessionData->toResendMutex());
-	QWriteLocker locker3(sessionData->toSendMutex());
-	QWriteLocker locker4(sessionData->wereAckedMutex());
-	auto &haveSent = sessionData->haveSentMap();
-	auto &toResend = sessionData->toResendMap();
-	auto &toSend = sessionData->toSendMap();
-	auto &wereAcked = sessionData->wereAckedMap();
-
-	auto newId = base::unixtime::mtproto_msg_id();
-	auto setSeqNumbers = RequestMap();
-	auto replaces = QMap<mtpMsgId, mtpMsgId>();
-	for (auto i = haveSent.cbegin(), e = haveSent.cend(); i != e; ++i) {
-		if (!i.value().isSentContainer()) {
-			if (!*(mtpMsgId*)(i.value()->constData() + 4)) continue;
-
-			mtpMsgId id = i.key();
-			if (id > newId) {
-				while (true) {
-					if (toResend.constFind(newId) == toResend.cend()
-						&& wereAcked.constFind(newId) == wereAcked.cend()
-						&& haveSent.constFind(newId) == haveSent.cend()) {
-						break;
-					}
-					const auto m = base::unixtime::mtproto_msg_id();
-					if (m <= newId) break; // wtf
-
-					newId = m;
-				}
-
-				MTP_LOG(_shiftedDcId, ("Replacing msgId %1 to %2!"
-					).arg(id
-					).arg(newId));
-				replaces.insert(id, newId);
-				id = newId;
-				*(mtpMsgId*)(i.value()->data() + 4) = id;
-			}
-			setSeqNumbers.insert(id, i.value());
-		}
-	}
-	// Collect all non-container requests.
-	for (auto i = toResend.cbegin(), e = toResend.cend(); i != e; ++i) {
-		const auto j = toSend.constFind(i.value());
-		if (j == toSend.cend()) continue;
-
-		if (!j.value().isSentContainer()) {
-			if (!*(mtpMsgId*)(j.value()->constData() + 4)) continue;
-
-			mtpMsgId id = i.key();
-			if (id > newId) {
-				while (true) {
-					if (toResend.constFind(newId) == toResend.cend()
-						&& wereAcked.constFind(newId) == wereAcked.cend()
-						&& haveSent.constFind(newId) == haveSent.cend()) {
-						break;
-					}
-					const auto m = base::unixtime::mtproto_msg_id();
-					if (m <= newId) break; // wtf
-
-					newId = m;
-				}
-
-				MTP_LOG(_shiftedDcId, ("Replacing msgId %1 to %2!"
-					).arg(id
-					).arg(newId));
-				replaces.insert(id, newId);
-				id = newId;
-				*(mtpMsgId*)(j.value()->data() + 4) = id;
-			}
-			setSeqNumbers.insert(id, j.value());
-		}
-	}
-
-	uint64 session = rand_value<uint64>();
-	DEBUG_LOG(("MTP Info: creating new session after bad_msg_notification, setting random server_session %1").arg(session));
-	sessionData->setSession(session);
-
-	for (auto i = setSeqNumbers.cbegin(), e = setSeqNumbers.cend(); i != e; ++i) { // generate new seq_numbers
-		bool wasNeedAck = (*(i.value()->data() + 6) & 1);
-		*(i.value()->data() + 6) = sessionData->nextRequestSeqNumber(wasNeedAck);
-	}
-	if (!replaces.isEmpty()) {
-		for (auto i = replaces.cbegin(), e = replaces.cend(); i != e; ++i) { // replace msgIds keys in all data structs
-			const auto j = haveSent.find(i.key());
-			if (j != haveSent.cend()) {
-				const auto req = j.value();
-				haveSent.erase(j);
-				haveSent.insert(i.value(), req);
-			}
-			const auto k = toResend.find(i.key());
-			if (k != toResend.cend()) {
-				const auto req = k.value();
-				toResend.erase(k);
-				toResend.insert(i.value(), req);
-			}
-			const auto l = wereAcked.find(i.key());
-			if (l != wereAcked.cend()) {
-				DEBUG_LOG(("MTP Info: Replaced %1 with %2 in wereAcked."
-					).arg(i.key()
-					).arg(i.value()));
-
-				const auto req = l.value();
-				wereAcked.erase(l);
-				wereAcked.insert(i.value(), req);
-			}
-		}
-		for (auto i = haveSent.cbegin(), e = haveSent.cend(); i != e; ++i) { // replace msgIds in saved containers
-			if (i.value().isSentContainer()) {
-				mtpMsgId *ids = (mtpMsgId*)(i.value()->data() + 8);
-				for (uint32 j = 0, l = (i.value()->size() - 8) >> 1; j < l; ++j) {
-					const auto k = replaces.constFind(ids[j]);
-					if (k != replaces.cend()) {
-						ids[j] = k.value();
-					}
-				}
-			}
-		}
-	}
-
-	ackRequestData.clear();
-	resendRequestData.clear();
-	{
-		QWriteLocker locker5(sessionData->stateRequestMutex());
-		sessionData->stateRequestMap().clear();
-	}
-
-	emit sessionResetDone();
-}
-
-mtpMsgId ConnectionPrivate::prepareToSend(SecureRequest &request, mtpMsgId currentLastId) {
-	if (request->size() < 9) return 0;
-	mtpMsgId msgId = *(mtpMsgId*)(request->constData() + 4);
-	if (msgId) { // resending this request
-		QWriteLocker locker(sessionData->toResendMutex());
-		auto &toResend = sessionData->toResendMap();
-		const auto i = toResend.find(msgId);
-		if (i != toResend.cend()) {
-			toResend.erase(i);
-		}
-	} else {
-		msgId = *(mtpMsgId*)(request->data() + 4) = currentLastId;
-		*(request->data() + 6) = sessionData->nextRequestSeqNumber(request.needAck());
-	}
-	return msgId;
-}
-
-mtpMsgId ConnectionPrivate::replaceMsgId(SecureRequest &request, mtpMsgId newId) {
-	if (request->size() < 9) return 0;
-
-	mtpMsgId oldMsgId = *(mtpMsgId*)(request->constData() + 4);
-	if (oldMsgId != newId) {
-		if (oldMsgId) {
-			QWriteLocker locker(sessionData->toResendMutex());
-			// haveSentMutex() and wereAckedMutex() were locked in tryToSend()
-
-			auto &toResend = sessionData->toResendMap();
-			auto &wereAcked = sessionData->wereAckedMap();
-			auto &haveSent = sessionData->haveSentMap();
-
-			while (true) {
-				if (toResend.constFind(newId) == toResend.cend() && wereAcked.constFind(newId) == wereAcked.cend() && haveSent.constFind(newId) == haveSent.cend()) {
-					break;
-				}
-				const auto m = base::unixtime::mtproto_msg_id();
-				if (m <= newId) break; // wtf
-
-				newId = m;
-			}
-
-			const auto i = toResend.find(oldMsgId);
-			if (i != toResend.cend()) {
-				const auto req = i.value();
-				toResend.erase(i);
-				toResend.insert(newId, req);
-			}
-
-			const auto j = wereAcked.find(oldMsgId);
-			if (j != wereAcked.cend()) {
-				const auto req = j.value();
-				wereAcked.erase(j);
-				wereAcked.insert(newId, req);
-			}
-
-			const auto k = haveSent.find(oldMsgId);
-			if (k != haveSent.cend()) {
-				const auto req = k.value();
-				haveSent.erase(k);
-				haveSent.insert(newId, req);
-			}
-
-			for (auto l = haveSent.begin(); l != haveSent.cend(); ++l) {
-				const auto req = l.value();
-				if (req.isSentContainer()) {
-					const auto ids = (mtpMsgId *)(req->data() + 8);
-					for (uint32 i = 0, l = (req->size() - 8) >> 1; i < l; ++i) {
-						if (ids[i] == oldMsgId) {
-							ids[i] = newId;
-						}
-					}
-				}
-			}
-		} else {
-			*(request->data() + 6) = sessionData->nextRequestSeqNumber(request.needAck());
-		}
-		*(mtpMsgId*)(request->data() + 4) = newId;
-	}
-	return newId;
-}
-
-mtpMsgId ConnectionPrivate::placeToContainer(SecureRequest &toSendRequest, mtpMsgId &bigMsgId, mtpMsgId *&haveSentArr, SecureRequest &req) {
-	auto msgId = prepareToSend(req, bigMsgId);
-	if (msgId > bigMsgId) {
-		msgId = replaceMsgId(req, bigMsgId);
-	}
-	if (msgId >= bigMsgId) {
-		bigMsgId = base::unixtime::mtproto_msg_id();
-	}
-	*(haveSentArr++) = msgId;
-
-	uint32 from = toSendRequest->size(), len = req.messageSize();
-	toSendRequest->resize(from + len);
-	memcpy(toSendRequest->data() + from, req->constData() + 4, len * sizeof(mtpPrime));
-
-	return msgId;
-}
-
-void ConnectionPrivate::tryToSend() {
-	QReadLocker lockFinished(&sessionDataMutex);
-	if (!sessionData || !_connection) {
-		return;
-	}
-
-	auto needsLayer = !_connectionOptions->inited;
-	auto state = getState();
-	auto prependOnly = (state != ConnectedState);
-	auto pingRequest = SecureRequest();
-	if (_shiftedDcId == BareDcId(_shiftedDcId)) { // main session
-		if (!prependOnly && !_pingIdToSend && !_pingId && _pingSendAt <= crl::now()) {
-			_pingIdToSend = rand_value<mtpPingId>();
-		}
-	}
-	if (_pingIdToSend) {
-		if (prependOnly || _shiftedDcId != BareDcId(_shiftedDcId)) {
-			pingRequest = SecureRequest::Serialize(MTPPing(
-				MTP_long(_pingIdToSend)
-			));
-			DEBUG_LOG(("MTP Info: sending ping, ping_id: %1"
-				).arg(_pingIdToSend));
-		} else {
-			pingRequest = SecureRequest::Serialize(MTPPing_delay_disconnect(
-				MTP_long(_pingIdToSend),
-				MTP_int(kPingDelayDisconnect)));
-			DEBUG_LOG(("MTP Info: sending ping_delay_disconnect, "
-				"ping_id: %1").arg(_pingIdToSend));
-		}
-
-		pingRequest->msDate = crl::now(); // > 0 - can send without container
-		_pingSendAt = pingRequest->msDate + kPingSendAfter;
-		pingRequest->requestId = 0; // dont add to haveSent / wereAcked maps
-
-		if (_shiftedDcId == BareDcId(_shiftedDcId) && !prependOnly) { // main session
-			_pingSender.callOnce(kPingSendAfterForce);
-		}
-
-		_pingId = _pingIdToSend;
-		_pingIdToSend = 0;
-	} else {
-		if (prependOnly) {
-			DEBUG_LOG(("MTP Info: dc %1 not sending, waiting for Connected state, state: %2").arg(_shiftedDcId).arg(state));
-			return; // just do nothing, if is not connected yet
-		} else {
-			DEBUG_LOG(("MTP Info: dc %1 trying to send after ping, state: %2").arg(_shiftedDcId).arg(state));
-		}
-	}
-
-	SecureRequest ackRequest, resendRequest, stateRequest, httpWaitRequest;
-	if (!prependOnly && !ackRequestData.isEmpty()) {
-		ackRequest = SecureRequest::Serialize(MTPMsgsAck(
-			MTP_msgs_ack(MTP_vector<MTPlong>(ackRequestData))));
-		ackRequest->msDate = crl::now(); // > 0 - can send without container
-		ackRequest->requestId = 0; // dont add to haveSent / wereAcked maps
-
-		ackRequestData.clear();
-	}
-	if (!prependOnly && !resendRequestData.isEmpty()) {
-		resendRequest = SecureRequest::Serialize(MTPMsgResendReq(
-			MTP_msg_resend_req(MTP_vector<MTPlong>(resendRequestData))));
-		resendRequest->msDate = crl::now(); // > 0 - can send without container
-		resendRequest->requestId = 0; // dont add to haveSent / wereAcked maps
-
-		resendRequestData.clear();
-	}
-	if (!prependOnly) {
-		QVector<MTPlong> stateReq;
-		{
-			QWriteLocker locker(sessionData->stateRequestMutex());
-			auto &ids = sessionData->stateRequestMap();
-			if (!ids.isEmpty()) {
-				stateReq.reserve(ids.size());
-				for (auto i = ids.cbegin(), e = ids.cend(); i != e; ++i) {
-					stateReq.push_back(MTP_long(i.key()));
-				}
-			}
-			ids.clear();
-		}
-		if (!stateReq.isEmpty()) {
-			stateRequest = SecureRequest::Serialize(MTPMsgsStateReq(
-				MTP_msgs_state_req(MTP_vector<MTPlong>(stateReq))));
-			stateRequest->msDate = crl::now(); // > 0 - can send without container
-			stateRequest->requestId = GetNextRequestId();// add to haveSent / wereAcked maps, but don't add to requestMap
-		}
-		if (_connection->usingHttpWait()) {
-			httpWaitRequest = SecureRequest::Serialize(MTPHttpWait(
-				MTP_http_wait(MTP_int(100), MTP_int(30), MTP_int(25000))));
-			httpWaitRequest->msDate = crl::now(); // > 0 - can send without container
-			httpWaitRequest->requestId = 0; // dont add to haveSent / wereAcked maps
-		}
-	}
-
-	MTPInitConnection<SecureRequest> initWrapper;
-	int32 initSize = 0, initSizeInInts = 0;
-	if (needsLayer) {
-		Assert(_connectionOptions != nullptr);
-		const auto systemLangCode = _connectionOptions->systemLangCode;
-		const auto cloudLangCode = _connectionOptions->cloudLangCode;
-		const auto langPackName = _connectionOptions->langPackName;
-		const auto deviceModel = (_dcType == DcType::Cdn)
-			? "n/a"
-			: _instance->deviceModel();
-		const auto systemVersion = (_dcType == DcType::Cdn)
-			? "n/a"
-			: _instance->systemVersion();
-#if defined OS_MAC_STORE
-		const auto appVersion = QString::fromLatin1(AppKotatoVersionStr)
-			+ " mac store";
-#elif defined OS_WIN_STORE // OS_MAC_STORE
-		const auto appVersion = QString::fromLatin1(AppKotatoVersionStr)
-			+ " win store";
-#else // OS_MAC_STORE || OS_WIN_STORE
-		const auto appVersion = QString::fromLatin1(AppKotatoVersionStr);
-#endif // OS_MAC_STORE || OS_WIN_STORE
-		const auto proxyType = _connectionOptions->proxy.type;
-		const auto mtprotoProxy = (proxyType == ProxyData::Type::Mtproto);
-		const auto clientProxyFields = mtprotoProxy
-			? MTP_inputClientProxy(
-				MTP_string(_connectionOptions->proxy.host),
-				MTP_int(_connectionOptions->proxy.port))
-			: MTPInputClientProxy();
-		using Flag = MTPInitConnection<SecureRequest>::Flag;
-		initWrapper = MTPInitConnection<SecureRequest>(
-			MTP_flags(mtprotoProxy ? Flag::f_proxy : Flag(0)),
-			MTP_int(ApiId),
-			MTP_string(deviceModel),
-			MTP_string(systemVersion),
-			MTP_string(appVersion),
-			MTP_string(systemLangCode),
-			MTP_string(langPackName),
-			MTP_string(cloudLangCode),
-			clientProxyFields,
-			SecureRequest());
-		initSizeInInts = (tl::count_length(initWrapper) >> 2) + 2;
-		initSize = initSizeInInts * sizeof(mtpPrime);
-	}
-
-	bool needAnyResponse = false;
-	SecureRequest toSendRequest;
-	{
-		QWriteLocker locker1(sessionData->toSendMutex());
-
-		auto toSendDummy = PreRequestMap();
-		auto &toSend = prependOnly ? toSendDummy : sessionData->toSendMap();
-		if (prependOnly) locker1.unlock();
-
-		uint32 toSendCount = toSend.size();
-		if (pingRequest) ++toSendCount;
-		if (ackRequest) ++toSendCount;
-		if (resendRequest) ++toSendCount;
-		if (stateRequest) ++toSendCount;
-		if (httpWaitRequest) ++toSendCount;
-
-		if (!toSendCount) return; // nothing to send
-
-		auto first = pingRequest ? pingRequest : (ackRequest ? ackRequest : (resendRequest ? resendRequest : (stateRequest ? stateRequest : (httpWaitRequest ? httpWaitRequest : toSend.cbegin().value()))));
-		if (toSendCount == 1 && first->msDate > 0) { // if can send without container
-			toSendRequest = first;
-			if (!prependOnly) {
-				toSend.clear();
-				locker1.unlock();
-			}
-
-			const auto msgId = prepareToSend(
-				toSendRequest,
-				base::unixtime::mtproto_msg_id());
-			if (pingRequest) {
-				_pingMsgId = msgId;
-				needAnyResponse = true;
-			} else if (resendRequest || stateRequest) {
-				needAnyResponse = true;
-			}
-
-			if (toSendRequest->requestId) {
-				if (toSendRequest.needAck()) {
-					toSendRequest->msDate = toSendRequest.isStateRequest() ? 0 : crl::now();
-
-					QWriteLocker locker2(sessionData->haveSentMutex());
-					auto &haveSent = sessionData->haveSentMap();
-					haveSent.insert(msgId, toSendRequest);
-
-					if (needsLayer && !toSendRequest->needsLayer) needsLayer = false;
-					if (toSendRequest->after) {
-						const auto toSendSize = tl::count_length(toSendRequest) >> 2;
-						auto wrappedRequest = SecureRequest::Prepare(
-							toSendSize,
-							toSendSize + 3);
-						wrappedRequest->resize(4);
-						memcpy(wrappedRequest->data(), toSendRequest->constData(), 4 * sizeof(mtpPrime));
-						wrapInvokeAfter(wrappedRequest, toSendRequest, haveSent);
-						toSendRequest = std::move(wrappedRequest);
-					}
-					if (needsLayer) {
-						const auto noWrapSize = (tl::count_length(toSendRequest) >> 2);
-						const auto toSendSize = noWrapSize + initSizeInInts;
-						auto wrappedRequest = SecureRequest::Prepare(toSendSize);
-						memcpy(wrappedRequest->data(), toSendRequest->constData(), 7 * sizeof(mtpPrime)); // all except length
-						wrappedRequest->push_back(mtpc_invokeWithLayer);
-						wrappedRequest->push_back(internal::CurrentLayer);
-						initWrapper.write<mtpBuffer>(*wrappedRequest);
-						wrappedRequest->resize(wrappedRequest->size() + noWrapSize);
-						memcpy(wrappedRequest->data() + wrappedRequest->size() - noWrapSize, toSendRequest->constData() + 8, noWrapSize * sizeof(mtpPrime));
-						toSendRequest = std::move(wrappedRequest);
-					}
-
-					needAnyResponse = true;
-				} else {
-					QWriteLocker locker3(sessionData->wereAckedMutex());
-					sessionData->wereAckedMap().insert(msgId, toSendRequest->requestId);
-				}
-			}
-		} else { // send in container
-			bool willNeedInit = false;
-			uint32 containerSize = 1 + 1, idsWrapSize = (toSendCount << 1); // cons + vector size, idsWrapSize - size of "request-like" wrap for msgId vector
-			if (pingRequest) containerSize += pingRequest.messageSize();
-			if (ackRequest) containerSize += ackRequest.messageSize();
-			if (resendRequest) containerSize += resendRequest.messageSize();
-			if (stateRequest) containerSize += stateRequest.messageSize();
-			if (httpWaitRequest) containerSize += httpWaitRequest.messageSize();
-			for (auto i = toSend.begin(), e = toSend.end(); i != e; ++i) {
-				containerSize += i.value().messageSize();
-				if (needsLayer && i.value()->needsLayer) {
-					containerSize += initSizeInInts;
-					willNeedInit = true;
-				}
-			}
-			mtpBuffer initSerialized;
-			if (willNeedInit) {
-				initSerialized.reserve(initSizeInInts);
-				initSerialized.push_back(mtpc_invokeWithLayer);
-				initSerialized.push_back(internal::CurrentLayer);
-				initWrapper.write<mtpBuffer>(initSerialized);
-			}
-			// prepare container + each in invoke after
-			toSendRequest = SecureRequest::Prepare(
-				containerSize,
-				containerSize + 3 * toSend.size());
-			toSendRequest->push_back(mtpc_msg_container);
-			toSendRequest->push_back(toSendCount);
-
-			// check for a valid container
-			auto bigMsgId = base::unixtime::mtproto_msg_id();
-
-			// the fact of this lock is used in replaceMsgId()
-			QWriteLocker locker2(sessionData->haveSentMutex());
-			auto &haveSent = sessionData->haveSentMap();
-
-			// the fact of this lock is used in replaceMsgId()
-			QWriteLocker locker3(sessionData->wereAckedMutex());
-			auto &wereAcked = sessionData->wereAckedMap();
-
-			// prepare "request-like" wrap for msgId vector
-			auto haveSentIdsWrap = SecureRequest::Prepare(idsWrapSize);
-			haveSentIdsWrap->requestId = 0;
-			haveSentIdsWrap->resize(haveSentIdsWrap->size() + idsWrapSize);
-			auto haveSentArr = (mtpMsgId*)(haveSentIdsWrap->data() + 8);
-
-			if (pingRequest) {
-				_pingMsgId = placeToContainer(toSendRequest, bigMsgId, haveSentArr, pingRequest);
-				needAnyResponse = true;
-			} else if (resendRequest || stateRequest) {
-				needAnyResponse = true;
-			}
-			for (auto i = toSend.begin(), e = toSend.end(); i != e; ++i) {
-				auto &req = i.value();
-				auto msgId = prepareToSend(req, bigMsgId);
-				if (msgId > bigMsgId) {
-					msgId = replaceMsgId(req, bigMsgId);
-				}
-				if (msgId >= bigMsgId) {
-					bigMsgId = base::unixtime::mtproto_msg_id();
-				}
-				*(haveSentArr++) = msgId;
-				bool added = false;
-				if (req->requestId) {
-					if (req.needAck()) {
-						req->msDate = req.isStateRequest() ? 0 : crl::now();
-						int32 reqNeedsLayer = (needsLayer && req->needsLayer) ? toSendRequest->size() : 0;
-						if (req->after) {
-							wrapInvokeAfter(toSendRequest, req, haveSent, reqNeedsLayer ? initSizeInInts : 0);
-							if (reqNeedsLayer) {
-								memcpy(toSendRequest->data() + reqNeedsLayer + 4, initSerialized.constData(), initSize);
-								*(toSendRequest->data() + reqNeedsLayer + 3) += initSize;
-							}
-							added = true;
-						} else if (reqNeedsLayer) {
-							toSendRequest->resize(reqNeedsLayer + initSizeInInts + req.messageSize());
-							memcpy(toSendRequest->data() + reqNeedsLayer, req->constData() + 4, 4 * sizeof(mtpPrime));
-							memcpy(toSendRequest->data() + reqNeedsLayer + 4, initSerialized.constData(), initSize);
-							memcpy(toSendRequest->data() + reqNeedsLayer + 4 + initSizeInInts, req->constData() + 8, tl::count_length(req));
-							*(toSendRequest->data() + reqNeedsLayer + 3) += initSize;
-							added = true;
-						}
-						haveSent.insert(msgId, req);
-
-						needAnyResponse = true;
-					} else {
-						wereAcked.insert(msgId, req->requestId);
-					}
-				}
-				if (!added) {
-					uint32 from = toSendRequest->size(), len = req.messageSize();
-					toSendRequest->resize(from + len);
-					memcpy(toSendRequest->data() + from, req->constData() + 4, len * sizeof(mtpPrime));
-				}
-			}
-			if (stateRequest) {
-				mtpMsgId msgId = placeToContainer(toSendRequest, bigMsgId, haveSentArr, stateRequest);
-				stateRequest->msDate = 0; // 0 for state request, do not request state of it
-				haveSent.insert(msgId, stateRequest);
-			}
-			if (resendRequest) placeToContainer(toSendRequest, bigMsgId, haveSentArr, resendRequest);
-			if (ackRequest) placeToContainer(toSendRequest, bigMsgId, haveSentArr, ackRequest);
-			if (httpWaitRequest) placeToContainer(toSendRequest, bigMsgId, haveSentArr, httpWaitRequest);
-
-			mtpMsgId contMsgId = prepareToSend(toSendRequest, bigMsgId);
-			*(mtpMsgId*)(haveSentIdsWrap->data() + 4) = contMsgId;
-			(*haveSentIdsWrap)[6] = 0; // for container, msDate = 0, seqNo = 0
-			haveSent.insert(contMsgId, haveSentIdsWrap);
-			toSend.clear();
-		}
-	}
-	sendSecureRequest(
-		std::move(toSendRequest),
-		needAnyResponse,
-		lockFinished);
-}
-
-void ConnectionPrivate::retryByTimer() {
-	QReadLocker lockFinished(&sessionDataMutex);
-	if (!sessionData) return;
-
-	if (_retryTimeout < 3) {
-		++_retryTimeout;
-	} else if (_retryTimeout == 3) {
-		_retryTimeout = 1000;
-	} else if (_retryTimeout < 64000) {
-		_retryTimeout *= 2;
-	}
-	if (keyId == kRecreateKeyId) {
-		if (sessionData->getKey()) {
-			unlockKey();
-
-			QWriteLocker lock(sessionData->keyMutex());
-			sessionData->owner()->destroyKey();
-		}
-		keyId = 0;
-	}
-	connectToServer();
-}
-
-void ConnectionPrivate::restartNow() {
-	_retryTimeout = 1;
-	_retryTimer.cancel();
-	restart();
-}
-
-void ConnectionPrivate::connectToServer(bool afterConfig) {
-	if (_finished) {
-		DEBUG_LOG(("MTP Error: "
-			"connectToServer() called for finished connection!"));
-		return;
-	}
-	auto hasKey = true;
-	{
-		QReadLocker lockFinished(&sessionDataMutex);
-		if (!sessionData) {
-			DEBUG_LOG(("MTP Error: "
-				"connectToServer() called for stopped connection!"));
-			return;
-		}
-		_connectionOptions = std::make_unique<ConnectionOptions>(
-			sessionData->connectionOptions());
-		hasKey = (sessionData->getKey() != nullptr);
-	}
-	auto bareDc = BareDcId(_shiftedDcId);
-	_dcType = _instance->dcOptions()->dcType(_shiftedDcId);
-
-	// Use media_only addresses only if key for this dc is already created.
-	if (_dcType == DcType::MediaDownload && !hasKey) {
-		_dcType = DcType::Regular;
-	} else if (_dcType == DcType::Cdn && !_instance->isKeysDestroyer()) {
-		if (!_instance->dcOptions()->hasCDNKeysForDc(bareDc)) {
-			requestCDNConfig();
-			return;
-		}
-	}
-
-	if (afterConfig && (!_testConnections.empty() || _connection)) {
-		return;
-	}
-
-	destroyAllConnections();
-	if (_connectionOptions->proxy.type == ProxyData::Type::Mtproto) {
-		// host, port, secret for mtproto proxy are taken from proxy.
-		appendTestConnection(DcOptions::Variants::Tcp, {}, 0, {});
-	} else {
-		using Variants = DcOptions::Variants;
-		const auto special = (_dcType == DcType::Temporary);
-		const auto variants = _instance->dcOptions()->lookup(
-			bareDc,
-			_dcType,
-			_connectionOptions->proxy.type != ProxyData::Type::None);
-		const auto useIPv4 = special ? true : _connectionOptions->useIPv4;
-		const auto useIPv6 = special ? false : _connectionOptions->useIPv6;
-		const auto useTcp = special ? true : _connectionOptions->useTcp;
-		const auto useHttp = special ? false : _connectionOptions->useHttp;
-		const auto skipAddress = !useIPv4
-			? Variants::IPv4
-			: !useIPv6
-			? Variants::IPv6
-			: Variants::AddressTypeCount;
-		const auto skipProtocol = !useTcp
-			? Variants::Tcp
-			: !useHttp
-			? Variants::Http
-			: Variants::ProtocolCount;
-		for (auto address = 0; address != Variants::AddressTypeCount; ++address) {
-			if (address == skipAddress) {
-				continue;
-			}
-			for (auto protocol = 0; protocol != Variants::ProtocolCount; ++protocol) {
-				if (protocol == skipProtocol) {
-					continue;
-				}
-				for (const auto &endpoint : variants.data[address][protocol]) {
-					appendTestConnection(
-						static_cast<Variants::Protocol>(protocol),
-						QString::fromStdString(endpoint.ip),
-						endpoint.port,
-						endpoint.secret);
-				}
-			}
-		}
-	}
-	if (_testConnections.empty()) {
-		if (_instance->isKeysDestroyer()) {
-			LOG(("MTP Error: DC %1 options for not found for auth key destruction!").arg(_shiftedDcId));
-			emit _instance->keyDestroyed(_shiftedDcId);
-			return;
-		} else if (afterConfig) {
-			LOG(("MTP Error: DC %1 options for not found right after config load!").arg(_shiftedDcId));
-			return restart();
-		}
-		DEBUG_LOG(("MTP Info: DC %1 options not found, waiting for config").arg(_shiftedDcId));
-		connect(_instance, SIGNAL(configLoaded()), this, SLOT(onConfigLoaded()), Qt::UniqueConnection);
-		InvokeQueued(_instance, [instance = _instance] {
-			instance->requestConfig();
-		});
-		return;
-	}
-	DEBUG_LOG(("Connection Info: Connecting to %1 with %2 test connections."
-		).arg(_shiftedDcId
-		).arg(_testConnections.size()));
-
-	if (!_startedConnectingAt) {
-		_startedConnectingAt = crl::now();
-	} else if (crl::now() - _startedConnectingAt > kRequestConfigTimeout) {
-		InvokeQueued(_instance, [instance = _instance] {
-			instance->requestConfigIfOld();
-		});
-	}
-
-	_retryTimer.cancel();
-	_waitForConnectedTimer.cancel();
-
-	setState(ConnectingState);
-	_pingId = _pingMsgId = _pingIdToSend = _pingSendAt = 0;
-	_pingSender.cancel();
-
-	_waitForConnectedTimer.callOnce(_waitForConnected);
-}
-
-void ConnectionPrivate::restart() {
-	QReadLocker lockFinished(&sessionDataMutex);
-	if (!sessionData) return;
-
-	DEBUG_LOG(("MTP Info: restarting Connection"));
-
-	_waitForReceivedTimer.cancel();
-	_waitForConnectedTimer.cancel();
-
-	auto key = sessionData->getKey();
-	if (key) {
-		if (!sessionData->isCheckedKey()) {
-			// No destroying in case of an error.
-			//
-			//if (mayBeBadKey) {
-			//	clearMessages();
-			//	keyId = kRecreateKeyId;
-//				retryTimeout = 1; // no ddos please
-			//	LOG(("MTP Info: key may be bad and was not checked - but won't be destroyed, no log outs because of bad server right now..."));
-			//}
-		} else {
-			sessionData->setCheckedKey(false);
-		}
-	}
-
-	lockFinished.unlock();
-	doDisconnect();
-
-	lockFinished.relock();
-	if (sessionData && _needSessionReset) {
-		resetSession();
-	}
-	restarted = true;
-	if (_retryTimer.isActive()) return;
-
-	DEBUG_LOG(("MTP Info: restart timeout: %1ms").arg(_retryTimeout));
-	setState(-_retryTimeout);
-}
-
-void ConnectionPrivate::onSentSome(uint64 size) {
-	if (!_waitForReceivedTimer.isActive()) {
-		auto remain = static_cast<uint64>(_waitForReceived);
-		if (!_oldConnection) {
-			// 8kb / sec, so 512 kb give 64 sec
-			auto remainBySize = size * _waitForReceived / 8192;
-			remain = snap(remainBySize, remain, uint64(kMaxReceiveTimeout));
-			if (remain != _waitForReceived) {
-				DEBUG_LOG(("Checking connect for request with size %1 bytes, delay will be %2").arg(size).arg(remain));
-			}
-		}
-		if (isUploadDcId(_shiftedDcId)) {
-			remain *= cNetUploadSessionsCount();
-		} else if (isDownloadDcId(_shiftedDcId)) {
-			remain *= cNetDownloadSessionsCount();
-		}
-		_waitForReceivedTimer.callOnce(remain);
-	}
-	if (!firstSentAt) firstSentAt = crl::now();
-}
-
-void ConnectionPrivate::onReceivedSome() {
-	if (_oldConnection) {
-		_oldConnection = false;
-		DEBUG_LOG(("This connection marked as not old!"));
-	}
-	_oldConnectionTimer.callOnce(kMarkConnectionOldTimeout);
-	_waitForReceivedTimer.cancel();
-	if (firstSentAt > 0) {
-		const auto ms = crl::now() - firstSentAt;
-		DEBUG_LOG(("MTP Info: response in %1ms, _waitForReceived: %2ms").arg(ms).arg(_waitForReceived));
-
-		if (ms > 0 && ms * 2 < _waitForReceived) {
-			_waitForReceived = qMax(ms * 2, kMinReceiveTimeout);
-		}
-		firstSentAt = -1;
-	}
-}
-
-void ConnectionPrivate::markConnectionOld() {
-	_oldConnection = true;
-	_waitForReceived = kMinReceiveTimeout;
-	DEBUG_LOG(("This connection marked as old! _waitForReceived now %1ms").arg(_waitForReceived));
-}
-
-void ConnectionPrivate::sendPingByTimer() {
-	if (_pingId) {
-		// _pingSendAt: when to send next ping (lastPingAt + kPingSendAfter)
-		// could be equal to zero.
-		const auto now = crl::now();
-		const auto mustSendTill = _pingSendAt
-			+ kPingSendAfterForce
-			- kPingSendAfter;
-		if (mustSendTill < now + 1000) {
-			LOG(("Could not send ping for some seconds, restarting..."));
-			return restart();
-		} else {
-			_pingSender.callOnce(mustSendTill - now);
-		}
-	} else {
-		emit needToSendAsync();
-	}
-}
-
-void ConnectionPrivate::onPingSendForce() {
-	if (!_pingId) {
-		_pingSendAt = 0;
-		DEBUG_LOG(("Will send ping!"));
-		tryToSend();
-	}
-}
-
-void ConnectionPrivate::waitReceivedFailed() {
-	Expects(_connectionOptions != nullptr);
-
-	if (!_connectionOptions->useTcp) {
-		return;
-	}
-
-	DEBUG_LOG(("MTP Info: bad connection, _waitForReceived: %1ms").arg(_waitForReceived));
-	if (_waitForReceived < kMaxReceiveTimeout) {
-		_waitForReceived *= 2;
-	}
-	doDisconnect();
-	restarted = true;
-	if (_retryTimer.isActive()) {
-		return;
-	}
-
-	DEBUG_LOG(("MTP Info: immediate restart!"));
-	InvokeQueued(this, [=] { connectToServer(); });
-}
-
-void ConnectionPrivate::waitConnectedFailed() {
-	DEBUG_LOG(("MTP Info: can't connect in %1ms").arg(_waitForConnected));
-	auto maxTimeout = kMaxConnectedTimeout;
-	for (const auto &connection : _testConnections) {
-		accumulate_max(maxTimeout, connection.data->fullConnectTimeout());
-	}
-	if (_waitForConnected < maxTimeout) {
-		_waitForConnected = std::min(maxTimeout, 2 * _waitForConnected);
-	}
-
-	connectingTimedOut();
-	restarted = true;
-
-	DEBUG_LOG(("MTP Info: immediate restart!"));
-	InvokeQueued(this, [=] { connectToServer(); });
-}
-
-void ConnectionPrivate::waitBetterFailed() {
-	confirmBestConnection();
-}
-
-void ConnectionPrivate::connectingTimedOut() {
-	for (const auto &connection : _testConnections) {
-		connection.data->timedOut();
-	}
-	doDisconnect();
-}
-
-void ConnectionPrivate::doDisconnect() {
-	destroyAllConnections();
-
-	{
-		QReadLocker lockFinished(&sessionDataMutex);
-		if (sessionData) {
-			unlockKey();
-		}
-	}
-
-	clearAuthKeyData();
-
-	setState(DisconnectedState);
-	restarted = false;
-}
-
-void ConnectionPrivate::finishAndDestroy() {
-	doDisconnect();
-	_finished = true;
-	emit finished(_owner);
-	deleteLater();
-}
-
-void ConnectionPrivate::requestCDNConfig() {
-	connect(
-		_instance,
-		SIGNAL(cdnConfigLoaded()),
-		this,
-		SLOT(onCDNConfigLoaded()),
-		Qt::UniqueConnection);
-	InvokeQueued(_instance, [instance = _instance] {
-		instance->requestCDNConfig();
-	});
-}
-
-void ConnectionPrivate::handleReceived() {
-	QReadLocker lockFinished(&sessionDataMutex);
-	if (!sessionData) return;
-
-	onReceivedSome();
-
-	auto restartOnError = [this, &lockFinished] {
-		lockFinished.unlock();
-		restart();
-	};
-
-	ReadLockerAttempt lock(sessionData->keyMutex());
-	if (!lock) {
-		DEBUG_LOG(("MTP Error: auth_key for dc %1 busy, cant lock").arg(_shiftedDcId));
-		clearMessages();
-		keyId = 0;
-
-		return restartOnError();
-	}
-
-	auto key = sessionData->getKey();
-	if (!key || key->keyId() != keyId) {
-		DEBUG_LOG(("MTP Error: auth_key id for dc %1 changed").arg(_shiftedDcId));
-		return restartOnError();
-	}
-
-	while (!_connection->received().empty()) {
-		auto intsBuffer = std::move(_connection->received().front());
-		_connection->received().pop_front();
-
-		constexpr auto kExternalHeaderIntsCount = 6U; // 2 auth_key_id, 4 msg_key
-		constexpr auto kEncryptedHeaderIntsCount = 8U; // 2 salt, 2 session, 2 msg_id, 1 seq_no, 1 length
-		constexpr auto kMinimalEncryptedIntsCount = kEncryptedHeaderIntsCount + 4U; // + 1 data + 3 padding
-		constexpr auto kMinimalIntsCount = kExternalHeaderIntsCount + kMinimalEncryptedIntsCount;
-		auto intsCount = uint32(intsBuffer.size());
-		auto ints = intsBuffer.constData();
-		if ((intsCount < kMinimalIntsCount) || (intsCount > kMaxMessageLength / kIntSize)) {
-			LOG(("TCP Error: bad message received, len %1").arg(intsCount * kIntSize));
-			TCP_LOG(("TCP Error: bad message %1").arg(Logs::mb(ints, intsCount * kIntSize).str()));
-
-			return restartOnError();
-		}
-		if (keyId != *(uint64*)ints) {
-			LOG(("TCP Error: bad auth_key_id %1 instead of %2 received").arg(keyId).arg(*(uint64*)ints));
-			TCP_LOG(("TCP Error: bad message %1").arg(Logs::mb(ints, intsCount * kIntSize).str()));
-
-			return restartOnError();
-		}
-
-		auto encryptedInts = ints + kExternalHeaderIntsCount;
-		auto encryptedIntsCount = (intsCount - kExternalHeaderIntsCount) & ~0x03U;
-		auto encryptedBytesCount = encryptedIntsCount * kIntSize;
-		auto decryptedBuffer = QByteArray(encryptedBytesCount, Qt::Uninitialized);
-		auto msgKey = *(MTPint128*)(ints + 2);
-
-#ifdef TDESKTOP_MTPROTO_OLD
-		aesIgeDecrypt_oldmtp(encryptedInts, decryptedBuffer.data(), encryptedBytesCount, key, msgKey);
-#else // TDESKTOP_MTPROTO_OLD
-		aesIgeDecrypt(encryptedInts, decryptedBuffer.data(), encryptedBytesCount, key, msgKey);
-#endif // TDESKTOP_MTPROTO_OLD
-
-		auto decryptedInts = reinterpret_cast<const mtpPrime*>(decryptedBuffer.constData());
-		auto serverSalt = *(uint64*)&decryptedInts[0];
-		auto session = *(uint64*)&decryptedInts[2];
-		auto msgId = *(uint64*)&decryptedInts[4];
-		auto seqNo = *(uint32*)&decryptedInts[6];
-		auto needAck = ((seqNo & 0x01) != 0);
-
-		auto messageLength = *(uint32*)&decryptedInts[7];
-		if (messageLength > kMaxMessageLength) {
-			LOG(("TCP Error: bad messageLength %1").arg(messageLength));
-			TCP_LOG(("TCP Error: bad message %1").arg(Logs::mb(ints, intsCount * kIntSize).str()));
-
-			return restartOnError();
-
-		}
-		auto fullDataLength = kEncryptedHeaderIntsCount * kIntSize + messageLength; // Without padding.
-
-		// Can underflow, but it is an unsigned type, so we just check the range later.
-		auto paddingSize = static_cast<uint32>(encryptedBytesCount) - static_cast<uint32>(fullDataLength);
-
-#ifdef TDESKTOP_MTPROTO_OLD
-		constexpr auto kMinPaddingSize_oldmtp = 0U;
-		constexpr auto kMaxPaddingSize_oldmtp = 15U;
-		auto badMessageLength = (/*paddingSize < kMinPaddingSize_oldmtp || */paddingSize > kMaxPaddingSize_oldmtp);
-
-		auto hashedDataLength = badMessageLength ? encryptedBytesCount : fullDataLength;
-		auto sha1ForMsgKeyCheck = hashSha1(decryptedInts, hashedDataLength);
-
-		constexpr auto kMsgKeyShift_oldmtp = 4U;
-		if (memcmp(&msgKey, sha1ForMsgKeyCheck.data() + kMsgKeyShift_oldmtp, sizeof(msgKey)) != 0) {
-			LOG(("TCP Error: bad SHA1 hash after aesDecrypt in message."));
-			TCP_LOG(("TCP Error: bad message %1").arg(Logs::mb(encryptedInts, encryptedBytesCount).str()));
-
-			return restartOnError();
-		}
-#else // TDESKTOP_MTPROTO_OLD
-		constexpr auto kMinPaddingSize = 12U;
-		constexpr auto kMaxPaddingSize = 1024U;
-		auto badMessageLength = (paddingSize < kMinPaddingSize || paddingSize > kMaxPaddingSize);
-
-		std::array<uchar, 32> sha256Buffer = { { 0 } };
-
-		SHA256_CTX msgKeyLargeContext;
-		SHA256_Init(&msgKeyLargeContext);
-		SHA256_Update(&msgKeyLargeContext, key->partForMsgKey(false), 32);
-		SHA256_Update(&msgKeyLargeContext, decryptedInts, encryptedBytesCount);
-		SHA256_Final(sha256Buffer.data(), &msgKeyLargeContext);
-
-		constexpr auto kMsgKeyShift = 8U;
-		if (memcmp(&msgKey, sha256Buffer.data() + kMsgKeyShift, sizeof(msgKey)) != 0) {
-			LOG(("TCP Error: bad SHA256 hash after aesDecrypt in message"));
-			TCP_LOG(("TCP Error: bad message %1").arg(Logs::mb(encryptedInts, encryptedBytesCount).str()));
-
-			return restartOnError();
-		}
-#endif // TDESKTOP_MTPROTO_OLD
-
-		if (badMessageLength || (messageLength & 0x03)) {
-			LOG(("TCP Error: bad msg_len received %1, data size: %2").arg(messageLength).arg(encryptedBytesCount));
-			TCP_LOG(("TCP Error: bad message %1").arg(Logs::mb(encryptedInts, encryptedBytesCount).str()));
-
-			return restartOnError();
-		}
-
-		TCP_LOG(("TCP Info: decrypted message %1,%2,%3 is %4 len").arg(msgId).arg(seqNo).arg(Logs::b(needAck)).arg(fullDataLength));
-
-		uint64 serverSession = sessionData->getSession();
-		if (session != serverSession) {
-			LOG(("MTP Error: bad server session received"));
-			TCP_LOG(("MTP Error: bad server session %1 instead of %2 in message received").arg(session).arg(serverSession));
-
-			return restartOnError();
-		}
-
-		const auto serverTime = int32(msgId >> 32);
-		const auto clientTime = base::unixtime::now();
-		const auto isReply = ((msgId & 0x03) == 1);
-		if (!isReply && ((msgId & 0x03) != 3)) {
-			LOG(("MTP Error: bad msg_id %1 in message received").arg(msgId));
-
-			return restartOnError();
-		}
-
-		bool badTime = false;
-		uint64 mySalt = sessionData->getSalt();
-		if (serverTime > clientTime + 60 || serverTime + 300 < clientTime) {
-			DEBUG_LOG(("MTP Info: bad server time from msg_id: %1, my time: %2").arg(serverTime).arg(clientTime));
-			badTime = true;
-		}
-
-		bool wasConnected = (getState() == ConnectedState);
-		if (serverSalt != mySalt) {
-			if (!badTime) {
-				DEBUG_LOG(("MTP Info: other salt received... received: %1, my salt: %2, updating...").arg(serverSalt).arg(mySalt));
-				sessionData->setSalt(serverSalt);
-				if (setState(ConnectedState, ConnectingState)) { // only connected
-					if (restarted) {
-						emit resendAllAsync();
-						restarted = false;
-					}
-				}
-			} else {
-				DEBUG_LOG(("MTP Info: other salt received... received: %1, my salt: %2").arg(serverSalt).arg(mySalt));
-			}
-		} else {
-			serverSalt = 0; // dont pass to handle method, so not to lock in setSalt()
-		}
-
-		if (needAck) ackRequestData.push_back(MTP_long(msgId));
-
-		auto res = HandleResult::Success; // if no need to handle, then succeed
-		auto from = decryptedInts + kEncryptedHeaderIntsCount;
-		auto end = from + (messageLength / kIntSize);
-		auto sfrom = decryptedInts + 4U; // msg_id + seq_no + length + message
-		MTP_LOG(_shiftedDcId, ("Recv: ") + mtpTextSerialize(sfrom, end));
-
-		bool needToHandle = false;
-		{
-			QWriteLocker lock(sessionData->receivedIdsMutex());
-			needToHandle = sessionData->receivedIdsSet().registerMsgId(msgId, needAck);
-		}
-		if (needToHandle) {
-			res = handleOneReceived(from, end, msgId, serverTime, serverSalt, badTime);
-		}
-		{
-			QWriteLocker lock(sessionData->receivedIdsMutex());
-			sessionData->receivedIdsSet().shrink();
-		}
-
-		// send acks
-		uint32 toAckSize = ackRequestData.size();
-		if (toAckSize) {
-			DEBUG_LOG(("MTP Info: will send %1 acks, ids: %2").arg(toAckSize).arg(LogIdsVector(ackRequestData)));
-			emit sendAnythingAsync(kAckSendWaiting);
-		}
-
-		bool emitSignal = false;
-		{
-			QReadLocker locker(sessionData->haveReceivedMutex());
-			emitSignal = !sessionData->haveReceivedResponses().isEmpty() || !sessionData->haveReceivedUpdates().isEmpty();
-			if (emitSignal) {
-				DEBUG_LOG(("MTP Info: emitting needToReceive() - need to parse in another thread, %1 responses, %2 updates.").arg(sessionData->haveReceivedResponses().size()).arg(sessionData->haveReceivedUpdates().size()));
-			}
-		}
-
-		if (emitSignal) {
-			emit needToReceive();
-		}
-
-		if (res != HandleResult::Success && res != HandleResult::Ignored) {
-			_needSessionReset = (res == HandleResult::ResetSession);
-
-			return restartOnError();
-		}
-		_retryTimeout = 1; // reset restart() timer
-
-		if (!sessionData->isCheckedKey()) {
-			DEBUG_LOG(("MTP Info: marked auth key as checked"));
-			sessionData->setCheckedKey(true);
-		}
-		_startedConnectingAt = crl::time(0);
-
-		if (!wasConnected) {
-			if (getState() == ConnectedState) {
-				emit needToSendAsync();
-			}
-		}
-	}
-	if (_connection->needHttpWait()) {
-		emit sendHttpWaitAsync();
-	}
-}
-
-ConnectionPrivate::HandleResult ConnectionPrivate::handleOneReceived(const mtpPrime *from, const mtpPrime *end, uint64 msgId, int32 serverTime, uint64 serverSalt, bool badTime) {
-	const auto cons = mtpTypeId(*from);
-
-	switch (cons) {
-
-	case mtpc_gzip_packed: {
-		DEBUG_LOG(("Message Info: gzip container"));
-		mtpBuffer response = ungzip(++from, end);
-		if (response.empty()) {
-			return HandleResult::RestartConnection;
-		}
-		return handleOneReceived(response.data(), response.data() + response.size(), msgId, serverTime, serverSalt, badTime);
-	}
-
-	case mtpc_msg_container: {
-		if (++from >= end) {
-			return HandleResult::ParseError;
-		}
-
-		const mtpPrime *otherEnd;
-		const auto msgsCount = (uint32)*(from++);
-		DEBUG_LOG(("Message Info: container received, count: %1").arg(msgsCount));
-		for (uint32 i = 0; i < msgsCount; ++i) {
-			if (from + 4 >= end) {
-				return HandleResult::ParseError;
-			}
-			otherEnd = from + 4;
-
-			MTPlong inMsgId;
-			if (!inMsgId.read(from, otherEnd)) {
-				return HandleResult::ParseError;
-			}
-			bool isReply = ((inMsgId.v & 0x03) == 1);
-			if (!isReply && ((inMsgId.v & 0x03) != 3)) {
-				LOG(("Message Error: bad msg_id %1 in contained message received").arg(inMsgId.v));
-				return HandleResult::RestartConnection;
-			}
-
-			MTPint inSeqNo;
-			if (!inSeqNo.read(from, otherEnd)) {
-				return HandleResult::ParseError;
-			}
-			MTPint bytes;
-			if (!bytes.read(from, otherEnd)) {
-				return HandleResult::ParseError;
-			}
-			if ((bytes.v & 0x03) || bytes.v < 4) {
-				LOG(("Message Error: bad length %1 of contained message received").arg(bytes.v));
-				return HandleResult::RestartConnection;
-			}
-
-			bool needAck = (inSeqNo.v & 0x01);
-			if (needAck) ackRequestData.push_back(inMsgId);
-
-			DEBUG_LOG(("Message Info: message from container, msg_id: %1, needAck: %2").arg(inMsgId.v).arg(Logs::b(needAck)));
-
-			otherEnd = from + (bytes.v >> 2);
-			if (otherEnd > end) {
-				return HandleResult::ParseError;
-			}
-
-			bool needToHandle = false;
-			{
-				QWriteLocker lock(sessionData->receivedIdsMutex());
-				needToHandle = sessionData->receivedIdsSet().registerMsgId(inMsgId.v, needAck);
-			}
-			auto res = HandleResult::Success; // if no need to handle, then succeed
-			if (needToHandle) {
-				res = handleOneReceived(from, otherEnd, inMsgId.v, serverTime, serverSalt, badTime);
-				badTime = false;
-			}
-			if (res != HandleResult::Success) {
-				return res;
-			}
-
-			from = otherEnd;
-		}
-	} return HandleResult::Success;
-
-	case mtpc_msgs_ack: {
-		MTPMsgsAck msg;
-		if (!msg.read(from, end)) {
-			return HandleResult::ParseError;
-		}
-		auto &ids = msg.c_msgs_ack().vmsg_ids().v;
-		uint32 idsCount = ids.size();
-
-		DEBUG_LOG(("Message Info: acks received, ids: %1").arg(LogIdsVector(ids)));
-		if (!idsCount) return (badTime ? HandleResult::Ignored : HandleResult::Success);
-
-		if (badTime) {
-			if (requestsFixTimeSalt(ids, serverTime, serverSalt)) {
-				badTime = false;
-			} else {
-				return HandleResult::Ignored;
-			}
-		}
-		requestsAcked(ids);
-	} return HandleResult::Success;
-
-	case mtpc_bad_msg_notification: {
-		MTPBadMsgNotification msg;
-		if (!msg.read(from, end)) {
-			return HandleResult::ParseError;
-		}
-		const auto &data(msg.c_bad_msg_notification());
-		LOG(("Message Info: bad message notification received (error_code %3) for msg_id = %1, seq_no = %2").arg(data.vbad_msg_id().v).arg(data.vbad_msg_seqno().v).arg(data.verror_code().v));
-
-		mtpMsgId resendId = data.vbad_msg_id().v;
-		if (resendId == _pingMsgId) {
-			_pingId = 0;
-		}
-		int32 errorCode = data.verror_code().v;
-		if (false
-			|| errorCode == 16
-			|| errorCode == 17
-			|| errorCode == 32
-			|| errorCode == 33
-			|| errorCode == 64) { // can handle
-			const auto needResend = false
-				|| (errorCode == 16) // bad msg_id
-				|| (errorCode == 17) // bad msg_id
-				|| (errorCode == 64); // bad container
-			if (errorCode == 64) { // bad container!
-				if (Logs::DebugEnabled()) {
-					SecureRequest request;
-					{
-						QWriteLocker locker(sessionData->haveSentMutex());
-						auto &haveSent = sessionData->haveSentMap();
-
-						const auto i = haveSent.constFind(resendId);
-						if (i == haveSent.cend()) {
-							LOG(("Message Error: Container not found!"));
-						} else {
-							request = i.value();
-						}
-					}
-					if (request) {
-						if (request.isSentContainer()) {
-							QStringList lst;
-							const auto ids = (const mtpMsgId*)(request->constData() + 8);
-							for (uint32 i = 0, l = (request->size() - 8) >> 1; i < l; ++i) {
-								lst.push_back(QString::number(ids[i]));
-							}
-							LOG(("Message Info: bad container received! messages: %1").arg(lst.join(',')));
-						} else {
-							LOG(("Message Error: bad container received, but request is not a container!"));
-						}
-					}
-				}
-			}
-
-			if (!wasSent(resendId)) {
-				DEBUG_LOG(("Message Error: "
-					"such message was not sent recently %1").arg(resendId));
-				return badTime
-					? HandleResult::Ignored
-					: HandleResult::Success;
-			}
-
-			if (needResend) { // bad msg_id or bad container
-				if (serverSalt) sessionData->setSalt(serverSalt);
-				base::unixtime::update(serverTime, true);
-
-				DEBUG_LOG(("Message Info: unixtime updated, now %1, resending in container...").arg(serverTime));
-
-				resend(resendId, 0, true);
-			} else { // must create new session, because msg_id and msg_seqno are inconsistent
-				if (badTime) {
-					if (serverSalt) sessionData->setSalt(serverSalt);
-					base::unixtime::update(serverTime, true);
-					badTime = false;
-				}
-				LOG(("Message Info: bad message notification received, msgId %1, error_code %2").arg(data.vbad_msg_id().v).arg(errorCode));
-				return HandleResult::ResetSession;
-			}
-		} else { // fatal (except 48, but it must not get here)
-			const auto badMsgId = mtpMsgId(data.vbad_msg_id().v);
-			const auto requestId = wasSent(resendId);
-			if (requestId) {
-				LOG(("Message Error: "
-					"bad message notification received, "
-					"msgId %1, error_code %2, fatal: clearing callbacks"
-					).arg(badMsgId
-					).arg(errorCode
-					));
-				_instance->clearCallbacksDelayed({ 1, RPCCallbackClear(
-					requestId,
-					-errorCode) });
-			} else {
-				DEBUG_LOG(("Message Error: "
-					"such message was not sent recently %1").arg(badMsgId));
-			}
-			return badTime
-				? HandleResult::Ignored
-				: HandleResult::Success;
-		}
-	} return HandleResult::Success;
-
-	case mtpc_bad_server_salt: {
-		MTPBadMsgNotification msg;
-		if (!msg.read(from, end)) {
-			return HandleResult::ParseError;
-		}
-		const auto &data(msg.c_bad_server_salt());
-		DEBUG_LOG(("Message Info: bad server salt received (error_code %4) for msg_id = %1, seq_no = %2, new salt: %3").arg(data.vbad_msg_id().v).arg(data.vbad_msg_seqno().v).arg(data.vnew_server_salt().v).arg(data.verror_code().v));
-
-		mtpMsgId resendId = data.vbad_msg_id().v;
-		if (resendId == _pingMsgId) {
-			_pingId = 0;
-		} else if (!wasSent(resendId)) {
-			DEBUG_LOG(("Message Error: such message was not sent recently %1").arg(resendId));
-			return (badTime ? HandleResult::Ignored : HandleResult::Success);
-		}
-
-		uint64 serverSalt = data.vnew_server_salt().v;
-		sessionData->setSalt(serverSalt);
-		base::unixtime::update(serverTime);
-
-		if (setState(ConnectedState, ConnectingState)) { // maybe only connected
-			if (restarted) {
-				emit resendAllAsync();
-				restarted = false;
-			}
-		}
-
-		badTime = false;
-
-		DEBUG_LOG(("Message Info: unixtime updated, now %1, server_salt updated, now %2, resending...").arg(serverTime).arg(serverSalt));
-		resend(resendId);
-	} return HandleResult::Success;
-
-	case mtpc_msgs_state_req: {
-		if (badTime) {
-			DEBUG_LOG(("Message Info: skipping with bad time..."));
-			return HandleResult::Ignored;
-		}
-		MTPMsgsStateReq msg;
-		if (!msg.read(from, end)) {
-			return HandleResult::ParseError;
-		}
-		auto &ids = msg.c_msgs_state_req().vmsg_ids().v;
-		auto idsCount = ids.size();
-		DEBUG_LOG(("Message Info: msgs_state_req received, ids: %1").arg(LogIdsVector(ids)));
-		if (!idsCount) return HandleResult::Success;
-
-		QByteArray info(idsCount, Qt::Uninitialized);
-		{
-			QReadLocker lock(sessionData->receivedIdsMutex());
-			auto &receivedIds = sessionData->receivedIdsSet();
-			auto minRecv = receivedIds.min();
-			auto maxRecv = receivedIds.max();
-
-			QReadLocker locker(sessionData->wereAckedMutex());
-			const auto &wereAcked = sessionData->wereAckedMap();
-			const auto wereAckedEnd = wereAcked.cend();
-
-			for (uint32 i = 0, l = idsCount; i < l; ++i) {
-				char state = 0;
-				uint64 reqMsgId = ids[i].v;
-				if (reqMsgId < minRecv) {
-					state |= 0x01;
-				} else if (reqMsgId > maxRecv) {
-					state |= 0x03;
-				} else {
-					auto msgIdState = receivedIds.lookup(reqMsgId);
-					if (msgIdState == ReceivedMsgIds::State::NotFound) {
-						state |= 0x02;
-					} else {
-						state |= 0x04;
-						if (wereAcked.constFind(reqMsgId) != wereAckedEnd) {
-							state |= 0x80; // we know, that server knows, that we received request
-						}
-						if (msgIdState == ReceivedMsgIds::State::NeedsAck) { // need ack, so we sent ack
-							state |= 0x08;
-						} else {
-							state |= 0x10;
-						}
-					}
-				}
-				info[i] = state;
-			}
-		}
-		emit sendMsgsStateInfoAsync(msgId, info);
-	} return HandleResult::Success;
-
-	case mtpc_msgs_state_info: {
-		MTPMsgsStateInfo msg;
-		if (!msg.read(from, end)) {
-			return HandleResult::ParseError;
-		}
-		auto &data = msg.c_msgs_state_info();
-
-		auto reqMsgId = data.vreq_msg_id().v;
-		auto &states = data.vinfo().v;
-
-		DEBUG_LOG(("Message Info: msg state received, msgId %1, reqMsgId: %2, HEX states %3").arg(msgId).arg(reqMsgId).arg(Logs::mb(states.data(), states.length()).str()));
-		SecureRequest requestBuffer;
-		{ // find this request in session-shared sent requests map
-			QReadLocker locker(sessionData->haveSentMutex());
-			const auto &haveSent = sessionData->haveSentMap();
-			const auto replyTo = haveSent.constFind(reqMsgId);
-			if (replyTo == haveSent.cend()) { // do not look in toResend, because we do not resend msgs_state_req requests
-				DEBUG_LOG(("Message Error: such message was not sent recently %1").arg(reqMsgId));
-				return (badTime ? HandleResult::Ignored : HandleResult::Success);
-			}
-			if (badTime) {
-				if (serverSalt) sessionData->setSalt(serverSalt); // requestsFixTimeSalt with no lookup
-				base::unixtime::update(serverTime, true);
-
-				DEBUG_LOG(("Message Info: unixtime updated from mtpc_msgs_state_info, now %1").arg(serverTime));
-
-				badTime = false;
-			}
-			requestBuffer = replyTo.value();
-		}
-		QVector<MTPlong> toAckReq(1, MTP_long(reqMsgId)), toAck;
-		requestsAcked(toAck, true);
-
-		if (requestBuffer->size() < 9) {
-			LOG(("Message Error: bad request %1 found in requestMap, size: %2").arg(reqMsgId).arg(requestBuffer->size()));
-			return HandleResult::RestartConnection;
-		}
-		const mtpPrime *rFrom = requestBuffer->constData() + 8, *rEnd = requestBuffer->constData() + requestBuffer->size();
-		if (mtpTypeId(*rFrom) == mtpc_msgs_state_req) {
-			MTPMsgsStateReq request;
-			if (!request.read(rFrom, rEnd)) {
-				LOG(("Message Error: could not parse sent msgs_state_req"));
-				return HandleResult::ParseError;
-			}
-			handleMsgsStates(request.c_msgs_state_req().vmsg_ids().v, states, toAck);
-		} else {
-			MTPMsgResendReq request;
-			if (!request.read(rFrom, rEnd)) {
-				LOG(("Message Error: could not parse sent msgs_state_req"));
-				return HandleResult::ParseError;
-			}
-			handleMsgsStates(request.c_msg_resend_req().vmsg_ids().v, states, toAck);
-		}
-
-		requestsAcked(toAck);
-	} return HandleResult::Success;
-
-	case mtpc_msgs_all_info: {
-		if (badTime) {
-			DEBUG_LOG(("Message Info: skipping with bad time..."));
-			return HandleResult::Ignored;
-		}
-
-		MTPMsgsAllInfo msg;
-		if (!msg.read(from, end)) {
-			return HandleResult::ParseError;
-		}
-		auto &data = msg.c_msgs_all_info();
-		auto &ids = data.vmsg_ids().v;
-		auto &states = data.vinfo().v;
-
-		QVector<MTPlong> toAck;
-
-		DEBUG_LOG(("Message Info: msgs all info received, msgId %1, reqMsgIds: %2, states %3").arg(msgId).arg(LogIdsVector(ids)).arg(Logs::mb(states.data(), states.length()).str()));
-		handleMsgsStates(ids, states, toAck);
-
-		requestsAcked(toAck);
-	} return HandleResult::Success;
-
-	case mtpc_msg_detailed_info: {
-		MTPMsgDetailedInfo msg;
-		if (!msg.read(from, end)) {
-			return HandleResult::ParseError;
-		}
-		const auto &data(msg.c_msg_detailed_info());
-
-		DEBUG_LOG(("Message Info: msg detailed info, sent msgId %1, answerId %2, status %3, bytes %4").arg(data.vmsg_id().v).arg(data.vanswer_msg_id().v).arg(data.vstatus().v).arg(data.vbytes().v));
-
-		QVector<MTPlong> ids(1, data.vmsg_id());
-		if (badTime) {
-			if (requestsFixTimeSalt(ids, serverTime, serverSalt)) {
-				badTime = false;
-			} else {
-				DEBUG_LOG(("Message Info: error, such message was not sent recently %1").arg(data.vmsg_id().v));
-				return HandleResult::Ignored;
-			}
-		}
-		requestsAcked(ids);
-
-		bool received = false;
-		MTPlong resMsgId = data.vanswer_msg_id();
-		{
-			QReadLocker lock(sessionData->receivedIdsMutex());
-			received = (sessionData->receivedIdsSet().lookup(resMsgId.v) != ReceivedMsgIds::State::NotFound);
-		}
-		if (received) {
-			ackRequestData.push_back(resMsgId);
-		} else {
-			DEBUG_LOG(("Message Info: answer message %1 was not received, requesting...").arg(resMsgId.v));
-			resendRequestData.push_back(resMsgId);
-		}
-	} return HandleResult::Success;
-
-	case mtpc_msg_new_detailed_info: {
-		if (badTime) {
-			DEBUG_LOG(("Message Info: skipping msg_new_detailed_info with bad time..."));
-			return HandleResult::Ignored;
-		}
-		MTPMsgDetailedInfo msg;
-		if (!msg.read(from, end)) {
-			return HandleResult::ParseError;
-		}
-		const auto &data(msg.c_msg_new_detailed_info());
-
-		DEBUG_LOG(("Message Info: msg new detailed info, answerId %2, status %3, bytes %4").arg(data.vanswer_msg_id().v).arg(data.vstatus().v).arg(data.vbytes().v));
-
-		bool received = false;
-		MTPlong resMsgId = data.vanswer_msg_id();
-		{
-			QReadLocker lock(sessionData->receivedIdsMutex());
-			received = (sessionData->receivedIdsSet().lookup(resMsgId.v) != ReceivedMsgIds::State::NotFound);
-		}
-		if (received) {
-			ackRequestData.push_back(resMsgId);
-		} else {
-			DEBUG_LOG(("Message Info: answer message %1 was not received, requesting...").arg(resMsgId.v));
-			resendRequestData.push_back(resMsgId);
-		}
-	} return HandleResult::Success;
-
-	case mtpc_msg_resend_req: {
-		MTPMsgResendReq msg;
-		if (!msg.read(from, end)) {
-			return HandleResult::ParseError;
-		}
-		auto &ids = msg.c_msg_resend_req().vmsg_ids().v;
-
-		auto idsCount = ids.size();
-		DEBUG_LOG(("Message Info: resend of msgs requested, ids: %1").arg(LogIdsVector(ids)));
-		if (!idsCount) return (badTime ? HandleResult::Ignored : HandleResult::Success);
-
-		QVector<quint64> toResend(ids.size());
-		for (int32 i = 0, l = ids.size(); i < l; ++i) {
-			toResend[i] = ids.at(i).v;
-		}
-		resendMany(toResend, 0, false, true);
-	} return HandleResult::Success;
-
-	case mtpc_rpc_result: {
-		if (from + 3 > end) {
-			return HandleResult::ParseError;
-		}
-		auto response = SerializedMessage();
-
-		MTPlong reqMsgId;
-		if (!reqMsgId.read(++from, end)) {
-			return HandleResult::ParseError;
-		}
-		mtpTypeId typeId = from[0];
-
-		DEBUG_LOG(("RPC Info: response received for %1, queueing...").arg(reqMsgId.v));
-
-		QVector<MTPlong> ids(1, reqMsgId);
-		if (badTime) {
-			if (requestsFixTimeSalt(ids, serverTime, serverSalt)) {
-				badTime = false;
-			} else {
-				DEBUG_LOG(("Message Info: error, such message was not sent recently %1").arg(reqMsgId.v));
-				return HandleResult::Ignored;
-			}
-		}
-		requestsAcked(ids, true);
-
-		if (typeId == mtpc_gzip_packed) {
-			DEBUG_LOG(("RPC Info: gzip container"));
-			response = ungzip(++from, end);
-			if (response.empty()) {
-				return HandleResult::RestartConnection;
-			}
-			typeId = response[0];
-		} else {
-			response.resize(end - from);
-			memcpy(response.data(), from, (end - from) * sizeof(mtpPrime));
-		}
-		if (typeId != mtpc_rpc_error) {
-			// An error could be some RPC_CALL_FAIL or other error inside
-			// the initConnection, so we're not sure yet that it was inited.
-			// Wait till a good response is received.
-			if (!_connectionOptions->inited) {
-				_connectionOptions->inited = true;
-				sessionData->notifyConnectionInited(*_connectionOptions);
-			}
-		}
-
-		auto requestId = wasSent(reqMsgId.v);
-		if (requestId && requestId != mtpRequestId(0xFFFFFFFF)) {
-			// Save rpc_result for processing in the main thread.
-			QWriteLocker locker(sessionData->haveReceivedMutex());
-			sessionData->haveReceivedResponses().insert(requestId, response);
-		} else {
-			DEBUG_LOG(("RPC Info: requestId not found for msgId %1").arg(reqMsgId.v));
-		}
-	} return HandleResult::Success;
-
-	case mtpc_new_session_created: {
-		const mtpPrime *start = from;
-		MTPNewSession msg;
-		if (!msg.read(from, end)) {
-			return HandleResult::ParseError;
-		}
-		const auto &data(msg.c_new_session_created());
-
-		if (badTime) {
-			if (requestsFixTimeSalt(QVector<MTPlong>(1, data.vfirst_msg_id()), serverTime, serverSalt)) {
-				badTime = false;
-			} else {
-				DEBUG_LOG(("Message Info: error, such message was not sent recently %1").arg(data.vfirst_msg_id().v));
-				return HandleResult::Ignored;
-			}
-		}
-
-		DEBUG_LOG(("Message Info: new server session created, unique_id %1, first_msg_id %2, server_salt %3").arg(data.vunique_id().v).arg(data.vfirst_msg_id().v).arg(data.vserver_salt().v));
-		sessionData->setSalt(data.vserver_salt().v);
-
-		mtpMsgId firstMsgId = data.vfirst_msg_id().v;
-		QVector<quint64> toResend;
-		{
-			QReadLocker locker(sessionData->haveSentMutex());
-			const auto &haveSent = sessionData->haveSentMap();
-			toResend.reserve(haveSent.size());
-			for (auto i = haveSent.cbegin(), e = haveSent.cend(); i != e; ++i) {
-				if (i.key() >= firstMsgId) break;
-				if (i.value()->requestId) toResend.push_back(i.key());
-			}
-		}
-		resendMany(toResend, 10, true);
-
-		mtpBuffer update(from - start);
-		if (from > start) memcpy(update.data(), start, (from - start) * sizeof(mtpPrime));
-
-		// Notify main process about new session - need to get difference.
-		QWriteLocker locker(sessionData->haveReceivedMutex());
-		sessionData->haveReceivedUpdates().push_back(SerializedMessage(update));
-	} return HandleResult::Success;
-
-	case mtpc_pong: {
-		MTPPong msg;
-		if (!msg.read(from, end)) {
-			return HandleResult::ParseError;
-		}
-		const auto &data(msg.c_pong());
-		DEBUG_LOG(("Message Info: pong received, msg_id: %1, ping_id: %2").arg(data.vmsg_id().v).arg(data.vping_id().v));
-
-		if (!wasSent(data.vmsg_id().v)) {
-			DEBUG_LOG(("Message Error: such msg_id %1 ping_id %2 was not sent recently").arg(data.vmsg_id().v).arg(data.vping_id().v));
-			return HandleResult::Ignored;
-		}
-		if (data.vping_id().v == _pingId) {
-			_pingId = 0;
-		} else {
-			DEBUG_LOG(("Message Info: just pong..."));
-		}
-
-		QVector<MTPlong> ids(1, data.vmsg_id());
-		if (badTime) {
-			if (requestsFixTimeSalt(ids, serverTime, serverSalt)) {
-				badTime = false;
-			} else {
-				return HandleResult::Ignored;
-			}
-		}
-		requestsAcked(ids, true);
-	} return HandleResult::Success;
-
-	}
-
-	if (badTime) {
-		DEBUG_LOG(("Message Error: bad time in updates cons, must create new session"));
-		return HandleResult::ResetSession;
-	}
-
-	if (_dcType == DcType::Regular) {
-		mtpBuffer update(end - from);
-		if (end > from) memcpy(update.data(), from, (end - from) * sizeof(mtpPrime));
-
-		// Notify main process about the new updates.
-		QWriteLocker locker(sessionData->haveReceivedMutex());
-		sessionData->haveReceivedUpdates().push_back(SerializedMessage(update));
-
-		if (cons != mtpc_updatesTooLong
-			&& cons != mtpc_updateShortMessage
-			&& cons != mtpc_updateShortChatMessage
-			&& cons != mtpc_updateShortSentMessage
-			&& cons != mtpc_updateShort
-			&& cons != mtpc_updatesCombined
-			&& cons != mtpc_updates) {
-			// Maybe some new unknown update?
-			LOG(("Message Error: unknown constructor 0x%1").arg(cons, 0, 16));
-		}
-	} else {
-		LOG(("Message Error: unexpected updates in dcType: %1").arg(static_cast<int>(_dcType)));
-	}
-
-	return HandleResult::Success;
-}
-
-mtpBuffer ConnectionPrivate::ungzip(const mtpPrime *from, const mtpPrime *end) const {
-	mtpBuffer result; // * 4 because of mtpPrime type
-	result.resize(0);
-
-	MTPstring packed;
-	if (!packed.read(from, end)) { // read packed string as serialized mtp string type
-		LOG(("RPC Error: could not read gziped bytes."));
-		return result;
-	}
-	uint32 packedLen = packed.v.size(), unpackedChunk = packedLen, unpackedLen = 0;
-
-	z_stream stream;
-	stream.zalloc = 0;
-	stream.zfree = 0;
-	stream.opaque = 0;
-	stream.avail_in = 0;
-	stream.next_in = 0;
-	int res = inflateInit2(&stream, 16 + MAX_WBITS);
-	if (res != Z_OK) {
-		LOG(("RPC Error: could not init zlib stream, code: %1").arg(res));
-		return result;
-	}
-	stream.avail_in = packedLen;
-	stream.next_in = reinterpret_cast<Bytef*>(packed.v.data());
-
-	stream.avail_out = 0;
-	while (!stream.avail_out) {
-		result.resize(result.size() + unpackedChunk);
-		stream.avail_out = unpackedChunk * sizeof(mtpPrime);
-		stream.next_out = (Bytef*)&result[result.size() - unpackedChunk];
-		int res = inflate(&stream, Z_NO_FLUSH);
-		if (res != Z_OK && res != Z_STREAM_END) {
-			inflateEnd(&stream);
-			LOG(("RPC Error: could not unpack gziped data, code: %1").arg(res));
-			DEBUG_LOG(("RPC Error: bad gzip: %1").arg(Logs::mb(packed.v.constData(), packedLen).str()));
-			return mtpBuffer();
-		}
-	}
-	if (stream.avail_out & 0x03) {
-		uint32 badSize = result.size() * sizeof(mtpPrime) - stream.avail_out;
-		LOG(("RPC Error: bad length of unpacked data %1").arg(badSize));
-		DEBUG_LOG(("RPC Error: bad unpacked data %1").arg(Logs::mb(result.data(), badSize).str()));
-		return mtpBuffer();
-	}
-	result.resize(result.size() - (stream.avail_out >> 2));
-	inflateEnd(&stream);
-	if (!result.size()) {
-		LOG(("RPC Error: bad length of unpacked data 0"));
-	}
-	return result;
-}
-
-bool ConnectionPrivate::requestsFixTimeSalt(const QVector<MTPlong> &ids, int32 serverTime, uint64 serverSalt) {
-	uint32 idsCount = ids.size();
-
-	for (uint32 i = 0; i < idsCount; ++i) {
-		if (wasSent(ids[i].v)) {// found such msg_id in recent acked requests or in recent sent requests
-			if (serverSalt) sessionData->setSalt(serverSalt);
-			base::unixtime::update(serverTime, true);
-			return true;
-		}
-	}
-	return false;
-}
-
-void ConnectionPrivate::requestsAcked(const QVector<MTPlong> &ids, bool byResponse) {
-	uint32 idsCount = ids.size();
-
-	DEBUG_LOG(("Message Info: requests acked, ids %1").arg(LogIdsVector(ids)));
-
-	auto clearedBecauseTooOld = std::vector<RPCCallbackClear>();
-	QVector<MTPlong> toAckMore;
-	{
-		QWriteLocker locker1(sessionData->wereAckedMutex());
-		auto &wereAcked = sessionData->wereAckedMap();
-
-		{
-			QWriteLocker locker2(sessionData->haveSentMutex());
-			auto &haveSent = sessionData->haveSentMap();
-
-			for (uint32 i = 0; i < idsCount; ++i) {
-				mtpMsgId msgId = ids[i].v;
-				const auto req = haveSent.find(msgId);
-				if (req != haveSent.cend()) {
-					if (!req.value()->msDate) {
-						DEBUG_LOG(("Message Info: container ack received, msgId %1").arg(ids[i].v));
-						uint32 inContCount = ((*req)->size() - 8) / 2;
-						const mtpMsgId *inContId = (const mtpMsgId *)(req.value()->constData() + 8);
-						toAckMore.reserve(toAckMore.size() + inContCount);
-						for (uint32 j = 0; j < inContCount; ++j) {
-							toAckMore.push_back(MTP_long(*(inContId++)));
-						}
-						haveSent.erase(req);
-					} else {
-						mtpRequestId reqId = req.value()->requestId;
-						bool moveToAcked = byResponse;
-						if (!moveToAcked) { // ignore ACK, if we need a response (if we have a handler)
-							moveToAcked = !_instance->hasCallbacks(reqId);
-						}
-						if (moveToAcked) {
-							wereAcked.insert(msgId, reqId);
-							haveSent.erase(req);
-						} else {
-							DEBUG_LOG(("Message Info: ignoring ACK for msgId %1 because request %2 requires a response").arg(msgId).arg(reqId));
-						}
-					}
-				} else {
-					DEBUG_LOG(("Message Info: msgId %1 was not found in recent sent, while acking requests, searching in resend...").arg(msgId));
-					QWriteLocker locker3(sessionData->toResendMutex());
-					auto &toResend = sessionData->toResendMap();
-					const auto reqIt = toResend.find(msgId);
-					if (reqIt != toResend.cend()) {
-						const auto reqId = reqIt.value();
-						bool moveToAcked = byResponse;
-						if (!moveToAcked) { // ignore ACK, if we need a response (if we have a handler)
-							moveToAcked = !_instance->hasCallbacks(reqId);
-						}
-						if (moveToAcked) {
-							QWriteLocker locker4(sessionData->toSendMutex());
-							auto &toSend = sessionData->toSendMap();
-							const auto req = toSend.find(reqId);
-							if (req != toSend.cend()) {
-								wereAcked.insert(msgId, req.value()->requestId);
-								if (req.value()->requestId != reqId) {
-									DEBUG_LOG(("Message Error: for msgId %1 found resent request, requestId %2, contains requestId %3").arg(msgId).arg(reqId).arg(req.value()->requestId));
-								} else {
-									DEBUG_LOG(("Message Info: acked msgId %1 that was prepared to resend, requestId %2").arg(msgId).arg(reqId));
-								}
-								toSend.erase(req);
-							} else {
-								DEBUG_LOG(("Message Info: msgId %1 was found in recent resent, requestId %2 was not found in prepared to send").arg(msgId));
-							}
-							toResend.erase(reqIt);
-						} else {
-							DEBUG_LOG(("Message Info: ignoring ACK for msgId %1 because request %2 requires a response").arg(msgId).arg(reqId));
-						}
-					} else {
-						DEBUG_LOG(("Message Info: msgId %1 was not found in recent resent either").arg(msgId));
-					}
-				}
-			}
-		}
-
-		uint32 ackedCount = wereAcked.size();
-		if (ackedCount > kIdsBufferSize) {
-			DEBUG_LOG(("Message Info: removing some old acked sent msgIds %1").arg(ackedCount - kIdsBufferSize));
-			clearedBecauseTooOld.reserve(ackedCount - kIdsBufferSize);
-			while (ackedCount-- > kIdsBufferSize) {
-				auto i = wereAcked.begin();
-				clearedBecauseTooOld.push_back(RPCCallbackClear(
-					i.value(),
-					RPCError::TimeoutError));
-				wereAcked.erase(i);
-			}
-		}
-	}
-
-	if (!clearedBecauseTooOld.empty()) {
-		_instance->clearCallbacksDelayed(std::move(clearedBecauseTooOld));
-	}
-
-	if (toAckMore.size()) {
-		requestsAcked(toAckMore);
-	}
-}
-
-void ConnectionPrivate::handleMsgsStates(const QVector<MTPlong> &ids, const QByteArray &states, QVector<MTPlong> &acked) {
-	uint32 idsCount = ids.size();
-	if (!idsCount) {
-		DEBUG_LOG(("Message Info: void ids vector in handleMsgsStates()"));
-		return;
-	}
-	if (states.size() < idsCount) {
-		LOG(("Message Error: got less states than required ids count."));
-		return;
-	}
-
-	acked.reserve(acked.size() + idsCount);
-	for (uint32 i = 0, count = idsCount; i < count; ++i) {
-		char state = states[i];
-		uint64 requestMsgId = ids[i].v;
-		{
-			QReadLocker locker(sessionData->haveSentMutex());
-			const auto &haveSent = sessionData->haveSentMap();
-			const auto haveSentEnd = haveSent.cend();
-			if (haveSent.find(requestMsgId) == haveSentEnd) {
-				DEBUG_LOG(("Message Info: state was received for msgId %1, but request is not found, looking in resent requests...").arg(requestMsgId));
-				QWriteLocker locker2(sessionData->toResendMutex());
-				auto &toResend = sessionData->toResendMap();
-				const auto reqIt = toResend.find(requestMsgId);
-				if (reqIt != toResend.cend()) {
-					if ((state & 0x07) != 0x04) { // was received
-						DEBUG_LOG(("Message Info: state was received for msgId %1, state %2, already resending in container").arg(requestMsgId).arg((int32)state));
-					} else {
-						DEBUG_LOG(("Message Info: state was received for msgId %1, state %2, ack, cancelling resend").arg(requestMsgId).arg((int32)state));
-						acked.push_back(MTP_long(requestMsgId)); // will remove from resend in requestsAcked
-					}
-				} else {
-					DEBUG_LOG(("Message Info: msgId %1 was not found in recent resent either").arg(requestMsgId));
-				}
-				continue;
-			}
-		}
-		if ((state & 0x07) != 0x04) { // was received
-			DEBUG_LOG(("Message Info: state was received for msgId %1, state %2, resending in container").arg(requestMsgId).arg((int32)state));
-			resend(requestMsgId, 10, true);
-		} else {
-			DEBUG_LOG(("Message Info: state was received for msgId %1, state %2, ack").arg(requestMsgId).arg((int32)state));
-			acked.push_back(MTP_long(requestMsgId));
-		}
-	}
-}
-
-void ConnectionPrivate::resend(quint64 msgId, qint64 msCanWait, bool forceContainer, bool sendMsgStateInfo) {
-	if (msgId == _pingMsgId) return;
-	emit resendAsync(msgId, msCanWait, forceContainer, sendMsgStateInfo);
-}
-
-void ConnectionPrivate::resendMany(QVector<quint64> msgIds, qint64 msCanWait, bool forceContainer, bool sendMsgStateInfo) {
-	for (int32 i = 0, l = msgIds.size(); i < l; ++i) {
-		if (msgIds.at(i) == _pingMsgId) {
-			msgIds.remove(i);
-			--l;
-		}
-	}
-	emit resendManyAsync(msgIds, msCanWait, forceContainer, sendMsgStateInfo);
-}
-
-void ConnectionPrivate::onConnected(
-		not_null<AbstractConnection*> connection) {
-	QReadLocker lockFinished(&sessionDataMutex);
-	if (!sessionData) return;
-
-	disconnect(connection, &AbstractConnection::connected, nullptr, nullptr);
-	if (!connection->isConnected()) {
-		LOG(("Connection Error: not connected in onConnected(), "
-			"state: %1").arg(connection->debugState()));
-
-		lockFinished.unlock();
-		return restart();
-	}
-
-	_waitForConnected = kMinConnectedTimeout;
-	_waitForConnectedTimer.cancel();
-
-	const auto i = ranges::find(
-		_testConnections,
-		connection.get(),
-		[](const TestConnection &test) { return test.data.get(); });
-	Assert(i != end(_testConnections));
-	const auto my = i->priority;
-	const auto j = ranges::find_if(
-		_testConnections,
-		[&](const TestConnection &test) { return test.priority > my; });
-	if (j != end(_testConnections)) {
-		DEBUG_LOG(("MTP Info: connection %1 succeed, "
-			"waiting for %2.").arg(i->data->tag()).arg(j->data->tag()));
-		_waitForBetterTimer.callOnce(kWaitForBetterTimeout);
-	} else {
-		DEBUG_LOG(("MTP Info: connection through IPv4 succeed."));
-		_waitForBetterTimer.cancel();
-		_connection = std::move(i->data);
-		_testConnections.clear();
-
-		lockFinished.unlock();
-		updateAuthKey();
-	}
-}
-
-void ConnectionPrivate::onDisconnected(
-		not_null<AbstractConnection*> connection) {
-	removeTestConnection(connection);
-
-	if (_testConnections.empty()) {
-		destroyAllConnections();
-		restart();
-	} else {
-		confirmBestConnection();
-	}
-}
-
-void ConnectionPrivate::confirmBestConnection() {
-	if (_waitForBetterTimer.isActive()) {
-		return;
-	}
-	const auto i = ranges::max_element(
-		_testConnections,
-		std::less<>(),
-		[](const TestConnection &test) {
-			return test.data->isConnected() ? test.priority : -1;
-		});
-	Assert(i != end(_testConnections));
-	if (!i->data->isConnected()) {
-		return;
-	}
-
-	DEBUG_LOG(("MTP Info: can't connect through better, using %1."
-		).arg(i->data->tag()));
-
-	_connection = std::move(i->data);
-	_testConnections.clear();
-
-	updateAuthKey();
-}
-
-void ConnectionPrivate::removeTestConnection(
-		not_null<AbstractConnection*> connection) {
-	_testConnections.erase(
-		ranges::remove(
-			_testConnections,
-			connection.get(),
-			[](const TestConnection &test) { return test.data.get(); }),
-		end(_testConnections));
-}
-
-void ConnectionPrivate::updateAuthKey() 	{
-	QReadLocker lockFinished(&sessionDataMutex);
-	if (!sessionData || !_connection) return;
-
-	DEBUG_LOG(("AuthKey Info: Connection updating key from Session, dc %1").arg(_shiftedDcId));
-	uint64 newKeyId = 0;
-	{
-		ReadLockerAttempt lock(sessionData->keyMutex());
-		if (!lock) {
-			DEBUG_LOG(("MTP Info: could not lock auth_key for read, waiting signal emit"));
-			clearMessages();
-			keyId = newKeyId;
-			return; // some other connection is getting key
-		}
-		auto key = sessionData->getKey();
-		newKeyId = key ? key->keyId() : 0;
-	}
-	if (keyId != newKeyId) {
-		clearMessages();
-		keyId = newKeyId;
-	}
-	DEBUG_LOG(("AuthKey Info: Connection update key from Session, dc %1 result: %2").arg(_shiftedDcId).arg(Logs::mb(&keyId, sizeof(keyId)).str()));
-	if (keyId) {
-		return authKeyCreated();
-	}
-
-	DEBUG_LOG(("AuthKey Info: No key in updateAuthKey(), will be creating auth_key"));
-	lockKey();
-
-	auto &key = sessionData->getKey();
-	if (key) {
-		if (keyId != key->keyId()) clearMessages();
-		keyId = key->keyId();
-		unlockKey();
-		return authKeyCreated();
-	} else if (_instance->isKeysDestroyer()) {
-		// We are here to destroy an old key, so we're done.
-		LOG(("MTP Error: No key %1 in updateAuthKey() for destroying.").arg(_shiftedDcId));
-		emit _instance->keyDestroyed(_shiftedDcId);
-		return;
-	}
-
-	_authKeyData = std::make_unique<ConnectionPrivate::AuthKeyCreateData>();
-	_authKeyStrings = std::make_unique<ConnectionPrivate::AuthKeyCreateStrings>();
-	const auto nonce = _authKeyData->nonce = rand_value<MTPint128>();
-
-	connect(_connection, &AbstractConnection::receivedData, [=] {
-		pqAnswered();
-	});
-
-	DEBUG_LOG(("AuthKey Info: sending Req_pq..."));
-	lockFinished.unlock();
-
-	sendNotSecureRequest(MTPReq_pq_multi(nonce));
-}
-
-void ConnectionPrivate::clearMessages() {
-	if (keyId && keyId != kRecreateKeyId && _connection) {
-		_connection->received().clear();
-	}
-}
-
-void ConnectionPrivate::pqAnswered() {
-	disconnect(_connection, &AbstractConnection::receivedData, nullptr, nullptr);
-	DEBUG_LOG(("AuthKey Info: receiving Req_pq answer..."));
-
-	MTPReq_pq::ResponseType res_pq;
-	if (!readNotSecureResponse(res_pq)) {
-		return restart();
-	}
-
-	auto &res_pq_data = res_pq.c_resPQ();
-	if (res_pq_data.vnonce() != _authKeyData->nonce) {
-		LOG(("AuthKey Error: received nonce <> sent nonce (in res_pq)!"));
-		DEBUG_LOG(("AuthKey Error: received nonce: %1, sent nonce: %2").arg(Logs::mb(&res_pq_data.vnonce(), 16).str()).arg(Logs::mb(&_authKeyData->nonce, 16).str()));
-		return restart();
-	}
-
-	auto rsaKey = internal::RSAPublicKey();
-	if (!_instance->dcOptions()->getDcRSAKey(BareDcId(_shiftedDcId), res_pq.c_resPQ().vserver_public_key_fingerprints().v, &rsaKey)) {
-		if (_dcType == DcType::Cdn) {
-			LOG(("Warning: CDN public RSA key not found"));
-			requestCDNConfig();
-			return;
-		}
-		LOG(("AuthKey Error: could not choose public RSA key"));
-		return restart();
-	}
-	Assert(rsaKey.isValid());
-
-	_authKeyData->server_nonce = res_pq_data.vserver_nonce();
-	_authKeyData->new_nonce = rand_value<MTPint256>();
-
-	auto &pq = res_pq_data.vpq().v;
-	auto p = QByteArray();
-	auto q = QByteArray();
-	if (!internal::parsePQ(pq, p, q)) {
-		LOG(("AuthKey Error: could not factor pq!"));
-		DEBUG_LOG(("AuthKey Error: problematic pq: %1").arg(Logs::mb(pq.constData(), pq.length()).str()));
-		return restart();
-	}
-
-	auto p_q_inner = MTP_p_q_inner_data_dc(
-		res_pq_data.vpq(),
-		MTP_bytes(std::move(p)),
-		MTP_bytes(std::move(q)),
-		_authKeyData->nonce,
-		_authKeyData->server_nonce,
-		_authKeyData->new_nonce,
-		MTP_int(getProtocolDcId()));
-	auto dhEncString = encryptPQInnerRSA(p_q_inner, rsaKey);
-	if (dhEncString.empty()) {
-		return restart();
-	}
-
-	connect(_connection, &AbstractConnection::receivedData, [=] {
-		dhParamsAnswered();
-	});
-
-	DEBUG_LOG(("AuthKey Info: sending Req_DH_params..."));
-
-	sendNotSecureRequest(MTPReq_DH_params(
-		_authKeyData->nonce,
-		_authKeyData->server_nonce,
-		p_q_inner.c_p_q_inner_data_dc().vp(),
-		p_q_inner.c_p_q_inner_data_dc().vq(),
-		MTP_long(rsaKey.getFingerPrint()),
-		MTP_bytes(dhEncString)));
-}
-
-bytes::vector ConnectionPrivate::encryptPQInnerRSA(
-		const MTPP_Q_inner_data &data,
-		const internal::RSAPublicKey &key) {
-	auto p_q_inner_size = tl::count_length(data);
-	auto encSize = (p_q_inner_size >> 2) + 6;
-	if (encSize >= 65) {
-		auto tmp = mtpBuffer();
-		tmp.reserve(encSize);
-		data.write(tmp);
-		LOG(("AuthKey Error: too large data for RSA encrypt, size %1").arg(encSize * sizeof(mtpPrime)));
-		DEBUG_LOG(("AuthKey Error: bad data for RSA encrypt %1").arg(Logs::mb(&tmp[0], tmp.size() * 4).str()));
-		return {}; // can't be 255-byte string
-	}
-
-	auto encBuffer = mtpBuffer();
-	encBuffer.reserve(65); // 260 bytes
-	encBuffer.resize(6);
-	encBuffer[0] = 0;
-	data.write(encBuffer);
-
-	hashSha1(&encBuffer[6], p_q_inner_size, &encBuffer[1]);
-	if (encSize < 65) {
-		encBuffer.resize(65);
-		memset_rand(&encBuffer[encSize], (65 - encSize) * sizeof(mtpPrime));
-	}
-
-	auto bytes = bytes::make_span(encBuffer);
-	auto bytesToEncrypt = bytes.subspan(3, 256);
-	return key.encrypt(bytesToEncrypt);
-}
-
-void ConnectionPrivate::dhParamsAnswered() {
-	disconnect(_connection, &AbstractConnection::receivedData, nullptr, nullptr);
-	DEBUG_LOG(("AuthKey Info: receiving Req_DH_params answer..."));
-
-	MTPReq_DH_params::ResponseType res_DH_params;
-	if (!readNotSecureResponse(res_DH_params)) {
-		return restart();
-	}
-
-	switch (res_DH_params.type()) {
-	case mtpc_server_DH_params_ok: {
-		const auto &encDH(res_DH_params.c_server_DH_params_ok());
-		if (encDH.vnonce() != _authKeyData->nonce) {
-			LOG(("AuthKey Error: received nonce <> sent nonce (in server_DH_params_ok)!"));
-			DEBUG_LOG(("AuthKey Error: received nonce: %1, sent nonce: %2").arg(Logs::mb(&encDH.vnonce(), 16).str()).arg(Logs::mb(&_authKeyData->nonce, 16).str()));
-			return restart();
-		}
-		if (encDH.vserver_nonce() != _authKeyData->server_nonce) {
-			LOG(("AuthKey Error: received server_nonce <> sent server_nonce (in server_DH_params_ok)!"));
-			DEBUG_LOG(("AuthKey Error: received server_nonce: %1, sent server_nonce: %2").arg(Logs::mb(&encDH.vserver_nonce(), 16).str()).arg(Logs::mb(&_authKeyData->server_nonce, 16).str()));
-			return restart();
-		}
-
-		auto &encDHStr = encDH.vencrypted_answer().v;
-		uint32 encDHLen = encDHStr.length(), encDHBufLen = encDHLen >> 2;
-		if ((encDHLen & 0x03) || encDHBufLen < 6) {
-			LOG(("AuthKey Error: bad encrypted data length %1 (in server_DH_params_ok)!").arg(encDHLen));
-			DEBUG_LOG(("AuthKey Error: received encrypted data %1").arg(Logs::mb(encDHStr.constData(), encDHLen).str()));
-			return restart();
-		}
-
-		uint32 nlen = tl::count_length(_authKeyData->new_nonce), slen = tl::count_length(_authKeyData->server_nonce);
-		uchar tmp_aes[1024], sha1ns[20], sha1sn[20], sha1nn[20];
-		memcpy(tmp_aes, &_authKeyData->new_nonce, nlen);
-		memcpy(tmp_aes + nlen, &_authKeyData->server_nonce, slen);
-		memcpy(tmp_aes + nlen + slen, &_authKeyData->new_nonce, nlen);
-		memcpy(tmp_aes + nlen + slen + nlen, &_authKeyData->new_nonce, nlen);
-		hashSha1(tmp_aes, nlen + slen, sha1ns);
-		hashSha1(tmp_aes + nlen, nlen + slen, sha1sn);
-		hashSha1(tmp_aes + nlen + slen, nlen + nlen, sha1nn);
-
-		mtpBuffer decBuffer;
-		decBuffer.resize(encDHBufLen);
-
-		memcpy(_authKeyData->aesKey, sha1ns, 20);
-		memcpy(_authKeyData->aesKey + 20, sha1sn, 12);
-		memcpy(_authKeyData->aesIV, sha1sn + 12, 8);
-		memcpy(_authKeyData->aesIV + 8, sha1nn, 20);
-		memcpy(_authKeyData->aesIV + 28, &_authKeyData->new_nonce, 4);
-
-		aesIgeDecryptRaw(encDHStr.constData(), &decBuffer[0], encDHLen, _authKeyData->aesKey, _authKeyData->aesIV);
-
-		const mtpPrime *from(&decBuffer[5]), *to(from), *end(from + (encDHBufLen - 5));
-		MTPServer_DH_inner_data dh_inner;
-		if (!dh_inner.read(to, end)) {
-			LOG(("AuthKey Error: could not decrypt server_DH_inner_data!"));
-			return restart();
-		}
-		const auto &dh_inner_data(dh_inner.c_server_DH_inner_data());
-		if (dh_inner_data.vnonce() != _authKeyData->nonce) {
-			LOG(("AuthKey Error: received nonce <> sent nonce (in server_DH_inner_data)!"));
-			DEBUG_LOG(("AuthKey Error: received nonce: %1, sent nonce: %2").arg(Logs::mb(&dh_inner_data.vnonce(), 16).str()).arg(Logs::mb(&_authKeyData->nonce, 16).str()));
-			return restart();
-		}
-		if (dh_inner_data.vserver_nonce() != _authKeyData->server_nonce) {
-			LOG(("AuthKey Error: received server_nonce <> sent server_nonce (in server_DH_inner_data)!"));
-			DEBUG_LOG(("AuthKey Error: received server_nonce: %1, sent server_nonce: %2").arg(Logs::mb(&dh_inner_data.vserver_nonce(), 16).str()).arg(Logs::mb(&_authKeyData->server_nonce, 16).str()));
-			return restart();
-		}
-		uchar sha1Buffer[20];
-		if (memcmp(&decBuffer[0], hashSha1(&decBuffer[5], (to - from) * sizeof(mtpPrime), sha1Buffer), 20)) {
-			LOG(("AuthKey Error: sha1 hash of encrypted part did not match!"));
-			DEBUG_LOG(("AuthKey Error: sha1 did not match, server_nonce: %1, new_nonce %2, encrypted data %3").arg(Logs::mb(&_authKeyData->server_nonce, 16).str()).arg(Logs::mb(&_authKeyData->new_nonce, 16).str()).arg(Logs::mb(encDHStr.constData(), encDHLen).str()));
-			return restart();
-		}
-		base::unixtime::update(dh_inner_data.vserver_time().v);
-
-		// check that dhPrime and (dhPrime - 1) / 2 are really prime
-		if (!IsPrimeAndGood(bytes::make_span(dh_inner_data.vdh_prime().v), dh_inner_data.vg().v)) {
-			LOG(("AuthKey Error: bad dh_prime primality!"));
-			return restart();
-		}
-
-		_authKeyStrings->dh_prime = bytes::make_vector(
-			dh_inner_data.vdh_prime().v);
-		_authKeyData->g = dh_inner_data.vg().v;
-		_authKeyStrings->g_a = bytes::make_vector(dh_inner_data.vg_a().v);
-		_authKeyData->retry_id = MTP_long(0);
-		_authKeyData->retries = 0;
-	} return dhClientParamsSend();
-
-	case mtpc_server_DH_params_fail: {
-		const auto &encDH(res_DH_params.c_server_DH_params_fail());
-		if (encDH.vnonce() != _authKeyData->nonce) {
-			LOG(("AuthKey Error: received nonce <> sent nonce (in server_DH_params_fail)!"));
-			DEBUG_LOG(("AuthKey Error: received nonce: %1, sent nonce: %2").arg(Logs::mb(&encDH.vnonce(), 16).str()).arg(Logs::mb(&_authKeyData->nonce, 16).str()));
-			return restart();
-		}
-		if (encDH.vserver_nonce() != _authKeyData->server_nonce) {
-			LOG(("AuthKey Error: received server_nonce <> sent server_nonce (in server_DH_params_fail)!"));
-			DEBUG_LOG(("AuthKey Error: received server_nonce: %1, sent server_nonce: %2").arg(Logs::mb(&encDH.vserver_nonce(), 16).str()).arg(Logs::mb(&_authKeyData->server_nonce, 16).str()));
-			return restart();
-		}
-		uchar sha1Buffer[20];
-		if (encDH.vnew_nonce_hash() != *(MTPint128*)(hashSha1(&_authKeyData->new_nonce, 32, sha1Buffer) + 1)) {
-			LOG(("AuthKey Error: received new_nonce_hash did not match!"));
-			DEBUG_LOG(("AuthKey Error: received new_nonce_hash: %1, new_nonce: %2").arg(Logs::mb(&encDH.vnew_nonce_hash(), 16).str()).arg(Logs::mb(&_authKeyData->new_nonce, 32).str()));
-			return restart();
-		}
-		LOG(("AuthKey Error: server_DH_params_fail received!"));
-	} return restart();
-
-	}
-	LOG(("AuthKey Error: unknown server_DH_params received, typeId = %1").arg(res_DH_params.type()));
-	return restart();
-}
-
-void ConnectionPrivate::dhClientParamsSend() {
-	if (++_authKeyData->retries > 5) {
-		LOG(("AuthKey Error: could not create auth_key for %1 retries").arg(_authKeyData->retries - 1));
-		return restart();
-	}
-
-	// gen rand 'b'
-	auto randomSeed = bytes::vector(ModExpFirst::kRandomPowerSize);
-	bytes::set_random(randomSeed);
-	auto g_b_data = CreateModExp(_authKeyData->g, _authKeyStrings->dh_prime, randomSeed);
-	if (g_b_data.modexp.empty()) {
-		LOG(("AuthKey Error: could not generate good g_b."));
-		return restart();
-	}
-
-	auto computedAuthKey = CreateAuthKey(_authKeyStrings->g_a, g_b_data.randomPower, _authKeyStrings->dh_prime);
-	if (computedAuthKey.empty()) {
-		LOG(("AuthKey Error: could not generate auth_key."));
-		return restart();
-	}
-	AuthKey::FillData(_authKeyStrings->auth_key, computedAuthKey);
-
-	// count auth_key hashes - parts of sha1(auth_key)
-	auto auth_key_sha = hashSha1(_authKeyStrings->auth_key.data(), _authKeyStrings->auth_key.size());
-	memcpy(&_authKeyData->auth_key_aux_hash, auth_key_sha.data(), 8);
-	memcpy(&_authKeyData->auth_key_hash, auth_key_sha.data() + 12, 8);
-
-	auto client_dh_inner = MTP_client_DH_inner_data(_authKeyData->nonce, _authKeyData->server_nonce, _authKeyData->retry_id, MTP_bytes(g_b_data.modexp));
-
-	auto sdhEncString = encryptClientDHInner(client_dh_inner);
-
-	connect(_connection, &AbstractConnection::receivedData, [=] {
-		dhClientParamsAnswered();
-	});
-
-	DEBUG_LOG(("AuthKey Info: sending Req_client_DH_params..."));
-	sendNotSecureRequest(MTPSet_client_DH_params(
-		_authKeyData->nonce,
-		_authKeyData->server_nonce,
-		MTP_string(std::move(sdhEncString))));
-}
-
-std::string ConnectionPrivate::encryptClientDHInner(const MTPClient_DH_Inner_Data &data) {
-	auto client_dh_inner_size = tl::count_length(data);
-	auto encSize = (client_dh_inner_size >> 2) + 5;
-	auto encFullSize = encSize;
-	if (encSize & 0x03) {
-		encFullSize += 4 - (encSize & 0x03);
-	}
-
-	auto encBuffer = mtpBuffer();
-	encBuffer.reserve(encFullSize);
-	encBuffer.resize(5);
-	data.write(encBuffer);
-
-	hashSha1(&encBuffer[5], client_dh_inner_size, &encBuffer[0]);
-	if (encSize < encFullSize) {
-		encBuffer.resize(encFullSize);
-		memset_rand(&encBuffer[encSize], (encFullSize - encSize) * sizeof(mtpPrime));
-	}
-
-	auto sdhEncString = std::string(encFullSize * 4, ' ');
-
-	aesIgeEncryptRaw(&encBuffer[0], &sdhEncString[0], encFullSize * sizeof(mtpPrime), _authKeyData->aesKey, _authKeyData->aesIV);
-
-	return sdhEncString;
-}
-
-void ConnectionPrivate::dhClientParamsAnswered() {
-	QReadLocker lockFinished(&sessionDataMutex);
-	if (!sessionData) return;
-
-	disconnect(_connection, &AbstractConnection::receivedData, nullptr, nullptr);
-	DEBUG_LOG(("AuthKey Info: receiving Req_client_DH_params answer..."));
-
-	MTPSet_client_DH_params::ResponseType res_client_DH_params;
-	if (!readNotSecureResponse(res_client_DH_params)) {
-		lockFinished.unlock();
-		return restart();
-	}
-
-	switch (res_client_DH_params.type()) {
-	case mtpc_dh_gen_ok: {
-		const auto &resDH(res_client_DH_params.c_dh_gen_ok());
-		if (resDH.vnonce() != _authKeyData->nonce) {
-			LOG(("AuthKey Error: received nonce <> sent nonce (in dh_gen_ok)!"));
-			DEBUG_LOG(("AuthKey Error: received nonce: %1, sent nonce: %2").arg(Logs::mb(&resDH.vnonce(), 16).str()).arg(Logs::mb(&_authKeyData->nonce, 16).str()));
-
-			lockFinished.unlock();
-			return restart();
-		}
-		if (resDH.vserver_nonce() != _authKeyData->server_nonce) {
-			LOG(("AuthKey Error: received server_nonce <> sent server_nonce (in dh_gen_ok)!"));
-			DEBUG_LOG(("AuthKey Error: received server_nonce: %1, sent server_nonce: %2").arg(Logs::mb(&resDH.vserver_nonce(), 16).str()).arg(Logs::mb(&_authKeyData->server_nonce, 16).str()));
-
-			lockFinished.unlock();
-			return restart();
-		}
-		_authKeyData->new_nonce_buf[32] = 1;
-		uchar sha1Buffer[20];
-		if (resDH.vnew_nonce_hash1() != *(MTPint128*)(hashSha1(_authKeyData->new_nonce_buf, 41, sha1Buffer) + 1)) {
-			LOG(("AuthKey Error: received new_nonce_hash1 did not match!"));
-			DEBUG_LOG(("AuthKey Error: received new_nonce_hash1: %1, new_nonce_buf: %2").arg(Logs::mb(&resDH.vnew_nonce_hash1(), 16).str()).arg(Logs::mb(_authKeyData->new_nonce_buf, 41).str()));
-
-			lockFinished.unlock();
-			return restart();
-		}
-
-		uint64 salt1 = _authKeyData->new_nonce.l.l, salt2 = _authKeyData->server_nonce.l, serverSalt = salt1 ^ salt2;
-		sessionData->setSalt(serverSalt);
-
-		auto authKey = std::make_shared<AuthKey>(AuthKey::Type::Generated, BareDcId(_shiftedDcId), _authKeyStrings->auth_key);
-
-		DEBUG_LOG(("AuthKey Info: auth key gen succeed, id: %1, server salt: %2").arg(authKey->keyId()).arg(serverSalt));
-
-		sessionData->owner()->notifyKeyCreated(std::move(authKey)); // slot will call authKeyCreated()
-		sessionData->clear(_instance);
-		unlockKey();
-	} return;
-
-	case mtpc_dh_gen_retry: {
-		const auto &resDH(res_client_DH_params.c_dh_gen_retry());
-		if (resDH.vnonce() != _authKeyData->nonce) {
-			LOG(("AuthKey Error: received nonce <> sent nonce (in dh_gen_retry)!"));
-			DEBUG_LOG(("AuthKey Error: received nonce: %1, sent nonce: %2").arg(Logs::mb(&resDH.vnonce(), 16).str()).arg(Logs::mb(&_authKeyData->nonce, 16).str()));
-
-			lockFinished.unlock();
-			return restart();
-		}
-		if (resDH.vserver_nonce() != _authKeyData->server_nonce) {
-			LOG(("AuthKey Error: received server_nonce <> sent server_nonce (in dh_gen_retry)!"));
-			DEBUG_LOG(("AuthKey Error: received server_nonce: %1, sent server_nonce: %2").arg(Logs::mb(&resDH.vserver_nonce(), 16).str()).arg(Logs::mb(&_authKeyData->server_nonce, 16).str()));
-
-			lockFinished.unlock();
-			return restart();
-		}
-		_authKeyData->new_nonce_buf[32] = 2;
-		uchar sha1Buffer[20];
-		if (resDH.vnew_nonce_hash2() != *(MTPint128*)(hashSha1(_authKeyData->new_nonce_buf, 41, sha1Buffer) + 1)) {
-			LOG(("AuthKey Error: received new_nonce_hash2 did not match!"));
-			DEBUG_LOG(("AuthKey Error: received new_nonce_hash2: %1, new_nonce_buf: %2").arg(Logs::mb(&resDH.vnew_nonce_hash2(), 16).str()).arg(Logs::mb(_authKeyData->new_nonce_buf, 41).str()));
-
-			lockFinished.unlock();
-			return restart();
-		}
-		_authKeyData->retry_id = _authKeyData->auth_key_aux_hash;
-	} return dhClientParamsSend();
-
-	case mtpc_dh_gen_fail: {
-		const auto &resDH(res_client_DH_params.c_dh_gen_fail());
-		if (resDH.vnonce() != _authKeyData->nonce) {
-			LOG(("AuthKey Error: received nonce <> sent nonce (in dh_gen_fail)!"));
-			DEBUG_LOG(("AuthKey Error: received nonce: %1, sent nonce: %2").arg(Logs::mb(&resDH.vnonce(), 16).str()).arg(Logs::mb(&_authKeyData->nonce, 16).str()));
-
-			lockFinished.unlock();
-			return restart();
-		}
-		if (resDH.vserver_nonce() != _authKeyData->server_nonce) {
-			LOG(("AuthKey Error: received server_nonce <> sent server_nonce (in dh_gen_fail)!"));
-			DEBUG_LOG(("AuthKey Error: received server_nonce: %1, sent server_nonce: %2").arg(Logs::mb(&resDH.vserver_nonce(), 16).str()).arg(Logs::mb(&_authKeyData->server_nonce, 16).str()));
-
-			lockFinished.unlock();
-			return restart();
-		}
-		_authKeyData->new_nonce_buf[32] = 3;
-		uchar sha1Buffer[20];
-		if (resDH.vnew_nonce_hash3() != *(MTPint128*)(hashSha1(_authKeyData->new_nonce_buf, 41, sha1Buffer) + 1)) {
-			LOG(("AuthKey Error: received new_nonce_hash3 did not match!"));
-			DEBUG_LOG(("AuthKey Error: received new_nonce_hash3: %1, new_nonce_buf: %2").arg(Logs::mb(&resDH.vnew_nonce_hash3(), 16).str()).arg(Logs::mb(_authKeyData->new_nonce_buf, 41).str()));
-
-			lockFinished.unlock();
-			return restart();
-		}
-		LOG(("AuthKey Error: dh_gen_fail received!"));
-	}
-
-		lockFinished.unlock();
-		return restart();
-
-	}
-	LOG(("AuthKey Error: unknown set_client_DH_params_answer received, typeId = %1").arg(res_client_DH_params.type()));
-
-	lockFinished.unlock();
-	return restart();
-}
-
-void ConnectionPrivate::authKeyCreated() {
-	clearAuthKeyData();
-
-	connect(_connection, &AbstractConnection::receivedData, [=] {
-		handleReceived();
-	});
-
-	if (sessionData->getSalt()) { // else receive salt in bad_server_salt first, then try to send all the requests
-		setState(ConnectedState);
-		if (restarted) {
-			emit resendAllAsync();
-			restarted = false;
-		}
-	}
-
-	_pingIdToSend = rand_value<uint64>(); // get server_salt
-
-	emit needToSendAsync();
-}
-
-void ConnectionPrivate::clearAuthKeyData() {
-	auto zeroMemory = [](bytes::span bytes) {
-#ifdef Q_OS_WIN2
-		SecureZeroMemory(bytes.data(), bytes.size());
-#else // Q_OS_WIN
-		auto end = reinterpret_cast<char*>(bytes.data()) + bytes.size();
-		for (volatile auto p = reinterpret_cast<volatile char*>(bytes.data()); p != end; ++p) {
-			*p = 0;
-		}
-#endif // Q_OS_WIN
-	};
-	if (_authKeyData) {
-		zeroMemory(gsl::make_span(reinterpret_cast<gsl::byte*>(_authKeyData.get()), sizeof(AuthKeyCreateData)));
-		_authKeyData.reset();
-	}
-	if (_authKeyStrings) {
-		if (!_authKeyStrings->dh_prime.empty()) {
-			zeroMemory(_authKeyStrings->dh_prime);
-		}
-		if (!_authKeyStrings->g_a.empty()) {
-			zeroMemory(_authKeyStrings->g_a);
-		}
-		zeroMemory(_authKeyStrings->auth_key);
-		_authKeyStrings.reset();
-	}
-}
-
-void ConnectionPrivate::onError(
-		not_null<AbstractConnection*> connection,
-		qint32 errorCode) {
-	if (errorCode == -429) {
-		LOG(("Protocol Error: -429 flood code returned!"));
-	} else if (errorCode == -444) {
-		LOG(("Protocol Error: -444 bad dc_id code returned!"));
-		InvokeQueued(_instance, [instance = _instance] {
-			instance->badConfigurationError();
-		});
-	}
-	removeTestConnection(connection);
-
-	if (_testConnections.empty()) {
-		handleError(errorCode);
-	} else {
-		confirmBestConnection();
-	}
-}
-
-void ConnectionPrivate::handleError(int errorCode) {
-	destroyAllConnections();
-	_waitForConnectedTimer.cancel();
-
-	if (errorCode == -404) {
-		if (_instance->isKeysDestroyer()) {
-			LOG(("MTP Info: -404 error received on destroying key %1, assuming it is destroyed.").arg(_shiftedDcId));
-			emit _instance->keyDestroyed(_shiftedDcId);
-			return;
-		} else if (_dcType == DcType::Cdn) {
-			LOG(("MTP Info: -404 error received in CDN dc %1, assuming it was destroyed, recreating.").arg(_shiftedDcId));
-			clearMessages();
-			keyId = kRecreateKeyId;
-			return restart();
-		}
-	}
-	MTP_LOG(_shiftedDcId, ("Restarting after error in connection, error code: %1...").arg(errorCode));
-	return restart();
-}
-
-void ConnectionPrivate::onReadyData() {
-}
-
-template <typename Request>
-void ConnectionPrivate::sendNotSecureRequest(const Request &request) {
-	auto packet = _connection->prepareNotSecurePacket(
-		request,
-		base::unixtime::mtproto_msg_id());
-
-	DEBUG_LOG(("AuthKey Info: sending request, size: %1, time: %3"
-		).arg(packet.size() - 8
-		).arg(packet[5]));
-
-	const auto bytesSize = packet.size() * sizeof(mtpPrime);
-
-	_connection->sendData(std::move(packet));
-
-	onSentSome(bytesSize);
-}
-
-template <typename Response>
-bool ConnectionPrivate::readNotSecureResponse(Response &response) {
-	onReceivedSome();
-
-	if (_connection->received().empty()) {
-		LOG(("AuthKey Error: "
-			"trying to read response from empty received list"));
-		return false;
-	}
-
-	const auto buffer = std::move(_connection->received().front());
-	_connection->received().pop_front();
-
-	const auto answer = _connection->parseNotSecureResponse(buffer);
-	if (answer.empty()) {
-		return false;
-	}
-	auto from = answer.data();
-	return response.read(from, from + answer.size());
-}
-
-bool ConnectionPrivate::sendSecureRequest(
-		SecureRequest &&request,
-		bool needAnyResponse,
-		QReadLocker &lockFinished) {
-	request.addPadding(_connection->requiresExtendedPadding());
-	uint32 fullSize = request->size();
-	if (fullSize < 9) {
-		return false;
-	}
-
-	auto messageSize = request.messageSize();
-	if (messageSize < 5 || fullSize < messageSize + 4) {
-		return false;
-	}
-
-	auto lock = ReadLockerAttempt(sessionData->keyMutex());
-	if (!lock) {
-		DEBUG_LOG(("MTP Info: could not lock key for read in sendBuffer(), dc %1, restarting...").arg(_shiftedDcId));
-
-		lockFinished.unlock();
-		restart();
-		return false;
-	}
-
-	auto key = sessionData->getKey();
-	if (!key || key->keyId() != keyId) {
-		DEBUG_LOG(("MTP Error: auth_key id for dc %1 changed").arg(_shiftedDcId));
-
-		lockFinished.unlock();
-		restart();
-		return false;
-	}
-
-	auto session = sessionData->getSession();
-	auto salt = sessionData->getSalt();
-
-	memcpy(request->data() + 0, &salt, 2 * sizeof(mtpPrime));
-	memcpy(request->data() + 2, &session, 2 * sizeof(mtpPrime));
-
-	auto from = request->constData() + 4;
-	MTP_LOG(_shiftedDcId, ("Send: ") + mtpTextSerialize(from, from + messageSize));
-
-#ifdef TDESKTOP_MTPROTO_OLD
-	uint32 padding = fullSize - 4 - messageSize;
-
-	uchar encryptedSHA[20];
-	MTPint128 &msgKey(*(MTPint128*)(encryptedSHA + 4));
-	hashSha1(
-		request->constData(),
-		(fullSize - padding) * sizeof(mtpPrime),
-		encryptedSHA);
-
-	auto packet = _connection->prepareSecurePacket(keyId, msgKey, fullSize);
-	const auto prefix = packet.size();
-	packet.resize(prefix + fullSize);
-
-	aesIgeEncrypt_oldmtp(
-		request->constData(),
-		&packet[prefix],
-		fullSize * sizeof(mtpPrime),
-		key,
-		msgKey);
-#else // TDESKTOP_MTPROTO_OLD
-	uchar encryptedSHA256[32];
-	MTPint128 &msgKey(*(MTPint128*)(encryptedSHA256 + 8));
-
-	SHA256_CTX msgKeyLargeContext;
-	SHA256_Init(&msgKeyLargeContext);
-	SHA256_Update(&msgKeyLargeContext, key->partForMsgKey(true), 32);
-	SHA256_Update(&msgKeyLargeContext, request->constData(), fullSize * sizeof(mtpPrime));
-	SHA256_Final(encryptedSHA256, &msgKeyLargeContext);
-
-	auto packet = _connection->prepareSecurePacket(keyId, msgKey, fullSize);
-	const auto prefix = packet.size();
-	packet.resize(prefix + fullSize);
-
-	aesIgeEncrypt(
-		request->constData(),
-		&packet[prefix],
-		fullSize * sizeof(mtpPrime),
-		key,
-		msgKey);
-#endif // TDESKTOP_MTPROTO_OLD
-
-	DEBUG_LOG(("MTP Info: sending request, size: %1, num: %2, time: %3").arg(fullSize + 6).arg((*request)[4]).arg((*request)[5]));
-
-	_connection->setSentEncrypted();
-	_connection->sendData(std::move(packet));
-
-	if (needAnyResponse) {
-		onSentSome((prefix + fullSize) * sizeof(mtpPrime));
-	}
-
-	return true;
-}
-
-mtpRequestId ConnectionPrivate::wasSent(mtpMsgId msgId) const {
-	if (msgId == _pingMsgId) return mtpRequestId(0xFFFFFFFF);
-	{
-		QReadLocker locker(sessionData->haveSentMutex());
-		const auto &haveSent = sessionData->haveSentMap();
-		const auto i = haveSent.constFind(msgId);
-		if (i != haveSent.cend()) {
-			return i.value()->requestId
-				? i.value()->requestId
-				: mtpRequestId(0xFFFFFFFF);
-		}
-	}
-	{
-		QReadLocker locker(sessionData->toResendMutex());
-		const auto &toResend = sessionData->toResendMap();
-		const auto i = toResend.constFind(msgId);
-		if (i != toResend.cend()) return i.value();
-	}
-	{
-		QReadLocker locker(sessionData->wereAckedMutex());
-		const auto &wereAcked = sessionData->wereAckedMap();
-		const auto i = wereAcked.constFind(msgId);
-		if (i != wereAcked.cend()) return i.value();
-	}
-	return 0;
-}
-
-void ConnectionPrivate::lockKey() {
-	unlockKey();
-	sessionData->keyMutex()->lockForWrite();
-	myKeyLock = true;
-}
-
-void ConnectionPrivate::unlockKey() {
-	if (myKeyLock) {
-		myKeyLock = false;
-		sessionData->keyMutex()->unlock();
-	}
-}
-
-ConnectionPrivate::~ConnectionPrivate() {
-	clearAuthKeyData();
-	Assert(_finished && _connection == nullptr && _testConnections.empty());
-}
-
-void ConnectionPrivate::stop() {
-	QWriteLocker lockFinished(&sessionDataMutex);
-	if (sessionData) {
-		if (myKeyLock) {
-			sessionData->owner()->notifyKeyCreated(AuthKeyPtr()); // release key lock, let someone else create it
-			sessionData->keyMutex()->unlock();
-			myKeyLock = false;
-		}
-		sessionData = nullptr;
-	}
-}
-
-} // namespace internal
-
-bool IsPrimeAndGood(bytes::const_span primeBytes, int g) {
-	return internal::IsPrimeAndGood(primeBytes, g);
-}
-
-bool IsGoodModExpFirst(
-		const openssl::BigNum &modexp,
-		const openssl::BigNum &prime) {
-	return internal::IsGoodModExpFirst(modexp, prime);
-}
-
-ModExpFirst CreateModExp(
-		int g,
-		bytes::const_span primeBytes,
-		bytes::const_span randomSeed) {
-	return internal::CreateModExp(g, primeBytes, randomSeed);
-}
-
-bytes::vector CreateAuthKey(
-		bytes::const_span firstBytes,
-		bytes::const_span randomBytes,
-		bytes::const_span primeBytes) {
-	return internal::CreateAuthKey(firstBytes, randomBytes, primeBytes);
-}
-
-} // namespace MTP
diff --git a/Telegram/SourceFiles/mtproto/connection.h b/Telegram/SourceFiles/mtproto/connection.h
deleted file mode 100644
index 3155ddbcf..000000000
--- a/Telegram/SourceFiles/mtproto/connection.h
+++ /dev/null
@@ -1,323 +0,0 @@
-/*
-This file is part of Telegram Desktop,
-the official desktop application for the Telegram messaging service.
-
-For license and copyright information please follow this link:
-https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
-*/
-#pragma once
-
-#include "mtproto/auth_key.h"
-#include "mtproto/dc_options.h"
-#include "mtproto/connection_abstract.h"
-#include "base/openssl_help.h"
-#include "base/timer.h"
-
-namespace MTP {
-
-// How much time to wait for some more requests, when sending msg acks.
-constexpr auto kAckSendWaiting = crl::time(10000);
-
-class Instance;
-
-[[nodiscard]] bool IsPrimeAndGood(bytes::const_span primeBytes, int g);
-struct ModExpFirst {
-	static constexpr auto kRandomPowerSize = 256;
-
-	bytes::vector modexp;
-	bytes::vector randomPower;
-};
-[[nodiscard]] bool IsGoodModExpFirst(
-	const openssl::BigNum &modexp,
-	const openssl::BigNum &prime);
-[[nodiscard]] ModExpFirst CreateModExp(
-	int g,
-	bytes::const_span primeBytes,
-	bytes::const_span randomSeed);
-[[nodiscard]] bytes::vector CreateAuthKey(
-	bytes::const_span firstBytes,
-	bytes::const_span randomBytes,
-	bytes::const_span primeBytes);
-
-namespace internal {
-
-class AbstractConnection;
-class ConnectionPrivate;
-class SessionData;
-class RSAPublicKey;
-struct ConnectionOptions;
-
-class Thread : public QThread {
-	// The Q_OBJECT meta info is used for qobject_cast!
-	Q_OBJECT
-
-public:
-	Thread() {
-		static int ThreadCounter = 0;
-		_threadIndex = ++ThreadCounter;
-	}
-	int getThreadIndex() const {
-		return _threadIndex;
-	}
-
-private:
-	int _threadIndex = 0;
-
-};
-
-class Connection {
-public:
-	enum ConnectionType {
-		TcpConnection,
-		HttpConnection
-	};
-
-	Connection(not_null<Instance*> instance);
-
-	void start(SessionData *data, ShiftedDcId shiftedDcId);
-
-	void kill();
-	void waitTillFinish();
-	~Connection();
-
-	static const int UpdateAlways = 666;
-
-	int32 state() const;
-	QString transport() const;
-
-private:
-	not_null<Instance*> _instance;
-	std::unique_ptr<QThread> _thread;
-	ConnectionPrivate *_private = nullptr;
-
-};
-
-class ConnectionPrivate : public QObject {
-	Q_OBJECT
-
-public:
-	ConnectionPrivate(
-		not_null<Instance*> instance,
-		not_null<QThread*> thread,
-		not_null<Connection*> owner,
-		not_null<SessionData*> data,
-		ShiftedDcId shiftedDcId);
-	~ConnectionPrivate();
-
-	void stop();
-
-	int32 getShiftedDcId() const;
-
-	int32 getState() const;
-	QString transport() const;
-
-signals:
-	void needToReceive();
-	void needToRestart();
-	void stateChanged(qint32 newState);
-	void sessionResetDone();
-
-	void needToSendAsync();
-	void sendAnythingAsync(qint64 msWait);
-	void sendHttpWaitAsync();
-	void sendPongAsync(quint64 msgId, quint64 pingId);
-	void sendMsgsStateInfoAsync(quint64 msgId, QByteArray data);
-	void resendAsync(quint64 msgId, qint64 msCanWait, bool forceContainer, bool sendMsgStateInfo);
-	void resendManyAsync(QVector<quint64> msgIds, qint64 msCanWait, bool forceContainer, bool sendMsgStateInfo);
-	void resendAllAsync();
-
-	void finished(internal::Connection *connection);
-
-public slots:
-	void restartNow();
-
-	void onPingSendForce();
-
-	void onSentSome(uint64 size);
-	void onReceivedSome();
-
-	void onReadyData();
-
-	// Auth key creation packet receive slots
-	void pqAnswered();
-	void dhParamsAnswered();
-	void dhClientParamsAnswered();
-
-	// General packet receive slot, connected to conn->receivedData signal
-	void handleReceived();
-
-	// Sessions signals, when we need to send something
-	void tryToSend();
-
-	void updateAuthKey();
-
-	void onConfigLoaded();
-	void onCDNConfigLoaded();
-
-private:
-	struct TestConnection {
-		ConnectionPointer data;
-		int priority = 0;
-	};
-	void connectToServer(bool afterConfig = false);
-	void connectingTimedOut();
-	void doDisconnect();
-	void restart();
-	void finishAndDestroy();
-	void requestCDNConfig();
-	void handleError(int errorCode);
-	void onError(
-		not_null<AbstractConnection*> connection,
-		qint32 errorCode);
-	void onConnected(not_null<AbstractConnection*> connection);
-	void onDisconnected(not_null<AbstractConnection*> connection);
-
-	void retryByTimer();
-	void waitConnectedFailed();
-	void waitReceivedFailed();
-	void waitBetterFailed();
-	void markConnectionOld();
-	void sendPingByTimer();
-
-	void destroyAllConnections();
-	void confirmBestConnection();
-	void removeTestConnection(not_null<AbstractConnection*> connection);
-	int16 getProtocolDcId() const;
-
-	mtpMsgId placeToContainer(
-		SecureRequest &toSendRequest,
-		mtpMsgId &bigMsgId,
-		mtpMsgId *&haveSentArr,
-		SecureRequest &req);
-	mtpMsgId prepareToSend(SecureRequest &request, mtpMsgId currentLastId);
-	mtpMsgId replaceMsgId(SecureRequest &request, mtpMsgId newId);
-
-	bool sendSecureRequest(
-		SecureRequest &&request,
-		bool needAnyResponse,
-		QReadLocker &lockFinished);
-	mtpRequestId wasSent(mtpMsgId msgId) const;
-
-	enum class HandleResult {
-		Success,
-		Ignored,
-		RestartConnection,
-		ResetSession,
-		ParseError,
-	};
-	[[nodiscard]] HandleResult handleOneReceived(const mtpPrime *from, const mtpPrime *end, uint64 msgId, int32 serverTime, uint64 serverSalt, bool badTime);
-	mtpBuffer ungzip(const mtpPrime *from, const mtpPrime *end) const;
-	void handleMsgsStates(const QVector<MTPlong> &ids, const QByteArray &states, QVector<MTPlong> &acked);
-
-	void clearMessages();
-
-	bool setState(int32 state, int32 ifState = Connection::UpdateAlways);
-
-	bytes::vector encryptPQInnerRSA(const MTPP_Q_inner_data &data, const internal::RSAPublicKey &key);
-	std::string encryptClientDHInner(const MTPClient_DH_Inner_Data &data);
-	void appendTestConnection(
-		DcOptions::Variants::Protocol protocol,
-		const QString &ip,
-		int port,
-		const bytes::vector &protocolSecret);
-
-	// if badTime received - search for ids in sessionData->haveSent and sessionData->wereAcked and sync time/salt, return true if found
-	bool requestsFixTimeSalt(const QVector<MTPlong> &ids, int32 serverTime, uint64 serverSalt);
-
-	// remove msgs with such ids from sessionData->haveSent, add to sessionData->wereAcked
-	void requestsAcked(const QVector<MTPlong> &ids, bool byResponse = false);
-
-	void resend(quint64 msgId, qint64 msCanWait = 0, bool forceContainer = false, bool sendMsgStateInfo = false);
-	void resendMany(QVector<quint64> msgIds, qint64 msCanWait = 0, bool forceContainer = false, bool sendMsgStateInfo = false);
-
-	template <typename Request>
-	void sendNotSecureRequest(const Request &request);
-
-	template <typename Response>
-	[[nodiscard]] bool readNotSecureResponse(Response &response);
-
-	not_null<Instance*> _instance;
-	DcType _dcType = DcType::Regular;
-
-	mutable QReadWriteLock stateConnMutex;
-	int32 _state = DisconnectedState;
-
-	bool _needSessionReset = false;
-	void resetSession();
-
-	ShiftedDcId _shiftedDcId = 0;
-	not_null<Connection*> _owner;
-	ConnectionPointer _connection;
-	std::vector<TestConnection> _testConnections;
-	crl::time _startedConnectingAt = 0;
-
-	base::Timer _retryTimer; // exp retry timer
-	int _retryTimeout = 1;
-	qint64 _retryWillFinish = 0;
-
-	base::Timer _oldConnectionTimer;
-	bool _oldConnection = true;
-
-	base::Timer _waitForConnectedTimer;
-	base::Timer _waitForReceivedTimer;
-	base::Timer _waitForBetterTimer;
-	crl::time _waitForReceived = 0;
-	crl::time _waitForConnected = 0;
-	crl::time firstSentAt = -1;
-
-	QVector<MTPlong> ackRequestData, resendRequestData;
-
-	mtpPingId _pingId = 0;
-	mtpPingId _pingIdToSend = 0;
-	crl::time _pingSendAt = 0;
-	mtpMsgId _pingMsgId = 0;
-	base::Timer _pingSender;
-
-	bool restarted = false;
-	bool _finished = false;
-
-	uint64 keyId = 0;
-	QReadWriteLock sessionDataMutex;
-	SessionData *sessionData = nullptr;
-	std::unique_ptr<ConnectionOptions> _connectionOptions;
-
-	bool myKeyLock = false;
-	void lockKey();
-	void unlockKey();
-
-	// Auth key creation fields and methods
-	struct AuthKeyCreateData {
-		AuthKeyCreateData()
-		: new_nonce(*(MTPint256*)((uchar*)new_nonce_buf))
-		, auth_key_aux_hash(*(MTPlong*)((uchar*)new_nonce_buf + 33)) {
-		}
-		MTPint128 nonce, server_nonce;
-		uchar new_nonce_buf[41] = { 0 }; // 32 bytes new_nonce + 1 check byte + 8 bytes of auth_key_aux_hash
-		MTPint256 &new_nonce;
-		MTPlong &auth_key_aux_hash;
-
-		uint32 retries = 0;
-		MTPlong retry_id;
-
-		int32 g = 0;
-
-		uchar aesKey[32] = { 0 };
-		uchar aesIV[32] = { 0 };
-		MTPlong auth_key_hash;
-	};
-	struct AuthKeyCreateStrings {
-		bytes::vector dh_prime;
-		bytes::vector g_a;
-		AuthKey::Data auth_key = { { gsl::byte{} } };
-	};
-	std::unique_ptr<AuthKeyCreateData> _authKeyData;
-	std::unique_ptr<AuthKeyCreateStrings> _authKeyStrings;
-
-	void dhClientParamsSend();
-	void authKeyCreated();
-	void clearAuthKeyData();
-
-};
-
-} // namespace internal
-} // namespace MTP
diff --git a/Telegram/SourceFiles/mtproto/connection_abstract.cpp b/Telegram/SourceFiles/mtproto/connection_abstract.cpp
index 48974856d..cf2f3bdb0 100644
--- a/Telegram/SourceFiles/mtproto/connection_abstract.cpp
+++ b/Telegram/SourceFiles/mtproto/connection_abstract.cpp
@@ -12,9 +12,10 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "mtproto/connection_resolving.h"
 #include "mtproto/session.h"
 #include "base/unixtime.h"
+#include "base/openssl_help.h"
 
 namespace MTP {
-namespace internal {
+namespace details {
 
 ConnectionPointer::ConnectionPointer() = default;
 
@@ -187,5 +188,11 @@ ConnectionPointer AbstractConnection::Create(
 	return result;
 }
 
-} // namespace internal
+uint32 AbstractConnection::extendedNotSecurePadding() const {
+	return requiresExtendedPadding()
+		? uint32(openssl::RandomValue<uchar>() & 0x3F)
+		: 0;
+}
+
+} // namespace details
 } // namespace MTP
diff --git a/Telegram/SourceFiles/mtproto/connection_abstract.h b/Telegram/SourceFiles/mtproto/connection_abstract.h
index b524388e3..695d83694 100644
--- a/Telegram/SourceFiles/mtproto/connection_abstract.h
+++ b/Telegram/SourceFiles/mtproto/connection_abstract.h
@@ -8,10 +8,17 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #pragma once
 
 #include "mtproto/dc_options.h"
+#include "mtproto/mtproto_proxy_data.h"
 #include "base/bytes.h"
 
+#include <QtCore/QObject>
+#include <QtCore/QThread>
+
 namespace MTP {
-namespace internal {
+
+class Instance;
+
+namespace details {
 
 struct ConnectionOptions;
 
@@ -57,17 +64,17 @@ public:
 	virtual ~AbstractConnection() = default;
 
 	// virtual constructor
-	static ConnectionPointer Create(
+	[[nodiscard]] static ConnectionPointer Create(
 		not_null<Instance*> instance,
 		DcOptions::Variants::Protocol protocol,
 		QThread *thread,
 		const bytes::vector &secret,
 		const ProxyData &proxy);
 
-	virtual ConnectionPointer clone(const ProxyData &proxy) = 0;
+	[[nodiscard]] virtual ConnectionPointer clone(const ProxyData &proxy) = 0;
 
-	virtual crl::time pingTime() const = 0;
-	virtual crl::time fullConnectTimeout() const = 0;
+	[[nodiscard]] virtual crl::time pingTime() const = 0;
+	[[nodiscard]] virtual crl::time fullConnectTimeout() const = 0;
 	virtual void sendData(mtpBuffer &&buffer) = 0;
 	virtual void disconnectFromServer() = 0;
 	virtual void connectToServer(
@@ -77,41 +84,44 @@ public:
 		int16 protocolDcId) = 0;
 	virtual void timedOut() {
 	}
-	virtual bool isConnected() const = 0;
-	virtual bool usingHttpWait() {
+	[[nodiscard]] virtual bool isConnected() const = 0;
+	[[nodiscard]] virtual bool usingHttpWait() {
 		return false;
 	}
-	virtual bool needHttpWait() {
+	[[nodiscard]] virtual bool needHttpWait() {
 		return false;
 	}
-	virtual bool requiresExtendedPadding() const {
+	[[nodiscard]] virtual bool requiresExtendedPadding() const {
 		return false;
 	}
 
-	virtual int32 debugState() const = 0;
+	[[nodiscard]] virtual int32 debugState() const = 0;
 
-	virtual QString transport() const = 0;
-	virtual QString tag() const = 0;
+	[[nodiscard]] virtual QString transport() const = 0;
+	[[nodiscard]] virtual QString tag() const = 0;
 
-	void setSentEncrypted() {
-		_sentEncrypted = true;
+	void setSentEncryptedWithKeyId(uint64 keyId) {
+		_sentEncryptedWithKeyId = keyId;
+	}
+	[[nodiscard]] uint64 sentEncryptedWithKeyId() const {
+		return _sentEncryptedWithKeyId;
 	}
 
 	using BuffersQueue = std::deque<mtpBuffer>;
-	BuffersQueue &received() {
+	[[nodiscard]] BuffersQueue &received() {
 		return _receivedQueue;
 	}
 
 	template <typename Request>
-	mtpBuffer prepareNotSecurePacket(
+	[[nodiscard]] mtpBuffer prepareNotSecurePacket(
 		const Request &request,
 		mtpMsgId newId) const;
-	mtpBuffer prepareSecurePacket(
+	[[nodiscard]] mtpBuffer prepareSecurePacket(
 		uint64 keyId,
 		MTPint128 msgKey,
 		uint32 size) const;
 
-	gsl::span<const mtpPrime> parseNotSecureResponse(
+	[[nodiscard]] gsl::span<const mtpPrime> parseNotSecureResponse(
 		const mtpBuffer &buffer) const;
 
 	// Used to emit error(...) with no real code from the server.
@@ -130,14 +140,19 @@ signals:
 
 protected:
 	BuffersQueue _receivedQueue; // list of received packets, not processed yet
-	bool _sentEncrypted = false;
 	int _pingTime = 0;
 	ProxyData _proxy;
 
 	// first we always send fake MTPReq_pq to see if connection works at all
 	// we send them simultaneously through TCP/HTTP/IPv4/IPv6 to choose the working one
-	mtpBuffer preparePQFake(const MTPint128 &nonce) const;
-	std::optional<MTPResPQ> readPQFakeReply(const mtpBuffer &buffer) const;
+	[[nodiscard]] mtpBuffer preparePQFake(const MTPint128 &nonce) const;
+	[[nodiscard]] std::optional<MTPResPQ> readPQFakeReply(
+		const mtpBuffer &buffer) const;
+
+private:
+	[[nodiscard]] uint32 extendedNotSecurePadding() const;
+
+	uint64 _sentEncryptedWithKeyId = 0;
 
 };
 
@@ -146,9 +161,7 @@ mtpBuffer AbstractConnection::prepareNotSecurePacket(
 		const Request &request,
 		mtpMsgId newId) const {
 	const auto intsSize = tl::count_length(request) >> 2;
-	const auto intsPadding = requiresExtendedPadding()
-		? uint32(rand_value<uchar>() & 0x3F)
-		: 0;
+	const auto intsPadding = extendedNotSecurePadding();
 
 	auto result = mtpBuffer();
 	constexpr auto kTcpPrefixInts = 2;
@@ -173,14 +186,14 @@ mtpBuffer AbstractConnection::prepareNotSecurePacket(
 	*messageLength = (result.size() - kPrefixInts + intsPadding) << 2;
 
 	if (intsPadding > 0) {
-		result.resize(result.size() + intsPadding);
-		memset_rand(
-			result.data() + result.size() - intsPadding,
-			intsPadding * sizeof(mtpPrime));
+		const auto skipPrimes = result.size();
+		result.resize(skipPrimes + intsPadding);
+		const auto skipBytes = skipPrimes * sizeof(mtpPrime);
+		bytes::set_random(bytes::make_span(result).subspan(skipBytes));
 	}
 
 	return result;
 }
 
-} // namespace internal
+} // namespace details
 } // namespace MTP
diff --git a/Telegram/SourceFiles/mtproto/connection_http.cpp b/Telegram/SourceFiles/mtproto/connection_http.cpp
index f7d6a81f7..3f9d005b7 100644
--- a/Telegram/SourceFiles/mtproto/connection_http.cpp
+++ b/Telegram/SourceFiles/mtproto/connection_http.cpp
@@ -10,7 +10,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "base/qthelp_url.h"
 
 namespace MTP {
-namespace internal {
+namespace details {
 namespace {
 
 constexpr auto kForceHttpPort = 80;
@@ -246,5 +246,5 @@ QUrl HttpConnection::url() const {
 	return QUrl(pattern.arg(_address).arg(kForceHttpPort));
 }
 
-} // namespace internal
+} // namespace details
 } // namespace MTP
diff --git a/Telegram/SourceFiles/mtproto/connection_http.h b/Telegram/SourceFiles/mtproto/connection_http.h
index 57fffb875..8fb867aa5 100644
--- a/Telegram/SourceFiles/mtproto/connection_http.h
+++ b/Telegram/SourceFiles/mtproto/connection_http.h
@@ -13,7 +13,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include <QtNetwork/QNetworkReply>
 
 namespace MTP {
-namespace internal {
+namespace details {
 
 class HttpConnection : public AbstractConnection {
 public:
@@ -64,5 +64,5 @@ private:
 
 };
 
-} // namespace internal
+} // namespace details
 } // namespace MTP
diff --git a/Telegram/SourceFiles/mtproto/connection_resolving.cpp b/Telegram/SourceFiles/mtproto/connection_resolving.cpp
index 0822d009b..7590db6a3 100644
--- a/Telegram/SourceFiles/mtproto/connection_resolving.cpp
+++ b/Telegram/SourceFiles/mtproto/connection_resolving.cpp
@@ -7,8 +7,10 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 */
 #include "mtproto/connection_resolving.h"
 
+#include "mtproto/mtp_instance.h"
+
 namespace MTP {
-namespace internal {
+namespace details {
 namespace {
 
 constexpr auto kOneConnectionTimeout = 4000;
@@ -254,5 +256,5 @@ QString ResolvingConnection::tag() const {
 	return _child ? _child->tag() : QString();
 }
 
-} // namespace internal
+} // namespace details
 } // namespace MTP
diff --git a/Telegram/SourceFiles/mtproto/connection_resolving.h b/Telegram/SourceFiles/mtproto/connection_resolving.h
index 4a91657db..eeb137113 100644
--- a/Telegram/SourceFiles/mtproto/connection_resolving.h
+++ b/Telegram/SourceFiles/mtproto/connection_resolving.h
@@ -7,12 +7,12 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 */
 #pragma once
 
-#include "mtproto/auth_key.h"
+#include "mtproto/mtproto_auth_key.h"
 #include "mtproto/connection_abstract.h"
 #include "base/timer.h"
 
 namespace MTP {
-namespace internal {
+namespace details {
 
 class ResolvingConnection : public AbstractConnection {
 public:
@@ -67,5 +67,5 @@ private:
 
 };
 
-} // namespace internal
+} // namespace details
 } // namespace MTP
diff --git a/Telegram/SourceFiles/mtproto/connection_tcp.cpp b/Telegram/SourceFiles/mtproto/connection_tcp.cpp
index 2b73bce79..f195c7c44 100644
--- a/Telegram/SourceFiles/mtproto/connection_tcp.cpp
+++ b/Telegram/SourceFiles/mtproto/connection_tcp.cpp
@@ -7,7 +7,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 */
 #include "mtproto/connection_tcp.h"
 
-#include "mtproto/mtp_abstract_socket.h"
+#include "mtproto/details/mtproto_abstract_socket.h"
 #include "base/bytes.h"
 #include "base/openssl_help.h"
 #include "base/qthelp_url.h"
@@ -17,7 +17,7 @@ extern "C" {
 } // extern "C"
 
 namespace MTP {
-namespace internal {
+namespace details {
 namespace {
 
 constexpr auto kPacketSizeMax = int(0x01000000 * sizeof(mtpPrime));
@@ -665,5 +665,5 @@ void TcpConnection::socketError() {
 
 TcpConnection::~TcpConnection() = default;
 
-} // namespace internal
+} // namespace details
 } // namespace MTP
diff --git a/Telegram/SourceFiles/mtproto/connection_tcp.h b/Telegram/SourceFiles/mtproto/connection_tcp.h
index 10da72760..1fc5319a1 100644
--- a/Telegram/SourceFiles/mtproto/connection_tcp.h
+++ b/Telegram/SourceFiles/mtproto/connection_tcp.h
@@ -8,10 +8,10 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #pragma once
 
 #include "mtproto/connection_abstract.h"
-#include "mtproto/auth_key.h"
+#include "mtproto/mtproto_auth_key.h"
 
 namespace MTP {
-namespace internal {
+namespace details {
 
 class AbstractSocket;
 
@@ -98,5 +98,5 @@ private:
 
 };
 
-} // namespace internal
+} // namespace details
 } // namespace MTP
diff --git a/Telegram/SourceFiles/mtproto/core_types.h b/Telegram/SourceFiles/mtproto/core_types.h
index 3d666d038..93724f611 100644
--- a/Telegram/SourceFiles/mtproto/core_types.h
+++ b/Telegram/SourceFiles/mtproto/core_types.h
@@ -122,96 +122,6 @@ static const mtpTypeId mtpLayers[] = {
 };
 static const uint32 mtpLayerMaxSingle = sizeof(mtpLayers) / sizeof(mtpLayers[0]);
 
-namespace MTP {
-namespace details {
-
-struct SecureRequestCreateTag {
-};
-
-} // namespace details
-
-class SecureRequestData;
-class SecureRequest {
-public:
-	SecureRequest() = default;
-
-	static constexpr auto kSaltInts = 2;
-	static constexpr auto kSessionIdInts = 2;
-	static constexpr auto kMessageIdInts = 2;
-	static constexpr auto kSeqNoPosition = kSaltInts
-		+ kSessionIdInts
-		+ kMessageIdInts;
-	static constexpr auto kSeqNoInts = 1;
-	static constexpr auto kMessageLengthPosition = kSeqNoPosition
-		+ kSeqNoInts;
-	static constexpr auto kMessageLengthInts = 1;
-	static constexpr auto kMessageBodyPosition = kMessageLengthPosition
-		+ kMessageLengthInts;
-
-	static SecureRequest Prepare(uint32 size, uint32 reserveSize = 0);
-
-	template <
-		typename Request,
-		typename = std::enable_if_t<tl::is_boxed_v<Request>>>
-	static SecureRequest Serialize(const Request &request);
-
-	// For template MTP requests and MTPBoxed instanciation.
-	template <typename Accumulator>
-	void write(Accumulator &to) const {
-		if (const auto size = sizeInBytes()) {
-			tl::Writer<Accumulator>::PutBytes(to, dataInBytes(), size);
-		}
-	}
-
-	SecureRequestData *operator->() const;
-	SecureRequestData &operator*() const;
-	explicit operator bool() const;
-
-	void addPadding(bool extended);
-	uint32 messageSize() const;
-
-	// "request-like" wrap for msgIds vector
-	bool isSentContainer() const;
-	bool isStateRequest() const;
-	bool needAck() const;
-
-	using ResponseType = void; // don't know real response type =(
-
-private:
-	explicit SecureRequest(const details::SecureRequestCreateTag &);
-
-	[[nodiscard]] size_t sizeInBytes() const;
-	[[nodiscard]] const void *dataInBytes() const;
-
-	std::shared_ptr<SecureRequestData> _data;
-
-};
-
-class SecureRequestData : public mtpBuffer {
-public:
-	explicit SecureRequestData(const details::SecureRequestCreateTag &) {
-	}
-
-	// in toSend: = 0 - must send in container, > 0 - can send without container
-	// in haveSent: = 0 - container with msgIds, > 0 - when was sent
-	int64 msDate = 0;
-
-	mtpRequestId requestId = 0;
-	SecureRequest after;
-	bool needsLayer = false;
-
-};
-
-template <typename Request, typename>
-SecureRequest SecureRequest::Serialize(const Request &request) {
-	const auto requestSize = tl::count_length(request) >> 2;
-	auto serialized = Prepare(requestSize);
-	request.template write<mtpBuffer>(*serialized);
-	return serialized;
-}
-
-} // namespace MTP
-
 using MTPint = tl::int_type;
 
 inline MTPint MTP_int(int32 v) {
@@ -328,80 +238,6 @@ inline MTPvector<T> MTP_vector() {
 	return tl::make_vector<T>();
 }
 
-// Human-readable text serialization
-
-struct MTPStringLogger {
-	static constexpr auto kBufferSize = 1024 * 1024; // 1 mb start size
-
-	MTPStringLogger()
-	: p(new char[kBufferSize])
-	, alloced(kBufferSize) {
-	}
-	~MTPStringLogger() {
-		delete[] p;
-	}
-
-	MTPStringLogger &add(const QString &data) {
-		auto d = data.toUtf8();
-		return add(d.constData(), d.size());
-	}
-
-	MTPStringLogger &add(const char *data, int32 len = -1) {
-		if (len < 0) len = strlen(data);
-		if (!len) return (*this);
-
-		ensureLength(len);
-		memcpy(p + size, data, len);
-		size += len;
-		return (*this);
-	}
-
-	MTPStringLogger &addSpaces(int32 level) {
-		int32 len = level * 2;
-		if (!len) return (*this);
-
-		ensureLength(len);
-		for (char *ptr = p + size, *end = ptr + len; ptr != end; ++ptr) {
-			*ptr = ' ';
-		}
-		size += len;
-		return (*this);
-	}
-
-	MTPStringLogger &error(const char *problem = "could not decode type") {
-		return add("[ERROR] (").add(problem).add(")");
-	}
-
-	void ensureLength(int32 add) {
-		if (size + add <= alloced) return;
-
-		int32 newsize = size + add;
-		if (newsize % kBufferSize) {
-			newsize += kBufferSize - (newsize % kBufferSize);
-		}
-		char *b = new char[newsize];
-		memcpy(b, p, size);
-		alloced = newsize;
-		delete[] p;
-		p = b;
-	}
-
-	char *p = nullptr;
-	int size = 0;
-	int alloced = 0;
-
-};
-
-[[nodiscard]] bool mtpTextSerializeType(MTPStringLogger &to, const mtpPrime *&from, const mtpPrime *end, mtpPrime cons = 0, uint32 level = 0, mtpPrime vcons = 0);
-
-[[nodiscard]] bool mtpTextSerializeCore(MTPStringLogger &to, const mtpPrime *&from, const mtpPrime *end, mtpTypeId cons, uint32 level, mtpPrime vcons = 0);
-
-inline QString mtpTextSerialize(const mtpPrime *&from, const mtpPrime *end) {
-	MTPStringLogger to;
-	[[maybe_unused]] bool result = mtpTextSerializeType(to, from, end, mtpc_core_message);
-	return QString::fromUtf8(to.p, to.size);
-}
-
 namespace tl {
 
 template <typename Accumulator>
diff --git a/Telegram/SourceFiles/mtproto/dc_options.cpp b/Telegram/SourceFiles/mtproto/dc_options.cpp
index 4dda90416..d82d60e10 100644
--- a/Telegram/SourceFiles/mtproto/dc_options.cpp
+++ b/Telegram/SourceFiles/mtproto/dc_options.cpp
@@ -7,12 +7,16 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 */
 #include "mtproto/dc_options.h"
 
-#include "storage/serialize_common.h"
+#include "mtproto/details/mtproto_rsa_public_key.h"
+#include "mtproto/facade.h"
 #include "mtproto/connection_tcp.h"
+#include "storage/serialize_common.h"
 
 namespace MTP {
 namespace {
 
+using namespace details;
+
 const char *(PublicRSAKeys[]) = { "\
 -----BEGIN RSA PUBLIC KEY-----\n\
 MIIBCgKCAQEAwVACPi9w23mF3tBkdZz+zwrzKOaaQdr01vAbU4E1pvkfj4sqDsm6\n\
@@ -67,6 +71,11 @@ public:
 	: _that(that)
 	, _lock(&_that->_useThroughLockers) {
 	}
+
+	void unlock() {
+		_lock.unlock();
+	}
+
 	~WriteLocker() {
 		_that->computeCdnDcIds();
 	}
@@ -83,6 +92,10 @@ public:
 	: _lock(&that->_useThroughLockers) {
 	}
 
+	void unlock() {
+		_lock.unlock();
+	}
+
 private:
 	QReadLocker _lock;
 
@@ -92,6 +105,8 @@ DcOptions::DcOptions() {
 	constructFromBuiltIn();
 }
 
+DcOptions::~DcOptions() = default;
+
 bool DcOptions::ValidateSecret(bytes::const_span secret) {
 	// See also TcpConnection::Protocol::Create.
 	return (secret.size() >= 21 && secret[0] == bytes::type(0xEE))
@@ -103,9 +118,9 @@ bool DcOptions::ValidateSecret(bytes::const_span secret) {
 void DcOptions::readBuiltInPublicKeys() {
 	for (const auto key : PublicRSAKeys) {
 		const auto keyBytes = bytes::make_span(key, strlen(key));
-		auto parsed = internal::RSAPublicKey(keyBytes);
-		if (parsed.isValid()) {
-			_publicKeys.emplace(parsed.getFingerPrint(), std::move(parsed));
+		auto parsed = RSAPublicKey(keyBytes);
+		if (parsed.valid()) {
+			_publicKeys.emplace(parsed.fingerprint(), std::move(parsed));
 		} else {
 			LOG(("MTP Error: could not read this public RSA key:"));
 			LOG((key));
@@ -169,7 +184,7 @@ void DcOptions::processFromList(
 		ApplyOneOption(data, dcId, flags, ip, port, secret);
 	}
 
-	auto difference = [&] {
+	const auto difference = [&] {
 		WriteLocker lock(this);
 		auto result = CountOptionsDifference(_data, data);
 		if (!result.empty()) {
@@ -177,8 +192,8 @@ void DcOptions::processFromList(
 		}
 		return result;
 	}();
-	if (!difference.empty()) {
-		_changed.notify(std::move(difference));
+	for (const auto dcId : difference) {
+		_changed.fire_copy(dcId);
 	}
 }
 
@@ -231,9 +246,8 @@ void DcOptions::addFromOther(DcOptions &&options) {
 			}
 		}
 	}
-
-	if (!idsChanged.empty()) {
-		_changed.notify(std::move(idsChanged));
+	for (const auto dcId : idsChanged) {
+		_changed.fire_copy(dcId);
 	}
 }
 
@@ -279,10 +293,10 @@ bool DcOptions::ApplyOneOption(
 	return true;
 }
 
-auto DcOptions::CountOptionsDifference(
+std::vector<DcId> DcOptions::CountOptionsDifference(
 		const std::map<DcId, std::vector<Endpoint>> &a,
-		const std::map<DcId, std::vector<Endpoint>> &b) -> Ids {
-	auto result = Ids();
+		const std::map<DcId, std::vector<Endpoint>> &b) {
+	auto result = std::vector<DcId>();
 	const auto find = [](
 			const std::vector<Endpoint> &where,
 			const Endpoint &what) {
@@ -503,9 +517,9 @@ void DcOptions::constructFromSerialized(const QByteArray &serialized) {
 				return;
 			}
 
-			auto key = internal::RSAPublicKey(n, e);
-			if (key.isValid()) {
-				_cdnPublicKeys[dcId].emplace(key.getFingerPrint(), std::move(key));
+			auto key = RSAPublicKey(n, e);
+			if (key.valid()) {
+				_cdnPublicKeys[dcId].emplace(key.fingerprint(), std::move(key));
 			} else {
 				LOG(("MTP Error: Could not read valid CDN public key."));
 			}
@@ -513,8 +527,16 @@ void DcOptions::constructFromSerialized(const QByteArray &serialized) {
 	}
 }
 
-DcOptions::Ids DcOptions::configEnumDcIds() const {
-	auto result = Ids();
+rpl::producer<DcId> DcOptions::changed() const {
+	return _changed.events();
+}
+
+rpl::producer<> DcOptions::cdnConfigChanged() const {
+	return _cdnConfigChanged.events();
+}
+
+std::vector<DcId> DcOptions::configEnumDcIds() const {
+	auto result = std::vector<DcId>();
 	{
 		ReadLocker lock(this);
 		result.reserve(_data.size());
@@ -539,8 +561,9 @@ DcType DcOptions::dcType(ShiftedDcId shiftedDcId) const {
 	if (_cdnDcIds.find(BareDcId(shiftedDcId)) != _cdnDcIds.cend()) {
 		return DcType::Cdn;
 	}
-	if (isDownloadDcId(shiftedDcId)) {
-		return DcType::MediaDownload;
+	const auto dcId = BareDcId(shiftedDcId);
+	if (isDownloadDcId(shiftedDcId) && hasMediaOnlyOptionsFor(dcId)) {
+		return DcType::MediaCluster;
 	}
 	return DcType::Regular;
 }
@@ -548,20 +571,23 @@ DcType DcOptions::dcType(ShiftedDcId shiftedDcId) const {
 void DcOptions::setCDNConfig(const MTPDcdnConfig &config) {
 	WriteLocker lock(this);
 	_cdnPublicKeys.clear();
-	for_const (auto &publicKey, config.vpublic_keys().v) {
-		Expects(publicKey.type() == mtpc_cdnPublicKey);
-		const auto &keyData = publicKey.c_cdnPublicKey();
-		const auto keyBytes = bytes::make_span(keyData.vpublic_key().v);
-		auto key = internal::RSAPublicKey(keyBytes);
-		if (key.isValid()) {
-			_cdnPublicKeys[keyData.vdc_id().v].emplace(
-				key.getFingerPrint(),
-				std::move(key));
-		} else {
-			LOG(("MTP Error: could not read this public RSA key:"));
-			LOG((qs(keyData.vpublic_key())));
-		}
+	for (const auto &key : config.vpublic_keys().v) {
+		key.match([&](const MTPDcdnPublicKey &data) {
+			const auto keyBytes = bytes::make_span(data.vpublic_key().v);
+			auto key = RSAPublicKey(keyBytes);
+			if (key.valid()) {
+				_cdnPublicKeys[data.vdc_id().v].emplace(
+					key.fingerprint(),
+					std::move(key));
+			} else {
+				LOG(("MTP Error: could not read this public RSA key:"));
+				LOG((qs(data.vpublic_key())));
+			}
+		});
 	}
+	lock.unlock();
+
+	_cdnConfigChanged.fire({});
 }
 
 bool DcOptions::hasCDNKeysForDc(DcId dcId) const {
@@ -569,20 +595,21 @@ bool DcOptions::hasCDNKeysForDc(DcId dcId) const {
 	return _cdnPublicKeys.find(dcId) != _cdnPublicKeys.cend();
 }
 
-bool DcOptions::getDcRSAKey(DcId dcId, const QVector<MTPlong> &fingerprints, internal::RSAPublicKey *result) const {
-	auto findKey = [&fingerprints, &result](const std::map<uint64, internal::RSAPublicKey> &keys) {
-		for_const (auto &fingerprint, fingerprints) {
-			auto it = keys.find(static_cast<uint64>(fingerprint.v));
+RSAPublicKey DcOptions::getDcRSAKey(
+		DcId dcId,
+		const QVector<MTPlong> &fingerprints) const {
+	const auto findKey = [&](const std::map<uint64, RSAPublicKey> &keys) {
+		for (const auto &fingerprint : fingerprints) {
+			const auto it = keys.find(static_cast<uint64>(fingerprint.v));
 			if (it != keys.cend()) {
-				*result = it->second;
-				return true;
+				return it->second;
 			}
 		}
-		return false;
+		return RSAPublicKey();
 	};
 	{
 		ReadLocker lock(this);
-		auto it = _cdnPublicKeys.find(dcId);
+		const auto it = _cdnPublicKeys.find(dcId);
 		if (it != _cdnPublicKeys.cend()) {
 			return findKey(it->second);
 		}
@@ -596,40 +623,54 @@ auto DcOptions::lookup(
 		bool throughProxy) const -> Variants {
 	using Flag = Flag;
 	auto result = Variants();
-	{
-		ReadLocker lock(this);
-		const auto i = _data.find(dcId);
-		if (i == end(_data)) {
-			return result;
-		}
-		for (const auto &endpoint : i->second) {
-			const auto flags = endpoint.flags;
-			if (type == DcType::Cdn && !(flags & Flag::f_cdn)) {
-				continue;
-			} else if (type != DcType::MediaDownload
-				&& (flags & Flag::f_media_only)) {
-				continue;
-			} else if (!ValidateSecret(endpoint.secret)) {
-				continue;
-			}
-			const auto address = (flags & Flag::f_ipv6)
-				? Variants::IPv6
-				: Variants::IPv4;
-			result.data[address][Variants::Tcp].push_back(endpoint);
-			if (!(flags & (Flag::f_tcpo_only | Flag::f_secret))) {
-				result.data[address][Variants::Http].push_back(endpoint);
-			}
-		}
-		if (type == DcType::MediaDownload) {
-			FilterIfHasWithFlag(result, Flag::f_media_only);
+
+	ReadLocker lock(this);
+	const auto i = _data.find(dcId);
+	if (i == end(_data)) {
+		return result;
+	}
+	for (const auto &endpoint : i->second) {
+		const auto flags = endpoint.flags;
+		if (type == DcType::Cdn && !(flags & Flag::f_cdn)) {
+			continue;
+		} else if (type != DcType::MediaCluster
+			&& (flags & Flag::f_media_only)) {
+			continue;
+		} else if (!ValidateSecret(endpoint.secret)) {
+			continue;
 		}
-		if (throughProxy) {
-			FilterIfHasWithFlag(result, Flag::f_static);
+		const auto address = (flags & Flag::f_ipv6)
+			? Variants::IPv6
+			: Variants::IPv4;
+		result.data[address][Variants::Tcp].push_back(endpoint);
+		if (!(flags & (Flag::f_tcpo_only | Flag::f_secret))) {
+			result.data[address][Variants::Http].push_back(endpoint);
 		}
 	}
+	if (type == DcType::MediaCluster) {
+		FilterIfHasWithFlag(result, Flag::f_media_only);
+	}
+	if (throughProxy) {
+		FilterIfHasWithFlag(result, Flag::f_static);
+	}
 	return result;
 }
 
+bool DcOptions::hasMediaOnlyOptionsFor(DcId dcId) const {
+	ReadLocker lock(this);
+	const auto i = _data.find(dcId);
+	if (i == end(_data)) {
+		return false;
+	}
+	for (const auto &endpoint : i->second) {
+		const auto flags = endpoint.flags;
+		if (flags & Flag::f_media_only) {
+			return true;
+		}
+	}
+	return false;
+}
+
 void DcOptions::FilterIfHasWithFlag(Variants &variants, Flag flag) {
 	const auto is = [&](const Endpoint &endpoint) {
 		return (endpoint.flags & flag) != 0;
diff --git a/Telegram/SourceFiles/mtproto/dc_options.h b/Telegram/SourceFiles/mtproto/dc_options.h
index cbd20d68a..11449d3ea 100644
--- a/Telegram/SourceFiles/mtproto/dc_options.h
+++ b/Telegram/SourceFiles/mtproto/dc_options.h
@@ -9,17 +9,22 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 
 #include "base/observer.h"
 #include "base/bytes.h"
-#include "mtproto/rsa_public_key.h"
+
+#include <QtCore/QReadWriteLock>
 #include <string>
 #include <vector>
 #include <map>
+#include <set>
 
 namespace MTP {
+namespace details {
+class RSAPublicKey;
+} // namespace details
 
 enum class DcType {
 	Regular,
 	Temporary,
-	MediaDownload,
+	MediaCluster,
 	Cdn,
 };
 class DcOptions {
@@ -49,6 +54,7 @@ public:
 	};
 
 	DcOptions();
+	~DcOptions();
 
 	[[nodiscard]] static bool ValidateSecret(bytes::const_span secret);
 
@@ -63,15 +69,13 @@ public:
 		const bytes::vector &secret);
 	QByteArray serialize() const;
 
-	using Ids = std::vector<DcId>;
-	base::Observable<Ids> &changed() const {
-		return _changed;
-	}
+	[[nodiscard]] rpl::producer<DcId> changed() const;
+	[[nodiscard]] rpl::producer<> cdnConfigChanged() const;
 	void setFromList(const MTPVector<MTPDcOption> &options);
 	void addFromList(const MTPVector<MTPDcOption> &options);
 	void addFromOther(DcOptions &&options);
 
-	Ids configEnumDcIds() const;
+	[[nodiscard]] std::vector<DcId> configEnumDcIds() const;
 
 	struct Variants {
 		enum Address {
@@ -86,12 +90,17 @@ public:
 		};
 		std::vector<Endpoint> data[AddressTypeCount][ProtocolCount];
 	};
-	Variants lookup(DcId dcId, DcType type, bool throughProxy) const;
-	DcType dcType(ShiftedDcId shiftedDcId) const;
+	[[nodiscard]] Variants lookup(
+		DcId dcId,
+		DcType type,
+		bool throughProxy) const;
+	[[nodiscard]] DcType dcType(ShiftedDcId shiftedDcId) const;
 
 	void setCDNConfig(const MTPDcdnConfig &config);
-	bool hasCDNKeysForDc(DcId dcId) const;
-	bool getDcRSAKey(DcId dcId, const QVector<MTPlong> &fingerprints, internal::RSAPublicKey *result) const;
+	[[nodiscard]] bool hasCDNKeysForDc(DcId dcId) const;
+	[[nodiscard]] details::RSAPublicKey getDcRSAKey(
+		DcId dcId,
+		const QVector<MTPlong> &fingerprints) const;
 
 	// Debug feature for now.
 	bool loadFromFile(const QString &path);
@@ -111,11 +120,13 @@ private:
 		const std::string &ip,
 		int port,
 		const bytes::vector &secret);
-	static Ids CountOptionsDifference(
+	static std::vector<DcId> CountOptionsDifference(
 		const std::map<DcId, std::vector<Endpoint>> &a,
 		const std::map<DcId, std::vector<Endpoint>> &b);
 	static void FilterIfHasWithFlag(Variants &variants, Flag flag);
 
+	[[nodiscard]] bool hasMediaOnlyOptionsFor(DcId dcId) const;
+
 	void processFromList(const QVector<MTPDcOption> &options, bool overwrite);
 	void computeCdnDcIds();
 
@@ -129,11 +140,12 @@ private:
 
 	std::map<DcId, std::vector<Endpoint>> _data;
 	std::set<DcId> _cdnDcIds;
-	std::map<uint64, internal::RSAPublicKey> _publicKeys;
-	std::map<DcId, std::map<uint64, internal::RSAPublicKey>> _cdnPublicKeys;
+	std::map<uint64, details::RSAPublicKey> _publicKeys;
+	std::map<DcId, std::map<uint64, details::RSAPublicKey>> _cdnPublicKeys;
 	mutable QReadWriteLock _useThroughLockers;
 
-	mutable base::Observable<Ids> _changed;
+	rpl::event_stream<DcId> _changed;
+	rpl::event_stream<> _cdnConfigChanged;
 
 	// True when we have overriden options from a .tdesktop-endpoints file.
 	bool _immutable = false;
diff --git a/Telegram/SourceFiles/mtproto/dcenter.cpp b/Telegram/SourceFiles/mtproto/dcenter.cpp
deleted file mode 100644
index be1fed5e6..000000000
--- a/Telegram/SourceFiles/mtproto/dcenter.cpp
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
-This file is part of Telegram Desktop,
-the official desktop application for the Telegram messaging service.
-
-For license and copyright information please follow this link:
-https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
-*/
-#include "mtproto/dcenter.h"
-
-#include "mtproto/facade.h"
-#include "mtproto/auth_key.h"
-#include "mtproto/dc_options.h"
-#include "mtproto/mtp_instance.h"
-#include "mtproto/special_config_request.h"
-#include "storage/localstorage.h"
-
-namespace MTP {
-namespace internal {
-namespace {
-
-constexpr auto kEnumerateDcTimeout = 8000; // 8 seconds timeout for help_getConfig to work (then move to other dc)
-constexpr auto kSpecialRequestTimeoutMs = 6000; // 4 seconds timeout for it to work in a specially requested dc.
-
-} // namespace
-
-Dcenter::Dcenter(not_null<Instance*> instance, DcId dcId, AuthKeyPtr &&key)
-: _instance(instance)
-, _id(dcId)
-, _key(std::move(key)) {
-	connect(this, SIGNAL(authKeyCreated()), this, SLOT(authKeyWrite()), Qt::QueuedConnection);
-}
-
-void Dcenter::authKeyWrite() {
-	DEBUG_LOG(("AuthKey Info: MTProtoDC::authKeyWrite() slot, dc %1").arg(_id));
-	if (_key) {
-		Local::writeMtpData();
-	}
-}
-
-void Dcenter::setKey(AuthKeyPtr &&key) {
-	DEBUG_LOG(("AuthKey Info: MTProtoDC::setKey(%1), emitting authKeyCreated, dc %2").arg(key ? key->keyId() : 0).arg(_id));
-	_key = std::move(key);
-	_connectionInited = false;
-	_instance->setKeyForWrite(_id, _key);
-	emit authKeyCreated();
-}
-
-QReadWriteLock *Dcenter::keyMutex() const {
-	return &keyLock;
-}
-
-const AuthKeyPtr &Dcenter::getKey() const {
-	return _key;
-}
-
-void Dcenter::destroyKey() {
-	setKey(AuthKeyPtr());
-}
-
-} // namespace internal
-} // namespace MTP
diff --git a/Telegram/SourceFiles/mtproto/dcenter.h b/Telegram/SourceFiles/mtproto/dcenter.h
deleted file mode 100644
index 7fab8d153..000000000
--- a/Telegram/SourceFiles/mtproto/dcenter.h
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
-This file is part of Telegram Desktop,
-the official desktop application for the Telegram messaging service.
-
-For license and copyright information please follow this link:
-https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
-*/
-#pragma once
-
-namespace MTP {
-
-class Instance;
-class AuthKey;
-using AuthKeyPtr = std::shared_ptr<AuthKey>;
-
-namespace internal {
-
-class Dcenter : public QObject {
-	Q_OBJECT
-
-public:
-	Dcenter(not_null<Instance*> instance, DcId dcId, AuthKeyPtr &&key);
-
-	QReadWriteLock *keyMutex() const;
-	const AuthKeyPtr &getKey() const;
-	void setKey(AuthKeyPtr &&key);
-	void destroyKey();
-
-	bool connectionInited() const {
-		QMutexLocker lock(&initLock);
-		return _connectionInited;
-	}
-	void setConnectionInited(bool connectionInited = true) {
-		QMutexLocker lock(&initLock);
-		_connectionInited = connectionInited;
-	}
-
-signals:
-	void authKeyCreated();
-	void connectionWasInited();
-
-private slots:
-	void authKeyWrite();
-
-private:
-	mutable QReadWriteLock keyLock;
-	mutable QMutex initLock;
-	not_null<Instance*> _instance;
-	DcId _id = 0;
-	AuthKeyPtr _key;
-	bool _connectionInited = false;
-
-};
-
-} // namespace internal
-} // namespace MTP
diff --git a/Telegram/SourceFiles/mtproto/dedicated_file_loader.cpp b/Telegram/SourceFiles/mtproto/dedicated_file_loader.cpp
index b85d6740f..afd794d9e 100644
--- a/Telegram/SourceFiles/mtproto/dedicated_file_loader.cpp
+++ b/Telegram/SourceFiles/mtproto/dedicated_file_loader.cpp
@@ -7,6 +7,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 */
 #include "mtproto/dedicated_file_loader.h"
 
+#include "mtproto/facade.h"
 #include "main/main_session.h"
 #include "main/main_account.h" // Account::sessionChanges.
 #include "core/application.h"
diff --git a/Telegram/SourceFiles/mtproto/dedicated_file_loader.h b/Telegram/SourceFiles/mtproto/dedicated_file_loader.h
index a21769f2b..645f7e29e 100644
--- a/Telegram/SourceFiles/mtproto/dedicated_file_loader.h
+++ b/Telegram/SourceFiles/mtproto/dedicated_file_loader.h
@@ -7,9 +7,9 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 */
 #pragma once
 
-namespace MTP {
+#include "mtproto/mtp_instance.h"
 
-class Instance;
+namespace MTP {
 
 class WeakInstance : private QObject, private base::Subscriber {
 public:
diff --git a/Telegram/SourceFiles/mtproto/mtp_abstract_socket.cpp b/Telegram/SourceFiles/mtproto/details/mtproto_abstract_socket.cpp
similarity index 74%
rename from Telegram/SourceFiles/mtproto/mtp_abstract_socket.cpp
rename to Telegram/SourceFiles/mtproto/details/mtproto_abstract_socket.cpp
index 1de6e6654..2ad0a44a6 100644
--- a/Telegram/SourceFiles/mtproto/mtp_abstract_socket.cpp
+++ b/Telegram/SourceFiles/mtproto/details/mtproto_abstract_socket.cpp
@@ -5,13 +5,12 @@ the official desktop application for the Telegram messaging service.
 For license and copyright information please follow this link:
 https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 */
-#include "mtproto/mtp_abstract_socket.h"
+#include "mtproto/details/mtproto_abstract_socket.h"
 
-#include "mtproto/mtp_tcp_socket.h"
-#include "mtproto/mtp_tls_socket.h"
+#include "mtproto/details/mtproto_tcp_socket.h"
+#include "mtproto/details/mtproto_tls_socket.h"
 
-namespace MTP {
-namespace internal {
+namespace MTP::details {
 
 std::unique_ptr<AbstractSocket> AbstractSocket::Create(
 		not_null<QThread*> thread,
@@ -24,5 +23,4 @@ std::unique_ptr<AbstractSocket> AbstractSocket::Create(
 	}
 }
 
-} // namespace internal
-} // namespace MTP
+} // namespace MTP::details
diff --git a/Telegram/SourceFiles/mtproto/mtp_abstract_socket.h b/Telegram/SourceFiles/mtproto/details/mtproto_abstract_socket.h
similarity index 95%
rename from Telegram/SourceFiles/mtproto/mtp_abstract_socket.h
rename to Telegram/SourceFiles/mtproto/details/mtproto_abstract_socket.h
index 4d5c35108..61da8b5e3 100644
--- a/Telegram/SourceFiles/mtproto/mtp_abstract_socket.h
+++ b/Telegram/SourceFiles/mtproto/details/mtproto_abstract_socket.h
@@ -10,8 +10,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "base/bytes.h"
 #include "base/basic_types.h"
 
-namespace MTP {
-namespace internal {
+namespace MTP::details {
 
 class AbstractSocket : protected QObject {
 public:
@@ -62,5 +61,4 @@ protected:
 
 };
 
-} // namespace internal
-} // namespace MTP
+} // namespace MTP::details
diff --git a/Telegram/SourceFiles/mtproto/details/mtproto_bound_key_creator.cpp b/Telegram/SourceFiles/mtproto/details/mtproto_bound_key_creator.cpp
new file mode 100644
index 000000000..c84a40bbd
--- /dev/null
+++ b/Telegram/SourceFiles/mtproto/details/mtproto_bound_key_creator.cpp
@@ -0,0 +1,93 @@
+/*
+This file is part of Telegram Desktop,
+the official desktop application for the Telegram messaging service.
+
+For license and copyright information please follow this link:
+https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+*/
+#include "mtproto/details/mtproto_bound_key_creator.h"
+
+#include "mtproto/details/mtproto_serialized_request.h"
+
+namespace MTP::details {
+
+BoundKeyCreator::BoundKeyCreator(DcKeyRequest request, Delegate delegate)
+: _request(request)
+, _delegate(std::move(delegate)) {
+}
+
+void BoundKeyCreator::start(
+		DcId dcId,
+		int16 protocolDcId,
+		not_null<AbstractConnection*> connection,
+		not_null<DcOptions*> dcOptions) {
+	Expects(!_creator.has_value());
+
+	auto delegate = DcKeyCreator::Delegate();
+	delegate.done = _delegate.unboundReady;
+	delegate.sentSome = _delegate.sentSome;
+	delegate.receivedSome = _delegate.receivedSome;
+
+	_creator.emplace(
+		dcId,
+		protocolDcId,
+		connection,
+		dcOptions,
+		std::move(delegate),
+		_request);
+}
+
+void BoundKeyCreator::stop() {
+	_creator = std::nullopt;
+}
+
+void BoundKeyCreator::bind(AuthKeyPtr &&persistentKey) {
+	stop();
+	_binder.emplace(std::move(persistentKey));
+}
+
+void BoundKeyCreator::restartBinder() {
+	if (_binder) {
+		_binder.emplace(_binder->persistentKey());
+	}
+}
+
+bool BoundKeyCreator::readyToBind() const {
+	return _binder.has_value();
+}
+
+SerializedRequest BoundKeyCreator::prepareBindRequest(
+		const AuthKeyPtr &temporaryKey,
+		uint64 sessionId) {
+	Expects(_binder.has_value());
+
+	return _binder->prepareRequest(temporaryKey, sessionId);
+}
+
+DcKeyBindState BoundKeyCreator::handleBindResponse(
+		const mtpBuffer &response) {
+	Expects(_binder.has_value());
+
+	return _binder->handleResponse(response);
+}
+
+AuthKeyPtr BoundKeyCreator::bindPersistentKey() const {
+	Expects(_binder.has_value());
+
+	return _binder->persistentKey();
+}
+
+bool IsDestroyedTemporaryKeyError(const mtpBuffer &buffer) {
+	auto from = buffer.data();
+	const auto end = from + buffer.size();
+	auto error = MTPRpcError();
+	if (!error.read(from, from + buffer.size())) {
+		return false;
+	}
+	return error.match([&](const MTPDrpc_error &data) {
+		return (data.verror_code().v == 401)
+			&& (data.verror_message().v == "AUTH_KEY_PERM_EMPTY");
+	});
+}
+
+} // namespace MTP::details
diff --git a/Telegram/SourceFiles/mtproto/details/mtproto_bound_key_creator.h b/Telegram/SourceFiles/mtproto/details/mtproto_bound_key_creator.h
new file mode 100644
index 000000000..a1ca4cb83
--- /dev/null
+++ b/Telegram/SourceFiles/mtproto/details/mtproto_bound_key_creator.h
@@ -0,0 +1,56 @@
+/*
+This file is part of Telegram Desktop,
+the official desktop application for the Telegram messaging service.
+
+For license and copyright information please follow this link:
+https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+*/
+#pragma once
+
+#include "mtproto/details/mtproto_dc_key_creator.h"
+#include "mtproto/details/mtproto_dc_key_binder.h"
+
+namespace MTP::details {
+
+class SerializedRequest;
+
+class BoundKeyCreator final {
+public:
+	struct Delegate {
+		Fn<void(base::expected<DcKeyResult, DcKeyError>)> unboundReady;
+		Fn<void(uint64)> sentSome;
+		Fn<void()> receivedSome;
+	};
+
+	BoundKeyCreator(DcKeyRequest request, Delegate delegate);
+
+	void start(
+		DcId dcId,
+		int16 protocolDcId,
+		not_null<AbstractConnection*> connection,
+		not_null<DcOptions*> dcOptions);
+	void stop();
+
+	void bind(AuthKeyPtr &&persistentKey);
+	void restartBinder();
+	[[nodiscard]] bool readyToBind() const;
+	[[nodiscard]] SerializedRequest prepareBindRequest(
+		const AuthKeyPtr &temporaryKey,
+		uint64 sessionId);
+	[[nodiscard]] DcKeyBindState handleBindResponse(
+		const mtpBuffer &response);
+	[[nodiscard]] AuthKeyPtr bindPersistentKey() const;
+
+private:
+	const DcKeyRequest _request;
+	Delegate _delegate;
+
+	std::optional<DcKeyCreator> _creator;
+	std::optional<DcKeyBinder> _binder;
+
+};
+
+
+[[nodiscard]] bool IsDestroyedTemporaryKeyError(const mtpBuffer &buffer);
+
+} // namespace MTP::details
diff --git a/Telegram/SourceFiles/mtproto/details/mtproto_dc_key_binder.cpp b/Telegram/SourceFiles/mtproto/details/mtproto_dc_key_binder.cpp
new file mode 100644
index 000000000..0f6b0b56c
--- /dev/null
+++ b/Telegram/SourceFiles/mtproto/details/mtproto_dc_key_binder.cpp
@@ -0,0 +1,132 @@
+/*
+This file is part of Telegram Desktop,
+the official desktop application for the Telegram messaging service.
+
+For license and copyright information please follow this link:
+https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+*/
+#include "mtproto/details/mtproto_dc_key_binder.h"
+
+#include "mtproto/details/mtproto_serialized_request.h"
+#include "mtproto/mtp_instance.h"
+#include "base/unixtime.h"
+#include "base/openssl_help.h"
+#include "scheme.h"
+
+#include <QtCore/QPointer>
+
+namespace MTP::details {
+namespace {
+
+[[nodiscard]] QByteArray EncryptBindAuthKeyInner(
+		const AuthKeyPtr &persistentKey,
+		mtpMsgId realMsgId,
+		const MTPBindAuthKeyInner &data) {
+	auto serialized = SerializedRequest::Serialize(data);
+	serialized.setMsgId(realMsgId);
+	serialized.setSeqNo(0);
+	serialized.addPadding(false, true);
+
+	constexpr auto kMsgIdPosition = SerializedRequest::kMessageIdPosition;
+	constexpr auto kMinMessageSize = 5;
+
+	const auto sizeInPrimes = serialized->size();
+	const auto messageSize = serialized.messageSize();
+	Assert(messageSize >= kMinMessageSize);
+	Assert(sizeInPrimes >= kMsgIdPosition + messageSize);
+
+	const auto sizeInBytes = sizeInPrimes * sizeof(mtpPrime);
+	const auto padding = sizeInBytes
+		- (kMsgIdPosition + messageSize) * sizeof(mtpPrime);
+
+	// session_id, salt - just random here.
+	bytes::set_random(bytes::make_span(*serialized).subspan(
+		0,
+		kMsgIdPosition * sizeof(mtpPrime)));
+
+	const auto hash = openssl::Sha1(bytes::make_span(*serialized).subspan(
+		0,
+		sizeInBytes - padding));
+	auto msgKey = MTPint128();
+	bytes::copy(
+		bytes::object_as_span(&msgKey),
+		bytes::make_span(hash).subspan(4));
+
+	constexpr auto kAuthKeyIdBytes = 2 * sizeof(mtpPrime);
+	constexpr auto kMessageKeyPosition = kAuthKeyIdBytes;
+	constexpr auto kMessageKeyBytes = 4 * sizeof(mtpPrime);
+	constexpr auto kPrefix = (kAuthKeyIdBytes + kMessageKeyBytes);
+	auto encrypted = QByteArray(kPrefix + sizeInBytes, Qt::Uninitialized);
+	*reinterpret_cast<uint64*>(encrypted.data()) = persistentKey->keyId();
+	*reinterpret_cast<MTPint128*>(encrypted.data() + kMessageKeyPosition)
+		= msgKey;
+
+	aesIgeEncrypt_oldmtp(
+		serialized->constData(),
+		encrypted.data() + kPrefix,
+		sizeInBytes,
+		persistentKey,
+		msgKey);
+
+	return encrypted;
+}
+
+} // namespace
+
+DcKeyBinder::DcKeyBinder(AuthKeyPtr &&persistentKey)
+: _persistentKey(std::move(persistentKey)) {
+	Expects(_persistentKey != nullptr);
+}
+
+SerializedRequest DcKeyBinder::prepareRequest(
+		const AuthKeyPtr &temporaryKey,
+		uint64 sessionId) {
+	Expects(temporaryKey != nullptr);
+	Expects(temporaryKey->expiresAt() != 0);
+
+	const auto nonce = openssl::RandomValue<uint64>();
+	const auto msgId = base::unixtime::mtproto_msg_id();
+	auto result = SerializedRequest::Serialize(MTPauth_BindTempAuthKey(
+		MTP_long(_persistentKey->keyId()),
+		MTP_long(nonce),
+		MTP_int(temporaryKey->expiresAt()),
+		MTP_bytes(EncryptBindAuthKeyInner(
+			_persistentKey,
+			msgId,
+			MTP_bind_auth_key_inner(
+				MTP_long(nonce),
+				MTP_long(temporaryKey->keyId()),
+				MTP_long(_persistentKey->keyId()),
+				MTP_long(sessionId),
+				MTP_int(temporaryKey->expiresAt()))))));
+	result.setMsgId(msgId);
+	return result;
+}
+
+DcKeyBindState DcKeyBinder::handleResponse(const mtpBuffer &response) {
+	Expects(!response.isEmpty());
+
+	auto from = response.begin();
+	const auto end = from + response.size();
+	auto error = MTPRpcError();
+	auto result = MTPBool();
+	if (response[0] == mtpc_boolTrue) {
+		return DcKeyBindState::Success;
+	} else if (response[0] == mtpc_rpc_error && error.read(from, end)) {
+		const auto destroyed = error.match([&](const MTPDrpc_error &data) {
+			return (data.verror_code().v == 400)
+				&& (data.verror_message().v == "ENCRYPTED_MESSAGE_INVALID");
+		});
+		return destroyed
+			? DcKeyBindState::DefinitelyDestroyed
+			: DcKeyBindState::Failed;
+	} else {
+		return DcKeyBindState::Failed;
+	}
+}
+
+AuthKeyPtr DcKeyBinder::persistentKey() const {
+	return _persistentKey;
+}
+
+} // namespace MTP::details
diff --git a/Telegram/SourceFiles/mtproto/details/mtproto_dc_key_binder.h b/Telegram/SourceFiles/mtproto/details/mtproto_dc_key_binder.h
new file mode 100644
index 000000000..882e0f88d
--- /dev/null
+++ b/Telegram/SourceFiles/mtproto/details/mtproto_dc_key_binder.h
@@ -0,0 +1,42 @@
+/*
+This file is part of Telegram Desktop,
+the official desktop application for the Telegram messaging service.
+
+For license and copyright information please follow this link:
+https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+*/
+#pragma once
+
+#include "mtproto/core_types.h"
+#include "mtproto/mtproto_auth_key.h"
+
+namespace MTP {
+class Instance;
+} // namespace MTP
+
+namespace MTP::details {
+
+class SerializedRequest;
+
+enum class DcKeyBindState {
+	Success,
+	Failed,
+	DefinitelyDestroyed,
+};
+
+class DcKeyBinder final {
+public:
+	explicit DcKeyBinder(AuthKeyPtr &&persistentKey);
+
+	[[nodiscard]] SerializedRequest prepareRequest(
+		const AuthKeyPtr &temporaryKey,
+		uint64 sessionId);
+	[[nodiscard]] DcKeyBindState handleResponse(const mtpBuffer &response);
+	[[nodiscard]] AuthKeyPtr persistentKey() const;
+
+private:
+	AuthKeyPtr _persistentKey;
+
+};
+
+} // namespace MTP::details
diff --git a/Telegram/SourceFiles/mtproto/details/mtproto_dc_key_creator.cpp b/Telegram/SourceFiles/mtproto/details/mtproto_dc_key_creator.cpp
new file mode 100644
index 000000000..d1da9f591
--- /dev/null
+++ b/Telegram/SourceFiles/mtproto/details/mtproto_dc_key_creator.cpp
@@ -0,0 +1,641 @@
+/*
+This file is part of Telegram Desktop,
+the official desktop application for the Telegram messaging service.
+
+For license and copyright information please follow this link:
+https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+*/
+#include "mtproto/details/mtproto_dc_key_creator.h"
+
+#include "mtproto/details/mtproto_rsa_public_key.h"
+#include "mtproto/connection_abstract.h"
+#include "mtproto/mtproto_dh_utils.h"
+#include "base/openssl_help.h"
+#include "base/unixtime.h"
+#include "scheme.h"
+#include "logs.h"
+
+#include <cmath>
+
+namespace MTP::details {
+namespace {
+
+struct ParsedPQ {
+	QByteArray p;
+	QByteArray q;
+};
+
+[[nodiscard]] ParsedPQ ParsePQ(const QByteArray &pqStr) {
+	if (pqStr.length() > 8) {
+		// More than 64 bit pq.
+		return ParsedPQ();
+	}
+
+	uint64 pq = 0, p, q;
+	const uchar *pqChars = (const uchar*)pqStr.constData();
+	for (uint32 i = 0, l = pqStr.length(); i < l; ++i) {
+		pq <<= 8;
+		pq |= (uint64)pqChars[i];
+	}
+	uint64 pqSqrt = (uint64)sqrtl((long double)pq), ySqr, y;
+	while (pqSqrt * pqSqrt > pq) --pqSqrt;
+	while (pqSqrt * pqSqrt < pq) ++pqSqrt;
+	for (ySqr = pqSqrt * pqSqrt - pq; ; ++pqSqrt, ySqr = pqSqrt * pqSqrt - pq) {
+		y = (uint64)sqrtl((long double)ySqr);
+		while (y * y > ySqr) --y;
+		while (y * y < ySqr) ++y;
+		if (!ySqr || y + pqSqrt >= pq) {
+			return ParsedPQ();
+		}
+		if (y * y == ySqr) {
+			p = pqSqrt + y;
+			q = (pqSqrt > y) ? (pqSqrt - y) : (y - pqSqrt);
+			break;
+		}
+	}
+	if (p > q) std::swap(p, q);
+
+	auto pStr = QByteArray(4, Qt::Uninitialized);
+	uchar *pChars = (uchar*)pStr.data();
+	for (uint32 i = 0; i < 4; ++i) {
+		*(pChars + 3 - i) = (uchar)(p & 0xFF);
+		p >>= 8;
+	}
+
+	auto qStr = QByteArray(4, Qt::Uninitialized);
+	uchar *qChars = (uchar*)qStr.data();
+	for (uint32 i = 0; i < 4; ++i) {
+		*(qChars + 3 - i) = (uchar)(q & 0xFF);
+		q >>= 8;
+	}
+
+	return { pStr, qStr };
+}
+
+template <typename PQInnerData>
+[[nodiscard]] bytes::vector EncryptPQInnerRSA(
+		const PQInnerData &data,
+		const RSAPublicKey &key) {
+	constexpr auto kSkipPrimes = 6;
+	constexpr auto kMaxPrimes = 65; // 260 bytes
+
+	using BoxedPQInnerData = std::conditional_t<
+		tl::is_boxed_v<PQInnerData>,
+		PQInnerData,
+		tl::boxed<PQInnerData>>;
+	const auto boxed = BoxedPQInnerData(data);
+	const auto p_q_inner_size = tl::count_length(boxed);
+	const auto sizeInPrimes = (p_q_inner_size >> 2) + kSkipPrimes;
+	if (sizeInPrimes >= kMaxPrimes) {
+		auto tmp = mtpBuffer();
+		tmp.reserve(sizeInPrimes);
+		boxed.write(tmp);
+		LOG(("AuthKey Error: too large data for RSA encrypt, size %1").arg(sizeInPrimes * sizeof(mtpPrime)));
+		DEBUG_LOG(("AuthKey Error: bad data for RSA encrypt %1").arg(Logs::mb(&tmp[0], tmp.size() * 4).str()));
+		return {}; // can't be 255-byte string
+	}
+
+	auto encBuffer = mtpBuffer();
+	encBuffer.reserve(kMaxPrimes);
+	encBuffer.resize(kSkipPrimes);
+	boxed.write(encBuffer);
+	encBuffer.resize(kMaxPrimes);
+	const auto bytes = bytes::make_span(encBuffer);
+
+	const auto hashSrc = bytes.subspan(
+		kSkipPrimes * sizeof(mtpPrime),
+		p_q_inner_size);
+	bytes::copy(bytes.subspan(sizeof(mtpPrime)), openssl::Sha1(hashSrc));
+	bytes::set_random(bytes.subspan(sizeInPrimes * sizeof(mtpPrime)));
+
+	const auto bytesToEncrypt = bytes.subspan(3, 256);
+	return key.encrypt(bytesToEncrypt);
+}
+
+[[nodiscard]] std::string EncryptClientDHInner(
+		const MTPClient_DH_Inner_Data &data,
+		const void *aesKey,
+		const void *aesIV) {
+	constexpr auto kSkipPrimes = openssl::kSha1Size / sizeof(mtpPrime);
+
+	auto client_dh_inner_size = tl::count_length(data);
+	auto encSize = (client_dh_inner_size >> 2) + kSkipPrimes;
+	auto encFullSize = encSize;
+	if (encSize & 0x03) {
+		encFullSize += 4 - (encSize & 0x03);
+	}
+
+	auto encBuffer = mtpBuffer();
+	encBuffer.reserve(encFullSize);
+	encBuffer.resize(kSkipPrimes);
+	data.write(encBuffer);
+	encBuffer.resize(encFullSize);
+
+	const auto bytes = bytes::make_span(encBuffer);
+
+	const auto hash = openssl::Sha1(bytes.subspan(
+		kSkipPrimes * sizeof(mtpPrime),
+		client_dh_inner_size));
+	bytes::copy(bytes, hash);
+	bytes::set_random(bytes.subspan(encSize * sizeof(mtpPrime)));
+
+	auto sdhEncString = std::string(encFullSize * 4, ' ');
+
+	aesIgeEncryptRaw(&encBuffer[0], &sdhEncString[0], encFullSize * sizeof(mtpPrime), aesKey, aesIV);
+
+	return sdhEncString;
+}
+
+// 128 lower-order bits of SHA1.
+MTPint128 NonceDigest(bytes::const_span data) {
+	const auto hash = openssl::Sha1(data);
+	return *(MTPint128*)(hash.data() + 4);
+}
+
+} // namespace
+
+DcKeyCreator::Attempt::~Attempt() {
+	const auto clearBytes = [](bytes::span bytes) {
+		OPENSSL_cleanse(bytes.data(), bytes.size());
+	};
+	OPENSSL_cleanse(&data, sizeof(data));
+	clearBytes(dhPrime);
+	clearBytes(g_a);
+	clearBytes(authKey);
+}
+
+DcKeyCreator::DcKeyCreator(
+	DcId dcId,
+	int16 protocolDcId,
+	not_null<AbstractConnection*> connection,
+	not_null<DcOptions*> dcOptions,
+	Delegate delegate,
+	DcKeyRequest request)
+: _connection(connection)
+, _dcOptions(dcOptions)
+, _dcId(dcId)
+, _protocolDcId(protocolDcId)
+, _request(request)
+, _delegate(std::move(delegate)) {
+	Expects(_request.temporaryExpiresIn > 0);
+	Expects(_delegate.done != nullptr);
+
+	QObject::connect(_connection, &AbstractConnection::receivedData, [=] {
+		answered();
+	});
+
+	if (_request.persistentNeeded) {
+		pqSend(&_persistent, 0);
+	} else {
+		pqSend(&_temporary, _request.temporaryExpiresIn);
+	}
+}
+
+DcKeyCreator::~DcKeyCreator() {
+	if (_delegate.done) {
+		stopReceiving();
+	}
+}
+
+template <typename RequestType>
+void DcKeyCreator::sendNotSecureRequest(const RequestType &request) {
+	auto packet = _connection->prepareNotSecurePacket(
+		request,
+		base::unixtime::mtproto_msg_id());
+
+	DEBUG_LOG(("AuthKey Info: sending request, size: %1, time: %3"
+		).arg(packet.size() - 8
+		).arg(packet[5]));
+
+	const auto bytesSize = packet.size() * sizeof(mtpPrime);
+
+	_connection->sendData(std::move(packet));
+
+	if (_delegate.sentSome) {
+		_delegate.sentSome(bytesSize);
+	}
+}
+
+template <typename RequestType, typename Response>
+std::optional<Response> DcKeyCreator::readNotSecureResponse(
+		gsl::span<const mtpPrime> answer) {
+	auto from = answer.data();
+	auto result = Response();
+	if (result.read(from, from + answer.size())) {
+		return result;
+	}
+	return std::nullopt;
+}
+
+void DcKeyCreator::answered() {
+	if (_delegate.receivedSome) {
+		_delegate.receivedSome();
+	}
+
+	if (_connection->received().empty()) {
+		LOG(("AuthKey Error: "
+			"trying to read response from empty received list"));
+		return failed();
+	}
+
+	const auto buffer = std::move(_connection->received().front());
+	_connection->received().pop_front();
+
+	const auto answer = _connection->parseNotSecureResponse(buffer);
+	if (answer.empty()) {
+		return failed();
+	}
+
+	handleAnswer(answer);
+}
+
+DcKeyCreator::Attempt *DcKeyCreator::attemptByNonce(const MTPint128 &nonce) {
+	if (_temporary.data.nonce == nonce) {
+		DEBUG_LOG(("AuthKey Info: receiving answer for temporary..."));
+		return &_temporary;
+	} else if (_persistent.data.nonce == nonce) {
+		DEBUG_LOG(("AuthKey Info: receiving answer for persistent..."));
+		return &_persistent;
+	}
+	LOG(("AuthKey Error: attempt by nonce not found."));
+	return nullptr;
+}
+
+void DcKeyCreator::handleAnswer(gsl::span<const mtpPrime> answer) {
+	if (const auto resPQ = readNotSecureResponse<MTPReq_pq>(answer)) {
+		const auto nonce = resPQ->match([](const auto &data) {
+			return data.vnonce();
+		});
+		if (const auto attempt = attemptByNonce(nonce)) {
+			DEBUG_LOG(("AuthKey Info: receiving Req_pq answer..."));
+			return pqAnswered(attempt, *resPQ);
+		}
+	} else if (const auto resDH = readNotSecureResponse<MTPReq_DH_params>(answer)) {
+		const auto nonce = resDH->match([](const auto &data) {
+			return data.vnonce();
+		});
+		if (const auto attempt = attemptByNonce(nonce)) {
+			DEBUG_LOG(("AuthKey Info: receiving Req_DH_params answer..."));
+			return dhParamsAnswered(attempt, *resDH);
+		}
+	} else if (const auto result = readNotSecureResponse<MTPSet_client_DH_params>(answer)) {
+		const auto nonce = result->match([](const auto &data) {
+			return data.vnonce();
+		});
+		if (const auto attempt = attemptByNonce(nonce)) {
+			DEBUG_LOG(("AuthKey Info: receiving Req_client_DH_params answer..."));
+			return dhClientParamsAnswered(attempt, *result);
+		}
+	}
+	LOG(("AuthKey Error: Unknown answer received."));
+	failed();
+}
+
+void DcKeyCreator::pqSend(not_null<Attempt*> attempt, TimeId expiresIn) {
+	DEBUG_LOG(("AuthKey Info: sending Req_pq for %1..."
+		).arg(expiresIn ? "temporary" : "persistent"));
+	attempt->stage = Stage::WaitingPQ;
+	attempt->expiresIn = expiresIn;
+	attempt->data.nonce = openssl::RandomValue<MTPint128>();
+	sendNotSecureRequest(MTPReq_pq_multi(attempt->data.nonce));
+}
+
+void DcKeyCreator::pqAnswered(
+		not_null<Attempt*> attempt,
+		const MTPresPQ &data) {
+	data.match([&](const MTPDresPQ &data) {
+		Expects(data.vnonce() == attempt->data.nonce);
+
+		if (attempt->stage != Stage::WaitingPQ) {
+			LOG(("AuthKey Error: Unexpected stage %1").arg(int(attempt->stage)));
+			return failed();
+		}
+		const auto rsaKey = _dcOptions->getDcRSAKey(
+			_dcId,
+			data.vserver_public_key_fingerprints().v);
+		if (!rsaKey.valid()) {
+			return failed(DcKeyError::UnknownPublicKey);
+		}
+
+		attempt->data.server_nonce = data.vserver_nonce();
+		attempt->data.new_nonce = openssl::RandomValue<MTPint256>();
+
+		const auto &pq = data.vpq().v;
+		const auto parsed = ParsePQ(data.vpq().v);
+		if (parsed.p.isEmpty() || parsed.q.isEmpty()) {
+			LOG(("AuthKey Error: could not factor pq!"));
+			DEBUG_LOG(("AuthKey Error: problematic pq: %1").arg(Logs::mb(pq.constData(), pq.length()).str()));
+			return failed();
+		}
+
+		const auto dhEncString = [&] {
+			return (attempt->expiresIn == 0)
+				? EncryptPQInnerRSA(
+					MTP_p_q_inner_data_dc(
+						data.vpq(),
+						MTP_bytes(parsed.p),
+						MTP_bytes(parsed.q),
+						attempt->data.nonce,
+						attempt->data.server_nonce,
+						attempt->data.new_nonce,
+						MTP_int(_protocolDcId)),
+					rsaKey)
+				: EncryptPQInnerRSA(
+					MTP_p_q_inner_data_temp_dc(
+						data.vpq(),
+						MTP_bytes(parsed.p),
+						MTP_bytes(parsed.q),
+						attempt->data.nonce,
+						attempt->data.server_nonce,
+						attempt->data.new_nonce,
+						MTP_int(_protocolDcId),
+						MTP_int(attempt->expiresIn)),
+					rsaKey);
+		}();
+		if (dhEncString.empty()) {
+			return failed();
+		}
+
+		attempt->stage = Stage::WaitingDH;
+		DEBUG_LOG(("AuthKey Info: sending Req_DH_params..."));
+		sendNotSecureRequest(MTPReq_DH_params(
+			attempt->data.nonce,
+			attempt->data.server_nonce,
+			MTP_bytes(parsed.p),
+			MTP_bytes(parsed.q),
+			MTP_long(rsaKey.fingerprint()),
+			MTP_bytes(dhEncString)));
+	});
+}
+
+void DcKeyCreator::dhParamsAnswered(
+		not_null<Attempt*> attempt,
+		const MTPserver_DH_Params &data) {
+	if (attempt->stage != Stage::WaitingDH) {
+		LOG(("AuthKey Error: Unexpected stage %1").arg(int(attempt->stage)));
+		return failed();
+	}
+	data.match([&](const MTPDserver_DH_params_ok &data) {
+		Expects(data.vnonce() == attempt->data.nonce);
+
+		if (data.vserver_nonce() != attempt->data.server_nonce) {
+			LOG(("AuthKey Error: received server_nonce <> sent server_nonce (in server_DH_params_ok)!"));
+			DEBUG_LOG(("AuthKey Error: received server_nonce: %1, sent server_nonce: %2").arg(Logs::mb(&data.vserver_nonce(), 16).str()).arg(Logs::mb(&attempt->data.server_nonce, 16).str()));
+			return failed();
+		}
+
+		auto &encDHStr = data.vencrypted_answer().v;
+		uint32 encDHLen = encDHStr.length(), encDHBufLen = encDHLen >> 2;
+		if ((encDHLen & 0x03) || encDHBufLen < 6) {
+			LOG(("AuthKey Error: bad encrypted data length %1 (in server_DH_params_ok)!").arg(encDHLen));
+			DEBUG_LOG(("AuthKey Error: received encrypted data %1").arg(Logs::mb(encDHStr.constData(), encDHLen).str()));
+			return failed();
+		}
+
+		const auto nlen = sizeof(attempt->data.new_nonce);
+		const auto slen = sizeof(attempt->data.server_nonce);
+		auto tmp_aes_buffer = bytes::array<1024>();
+		const auto tmp_aes = bytes::make_span(tmp_aes_buffer);
+		bytes::copy(tmp_aes, bytes::object_as_span(&attempt->data.new_nonce));
+		bytes::copy(tmp_aes.subspan(nlen), bytes::object_as_span(&attempt->data.server_nonce));
+		bytes::copy(tmp_aes.subspan(nlen + slen), bytes::object_as_span(&attempt->data.new_nonce));
+		bytes::copy(tmp_aes.subspan(nlen + slen + nlen), bytes::object_as_span(&attempt->data.new_nonce));
+		const auto sha1ns = openssl::Sha1(tmp_aes.subspan(0, nlen + slen));
+		const auto sha1sn = openssl::Sha1(tmp_aes.subspan(nlen, nlen + slen));
+		const auto sha1nn = openssl::Sha1(tmp_aes.subspan(nlen + slen, nlen + nlen));
+
+		mtpBuffer decBuffer;
+		decBuffer.resize(encDHBufLen);
+
+		const auto aesKey = bytes::make_span(attempt->data.aesKey);
+		const auto aesIV = bytes::make_span(attempt->data.aesIV);
+		bytes::copy(aesKey, bytes::make_span(sha1ns).subspan(0, 20));
+		bytes::copy(aesKey.subspan(20), bytes::make_span(sha1sn).subspan(0, 12));
+		bytes::copy(aesIV, bytes::make_span(sha1sn).subspan(12, 8));
+		bytes::copy(aesIV.subspan(8), bytes::make_span(sha1nn).subspan(0, 20));
+		bytes::copy(aesIV.subspan(28), bytes::object_as_span(&attempt->data.new_nonce).subspan(0, 4));
+
+		aesIgeDecryptRaw(encDHStr.constData(), &decBuffer[0], encDHLen, aesKey.data(), aesIV.data());
+
+		const mtpPrime *from(&decBuffer[5]), *to(from), *end(from + (encDHBufLen - 5));
+		MTPServer_DH_inner_data dh_inner;
+		if (!dh_inner.read(to, end)) {
+			LOG(("AuthKey Error: could not decrypt server_DH_inner_data!"));
+			return failed();
+		}
+		const auto &dh_inner_data(dh_inner.c_server_DH_inner_data());
+		if (dh_inner_data.vnonce() != attempt->data.nonce) {
+			LOG(("AuthKey Error: received nonce <> sent nonce (in server_DH_inner_data)!"));
+			DEBUG_LOG(("AuthKey Error: received nonce: %1, sent nonce: %2").arg(Logs::mb(&dh_inner_data.vnonce(), 16).str()).arg(Logs::mb(&attempt->data.nonce, 16).str()));
+			return failed();
+		}
+		if (dh_inner_data.vserver_nonce() != attempt->data.server_nonce) {
+			LOG(("AuthKey Error: received server_nonce <> sent server_nonce (in server_DH_inner_data)!"));
+			DEBUG_LOG(("AuthKey Error: received server_nonce: %1, sent server_nonce: %2").arg(Logs::mb(&dh_inner_data.vserver_nonce(), 16).str()).arg(Logs::mb(&attempt->data.server_nonce, 16).str()));
+			return failed();
+		}
+		const auto sha1Buffer = openssl::Sha1(
+			bytes::make_span(decBuffer).subspan(
+				5 * sizeof(mtpPrime),
+				(to - from) * sizeof(mtpPrime)));
+		const auto sha1Dec = bytes::make_span(decBuffer).subspan(
+			0,
+			openssl::kSha1Size);
+		if (bytes::compare(sha1Dec, sha1Buffer)) {
+			LOG(("AuthKey Error: sha1 hash of encrypted part did not match!"));
+			DEBUG_LOG(("AuthKey Error: sha1 did not match, server_nonce: %1, new_nonce %2, encrypted data %3").arg(Logs::mb(&attempt->data.server_nonce, 16).str()).arg(Logs::mb(&attempt->data.new_nonce, 16).str()).arg(Logs::mb(encDHStr.constData(), encDHLen).str()));
+			return failed();
+		}
+		base::unixtime::update(dh_inner_data.vserver_time().v);
+
+		// check that dhPrime and (dhPrime - 1) / 2 are really prime
+		if (!IsPrimeAndGood(bytes::make_span(dh_inner_data.vdh_prime().v), dh_inner_data.vg().v)) {
+			LOG(("AuthKey Error: bad dh_prime primality!"));
+			return failed();
+		}
+
+		attempt->dhPrime = bytes::make_vector(
+			dh_inner_data.vdh_prime().v);
+		attempt->data.g = dh_inner_data.vg().v;
+		attempt->g_a = bytes::make_vector(dh_inner_data.vg_a().v);
+		attempt->data.retry_id = MTP_long(0);
+		attempt->retries = 0;
+		dhClientParamsSend(attempt);
+	}, [&](const MTPDserver_DH_params_fail &data) {
+		Expects(data.vnonce() == attempt->data.nonce);
+
+		if (data.vserver_nonce() != attempt->data.server_nonce) {
+			LOG(("AuthKey Error: received server_nonce <> sent server_nonce (in server_DH_params_fail)!"));
+			DEBUG_LOG(("AuthKey Error: received server_nonce: %1, sent server_nonce: %2").arg(Logs::mb(&data.vserver_nonce(), 16).str()).arg(Logs::mb(&attempt->data.server_nonce, 16).str()));
+			return failed();
+		}
+		if (data.vnew_nonce_hash() != NonceDigest(bytes::object_as_span(&attempt->data.new_nonce))) {
+			LOG(("AuthKey Error: received new_nonce_hash did not match!"));
+			DEBUG_LOG(("AuthKey Error: received new_nonce_hash: %1, new_nonce: %2").arg(Logs::mb(&data.vnew_nonce_hash(), 16).str()).arg(Logs::mb(&attempt->data.new_nonce, 32).str()));
+			return failed();
+		}
+		LOG(("AuthKey Error: server_DH_params_fail received!"));
+		failed();
+	});
+}
+
+void DcKeyCreator::dhClientParamsSend(not_null<Attempt*> attempt) {
+	if (++attempt->retries > 5) {
+		LOG(("AuthKey Error: could not create auth_key for %1 retries").arg(attempt->retries - 1));
+		return failed();
+	}
+
+	// gen rand 'b'
+	auto randomSeed = bytes::vector(ModExpFirst::kRandomPowerSize);
+	bytes::set_random(randomSeed);
+	auto g_b_data = CreateModExp(attempt->data.g, attempt->dhPrime, randomSeed);
+	if (g_b_data.modexp.empty()) {
+		LOG(("AuthKey Error: could not generate good g_b."));
+		return failed();
+	}
+
+	auto computedAuthKey = CreateAuthKey(attempt->g_a, g_b_data.randomPower, attempt->dhPrime);
+	if (computedAuthKey.empty()) {
+		LOG(("AuthKey Error: could not generate auth_key."));
+		return failed();
+	}
+	AuthKey::FillData(attempt->authKey, computedAuthKey);
+
+	auto auth_key_sha = openssl::Sha1(attempt->authKey);
+	memcpy(&attempt->data.auth_key_aux_hash, auth_key_sha.data(), 8);
+	memcpy(&attempt->data.auth_key_hash, auth_key_sha.data() + 12, 8);
+
+	const auto client_dh_inner = MTP_client_DH_inner_data(
+		attempt->data.nonce,
+		attempt->data.server_nonce,
+		attempt->data.retry_id,
+		MTP_bytes(g_b_data.modexp));
+
+	auto sdhEncString = EncryptClientDHInner(
+		client_dh_inner,
+		attempt->data.aesKey.data(),
+		attempt->data.aesIV.data());
+
+	attempt->stage = Stage::WaitingDone;
+	DEBUG_LOG(("AuthKey Info: sending Req_client_DH_params..."));
+	sendNotSecureRequest(MTPSet_client_DH_params(
+		attempt->data.nonce,
+		attempt->data.server_nonce,
+		MTP_string(std::move(sdhEncString))));
+}
+
+void DcKeyCreator::dhClientParamsAnswered(
+		not_null<Attempt*> attempt,
+		const MTPset_client_DH_params_answer &data) {
+	if (attempt->stage != Stage::WaitingDone) {
+		LOG(("AuthKey Error: Unexpected stage %1").arg(int(attempt->stage)));
+		return failed();
+	}
+
+	data.match([&](const MTPDdh_gen_ok &data) {
+		if (data.vnonce() != attempt->data.nonce) {
+			LOG(("AuthKey Error: received nonce <> sent nonce (in dh_gen_ok)!"));
+			DEBUG_LOG(("AuthKey Error: received nonce: %1, sent nonce: %2").arg(Logs::mb(&data.vnonce(), 16).str()).arg(Logs::mb(&attempt->data.nonce, 16).str()));
+			return failed();
+		}
+		if (data.vserver_nonce() != attempt->data.server_nonce) {
+			LOG(("AuthKey Error: received server_nonce <> sent server_nonce (in dh_gen_ok)!"));
+			DEBUG_LOG(("AuthKey Error: received server_nonce: %1, sent server_nonce: %2").arg(Logs::mb(&data.vserver_nonce(), 16).str()).arg(Logs::mb(&attempt->data.server_nonce, 16).str()));
+			return failed();
+		}
+		attempt->data.new_nonce_buf[32] = bytes::type(1);
+		if (data.vnew_nonce_hash1() != NonceDigest(attempt->data.new_nonce_buf)) {
+			LOG(("AuthKey Error: received new_nonce_hash1 did not match!"));
+			DEBUG_LOG(("AuthKey Error: received new_nonce_hash1: %1, new_nonce_buf: %2").arg(Logs::mb(&data.vnew_nonce_hash1(), 16).str()).arg(Logs::mb(attempt->data.new_nonce_buf.data(), 41).str()));
+			return failed();
+		}
+
+		uint64 salt1 = attempt->data.new_nonce.l.l, salt2 = attempt->data.server_nonce.l;
+		attempt->data.doneSalt = salt1 ^ salt2;
+		attempt->stage = Stage::Ready;
+		done();
+	}, [&](const MTPDdh_gen_retry &data) {
+		if (data.vnonce() != attempt->data.nonce) {
+			LOG(("AuthKey Error: received nonce <> sent nonce (in dh_gen_retry)!"));
+			DEBUG_LOG(("AuthKey Error: received nonce: %1, sent nonce: %2").arg(Logs::mb(&data.vnonce(), 16).str()).arg(Logs::mb(&attempt->data.nonce, 16).str()));
+			return failed();
+		}
+		if (data.vserver_nonce() != attempt->data.server_nonce) {
+			LOG(("AuthKey Error: received server_nonce <> sent server_nonce (in dh_gen_retry)!"));
+			DEBUG_LOG(("AuthKey Error: received server_nonce: %1, sent server_nonce: %2").arg(Logs::mb(&data.vserver_nonce(), 16).str()).arg(Logs::mb(&attempt->data.server_nonce, 16).str()));
+			return failed();
+		}
+		attempt->data.new_nonce_buf[32] = bytes::type(2);
+		uchar sha1Buffer[20];
+		if (data.vnew_nonce_hash2() != NonceDigest(attempt->data.new_nonce_buf)) {
+			LOG(("AuthKey Error: received new_nonce_hash2 did not match!"));
+			DEBUG_LOG(("AuthKey Error: received new_nonce_hash2: %1, new_nonce_buf: %2").arg(Logs::mb(&data.vnew_nonce_hash2(), 16).str()).arg(Logs::mb(attempt->data.new_nonce_buf.data(), 41).str()));
+			return failed();
+		}
+		attempt->data.retry_id = attempt->data.auth_key_aux_hash;
+		dhClientParamsSend(attempt);
+	}, [&](const MTPDdh_gen_fail &data) {
+		if (data.vnonce() != attempt->data.nonce) {
+			LOG(("AuthKey Error: received nonce <> sent nonce (in dh_gen_fail)!"));
+			DEBUG_LOG(("AuthKey Error: received nonce: %1, sent nonce: %2").arg(Logs::mb(&data.vnonce(), 16).str()).arg(Logs::mb(&attempt->data.nonce, 16).str()));
+			return failed();
+		}
+		if (data.vserver_nonce() != attempt->data.server_nonce) {
+			LOG(("AuthKey Error: received server_nonce <> sent server_nonce (in dh_gen_fail)!"));
+			DEBUG_LOG(("AuthKey Error: received server_nonce: %1, sent server_nonce: %2").arg(Logs::mb(&data.vserver_nonce(), 16).str()).arg(Logs::mb(&attempt->data.server_nonce, 16).str()));
+			return failed();
+		}
+		attempt->data.new_nonce_buf[32] = bytes::type(3);
+		uchar sha1Buffer[20];
+		if (data.vnew_nonce_hash3() != NonceDigest(attempt->data.new_nonce_buf)) {
+			LOG(("AuthKey Error: received new_nonce_hash3 did not match!"));
+			DEBUG_LOG(("AuthKey Error: received new_nonce_hash3: %1, new_nonce_buf: %2").arg(Logs::mb(&data.vnew_nonce_hash3(), 16).str()).arg(Logs::mb(attempt->data.new_nonce_buf.data(), 41).str()));
+			return failed();
+		}
+		LOG(("AuthKey Error: dh_gen_fail received!"));
+		failed();
+	});
+}
+
+void DcKeyCreator::failed(DcKeyError error) {
+	stopReceiving();
+	auto onstack = base::take(_delegate.done);
+	onstack(tl::unexpected(error));
+}
+
+void DcKeyCreator::done() {
+	if (_temporary.stage == Stage::None) {
+		pqSend(&_temporary, _request.temporaryExpiresIn);
+		return;
+	}
+	Assert(_temporary.stage == Stage::Ready);
+	Assert(_persistent.stage == Stage::Ready || _persistent.stage == Stage::None);
+
+	auto result = DcKeyResult();
+	result.temporaryKey = std::make_shared<AuthKey>(
+		AuthKey::Type::Temporary,
+		_dcId,
+		_temporary.authKey);
+	result.temporaryServerSalt = _temporary.data.doneSalt;
+	if (_persistent.stage == Stage::Ready) {
+		result.persistentKey = std::make_shared<AuthKey>(
+			AuthKey::Type::Generated,
+			_dcId,
+			_persistent.authKey);
+		result.persistentServerSalt = _persistent.data.doneSalt;
+	}
+
+	stopReceiving();
+	auto onstack = base::take(_delegate.done);
+	onstack(std::move(result));
+}
+
+void DcKeyCreator::stopReceiving() {
+	QObject::disconnect(
+		_connection,
+		&AbstractConnection::receivedData,
+		nullptr,
+		nullptr);
+}
+
+} // namespace MTP::details
diff --git a/Telegram/SourceFiles/mtproto/details/mtproto_dc_key_creator.h b/Telegram/SourceFiles/mtproto/details/mtproto_dc_key_creator.h
new file mode 100644
index 000000000..f62bb8f41
--- /dev/null
+++ b/Telegram/SourceFiles/mtproto/details/mtproto_dc_key_creator.h
@@ -0,0 +1,139 @@
+/*
+This file is part of Telegram Desktop,
+the official desktop application for the Telegram messaging service.
+
+For license and copyright information please follow this link:
+https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+*/
+#pragma once
+
+#include "mtproto/core_types.h"
+#include "mtproto/mtproto_auth_key.h"
+#include "mtproto/connection_abstract.h"
+#include "base/basic_types.h"
+#include "base/expected.h"
+
+namespace MTP {
+class DcOptions;
+} // namespace MTP
+
+namespace MTP::details {
+
+struct DcKeyRequest {
+	TimeId temporaryExpiresIn = 0;
+	bool persistentNeeded = false;
+};
+
+enum class DcKeyError {
+	UnknownPublicKey,
+	Other,
+};
+
+struct DcKeyResult {
+	AuthKeyPtr persistentKey;
+	AuthKeyPtr temporaryKey;
+	uint64 temporaryServerSalt = 0;
+	uint64 persistentServerSalt = 0;
+};
+
+class DcKeyCreator final {
+public:
+	struct Delegate {
+		Fn<void(base::expected<DcKeyResult, DcKeyError>)> done;
+		Fn<void(uint64)> sentSome;
+		Fn<void()> receivedSome;
+	};
+
+	DcKeyCreator(
+		DcId dcId,
+		int16 protocolDcId,
+		not_null<AbstractConnection*> connection,
+		not_null<DcOptions*> dcOptions,
+		Delegate delegate,
+		DcKeyRequest request);
+	~DcKeyCreator();
+
+private:
+	enum class Stage {
+		None,
+		WaitingPQ,
+		WaitingDH,
+		WaitingDone,
+		Ready,
+	};
+	struct Data {
+		Data()
+		: new_nonce(*(MTPint256*)((uchar*)new_nonce_buf.data()))
+		, auth_key_aux_hash(*(MTPlong*)((uchar*)new_nonce_buf.data() + 33)) {
+		}
+		MTPint128 nonce, server_nonce;
+
+		// 32 bytes new_nonce + 1 check byte + 8 bytes of auth_key_aux_hash.
+		bytes::array<41> new_nonce_buf;
+
+		MTPint256 &new_nonce;
+		MTPlong &auth_key_aux_hash;
+
+		MTPlong retry_id;
+
+		int32 g = 0;
+
+		bytes::array<32> aesKey;
+		bytes::array<32> aesIV;
+		MTPlong auth_key_hash;
+		uint64 doneSalt = 0;
+	};
+	struct Attempt {
+		~Attempt();
+
+		Data data;
+		bytes::vector dhPrime;
+		bytes::vector g_a;
+		AuthKey::Data authKey = { { gsl::byte{} } };
+		TimeId expiresIn = 0;
+		uint32 retries = 0;
+		Stage stage = Stage::None;
+	};
+
+	template <typename RequestType>
+	void sendNotSecureRequest(const RequestType &request);
+
+	template <
+		typename RequestType,
+		typename Response = typename RequestType::ResponseType>
+	[[nodiscard]] std::optional<Response> readNotSecureResponse(
+			gsl::span<const mtpPrime> answer);
+
+	Attempt *attemptByNonce(const MTPint128 &nonce);
+
+	void answered();
+	void handleAnswer(gsl::span<const mtpPrime> answer);
+	void pqSend(not_null<Attempt*> attempt, TimeId expiresIn);
+	void pqAnswered(
+		not_null<Attempt*> attempt,
+		const MTPresPQ &data);
+	void dhParamsAnswered(
+		not_null<Attempt*> attempt,
+		const MTPserver_DH_Params &data);
+	void dhClientParamsSend(not_null<Attempt*> attempt);
+	void dhClientParamsAnswered(
+		not_null<Attempt*> attempt,
+		const MTPset_client_DH_params_answer &data);
+
+	void stopReceiving();
+	void failed(DcKeyError error = DcKeyError::Other);
+	void done();
+
+	const not_null<AbstractConnection*> _connection;
+	const not_null<DcOptions*> _dcOptions;
+	const DcId _dcId = 0;
+	const int16 _protocolDcId = 0;
+	const DcKeyRequest _request;
+	Delegate _delegate;
+
+	Attempt _temporary;
+	Attempt _persistent;
+
+};
+
+} // namespace MTP::details
diff --git a/Telegram/SourceFiles/mtproto/details/mtproto_dcenter.cpp b/Telegram/SourceFiles/mtproto/details/mtproto_dcenter.cpp
new file mode 100644
index 000000000..7dbf0a602
--- /dev/null
+++ b/Telegram/SourceFiles/mtproto/details/mtproto_dcenter.cpp
@@ -0,0 +1,169 @@
+/*
+This file is part of Telegram Desktop,
+the official desktop application for the Telegram messaging service.
+
+For license and copyright information please follow this link:
+https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+*/
+#include "mtproto/details/mtproto_dcenter.h"
+
+#include "mtproto/facade.h"
+#include "mtproto/mtproto_auth_key.h"
+#include "mtproto/dc_options.h"
+#include "mtproto/mtp_instance.h"
+#include "mtproto/special_config_request.h"
+
+namespace MTP {
+namespace details {
+namespace {
+
+constexpr auto kEnumerateDcTimeout = 8000; // 8 seconds timeout for help_getConfig to work (then move to other dc)
+constexpr auto kSpecialRequestTimeoutMs = 6000; // 4 seconds timeout for it to work in a specially requested dc.
+
+int IndexByType(TemporaryKeyType type) {
+	switch (type) {
+	case TemporaryKeyType::Regular: return 0;
+	case TemporaryKeyType::MediaCluster: return 1;
+	}
+	Unexpected("Type value in IndexByType.");
+}
+
+int IndexByType(CreatingKeyType type) {
+	switch (type) {
+	case CreatingKeyType::Persistent:
+	case CreatingKeyType::TemporaryRegular: return 0;
+	case CreatingKeyType::TemporaryMediaCluster: return 1;
+	}
+	Unexpected("Creating type value in IndexByType.");
+}
+
+const char *NameOfType(CreatingKeyType type) {
+	switch (type) {
+	case CreatingKeyType::Persistent: return "persistent";
+	case CreatingKeyType::TemporaryRegular: return "regular";
+	case CreatingKeyType::TemporaryMediaCluster: return "media";
+	}
+	Unexpected("Type value in NameOfType.");
+}
+
+} // namespace
+
+
+TemporaryKeyType TemporaryKeyTypeByDcType(DcType type) {
+	return (type == DcType::MediaCluster)
+		? TemporaryKeyType::MediaCluster
+		: TemporaryKeyType::Regular;
+}
+
+Dcenter::Dcenter(DcId dcId, AuthKeyPtr &&key)
+: _id(dcId)
+, _persistentKey(std::move(key)) {
+}
+
+DcId Dcenter::id() const {
+	return _id;
+}
+
+AuthKeyPtr Dcenter::getTemporaryKey(TemporaryKeyType type) const {
+	QReadLocker lock(&_mutex);
+	return _temporaryKeys[IndexByType(type)];
+}
+
+AuthKeyPtr Dcenter::getPersistentKey() const {
+	QReadLocker lock(&_mutex);
+	return _persistentKey;
+}
+
+bool Dcenter::destroyTemporaryKey(uint64 keyId) {
+	QWriteLocker lock(&_mutex);
+	for (auto &key : _temporaryKeys) {
+		if (key && key->keyId() == keyId) {
+			key = nullptr;
+			_connectionInited = false;
+			return true;
+		}
+	}
+	return false;
+}
+
+bool Dcenter::destroyConfirmedForgottenKey(uint64 keyId) {
+	QWriteLocker lock(&_mutex);
+	if (!_persistentKey || _persistentKey->keyId() != keyId) {
+		return false;
+	}
+	for (auto &key : _temporaryKeys) {
+		key = nullptr;
+	}
+	_persistentKey = nullptr;
+	_connectionInited = false;
+	return true;
+}
+
+bool Dcenter::connectionInited() const {
+	QReadLocker lock(&_mutex);
+	return _connectionInited;
+}
+
+void Dcenter::setConnectionInited(bool connectionInited) {
+	QWriteLocker lock(&_mutex);
+	_connectionInited = connectionInited;
+}
+
+CreatingKeyType Dcenter::acquireKeyCreation(DcType type) {
+	QReadLocker lock(&_mutex);
+	const auto keyType = TemporaryKeyTypeByDcType(type);
+	const auto index = IndexByType(keyType);
+	auto &key = _temporaryKeys[index];
+	if (key != nullptr) {
+		return CreatingKeyType::None;
+	}
+	auto expected = false;
+	const auto regular = IndexByType(TemporaryKeyType::Regular);
+	if (keyType == TemporaryKeyType::MediaCluster && _temporaryKeys[regular]) {
+		return !_creatingKeys[index].compare_exchange_strong(expected, true)
+			? CreatingKeyType::None
+			: CreatingKeyType::TemporaryMediaCluster;
+	}
+	return !_creatingKeys[regular].compare_exchange_strong(expected, true)
+		? CreatingKeyType::None
+		: (type != DcType::Cdn && !_persistentKey)
+		? CreatingKeyType::Persistent
+		: CreatingKeyType::TemporaryRegular;
+}
+
+bool Dcenter::releaseKeyCreationOnDone(
+		CreatingKeyType type,
+		const AuthKeyPtr &temporaryKey,
+		const AuthKeyPtr &persistentKeyUsedForBind) {
+	Expects(_creatingKeys[IndexByType(type)]);
+	Expects(_temporaryKeys[IndexByType(type)] == nullptr);
+	Expects(temporaryKey != nullptr);
+
+	QWriteLocker lock(&_mutex);
+	if (type == CreatingKeyType::Persistent) {
+		_persistentKey = persistentKeyUsedForBind;
+	} else if (_persistentKey != persistentKeyUsedForBind) {
+		return false;
+	}
+	_temporaryKeys[IndexByType(type)] = temporaryKey;
+	_creatingKeys[IndexByType(type)] = false;
+	_connectionInited = false;
+
+	DEBUG_LOG(("AuthKey Info: Dcenter::releaseKeyCreationOnDone(%1, %2, %3)."
+		).arg(NameOfType(type)
+		).arg(temporaryKey ? temporaryKey->keyId() : 0
+		).arg(persistentKeyUsedForBind
+			? persistentKeyUsedForBind->keyId()
+			: 0));
+	return true;
+}
+
+void Dcenter::releaseKeyCreationOnFail(CreatingKeyType type) {
+	Expects(_creatingKeys[IndexByType(type)]);
+	Expects(_temporaryKeys[IndexByType(type)] == nullptr);
+
+	_creatingKeys[IndexByType(type)] = false;
+}
+
+} // namespace details
+} // namespace MTP
diff --git a/Telegram/SourceFiles/mtproto/details/mtproto_dcenter.h b/Telegram/SourceFiles/mtproto/details/mtproto_dcenter.h
new file mode 100644
index 000000000..651dcf171
--- /dev/null
+++ b/Telegram/SourceFiles/mtproto/details/mtproto_dcenter.h
@@ -0,0 +1,70 @@
+/*
+This file is part of Telegram Desktop,
+the official desktop application for the Telegram messaging service.
+
+For license and copyright information please follow this link:
+https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+*/
+#pragma once
+
+#include <QtCore/QReadWriteLock>
+
+namespace MTP {
+
+class Instance;
+class AuthKey;
+using AuthKeyPtr = std::shared_ptr<AuthKey>;
+enum class DcType;
+
+namespace details {
+
+enum class TemporaryKeyType {
+	Regular,
+	MediaCluster
+};
+
+enum class CreatingKeyType {
+	None,
+	Persistent,
+	TemporaryRegular,
+	TemporaryMediaCluster
+};
+
+[[nodiscard]] TemporaryKeyType TemporaryKeyTypeByDcType(DcType type);
+
+class Dcenter : public QObject {
+public:
+	// Main thread.
+	Dcenter(DcId dcId, AuthKeyPtr &&key);
+
+	// Thread-safe.
+	[[nodiscard]] DcId id() const;
+	[[nodiscard]] AuthKeyPtr getPersistentKey() const;
+	[[nodiscard]] AuthKeyPtr getTemporaryKey(TemporaryKeyType type) const;
+	[[nodiscard]] CreatingKeyType acquireKeyCreation(DcType type);
+	bool releaseKeyCreationOnDone(
+		CreatingKeyType type,
+		const AuthKeyPtr &temporaryKey,
+		const AuthKeyPtr &persistentKeyUsedForBind);
+	void releaseKeyCreationOnFail(CreatingKeyType type);
+	bool destroyTemporaryKey(uint64 keyId);
+	bool destroyConfirmedForgottenKey(uint64 keyId);
+
+	[[nodiscard]] bool connectionInited() const;
+	void setConnectionInited(bool connectionInited = true);
+
+private:
+	static constexpr auto kTemporaryKeysCount = 2;
+
+	const DcId _id = 0;
+	mutable QReadWriteLock _mutex;
+
+	AuthKeyPtr _temporaryKeys[kTemporaryKeysCount];
+	AuthKeyPtr _persistentKey;
+	bool _connectionInited = false;
+	std::atomic<bool> _creatingKeys[kTemporaryKeysCount] = { false };
+
+};
+
+} // namespace details
+} // namespace MTP
diff --git a/Telegram/SourceFiles/mtproto/details/mtproto_domain_resolver.cpp b/Telegram/SourceFiles/mtproto/details/mtproto_domain_resolver.cpp
new file mode 100644
index 000000000..b26308978
--- /dev/null
+++ b/Telegram/SourceFiles/mtproto/details/mtproto_domain_resolver.cpp
@@ -0,0 +1,362 @@
+/*
+This file is part of Telegram Desktop,
+the official desktop application for the Telegram messaging service.
+
+For license and copyright information please follow this link:
+https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+*/
+#include "mtproto/details/mtproto_domain_resolver.h"
+
+#include "base/openssl_help.h"
+#include "base/invoke_queued.h"
+#include "base/call_delayed.h"
+
+#include <QtCore/QJsonDocument>
+#include <QtCore/QJsonArray>
+#include <QtCore/QJsonObject>
+#include <range/v3/algorithm/shuffle.hpp>
+#include <range/v3/algorithm/reverse.hpp>
+#include <range/v3/algorithm/remove.hpp>
+#include <random>
+
+namespace MTP::details {
+namespace {
+
+constexpr auto kSendNextTimeout = crl::time(800);
+constexpr auto kMinTimeToLive = 10 * crl::time(1000);
+constexpr auto kMaxTimeToLive = 300 * crl::time(1000);
+
+} // namespace
+
+const std::vector<QString> &DnsDomains() {
+	static const auto kResult = std::vector<QString>{
+		"google.com",
+		"www.google.com",
+		"google.ru",
+		"www.google.ru",
+	};
+	return kResult;
+}
+
+QString GenerateDnsRandomPadding() {
+	constexpr char kValid[] = "abcdefghijklmnopqrstuvwxyz"
+		"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
+
+	auto result = QString();
+	const auto count = [&] {
+		constexpr auto kMinPadding = 13;
+		constexpr auto kMaxPadding = 128;
+		while (true) {
+			const auto result = 1 + (openssl::RandomValue<uchar>() / 2);
+			Assert(result <= kMaxPadding);
+			if (result >= kMinPadding) {
+				return result;
+			}
+		}
+	}();
+	result.resize(count);
+	for (auto &ch : result) {
+		ch = kValid[openssl::RandomValue<uchar>() % (sizeof(kValid) - 1)];
+	}
+	return result;
+}
+
+QByteArray DnsUserAgent() {
+	static const auto kResult = QByteArray(
+		"Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
+		"AppleWebKit/537.36 (KHTML, like Gecko) "
+		"Chrome/77.0.3865.90 Safari/537.36");
+	return kResult;
+}
+
+std::vector<DnsEntry> ParseDnsResponse(
+		const QByteArray &bytes,
+		std::optional<int> typeRestriction) {
+	// Read and store to "result" all the data bytes from the response:
+	// { ..,
+	//   "Answer": [
+	//     { .., "data": "bytes1", "TTL": int, .. },
+	//     { .., "data": "bytes2", "TTL": int, .. }
+	//   ],
+	// .. }
+	auto error = QJsonParseError{ 0, QJsonParseError::NoError };
+	const auto document = QJsonDocument::fromJson(bytes, &error);
+	if (error.error != QJsonParseError::NoError) {
+		LOG(("Config Error: Failed to parse dns response JSON, error: %1"
+			).arg(error.errorString()));
+		return {};
+	} else if (!document.isObject()) {
+		LOG(("Config Error: Not an object received in dns response JSON."));
+		return {};
+	}
+	const auto response = document.object();
+	const auto answerIt = response.find("Answer");
+	if (answerIt == response.constEnd()) {
+		LOG(("Config Error: Could not find Answer in dns response JSON."));
+		return {};
+	} else if (!(*answerIt).isArray()) {
+		LOG(("Config Error: Not an array received "
+			"in Answer in dns response JSON."));
+		return {};
+	}
+
+	auto result = std::vector<DnsEntry>();
+	for (const auto elem : (*answerIt).toArray()) {
+		if (!elem.isObject()) {
+			LOG(("Config Error: Not an object found "
+				"in Answer array in dns response JSON."));
+			continue;
+		}
+		const auto object = elem.toObject();
+		if (typeRestriction) {
+			const auto typeIt = object.find("type");
+			const auto type = int(std::round((*typeIt).toDouble()));
+			if (!(*typeIt).isDouble()) {
+				LOG(("Config Error: Not a number in type field "
+					"in Answer array in dns response JSON."));
+				continue;
+			} else if (type != *typeRestriction) {
+				continue;
+			}
+		}
+		const auto dataIt = object.find("data");
+		if (dataIt == object.constEnd()) {
+			LOG(("Config Error: Could not find data "
+				"in Answer array entry in dns response JSON."));
+			continue;
+		} else if (!(*dataIt).isString()) {
+			LOG(("Config Error: Not a string data found "
+				"in Answer array entry in dns response JSON."));
+			continue;
+		}
+
+		const auto ttlIt = object.find("TTL");
+		const auto ttl = (ttlIt != object.constEnd())
+			? crl::time(std::round((*ttlIt).toDouble()))
+			: crl::time(0);
+		result.push_back({ (*dataIt).toString(), ttl });
+	}
+	return result;
+}
+
+ServiceWebRequest::ServiceWebRequest(not_null<QNetworkReply*> reply)
+: reply(reply.get()) {
+}
+
+ServiceWebRequest::ServiceWebRequest(ServiceWebRequest &&other)
+: reply(base::take(other.reply)) {
+}
+
+ServiceWebRequest &ServiceWebRequest::operator=(ServiceWebRequest &&other) {
+	if (reply != other.reply) {
+		destroy();
+		reply = base::take(other.reply);
+	}
+	return *this;
+}
+
+void ServiceWebRequest::destroy() {
+	if (const auto value = base::take(reply)) {
+		value->disconnect(
+			value,
+			&QNetworkReply::finished,
+			nullptr,
+			nullptr);
+		value->abort();
+		value->deleteLater();
+	}
+}
+
+ServiceWebRequest::~ServiceWebRequest() {
+	if (reply) {
+		reply->deleteLater();
+	}
+}
+
+DomainResolver::DomainResolver(Fn<void(
+	const QString &host,
+	const QStringList &ips,
+	crl::time expireAt)> callback)
+: _callback(std::move(callback)) {
+	_manager.setProxy(QNetworkProxy::NoProxy);
+}
+
+void DomainResolver::resolve(const QString &domain) {
+	resolve({ domain, false });
+	resolve({ domain, true });
+}
+
+void DomainResolver::resolve(const AttemptKey &key) {
+	if (_attempts.find(key) != end(_attempts)) {
+		return;
+	} else if (_requests.find(key) != end(_requests)) {
+		return;
+	}
+	const auto i = _cache.find(key);
+	_lastTimestamp = crl::now();
+	if (i != end(_cache) && i->second.expireAt > _lastTimestamp) {
+		checkExpireAndPushResult(key.domain);
+		return;
+	}
+
+	auto attempts = std::vector<Attempt>();
+	auto domains = DnsDomains();
+	std::random_device rd;
+	ranges::shuffle(domains, std::mt19937(rd()));
+	const auto takeDomain = [&] {
+		const auto result = domains.back();
+		domains.pop_back();
+		return result;
+	};
+	const auto shuffle = [&](int from, int till) {
+		Expects(till > from);
+
+		ranges::shuffle(
+			begin(attempts) + from,
+			begin(attempts) + till,
+			std::mt19937(rd()));
+	};
+
+	attempts.push_back({ Type::Google, "dns.google.com" });
+	attempts.push_back({ Type::Google, takeDomain(), "dns" });
+	attempts.push_back({ Type::Mozilla, "mozilla.cloudflare-dns.com" });
+	while (!domains.empty()) {
+		attempts.push_back({ Type::Google, takeDomain(), "dns" });
+	}
+
+	shuffle(0, 2);
+
+	ranges::reverse(attempts); // We go from last to first.
+
+	_attempts.emplace(key, Attempts{ std::move(attempts) });
+	sendNextRequest(key);
+}
+
+void DomainResolver::checkExpireAndPushResult(const QString &domain) {
+	const auto ipv4 = _cache.find({ domain, false });
+	if (ipv4 == end(_cache) || ipv4->second.expireAt <= _lastTimestamp) {
+		return;
+	}
+	auto result = ipv4->second;
+	const auto ipv6 = _cache.find({ domain, true });
+	if (ipv6 != end(_cache) && ipv6->second.expireAt > _lastTimestamp) {
+		result.ips.append(ipv6->second.ips);
+		accumulate_min(result.expireAt, ipv6->second.expireAt);
+	}
+	InvokeQueued(this, [=] {
+		_callback(domain, result.ips, result.expireAt);
+	});
+}
+
+void DomainResolver::sendNextRequest(const AttemptKey &key) {
+	auto i = _attempts.find(key);
+	if (i == end(_attempts)) {
+		return;
+	}
+	auto &attempts = i->second;
+	auto &list = attempts.list;
+	const auto attempt = list.back();
+	list.pop_back();
+
+	if (!list.empty()) {
+		base::call_delayed(kSendNextTimeout, &attempts.guard, [=] {
+			sendNextRequest(key);
+		});
+	}
+	performRequest(key, attempt);
+}
+
+void DomainResolver::performRequest(
+		const AttemptKey &key,
+		const Attempt &attempt) {
+	auto url = QUrl();
+	url.setScheme("https");
+	auto request = QNetworkRequest();
+	switch (attempt.type) {
+	case Type::Mozilla: {
+		url.setHost(attempt.data);
+		url.setPath("/dns-query");
+		url.setQuery(QStringLiteral("name=%1&type=%2&random_padding=%3"
+		).arg(key.domain
+		).arg(key.ipv6 ? 28 : 1
+		).arg(GenerateDnsRandomPadding()));
+		request.setRawHeader("accept", "application/dns-json");
+	} break;
+	case Type::Google: {
+		url.setHost(attempt.data);
+		url.setPath("/resolve");
+		url.setQuery(QStringLiteral("name=%1&type=%2&random_padding=%3"
+		).arg(key.domain
+		).arg(key.ipv6 ? 28 : 1
+		).arg(GenerateDnsRandomPadding()));
+		if (!attempt.host.isEmpty()) {
+			const auto host = attempt.host + ".google.com";
+			request.setRawHeader("Host", host.toLatin1());
+		}
+	} break;
+	default: Unexpected("Type in SpecialConfigRequest::performRequest.");
+	}
+	request.setUrl(url);
+	request.setRawHeader("User-Agent", DnsUserAgent());
+	const auto i = _requests.emplace(
+		key,
+		std::vector<ServiceWebRequest>()).first;
+	const auto reply = i->second.emplace_back(
+		_manager.get(request)
+	).reply;
+	connect(reply, &QNetworkReply::finished, this, [=] {
+		requestFinished(key, reply);
+	});
+}
+
+void DomainResolver::requestFinished(
+		const AttemptKey &key,
+		not_null<QNetworkReply*> reply) {
+	const auto result = finalizeRequest(key, reply);
+	const auto response = ParseDnsResponse(result);
+	if (response.empty()) {
+		return;
+	}
+	_requests.erase(key);
+	_attempts.erase(key);
+
+	auto entry = CacheEntry();
+	auto ttl = kMaxTimeToLive;
+	for (const auto &item : response) {
+		entry.ips.push_back(item.data);
+		ttl = std::min(
+			ttl,
+			std::max(item.TTL * crl::time(1000), kMinTimeToLive));
+	}
+	_lastTimestamp = crl::now();
+	entry.expireAt = _lastTimestamp + ttl;
+	_cache[key] = std::move(entry);
+
+	checkExpireAndPushResult(key.domain);
+}
+
+QByteArray DomainResolver::finalizeRequest(
+		const AttemptKey &key,
+		not_null<QNetworkReply*> reply) {
+	if (reply->error() != QNetworkReply::NoError) {
+		LOG(("Resolve Error: Failed to get response, error: %2 (%3)"
+			).arg(reply->errorString()
+			).arg(reply->error()));
+	}
+	const auto result = reply->readAll();
+	const auto i = _requests.find(key);
+	if (i != end(_requests)) {
+		auto &requests = i->second;
+		const auto from = ranges::remove(
+			requests,
+			reply,
+			[](const ServiceWebRequest &request) { return request.reply; });
+		requests.erase(from, end(requests));
+		if (requests.empty()) {
+			_requests.erase(i);
+		}
+	}
+	return result;
+}
+
+} // namespace MTP::details
diff --git a/Telegram/SourceFiles/mtproto/details/mtproto_domain_resolver.h b/Telegram/SourceFiles/mtproto/details/mtproto_domain_resolver.h
new file mode 100644
index 000000000..cb1979bbb
--- /dev/null
+++ b/Telegram/SourceFiles/mtproto/details/mtproto_domain_resolver.h
@@ -0,0 +1,106 @@
+/*
+This file is part of Telegram Desktop,
+the official desktop application for the Telegram messaging service.
+
+For license and copyright information please follow this link:
+https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+*/
+#pragma once
+
+#include "base/weak_ptr.h"
+
+#include <QtCore/QPointer>
+#include <QtNetwork/QNetworkReply>
+#include <optional>
+
+namespace MTP::details {
+
+[[nodiscard]] const std::vector<QString> &DnsDomains();
+[[nodiscard]] QString GenerateDnsRandomPadding();
+[[nodiscard]] QByteArray DnsUserAgent();
+
+struct DnsEntry {
+	QString data;
+	crl::time TTL = 0;
+};
+
+[[nodiscard]] std::vector<DnsEntry> ParseDnsResponse(
+	const QByteArray &bytes,
+	std::optional<int> typeRestriction = std::nullopt);
+
+struct ServiceWebRequest {
+	ServiceWebRequest(not_null<QNetworkReply*> reply);
+	ServiceWebRequest(ServiceWebRequest &&other);
+	ServiceWebRequest &operator=(ServiceWebRequest &&other);
+	~ServiceWebRequest();
+
+	void destroy();
+
+	QPointer<QNetworkReply> reply;
+};
+
+class DomainResolver : public QObject {
+public:
+	DomainResolver(Fn<void(
+		const QString &domain,
+		const QStringList &ips,
+		crl::time expireAt)> callback);
+
+	void resolve(const QString &domain);
+
+private:
+	enum class Type {
+		Mozilla,
+		Google,
+	};
+	struct Attempt {
+		Type type;
+		QString data;
+		QString host;
+	};
+	struct AttemptKey {
+		QString domain;
+		bool ipv6 = false;
+
+		inline bool operator<(const AttemptKey &other) const {
+			return (domain < other.domain)
+				|| (domain == other.domain && !ipv6 && other.ipv6);
+		}
+		inline bool operator==(const AttemptKey &other) const {
+			return (domain == other.domain) && (ipv6 == other.ipv6);
+		}
+	};
+	struct CacheEntry {
+		QStringList ips;
+		crl::time expireAt = 0;
+	};
+	struct Attempts {
+		std::vector<Attempt> list;
+		base::has_weak_ptr guard;
+	};
+
+	void resolve(const AttemptKey &key);
+	void sendNextRequest(const AttemptKey &key);
+	void performRequest(const AttemptKey &key, const Attempt &attempt);
+	void checkExpireAndPushResult(const QString &domain);
+	void requestFinished(
+		const AttemptKey &key,
+		not_null<QNetworkReply*> reply);
+	QByteArray finalizeRequest(
+		const AttemptKey &key,
+		not_null<QNetworkReply*> reply);
+
+	Fn<void(
+		const QString &domain,
+		const QStringList &ips,
+		crl::time expireAt)> _callback;
+
+	QNetworkAccessManager _manager;
+	std::map<AttemptKey, Attempts> _attempts;
+	std::map<AttemptKey, std::vector<ServiceWebRequest>> _requests;
+	std::map<AttemptKey, CacheEntry> _cache;
+	crl::time _lastTimestamp = 0;
+
+};
+
+} // namespace MTP::details
diff --git a/Telegram/SourceFiles/mtproto/core_types.cpp b/Telegram/SourceFiles/mtproto/details/mtproto_dump_to_text.cpp
similarity index 52%
rename from Telegram/SourceFiles/mtproto/core_types.cpp
rename to Telegram/SourceFiles/mtproto/details/mtproto_dump_to_text.cpp
index 7a5a8bc1f..2ec424f6c 100644
--- a/Telegram/SourceFiles/mtproto/core_types.cpp
+++ b/Telegram/SourceFiles/mtproto/details/mtproto_dump_to_text.cpp
@@ -5,142 +5,15 @@ the official desktop application for the Telegram messaging service.
 For license and copyright information please follow this link:
 https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 */
-#include "mtproto/core_types.h"
+#include "mtproto/details/mtproto_dump_to_text.h"
 
-#include "zlib.h"
+#include "base/zlib_help.h"
+#include "scheme-dump_to_text.h"
+#include "scheme.h"
 
-namespace MTP {
-namespace {
+namespace MTP::details {
 
-uint32 CountPaddingAmountInInts(uint32 requestSize, bool extended) {
-#ifdef TDESKTOP_MTPROTO_OLD
-	return ((8 + requestSize) & 0x03)
-		? (4 - ((8 + requestSize) & 0x03))
-		: 0;
-#else // TDESKTOP_MTPROTO_OLD
-	auto result = ((8 + requestSize) & 0x03)
-		? (4 - ((8 + requestSize) & 0x03))
-		: 0;
-
-	// At least 12 bytes of random padding.
-	if (result < 3) {
-		result += 4;
-	}
-
-	if (extended) {
-		// Some more random padding.
-		result += ((rand_value<uchar>() & 0x0F) << 2);
-	}
-
-	return result;
-#endif // TDESKTOP_MTPROTO_OLD
-}
-
-} // namespace
-
-SecureRequest::SecureRequest(const details::SecureRequestCreateTag &tag)
-: _data(std::make_shared<SecureRequestData>(tag)) {
-}
-
-SecureRequest SecureRequest::Prepare(uint32 size, uint32 reserveSize) {
-	const auto finalSize = std::max(size, reserveSize);
-
-	auto result = SecureRequest(details::SecureRequestCreateTag{});
-	result->reserve(kMessageBodyPosition + finalSize);
-	result->resize(kMessageBodyPosition);
-	result->back() = (size << 2);
-	return result;
-}
-
-SecureRequestData *SecureRequest::operator->() const {
-	Expects(_data != nullptr);
-
-	return _data.get();
-}
-
-SecureRequestData &SecureRequest::operator*() const {
-	Expects(_data != nullptr);
-
-	return *_data;
-}
-
-SecureRequest::operator bool() const {
-	return (_data != nullptr);
-}
-
-void SecureRequest::addPadding(bool extended) {
-	if (_data->size() <= kMessageBodyPosition) return;
-
-	const auto requestSize = (tl::count_length(*this) >> 2);
-	const auto padding = CountPaddingAmountInInts(requestSize, extended);
-	const auto fullSize = kMessageBodyPosition + requestSize + padding;
-	if (uint32(_data->size()) != fullSize) {
-		_data->resize(fullSize);
-		if (padding > 0) {
-			memset_rand(
-				_data->data() + (fullSize - padding),
-				padding * sizeof(mtpPrime));
-		}
-	}
-}
-
-uint32 SecureRequest::messageSize() const {
-	if (_data->size() <= kMessageBodyPosition) {
-		return 0;
-	}
-	const auto ints = (tl::count_length(*this) >> 2);
-	return kMessageIdInts + kSeqNoInts + kMessageLengthInts + ints;
-}
-
-bool SecureRequest::isSentContainer() const {
-	if (_data->size() <= kMessageBodyPosition) {
-		return false;
-	}
-	return (!_data->msDate && !(*_data)[kSeqNoPosition]); // msDate = 0, seqNo = 0
-}
-
-bool SecureRequest::isStateRequest() const {
-	if (_data->size() <= kMessageBodyPosition) {
-		return false;
-	}
-	const auto type = mtpTypeId((*_data)[kMessageBodyPosition]);
-	return (type == mtpc_msgs_state_req);
-}
-
-bool SecureRequest::needAck() const {
-	if (_data->size() <= kMessageBodyPosition) {
-		return false;
-	}
-	const auto type = mtpTypeId((*_data)[kMessageBodyPosition]);
-	switch (type) {
-	case mtpc_msg_container:
-	case mtpc_msgs_ack:
-	case mtpc_http_wait:
-	case mtpc_bad_msg_notification:
-	case mtpc_msgs_all_info:
-	case mtpc_msgs_state_info:
-	case mtpc_msg_detailed_info:
-	case mtpc_msg_new_detailed_info:
-		return false;
-	}
-	return true;
-}
-
-size_t SecureRequest::sizeInBytes() const {
-	return (_data && _data->size() > kMessageBodyPosition)
-		? (*_data)[kMessageLengthPosition]
-		: 0;
-}
-
-const void *SecureRequest::dataInBytes() const {
-	return (_data && _data->size() > kMessageBodyPosition)
-		? (_data->constData() + kMessageBodyPosition)
-		: nullptr;
-}
-
-} // namespace MTP
-
-bool mtpTextSerializeCore(MTPStringLogger &to, const mtpPrime *&from, const mtpPrime *end, mtpTypeId cons, uint32 level, mtpPrime vcons) {
+bool DumpToTextCore(DumpToTextBuffer &to, const mtpPrime *&from, const mtpPrime *end, mtpTypeId cons, uint32 level, mtpPrime vcons) {
 	switch (mtpTypeId(cons)) {
 	case mtpc_int: {
 		MTPint value;
@@ -206,7 +79,7 @@ bool mtpTextSerializeCore(MTPStringLogger &to, const mtpPrime *&from, const mtpP
 				to.add("\n").addSpaces(level);
 				for (int32 i = 0; i < cnt; ++i) {
 					to.add("  ");
-					if (!mtpTextSerializeType(to, from, end, vcons, level + 1)) {
+					if (!DumpToTextType(to, from, end, vcons, level + 1)) {
 						return false;
 					}
 					to.add(",\n").addSpaces(level);
@@ -263,14 +136,14 @@ bool mtpTextSerializeCore(MTPStringLogger &to, const mtpPrime *&from, const mtpP
 		}
 		const mtpPrime *newFrom = result.constData(), *newEnd = result.constData() + result.size();
 		to.add("[GZIPPED] ");
-		return mtpTextSerializeType(to, newFrom, newEnd, 0, level);
+		return DumpToTextType(to, newFrom, newEnd, 0, level);
 	} break;
 
 	default: {
 		for (uint32 i = 1; i < mtpLayerMaxSingle; ++i) {
 			if (cons == mtpLayers[i]) {
 				to.add("[LAYER").add(QString::number(i + 1)).add("] ");
-				return mtpTextSerializeType(to, from, end, 0, level);
+				return DumpToTextType(to, from, end, 0, level);
 			}
 		}
 		if (cons == mtpc_invokeWithLayer) {
@@ -279,9 +152,17 @@ bool mtpTextSerializeCore(MTPStringLogger &to, const mtpPrime *&from, const mtpP
 			}
 			int32 layer = *(from++);
 			to.add("[LAYER").add(QString::number(layer)).add("] ");
-			return mtpTextSerializeType(to, from, end, 0, level);
+			return DumpToTextType(to, from, end, 0, level);
 		}
 	} break;
 	}
 	return false;
 }
+
+QString DumpToText(const mtpPrime *&from, const mtpPrime *end) {
+	DumpToTextBuffer to;
+	[[maybe_unused]] bool result = DumpToTextType(to, from, end, mtpc_core_message);
+	return QString::fromUtf8(to.p, to.size);
+}
+
+} // namespace MTP::details
diff --git a/Telegram/SourceFiles/mtproto/details/mtproto_dump_to_text.h b/Telegram/SourceFiles/mtproto/details/mtproto_dump_to_text.h
new file mode 100644
index 000000000..61c47665e
--- /dev/null
+++ b/Telegram/SourceFiles/mtproto/details/mtproto_dump_to_text.h
@@ -0,0 +1,82 @@
+/*
+This file is part of Telegram Desktop,
+the official desktop application for the Telegram messaging service.
+
+For license and copyright information please follow this link:
+https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+*/
+#pragma once
+
+#include "mtproto/core_types.h"
+#include "mtproto/details/mtproto_serialized_request.h"
+
+namespace MTP::details {
+
+// Human-readable text serialization
+QString DumpToText(const mtpPrime *&from, const mtpPrime *end);
+
+struct DumpToTextBuffer {
+	static constexpr auto kBufferSize = 1024 * 1024; // 1 mb start size
+
+	DumpToTextBuffer()
+		: p(new char[kBufferSize])
+		, alloced(kBufferSize) {
+	}
+	~DumpToTextBuffer() {
+		delete[] p;
+	}
+
+	DumpToTextBuffer &add(const QString &data) {
+		auto d = data.toUtf8();
+		return add(d.constData(), d.size());
+	}
+
+	DumpToTextBuffer &add(const char *data, int32 len = -1) {
+		if (len < 0) len = strlen(data);
+		if (!len) return (*this);
+
+		ensureLength(len);
+		memcpy(p + size, data, len);
+		size += len;
+		return (*this);
+	}
+
+	DumpToTextBuffer &addSpaces(int32 level) {
+		int32 len = level * 2;
+		if (!len) return (*this);
+
+		ensureLength(len);
+		for (char *ptr = p + size, *end = ptr + len; ptr != end; ++ptr) {
+			*ptr = ' ';
+		}
+		size += len;
+		return (*this);
+	}
+
+	DumpToTextBuffer &error(const char *problem = "could not decode type") {
+		return add("[ERROR] (").add(problem).add(")");
+	}
+
+	void ensureLength(int32 add) {
+		if (size + add <= alloced) return;
+
+		int32 newsize = size + add;
+		if (newsize % kBufferSize) {
+			newsize += kBufferSize - (newsize % kBufferSize);
+		}
+		char *b = new char[newsize];
+		memcpy(b, p, size);
+		alloced = newsize;
+		delete[] p;
+		p = b;
+	}
+
+	char *p = nullptr;
+	int size = 0;
+	int alloced = 0;
+
+};
+
+[[nodiscard]] bool DumpToTextCore(DumpToTextBuffer &to, const mtpPrime *&from, const mtpPrime *end, mtpTypeId cons, uint32 level, mtpPrime vcons = 0);
+
+} // namespace MTP::details
diff --git a/Telegram/SourceFiles/mtproto/details/mtproto_received_ids_manager.cpp b/Telegram/SourceFiles/mtproto/details/mtproto_received_ids_manager.cpp
new file mode 100644
index 000000000..28e6ad518
--- /dev/null
+++ b/Telegram/SourceFiles/mtproto/details/mtproto_received_ids_manager.cpp
@@ -0,0 +1,54 @@
+/*
+This file is part of Telegram Desktop,
+the official desktop application for the Telegram messaging service.
+
+For license and copyright information please follow this link:
+https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+*/
+#include "mtproto/details/mtproto_received_ids_manager.h"
+
+namespace MTP::details {
+
+bool ReceivedIdsManager::registerMsgId(mtpMsgId msgId, bool needAck) {
+	const auto i = _idsNeedAck.find(msgId);
+	if (i == _idsNeedAck.end()) {
+		if (_idsNeedAck.size() < kIdsBufferSize || msgId > min()) {
+			_idsNeedAck.emplace(msgId, needAck);
+			return true;
+		}
+		MTP_LOG(-1, ("No need to handle - %1 < min = %2").arg(msgId).arg(min()));
+	} else {
+		MTP_LOG(-1, ("No need to handle - %1 already is in map").arg(msgId));
+	}
+	return false;
+}
+
+mtpMsgId ReceivedIdsManager::min() const {
+	return _idsNeedAck.empty() ? 0 : _idsNeedAck.begin()->first;
+}
+
+mtpMsgId ReceivedIdsManager::max() const {
+	auto end = _idsNeedAck.end();
+	return _idsNeedAck.empty() ? 0 : (--end)->first;
+}
+
+ReceivedIdsManager::State ReceivedIdsManager::lookup(mtpMsgId msgId) const {
+	auto i = _idsNeedAck.find(msgId);
+	if (i == _idsNeedAck.end()) {
+		return State::NotFound;
+	}
+	return i->second ? State::NeedsAck : State::NoAckNeeded;
+}
+
+void ReceivedIdsManager::shrink() {
+	auto size = _idsNeedAck.size();
+	while (size-- > kIdsBufferSize) {
+		_idsNeedAck.erase(_idsNeedAck.begin());
+	}
+}
+
+void ReceivedIdsManager::clear() {
+	_idsNeedAck.clear();
+}
+
+} // namespace MTP::details
diff --git a/Telegram/SourceFiles/mtproto/details/mtproto_received_ids_manager.h b/Telegram/SourceFiles/mtproto/details/mtproto_received_ids_manager.h
new file mode 100644
index 000000000..2a8d6a57a
--- /dev/null
+++ b/Telegram/SourceFiles/mtproto/details/mtproto_received_ids_manager.h
@@ -0,0 +1,38 @@
+/*
+This file is part of Telegram Desktop,
+the official desktop application for the Telegram messaging service.
+
+For license and copyright information please follow this link:
+https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+*/
+#pragma once
+
+#include "base/flat_map.h"
+
+namespace MTP::details {
+
+// Received msgIds and wereAcked msgIds count stored.
+inline constexpr auto kIdsBufferSize = 400;
+
+class ReceivedIdsManager final {
+public:
+	enum class State {
+		NotFound,
+		NeedsAck,
+		NoAckNeeded,
+	};
+
+	bool registerMsgId(mtpMsgId msgId, bool needAck);
+	[[nodiscard]] mtpMsgId min() const;
+	[[nodiscard]] mtpMsgId max() const;
+	[[nodiscard]] State lookup(mtpMsgId msgId) const;
+
+	void shrink();
+	void clear();
+
+private:
+	base::flat_map<mtpMsgId, bool> _idsNeedAck;
+
+};
+
+} // namespace MTP::details
diff --git a/Telegram/SourceFiles/mtproto/details/mtproto_rsa_public_key.cpp b/Telegram/SourceFiles/mtproto/details/mtproto_rsa_public_key.cpp
new file mode 100644
index 000000000..8d47ed822
--- /dev/null
+++ b/Telegram/SourceFiles/mtproto/details/mtproto_rsa_public_key.cpp
@@ -0,0 +1,294 @@
+/*
+This file is part of Telegram Desktop,
+the official desktop application for the Telegram messaging service.
+
+For license and copyright information please follow this link:
+https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+*/
+#include "mtproto/details/mtproto_rsa_public_key.h"
+
+#include "base/openssl_help.h"
+
+namespace MTP::details {
+namespace {
+#if OPENSSL_VERSION_NUMBER < 0x10100000L || (defined(LIBRESSL_VERSION_NUMBER) && LIBRESSL_VERSION_NUMBER < 0x2070000fL)
+
+// This is a key setter for compatibility with OpenSSL 1.0
+int RSA_set0_key(RSA *r, BIGNUM *n, BIGNUM *e, BIGNUM *d) {
+	if ((r->n == nullptr && n == nullptr) || (r->e == nullptr && e == nullptr)) {
+		return 0;
+	}
+	if (n != nullptr) {
+		BN_free(r->n);
+		r->n = n;
+	}
+	if (e != nullptr) {
+		BN_free(r->e);
+		r->e = e;
+	}
+	if (d != nullptr) {
+		BN_free(r->d);
+		r->d = d;
+	}
+	return 1;
+}
+
+// This is a key getter for compatibility with OpenSSL 1.0
+void RSA_get0_key(const RSA *r, const BIGNUM **n, const BIGNUM **e, const BIGNUM **d) {
+	if (n != nullptr) {
+		*n = r->n;
+	}
+	if (e != nullptr) {
+		*e = r->e;
+	}
+	if (d != nullptr) {
+		*d = r->d;
+	}
+}
+
+#endif
+
+enum class Format {
+	RSAPublicKey,
+	RSA_PUBKEY,
+	Unknown,
+};
+
+Format GuessFormat(bytes::const_span key) {
+	const auto array = QByteArray::fromRawData(
+		reinterpret_cast<const char*>(key.data()),
+		key.size());
+	if (array.indexOf("BEGIN RSA PUBLIC KEY") >= 0) {
+		return Format::RSAPublicKey;
+	} else if (array.indexOf("BEGIN PUBLIC KEY") >= 0) {
+		return Format::RSA_PUBKEY;
+	}
+	return Format::Unknown;
+}
+
+RSA *CreateRaw(bytes::const_span key) {
+	const auto format = GuessFormat(key);
+	const auto bio = BIO_new_mem_buf(
+		const_cast<gsl::byte*>(key.data()),
+		key.size());
+	switch (format) {
+	case Format::RSAPublicKey:
+		return PEM_read_bio_RSAPublicKey(bio, nullptr, nullptr, nullptr);
+	case Format::RSA_PUBKEY:
+		return PEM_read_bio_RSA_PUBKEY(bio, nullptr, nullptr, nullptr);
+	}
+	Unexpected("format in RSAPublicKey::Private::Create.");
+}
+
+} // namespace
+
+class RSAPublicKey::Private {
+public:
+	explicit Private(bytes::const_span key);
+	Private(bytes::const_span nBytes, bytes::const_span eBytes);
+	~Private();
+
+	[[nodiscard]] bool valid() const;
+	[[nodiscard]] uint64 fingerprint() const;
+	[[nodiscard]] bytes::vector getN() const;
+	[[nodiscard]] bytes::vector getE() const;
+	[[nodiscard]] bytes::vector encrypt(bytes::const_span data) const;
+	[[nodiscard]] bytes::vector decrypt(bytes::const_span data) const;
+	[[nodiscard]] bytes::vector encryptOAEPpadding(
+		bytes::const_span data) const;
+
+private:
+	void computeFingerprint();
+	[[nodiscard]] static bytes::vector ToBytes(const BIGNUM *number);
+
+	RSA *_rsa = nullptr;
+	uint64 _fingerprint = 0;
+
+};
+
+RSAPublicKey::Private::Private(bytes::const_span key)
+	: _rsa(CreateRaw(key)) {
+	if (_rsa) {
+		computeFingerprint();
+	}
+}
+
+RSAPublicKey::Private::Private(bytes::const_span nBytes, bytes::const_span eBytes)
+	: _rsa(RSA_new()) {
+	if (_rsa) {
+		const auto n = openssl::BigNum(nBytes).takeRaw();
+		const auto e = openssl::BigNum(eBytes).takeRaw();
+		const auto valid = (n != nullptr) && (e != nullptr);
+		// We still pass both values to RSA_set0_key() so that even
+		// if only one of them is valid RSA would take ownership of it.
+		if (!RSA_set0_key(_rsa, n, e, nullptr) || !valid) {
+			RSA_free(base::take(_rsa));
+		} else {
+			computeFingerprint();
+		}
+	}
+}
+
+bool RSAPublicKey::Private::valid() const {
+	return _rsa != nullptr;
+}
+
+uint64 RSAPublicKey::Private::fingerprint() const {
+	return _fingerprint;
+}
+
+bytes::vector RSAPublicKey::Private::getN() const {
+	Expects(valid());
+
+	const BIGNUM *n;
+	RSA_get0_key(_rsa, &n, nullptr, nullptr);
+	return ToBytes(n);
+}
+
+bytes::vector RSAPublicKey::Private::getE() const {
+	Expects(valid());
+
+	const BIGNUM *e;
+	RSA_get0_key(_rsa, nullptr, &e, nullptr);
+	return ToBytes(e);
+}
+
+bytes::vector RSAPublicKey::Private::encrypt(bytes::const_span data) const {
+	Expects(valid());
+
+	constexpr auto kEncryptSize = 256;
+	auto result = bytes::vector(kEncryptSize, gsl::byte{});
+	auto res = RSA_public_encrypt(kEncryptSize, reinterpret_cast<const unsigned char*>(data.data()), reinterpret_cast<unsigned char*>(result.data()), _rsa, RSA_NO_PADDING);
+	if (res < 0 || res > kEncryptSize) {
+		ERR_load_crypto_strings();
+		LOG(("RSA Error: RSA_public_encrypt failed, key fp: %1, result: %2, error: %3").arg(fingerprint()).arg(res).arg(ERR_error_string(ERR_get_error(), 0)));
+		return {};
+	} else if (auto zeroBytes = kEncryptSize - res) {
+		auto resultBytes = gsl::make_span(result);
+		bytes::move(resultBytes.subspan(zeroBytes, res), resultBytes.subspan(0, res));
+		bytes::set_with_const(resultBytes.subspan(0, zeroBytes), gsl::byte{});
+	}
+	return result;
+}
+
+bytes::vector RSAPublicKey::Private::decrypt(bytes::const_span data) const {
+	Expects(valid());
+
+	constexpr auto kDecryptSize = 256;
+	auto result = bytes::vector(kDecryptSize, gsl::byte{});
+	auto res = RSA_public_decrypt(kDecryptSize, reinterpret_cast<const unsigned char*>(data.data()), reinterpret_cast<unsigned char*>(result.data()), _rsa, RSA_NO_PADDING);
+	if (res < 0 || res > kDecryptSize) {
+		ERR_load_crypto_strings();
+		LOG(("RSA Error: RSA_public_encrypt failed, key fp: %1, result: %2, error: %3").arg(fingerprint()).arg(res).arg(ERR_error_string(ERR_get_error(), 0)));
+		return {};
+	} else if (auto zeroBytes = kDecryptSize - res) {
+		auto resultBytes = gsl::make_span(result);
+		bytes::move(resultBytes.subspan(zeroBytes - res, res), resultBytes.subspan(0, res));
+		bytes::set_with_const(resultBytes.subspan(0, zeroBytes - res), gsl::byte{});
+	}
+	return result;
+}
+
+bytes::vector RSAPublicKey::Private::encryptOAEPpadding(bytes::const_span data) const {
+	Expects(valid());
+
+	const auto resultSize = RSA_size(_rsa);
+	auto result = bytes::vector(resultSize, gsl::byte{});
+	const auto encryptedSize = RSA_public_encrypt(
+		data.size(),
+		reinterpret_cast<const unsigned char*>(data.data()),
+		reinterpret_cast<unsigned char*>(result.data()),
+		_rsa,
+		RSA_PKCS1_OAEP_PADDING);
+	if (encryptedSize != resultSize) {
+		ERR_load_crypto_strings();
+		LOG(("RSA Error: RSA_public_encrypt failed, "
+			"key fp: %1, result: %2, error: %3"
+			).arg(fingerprint()
+			).arg(encryptedSize
+			).arg(ERR_error_string(ERR_get_error(), 0)
+			));
+		return {};
+	}
+	return result;
+}
+
+RSAPublicKey::Private::~Private() {
+	RSA_free(_rsa);
+}
+
+void RSAPublicKey::Private::computeFingerprint() {
+	Expects(valid());
+
+	const BIGNUM *n, *e;
+	mtpBuffer string;
+	RSA_get0_key(_rsa, &n, &e, nullptr);
+	MTP_bytes(ToBytes(n)).write(string);
+	MTP_bytes(ToBytes(e)).write(string);
+
+	bytes::array<20> sha1Buffer;
+	openssl::Sha1To(sha1Buffer, bytes::make_span(string));
+	_fingerprint = *(uint64*)(sha1Buffer.data() + 12);
+}
+
+bytes::vector RSAPublicKey::Private::ToBytes(const BIGNUM *number) {
+	auto size = BN_num_bytes(number);
+	auto result = bytes::vector(size, gsl::byte{});
+	BN_bn2bin(number, reinterpret_cast<unsigned char*>(result.data()));
+	return result;
+}
+
+RSAPublicKey::RSAPublicKey(bytes::const_span key)
+: _private(std::make_shared<Private>(key)) {
+}
+
+RSAPublicKey::RSAPublicKey(
+	bytes::const_span nBytes,
+	bytes::const_span eBytes)
+: _private(std::make_shared<Private>(nBytes, eBytes)) {
+}
+
+bool RSAPublicKey::empty() const {
+	return !_private;
+}
+
+bool RSAPublicKey::valid() const {
+	return !empty() && _private->valid();
+}
+
+uint64 RSAPublicKey::fingerprint() const {
+	Expects(valid());
+
+	return _private->fingerprint();
+}
+
+bytes::vector RSAPublicKey::getN() const {
+	Expects(valid());
+
+	return _private->getN();
+}
+
+bytes::vector RSAPublicKey::getE() const {
+	Expects(valid());
+
+	return _private->getE();
+}
+
+bytes::vector RSAPublicKey::encrypt(bytes::const_span data) const {
+	Expects(valid());
+
+	return _private->encrypt(data);
+}
+
+bytes::vector RSAPublicKey::decrypt(bytes::const_span data) const {
+	Expects(valid());
+
+	return _private->decrypt(data);
+}
+
+bytes::vector RSAPublicKey::encryptOAEPpadding(
+		bytes::const_span data) const {
+	return _private->encryptOAEPpadding(data);
+}
+
+} // namespace MTP::details
diff --git a/Telegram/SourceFiles/mtproto/rsa_public_key.h b/Telegram/SourceFiles/mtproto/details/mtproto_rsa_public_key.h
similarity index 69%
rename from Telegram/SourceFiles/mtproto/rsa_public_key.h
rename to Telegram/SourceFiles/mtproto/details/mtproto_rsa_public_key.h
index 8e748d8a5..86978061d 100644
--- a/Telegram/SourceFiles/mtproto/rsa_public_key.h
+++ b/Telegram/SourceFiles/mtproto/details/mtproto_rsa_public_key.h
@@ -9,8 +9,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 
 #include "base/bytes.h"
 
-namespace MTP {
-namespace internal {
+namespace MTP::details {
 
 // this class holds an RSA public key and can encrypt fixed-size messages with it
 class RSAPublicKey final {
@@ -26,19 +25,20 @@ public:
 	// or in "-----BEGIN PUBLIC KEY----- ..." format
 	explicit RSAPublicKey(bytes::const_span key);
 
-	bool isValid() const;
-	uint64 getFingerPrint() const;
-	bytes::vector getN() const;
-	bytes::vector getE() const;
+	[[nodiscard]] bool empty() const;
+	[[nodiscard]] bool valid() const;
+	[[nodiscard]] uint64 fingerprint() const;
+	[[nodiscard]] bytes::vector getN() const;
+	[[nodiscard]] bytes::vector getE() const;
 
 	// data has exactly 256 chars to be encrypted
-	bytes::vector encrypt(bytes::const_span data) const;
+	[[nodiscard]] bytes::vector encrypt(bytes::const_span data) const;
 
 	// data has exactly 256 chars to be decrypted
-	bytes::vector decrypt(bytes::const_span data) const;
+	[[nodiscard]] bytes::vector decrypt(bytes::const_span data) const;
 
 	// data has lequal than 215 chars to be decrypted
-	bytes::vector encryptOAEPpadding(bytes::const_span data) const;
+	[[nodiscard]] bytes::vector encryptOAEPpadding(bytes::const_span data) const;
 
 private:
 	class Private;
@@ -46,5 +46,4 @@ private:
 
 };
 
-} // namespace internal
-} // namespace MTP
+} // namespace MTP::details
diff --git a/Telegram/SourceFiles/mtproto/details/mtproto_serialized_request.cpp b/Telegram/SourceFiles/mtproto/details/mtproto_serialized_request.cpp
new file mode 100644
index 000000000..5b04acafb
--- /dev/null
+++ b/Telegram/SourceFiles/mtproto/details/mtproto_serialized_request.cpp
@@ -0,0 +1,156 @@
+/*
+This file is part of Telegram Desktop,
+the official desktop application for the Telegram messaging service.
+
+For license and copyright information please follow this link:
+https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+*/
+#include "mtproto/details/mtproto_serialized_request.h"
+
+#include "base/openssl_help.h"
+
+namespace MTP::details {
+namespace {
+
+uint32 CountPaddingPrimesCount(uint32 requestSize, bool extended, bool old) {
+	if (old) {
+		return ((8 + requestSize) & 0x03)
+			? (4 - ((8 + requestSize) & 0x03))
+			: 0;
+	}
+	auto result = ((8 + requestSize) & 0x03)
+		? (4 - ((8 + requestSize) & 0x03))
+		: 0;
+
+	// At least 12 bytes of random padding.
+	if (result < 3) {
+		result += 4;
+	}
+
+	if (extended) {
+		// Some more random padding.
+		result += ((openssl::RandomValue<uchar>() & 0x0F) << 2);
+	}
+
+	return result;
+}
+
+} // namespace
+
+SerializedRequest::SerializedRequest(const RequestConstructHider::Tag &tag)
+: _data(std::make_shared<RequestData>(tag)) {
+}
+
+SerializedRequest SerializedRequest::Prepare(
+		uint32 size,
+		uint32 reserveSize) {
+	Expects(size > 0);
+
+	const auto finalSize = std::max(size, reserveSize);
+
+	auto result = SerializedRequest(RequestConstructHider::Tag{});
+	result->reserve(kMessageBodyPosition + finalSize);
+	result->resize(kMessageBodyPosition);
+	result->back() = (size << 2);
+	result->lastSentTime = crl::now();
+	return result;
+}
+
+RequestData *SerializedRequest::operator->() const {
+	Expects(_data != nullptr);
+
+	return _data.get();
+}
+
+RequestData &SerializedRequest::operator*() const {
+	Expects(_data != nullptr);
+
+	return *_data;
+}
+
+SerializedRequest::operator bool() const {
+	return (_data != nullptr);
+}
+
+void SerializedRequest::setMsgId(mtpMsgId msgId) {
+	Expects(_data != nullptr);
+	Expects(_data->size() > kMessageBodyPosition);
+
+	memcpy(_data->data() + kMessageIdPosition, &msgId, sizeof(mtpMsgId));
+}
+
+mtpMsgId SerializedRequest::getMsgId() const {
+	Expects(_data != nullptr);
+	Expects(_data->size() > kMessageBodyPosition);
+
+	return *(mtpMsgId*)(_data->constData() + kMessageIdPosition);
+}
+
+void SerializedRequest::setSeqNo(uint32 seqNo) {
+	Expects(_data != nullptr);
+	Expects(_data->size() > kMessageBodyPosition);
+
+	(*_data)[kSeqNoPosition] = mtpPrime(seqNo);
+}
+
+uint32 SerializedRequest::getSeqNo() const {
+	Expects(_data != nullptr);
+	Expects(_data->size() > kMessageBodyPosition);
+
+	return uint32((*_data)[kSeqNoPosition]);
+}
+
+void SerializedRequest::addPadding(bool extended, bool old) {
+	Expects(_data != nullptr);
+	Expects(_data->size() > kMessageBodyPosition);
+
+	const auto requestSize = (tl::count_length(*this) >> 2);
+	const auto padding = CountPaddingPrimesCount(requestSize, extended, old);
+	const auto fullSize = kMessageBodyPosition + requestSize + padding;
+	if (uint32(_data->size()) != fullSize) {
+		_data->resize(fullSize);
+		if (padding > 0) {
+			bytes::set_random(bytes::make_span(*_data).subspan(
+				(fullSize - padding) * sizeof(mtpPrime)));
+		}
+	}
+}
+
+uint32 SerializedRequest::messageSize() const {
+	Expects(_data != nullptr);
+	Expects(_data->size() > kMessageBodyPosition);
+
+	const auto ints = (tl::count_length(*this) >> 2);
+	return kMessageIdInts + kSeqNoInts + kMessageLengthInts + ints;
+}
+
+bool SerializedRequest::needAck() const {
+	Expects(_data != nullptr);
+	Expects(_data->size() > kMessageBodyPosition);
+
+	const auto type = mtpTypeId((*_data)[kMessageBodyPosition]);
+	switch (type) {
+	case mtpc_msg_container:
+	case mtpc_msgs_ack:
+	case mtpc_http_wait:
+	case mtpc_bad_msg_notification:
+	case mtpc_msgs_all_info:
+	case mtpc_msgs_state_info:
+	case mtpc_msg_detailed_info:
+	case mtpc_msg_new_detailed_info:
+		return false;
+	}
+	return true;
+}
+
+size_t SerializedRequest::sizeInBytes() const {
+	Expects(!_data || _data->size() > kMessageBodyPosition);
+	return _data ? (*_data)[kMessageLengthPosition] : 0;
+}
+
+const void *SerializedRequest::dataInBytes() const {
+	Expects(!_data || _data->size() > kMessageBodyPosition);
+	return _data ? (_data->constData() + kMessageBodyPosition) : nullptr;
+}
+
+} // namespace MTP
diff --git a/Telegram/SourceFiles/mtproto/details/mtproto_serialized_request.h b/Telegram/SourceFiles/mtproto/details/mtproto_serialized_request.h
new file mode 100644
index 000000000..ad9901b2b
--- /dev/null
+++ b/Telegram/SourceFiles/mtproto/details/mtproto_serialized_request.h
@@ -0,0 +1,107 @@
+/*
+This file is part of Telegram Desktop,
+the official desktop application for the Telegram messaging service.
+
+For license and copyright information please follow this link:
+https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+*/
+#pragma once
+
+#include "mtproto/core_types.h"
+
+#include <crl/crl_time.h>
+
+namespace MTP {
+namespace details {
+
+class RequestData;
+class SerializedRequest;
+
+class RequestConstructHider {
+	struct Tag {};
+	friend class RequestData;
+	friend class SerializedRequest;
+};
+
+class SerializedRequest {
+public:
+	SerializedRequest() = default;
+
+	static constexpr auto kSaltInts = 2;
+	static constexpr auto kSessionIdInts = 2;
+	static constexpr auto kMessageIdPosition = kSaltInts + kSessionIdInts;
+	static constexpr auto kMessageIdInts = 2;
+	static constexpr auto kSeqNoPosition = kMessageIdPosition
+		+ kMessageIdInts;
+	static constexpr auto kSeqNoInts = 1;
+	static constexpr auto kMessageLengthPosition = kSeqNoPosition
+		+ kSeqNoInts;
+	static constexpr auto kMessageLengthInts = 1;
+	static constexpr auto kMessageBodyPosition = kMessageLengthPosition
+		+ kMessageLengthInts;
+
+	static SerializedRequest Prepare(uint32 size, uint32 reserveSize = 0);
+
+	template <
+		typename Request,
+		typename = std::enable_if_t<tl::is_boxed_v<Request>>>
+		static SerializedRequest Serialize(const Request &request);
+
+	// For template MTP requests and MTPBoxed instantiation.
+	template <typename Accumulator>
+	void write(Accumulator &to) const {
+		if (const auto size = sizeInBytes()) {
+			tl::Writer<Accumulator>::PutBytes(to, dataInBytes(), size);
+		}
+	}
+
+	RequestData *operator->() const;
+	RequestData &operator*() const;
+	explicit operator bool() const;
+
+	void setMsgId(mtpMsgId msgId);
+	[[nodiscard]] mtpMsgId getMsgId() const;
+
+	void setSeqNo(uint32 seqNo);
+	[[nodiscard]] uint32 getSeqNo() const;
+
+	void addPadding(bool extended, bool old);
+	[[nodiscard]] uint32 messageSize() const;
+
+	[[nodiscard]] bool needAck() const;
+
+	using ResponseType = void; // don't know real response type =(
+
+private:
+	explicit SerializedRequest(const RequestConstructHider::Tag &);
+
+	[[nodiscard]] size_t sizeInBytes() const;
+	[[nodiscard]] const void *dataInBytes() const;
+
+	std::shared_ptr<RequestData> _data;
+
+};
+
+class RequestData : public mtpBuffer {
+public:
+	explicit RequestData(const RequestConstructHider::Tag &) {
+	}
+
+	SerializedRequest after;
+	crl::time lastSentTime = 0;
+	mtpRequestId requestId = 0;
+	bool needsLayer = false;
+	bool forceSendInContainer = false;
+
+};
+
+template <typename Request, typename>
+SerializedRequest SerializedRequest::Serialize(const Request &request) {
+	const auto requestSize = tl::count_length(request) >> 2;
+	auto serialized = Prepare(requestSize);
+	request.template write<mtpBuffer>(*serialized);
+	return serialized;
+}
+
+} // namespace details
+} // namespace MTP
diff --git a/Telegram/SourceFiles/mtproto/mtp_tcp_socket.cpp b/Telegram/SourceFiles/mtproto/details/mtproto_tcp_socket.cpp
similarity index 97%
rename from Telegram/SourceFiles/mtproto/mtp_tcp_socket.cpp
rename to Telegram/SourceFiles/mtproto/details/mtproto_tcp_socket.cpp
index 3349cbadd..53680461a 100644
--- a/Telegram/SourceFiles/mtproto/mtp_tcp_socket.cpp
+++ b/Telegram/SourceFiles/mtproto/details/mtproto_tcp_socket.cpp
@@ -5,12 +5,11 @@ the official desktop application for the Telegram messaging service.
 For license and copyright information please follow this link:
 https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 */
-#include "mtproto/mtp_tcp_socket.h"
+#include "mtproto/details/mtproto_tcp_socket.h"
 
 #include "base/invoke_queued.h"
 
-namespace MTP {
-namespace internal {
+namespace MTP::details {
 
 TcpSocket::TcpSocket(not_null<QThread*> thread, const QNetworkProxy &proxy)
 : AbstractSocket(thread) {
@@ -153,5 +152,4 @@ void TcpSocket::handleError(int errorCode) {
 	_error.fire({});
 }
 
-} // namespace internal
-} // namespace MTP
+} // namespace MTP::details
diff --git a/Telegram/SourceFiles/mtproto/mtp_tcp_socket.h b/Telegram/SourceFiles/mtproto/details/mtproto_tcp_socket.h
similarity index 87%
rename from Telegram/SourceFiles/mtproto/mtp_tcp_socket.h
rename to Telegram/SourceFiles/mtproto/details/mtproto_tcp_socket.h
index 487b2dcc0..6c8bac882 100644
--- a/Telegram/SourceFiles/mtproto/mtp_tcp_socket.h
+++ b/Telegram/SourceFiles/mtproto/details/mtproto_tcp_socket.h
@@ -7,10 +7,9 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 */
 #pragma once
 
-#include "mtproto/mtp_abstract_socket.h"
+#include "mtproto/details/mtproto_abstract_socket.h"
 
-namespace MTP {
-namespace internal {
+namespace MTP::details {
 
 class TcpSocket final : public AbstractSocket {
 public:
@@ -35,5 +34,4 @@ private:
 
 };
 
-} // namespace internal
-} // namespace MTP
+} // namespace MTP::details
diff --git a/Telegram/SourceFiles/mtproto/mtp_tls_socket.cpp b/Telegram/SourceFiles/mtproto/details/mtproto_tls_socket.cpp
similarity index 99%
rename from Telegram/SourceFiles/mtproto/mtp_tls_socket.cpp
rename to Telegram/SourceFiles/mtproto/details/mtproto_tls_socket.cpp
index 691a482cd..385dff13a 100644
--- a/Telegram/SourceFiles/mtproto/mtp_tls_socket.cpp
+++ b/Telegram/SourceFiles/mtproto/details/mtproto_tls_socket.cpp
@@ -5,9 +5,9 @@ the official desktop application for the Telegram messaging service.
 For license and copyright information please follow this link:
 https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 */
-#include "mtproto/mtp_tls_socket.h"
+#include "mtproto/details/mtproto_tls_socket.h"
 
-#include "mtproto/mtp_tcp_socket.h"
+#include "mtproto/details/mtproto_tcp_socket.h"
 #include "base/openssl_help.h"
 #include "base/bytes.h"
 #include "base/invoke_queued.h"
@@ -16,8 +16,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include <QtCore/QtEndian>
 #include <range/v3/algorithm/reverse.hpp>
 
-namespace MTP {
-namespace internal {
+namespace MTP::details {
 namespace {
 
 constexpr auto kMaxGrease = 8;
@@ -778,5 +777,4 @@ void TlsSocket::handleError(int errorCode) {
 	_error.fire({});
 }
 
-} // namespace internal
-} // namespace MTP
+} // namespace MTP::details
diff --git a/Telegram/SourceFiles/mtproto/mtp_tls_socket.h b/Telegram/SourceFiles/mtproto/details/mtproto_tls_socket.h
similarity index 92%
rename from Telegram/SourceFiles/mtproto/mtp_tls_socket.h
rename to Telegram/SourceFiles/mtproto/details/mtproto_tls_socket.h
index df8742b34..01848230a 100644
--- a/Telegram/SourceFiles/mtproto/mtp_tls_socket.h
+++ b/Telegram/SourceFiles/mtproto/details/mtproto_tls_socket.h
@@ -7,10 +7,9 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 */
 #pragma once
 
-#include "mtproto/mtp_abstract_socket.h"
+#include "mtproto/details/mtproto_abstract_socket.h"
 
-namespace MTP {
-namespace internal {
+namespace MTP::details {
 
 class TlsSocket final : public AbstractSocket {
 public:
@@ -64,5 +63,4 @@ private:
 
 };
 
-} // namespace internal
-} // namespace MTP
+} // namespace MTP::details
diff --git a/Telegram/SourceFiles/mtproto/facade.cpp b/Telegram/SourceFiles/mtproto/facade.cpp
index 920a2c723..a776a958e 100644
--- a/Telegram/SourceFiles/mtproto/facade.cpp
+++ b/Telegram/SourceFiles/mtproto/facade.cpp
@@ -12,7 +12,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "main/main_account.h"
 
 namespace MTP {
-namespace internal {
+namespace details {
 namespace {
 
 int PauseLevel = 0;
@@ -36,7 +36,7 @@ void unpause() {
 	}
 }
 
-} // namespace internal
+} // namespace details
 
 Instance *MainInstance() {
 	return Core::IsAppLaunched()
diff --git a/Telegram/SourceFiles/mtproto/facade.h b/Telegram/SourceFiles/mtproto/facade.h
index dfa3dab83..e4c55162b 100644
--- a/Telegram/SourceFiles/mtproto/facade.h
+++ b/Telegram/SourceFiles/mtproto/facade.h
@@ -11,13 +11,13 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "mtproto/mtp_instance.h"
 
 namespace MTP {
-namespace internal {
+namespace details {
 
 [[nodiscard]] bool paused();
 void pause();
 void unpause();
 
-} // namespace internal
+} // namespace details
 
 // send(MTPhelp_GetConfig(), MTP::configDcId(dc)) - for dc enumeration
 constexpr ShiftedDcId configDcId(DcId dcId) {
@@ -34,29 +34,27 @@ constexpr ShiftedDcId updaterDcId(DcId dcId) {
 	return ShiftDcId(dcId, kUpdaterDcShift);
 }
 
-constexpr auto kDownloadSessionsCount = 2;
 constexpr auto kUploadSessionsCount = 2;
-
-constexpr auto kDownloadSessionsCountMax = 8;
 constexpr auto kUploadSessionsCountMax = 8;
 
-namespace internal {
+namespace details {
 
 constexpr ShiftedDcId downloadDcId(DcId dcId, int index) {
-	static_assert(kDownloadSessionsCountMax < kMaxMediaDcCount, "Too large MTPDownloadSessionsCount!");
+	Expects(index < kMaxMediaDcCount);
+
 	return ShiftDcId(dcId, kBaseDownloadDcShift + index);
 };
 
-} // namespace internal
+} // namespace details
 
 // send(req, callbacks, MTP::downloadDcId(dc, index)) - for download shifted dc id
 inline ShiftedDcId downloadDcId(DcId dcId, int index) {
-	Expects(index >= 0 && index < cNetDownloadSessionsCount());
-	return internal::downloadDcId(dcId, index);
+	return details::downloadDcId(dcId, index);
 }
 
 inline constexpr bool isDownloadDcId(ShiftedDcId shiftedDcId) {
-	return (shiftedDcId >= internal::downloadDcId(0, 0)) && (shiftedDcId < internal::downloadDcId(0, kDownloadSessionsCountMax - 1) + kDcShift);
+	return (shiftedDcId >= details::downloadDcId(0, 0))
+		&& (shiftedDcId < details::downloadDcId(0, kMaxMediaDcCount - 1) + kDcShift);
 }
 
 inline bool isCdnDc(MTPDdcOption::Flags flags) {
@@ -78,25 +76,26 @@ inline DcId getTemporaryIdFromRealDcId(ShiftedDcId shiftedDcId) {
 	return (dcId < Instance::Config::kTemporaryMainDc) ? (dcId + Instance::Config::kTemporaryMainDc) : 0;
 }
 
-namespace internal {
+namespace details {
 
 constexpr ShiftedDcId uploadDcId(DcId dcId, int index) {
 	static_assert(kUploadSessionsCountMax < kMaxMediaDcCount, "Too large MTPUploadSessionsCount!");
 	return ShiftDcId(dcId, kBaseUploadDcShift + index);
 };
 
-} // namespace internal
+} // namespace details
 
 // send(req, callbacks, MTP::uploadDcId(index)) - for upload shifted dc id
 // uploading always to the main dc so BareDcId(result) == 0
 inline ShiftedDcId uploadDcId(int index) {
 	Expects(index >= 0 && index < cNetUploadSessionsCount());
 
-	return internal::uploadDcId(0, index);
+	return details::uploadDcId(0, index);
 };
 
 constexpr bool isUploadDcId(ShiftedDcId shiftedDcId) {
-	return (shiftedDcId >= internal::uploadDcId(0, 0)) && (shiftedDcId < internal::uploadDcId(0, kUploadSessionsCountMax - 1) + kDcShift);
+	return (shiftedDcId >= details::uploadDcId(0, 0))
+		&& (shiftedDcId < details::uploadDcId(0, kUploadSessionsCountMax - 1) + kDcShift);
 }
 
 inline ShiftedDcId destroyKeyNextDcId(ShiftedDcId shiftedDcId) {
diff --git a/Telegram/SourceFiles/mtproto/mtp_instance.cpp b/Telegram/SourceFiles/mtproto/mtp_instance.cpp
index 87f5b4f88..411d70c45 100644
--- a/Telegram/SourceFiles/mtproto/mtp_instance.cpp
+++ b/Telegram/SourceFiles/mtproto/mtp_instance.cpp
@@ -7,18 +7,17 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 */
 #include "mtproto/mtp_instance.h"
 
+#include "mtproto/details/mtproto_dcenter.h"
+#include "mtproto/details/mtproto_rsa_public_key.h"
+#include "mtproto/special_config_request.h"
 #include "mtproto/session.h"
 #include "mtproto/dc_options.h"
-#include "mtproto/dcenter.h"
 #include "mtproto/config_loader.h"
-#include "mtproto/special_config_request.h"
-#include "mtproto/connection.h"
 #include "mtproto/sender.h"
-#include "mtproto/rsa_public_key.h"
 #include "storage/localstorage.h"
 #include "calls/calls_instance.h"
-#include "main/main_account.h"
-#include "main/main_session.h"
+#include "main/main_session.h" // Session::Exists.
+#include "main/main_account.h" // Account::configUpdated.
 #include "apiwrap.h"
 #include "core/application.h"
 #include "lang/lang_instance.h"
@@ -26,16 +25,33 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "base/unixtime.h"
 #include "base/call_delayed.h"
 #include "base/timer.h"
-#include "facades.h"
+#include "facades.h" // Proxies list.
 
 namespace MTP {
 namespace {
 
 constexpr auto kConfigBecomesOldIn = 2 * 60 * crl::time(1000);
 constexpr auto kConfigBecomesOldForBlockedIn = 8 * crl::time(1000);
+constexpr auto kCheckKeyEach = 60 * crl::time(1000);
+
+using namespace details;
+
+std::atomic<int> GlobalAtomicRequestId = 0;
 
 } // namespace
 
+namespace details {
+
+int GetNextRequestId() {
+	const auto result = ++GlobalAtomicRequestId;
+	if (result == std::numeric_limits<int>::max() / 2) {
+		GlobalAtomicRequestId = 0;
+	}
+	return result;
+}
+
+} // namespace details
+
 class Instance::Private : private Sender {
 public:
 	Private(not_null<Instance*> instance, not_null<DcOptions*> options, Instance::Mode mode);
@@ -48,9 +64,12 @@ public:
 	void setMainDcId(DcId mainDcId);
 	[[nodiscard]] DcId mainDcId() const;
 
-	void setKeyForWrite(DcId dcId, const AuthKeyPtr &key);
+	void dcPersistentKeyChanged(DcId dcId, const AuthKeyPtr &persistentKey);
+	void dcTemporaryKeyChanged(DcId dcId);
+	[[nodiscard]] rpl::producer<DcId> dcTemporaryKeyChanged() const;
 	[[nodiscard]] AuthKeysList getKeysForWrite() const;
 	void addKeysForDestroy(AuthKeysList &&keys);
+	[[nodiscard]] rpl::producer<> allKeysDestroyed() const;
 
 	[[nodiscard]] not_null<DcOptions*> dcOptions();
 
@@ -66,6 +85,9 @@ public:
 	void badConfigurationError();
 	void syncHttpUnixtime();
 
+	void restartedByTimeout(ShiftedDcId shiftedDcId);
+	[[nodiscard]] rpl::producer<ShiftedDcId> restartsByTimeout() const;
+
 	void restart();
 	void restart(ShiftedDcId shiftedDcId);
 	[[nodiscard]] int32 dcstate(ShiftedDcId shiftedDcId = 0);
@@ -74,21 +96,21 @@ public:
 	void cancel(mtpRequestId requestId);
 	[[nodiscard]] int32 state(mtpRequestId requestId); // < 0 means waiting for such count of ms
 	void killSession(ShiftedDcId shiftedDcId);
-	void killSession(std::unique_ptr<internal::Session> session);
 	void stopSession(ShiftedDcId shiftedDcId);
 	void reInitConnection(DcId dcId);
-	void logout(RPCDoneHandlerPtr onDone, RPCFailHandlerPtr onFail);
+	void logout(Fn<void()> done);
 
-	std::shared_ptr<internal::Dcenter> getDcById(ShiftedDcId shiftedDcId);
+	not_null<Dcenter*> getDcById(ShiftedDcId shiftedDcId);
+	Dcenter *findDc(ShiftedDcId shiftedDcId);
+	not_null<Dcenter*> addDc(
+		ShiftedDcId shiftedDcId,
+		AuthKeyPtr &&key = nullptr);
+	void removeDc(ShiftedDcId shiftedDcId);
 	void unpaused();
 
-	void queueQuittingConnection(
-		std::unique_ptr<internal::Connection> &&connection);
-	void connectionFinished(internal::Connection *connection);
-
 	void sendRequest(
 		mtpRequestId requestId,
-		SecureRequest &&request,
+		SerializedRequest &&request,
 		RPCResponseHandler &&callbacks,
 		ShiftedDcId shiftedDcId,
 		crl::time msCanWait,
@@ -98,10 +120,9 @@ public:
 	void unregisterRequest(mtpRequestId requestId);
 	void storeRequest(
 		mtpRequestId requestId,
-		const SecureRequest &request,
+		const SerializedRequest &request,
 		RPCResponseHandler &&callbacks);
-	SecureRequest getRequest(mtpRequestId requestId);
-	void clearCallbacksDelayed(std::vector<RPCCallbackClear> &&ids);
+	SerializedRequest getRequest(mtpRequestId requestId);
 	void execCallback(mtpRequestId requestId, const mtpPrime *from, const mtpPrime *end);
 	bool hasCallbacks(mtpRequestId requestId);
 	void globalCallback(const mtpPrime *from, const mtpPrime *end);
@@ -121,7 +142,7 @@ public:
 	void setSessionResetHandler(Fn<void(ShiftedDcId shiftedDcId)> handler);
 	void clearGlobalHandlers();
 
-	not_null<internal::Session*> getSession(ShiftedDcId shiftedDcId);
+	[[nodiscard]] not_null<Session*> getSession(ShiftedDcId shiftedDcId);
 
 	bool isNormal() const {
 		return (_mode == Instance::Mode::Normal);
@@ -131,10 +152,11 @@ public:
 	}
 
 	void scheduleKeyDestroy(ShiftedDcId shiftedDcId);
+	void keyWasPossiblyDestroyed(ShiftedDcId shiftedDcId);
 	void performKeyDestroy(ShiftedDcId shiftedDcId);
 	void completedKeyDestroy(ShiftedDcId shiftedDcId);
+	void keyDestroyedOnServer(ShiftedDcId shiftedDcId, uint64 keyId);
 
-	void clearKilledSessions();
 	void prepareToDestroy();
 
 private:
@@ -145,6 +167,11 @@ private:
 	bool exportFail(const RPCError &error, mtpRequestId requestId);
 	bool onErrorDefault(mtpRequestId requestId, const RPCError &error);
 
+	Session *findSession(ShiftedDcId shiftedDcId);
+	not_null<Session*> startSession(ShiftedDcId shiftedDcId);
+	Session *removeSession(ShiftedDcId shiftedDcId);
+	[[nodiscard]] not_null<QThread*> getThreadForDc(ShiftedDcId shiftedDcId);
+
 	void applyDomainIps(
 		const QString &host,
 		const QStringList &ips,
@@ -162,32 +189,31 @@ private:
 	std::optional<ShiftedDcId> changeRequestByDc(
 		mtpRequestId requestId, DcId newdc);
 
-	// RPCError::NoError means do not toggle onError callback.
-	void clearCallbacks(
-		mtpRequestId requestId,
-		int32 errorCode = RPCError::NoError);
-	void clearCallbacks(const std::vector<RPCCallbackClear> &ids);
-
 	void checkDelayedRequests();
 
 	const not_null<Instance*> _instance;
 	const not_null<DcOptions*> _dcOptions;
 	const Instance::Mode _mode = Instance::Mode::Normal;
 
-	DcId _mainDcId = Config::kDefaultMainDc;
-	bool _mainDcIdForced = false;
-	std::map<DcId, std::shared_ptr<internal::Dcenter>> _dcenters;
+	std::unique_ptr<QThread> _mainSessionThread;
+	std::unique_ptr<QThread> _otherSessionsThread;
+	std::vector<std::unique_ptr<QThread>> _fileSessionThreads;
 
 	QString _deviceModel;
 	QString _systemVersion;
 
-	internal::Session *_mainSession = nullptr;
-	std::map<ShiftedDcId, std::unique_ptr<internal::Session>> _sessions;
-	std::vector<std::unique_ptr<internal::Session>> _killedSessions; // delayed delete
+	DcId _mainDcId = Config::kDefaultMainDc;
+	bool _mainDcIdForced = false;
+	base::flat_map<DcId, std::unique_ptr<Dcenter>> _dcenters;
+	std::vector<std::unique_ptr<Dcenter>> _dcentersToDestroy;
+	rpl::event_stream<DcId> _dcTemporaryKeyChanged;
 
-	base::set_of_unique_ptr<internal::Connection> _quittingConnections;
+	Session *_mainSession = nullptr;
+	base::flat_map<ShiftedDcId, std::unique_ptr<Session>> _sessions;
+	std::vector<std::unique_ptr<Session>> _sessionsToDestroy;
+	rpl::event_stream<ShiftedDcId> _restartsByTimeout;
 
-	std::unique_ptr<internal::ConfigLoader> _configLoader;
+	std::unique_ptr<ConfigLoader> _configLoader;
 	std::unique_ptr<DomainResolver> _domainResolver;
 	std::unique_ptr<SpecialConfigRequest> _httpUnixtimeLoader;
 	QString _userPhone;
@@ -195,10 +221,10 @@ private:
 	crl::time _lastConfigLoadedTime = 0;
 	crl::time _configExpiresAt = 0;
 
-	std::map<DcId, AuthKeyPtr> _keysForWrite;
-	mutable QReadWriteLock _keysForWriteLock;
+	base::flat_map<DcId, AuthKeyPtr> _keysForWrite;
+	base::flat_map<ShiftedDcId, mtpRequestId> _logoutGuestRequestIds;
 
-	std::map<ShiftedDcId, mtpRequestId> _logoutGuestRequestIds;
+	rpl::event_stream<> _allKeysDestroyed;
 
 	// holds dcWithShift for request to this dc or -dc for request to main dc
 	std::map<mtpRequestId, ShiftedDcId> _requestsByDc;
@@ -210,7 +236,7 @@ private:
 	std::map<mtpRequestId, RPCResponseHandler> _parserMap;
 	QMutex _parserMapLock;
 
-	std::map<mtpRequestId, SecureRequest> _requestMap;
+	std::map<mtpRequestId, SerializedRequest> _requestMap;
 	QReadWriteLock _requestMapLock;
 
 	std::deque<std::pair<mtpRequestId, crl::time>> _delayedRequests;
@@ -227,29 +253,24 @@ private:
 
 	base::Timer _checkDelayedTimer;
 
-	// Debug flag to find out how we end up crashing.
-	bool MustNotCreateSessions = false;
-
 };
 
 Instance::Private::Private(
 	not_null<Instance*> instance,
 	not_null<DcOptions*> options,
 	Instance::Mode mode)
-: Sender()
+: Sender(instance)
 , _instance(instance)
 , _dcOptions(options)
 , _mode(mode) {
+	const auto idealThreadPoolSize = QThread::idealThreadCount();
+	_fileSessionThreads.resize(2 * std::max(idealThreadPoolSize / 2, 1));
 }
 
 void Instance::Private::start(Config &&config) {
 	_deviceModel = std::move(config.deviceModel);
 	_systemVersion = std::move(config.systemVersion);
 
-	if (isKeysDestroyer()) {
-		_instance->connect(_instance, SIGNAL(keyDestroyed(qint32)), _instance, SLOT(onKeyDestroyed(qint32)), Qt::QueuedConnection);
-	}
-
 	for (auto &key : config.keys) {
 		auto dcId = key->dcId();
 		auto shiftedDcId = dcId;
@@ -263,9 +284,7 @@ void Instance::Private::start(Config &&config) {
 			}
 		}
 		_keysForWrite[shiftedDcId] = key;
-
-		auto dc = std::make_shared<internal::Dcenter>(_instance, dcId, std::move(key));
-		_dcenters.emplace(shiftedDcId, std::move(dc));
+		addDc(shiftedDcId, std::move(key));
 	}
 
 	if (config.mainDcId != Config::kNotSetMainDc) {
@@ -274,19 +293,11 @@ void Instance::Private::start(Config &&config) {
 	}
 
 	if (isKeysDestroyer()) {
-		for (auto &dc : _dcenters) {
-			Assert(!MustNotCreateSessions);
-			auto shiftedDcId = dc.first;
-			auto session = std::make_unique<internal::Session>(_instance, shiftedDcId);
-			auto it = _sessions.emplace(shiftedDcId, std::move(session)).first;
-			it->second->start();
+		for (const auto &[shiftedDcId, dc] : _dcenters) {
+			startSession(shiftedDcId);
 		}
 	} else if (_mainDcId != Config::kNoneMainDc) {
-		Assert(!MustNotCreateSessions);
-		auto main = std::make_unique<internal::Session>(_instance, _mainDcId);
-		_mainSession = main.get();
-		_sessions.emplace(_mainDcId, std::move(main));
-		_mainSession->start();
+		_mainSession = startSession(_mainDcId);
 	}
 
 	_checkDelayedTimer.setCallback([this] { checkDelayedRequests(); });
@@ -342,8 +353,8 @@ void Instance::Private::applyDomainIps(
 	}
 	if (applyToProxy(Global::RefSelectedProxy())
 		&& (Global::ProxySettings() == ProxyData::Settings::Enabled)) {
-		for (auto &session : _sessions) {
-			session.second->refreshOptions();
+		for (const auto &[shiftedDcId, session] : _sessions) {
+			session->refreshOptions();
 		}
 	}
 	emit _instance->proxyDomainResolved(host, ips, expireAt);
@@ -405,7 +416,7 @@ void Instance::Private::requestConfig() {
 	if (_configLoader || isKeysDestroyer()) {
 		return;
 	}
-	_configLoader = std::make_unique<internal::ConfigLoader>(
+	_configLoader = std::make_unique<ConfigLoader>(
 		_instance,
 		_userPhone,
 		rpcDone([=](const MTPConfig &result) { configLoadDone(result); }),
@@ -439,6 +450,14 @@ void Instance::Private::syncHttpUnixtime() {
 	});
 }
 
+void Instance::Private::restartedByTimeout(ShiftedDcId shiftedDcId) {
+	_restartsByTimeout.fire_copy(shiftedDcId);
+}
+
+rpl::producer<ShiftedDcId> Instance::Private::restartsByTimeout() const {
+	return _restartsByTimeout.events();
+}
+
 void Instance::Private::requestConfigIfOld() {
 	const auto timeout = Global::BlockedMode()
 		? kConfigBecomesOldForBlockedIn
@@ -468,27 +487,24 @@ void Instance::Private::requestCDNConfig() {
 		MTPhelp_GetCdnConfig()
 	).done([this](const MTPCdnConfig &result) {
 		_cdnConfigLoadRequestId = 0;
-
-		Expects(result.type() == mtpc_cdnConfig);
-		dcOptions()->setCDNConfig(result.c_cdnConfig());
-
+		result.match([&](const MTPDcdnConfig &data) {
+			dcOptions()->setCDNConfig(data);
+		});
 		Local::writeSettings();
-
-		emit _instance->cdnConfigLoaded();
 	}).send();
 }
 
 void Instance::Private::restart() {
-	for (auto &session : _sessions) {
-		session.second->restart();
+	for (const auto &[shiftedDcId, session] : _sessions) {
+		session->restart();
 	}
 }
 
 void Instance::Private::restart(ShiftedDcId shiftedDcId) {
-	auto dcId = BareDcId(shiftedDcId);
-	for (auto &session : _sessions) {
-		if (BareDcId(session.second->getDcWithShift()) == dcId) {
-			session.second->restart();
+	const auto dcId = BareDcId(shiftedDcId);
+	for (const auto &[shiftedDcId, session] : _sessions) {
+		if (BareDcId(shiftedDcId) == dcId) {
+			session->restart();
 		}
 	}
 }
@@ -504,11 +520,9 @@ int32 Instance::Private::dcstate(ShiftedDcId shiftedDcId) {
 		shiftedDcId += BareDcId(_mainSession->getDcWithShift());
 	}
 
-	auto it = _sessions.find(shiftedDcId);
-	if (it != _sessions.cend()) {
-		return it->second->getState();
+	if (const auto session = findSession(shiftedDcId)) {
+		return session->getState();
 	}
-
 	return DisconnectedState;
 }
 
@@ -522,11 +536,9 @@ QString Instance::Private::dctransport(ShiftedDcId shiftedDcId) {
 		shiftedDcId += BareDcId(_mainSession->getDcWithShift());
 	}
 
-	auto it = _sessions.find(shiftedDcId);
-	if (it != _sessions.cend()) {
-		return it->second->transport();
+	if (const auto session = findSession(shiftedDcId)) {
+		return session->transport();
 	}
-
 	return QString();
 }
 
@@ -553,7 +565,9 @@ void Instance::Private::cancel(mtpRequestId requestId) {
 		const auto session = getSession(qAbs(*shiftedDcId));
 		session->cancel(requestId, msgId);
 	}
-	clearCallbacks(requestId);
+
+	QMutexLocker locker(&_parserMapLock);
+	_parserMap.erase(requestId);
 }
 
 // result < 0 means waiting for such count of ms.
@@ -570,77 +584,65 @@ int32 Instance::Private::state(mtpRequestId requestId) {
 }
 
 void Instance::Private::killSession(ShiftedDcId shiftedDcId) {
-	auto checkIfMainAndKill = [this](ShiftedDcId shiftedDcId) {
-		auto it = _sessions.find(shiftedDcId);
-		if (it != _sessions.cend()) {
-			_killedSessions.push_back(std::move(it->second));
-			_sessions.erase(it);
-			_killedSessions.back()->kill();
-			return (_killedSessions.back().get() == _mainSession);
+	const auto checkIfMainAndKill = [&](ShiftedDcId shiftedDcId) {
+		if (const auto removed = removeSession(shiftedDcId)) {
+			return (removed == _mainSession);
 		}
 		return false;
 	};
 	if (checkIfMainAndKill(shiftedDcId)) {
 		checkIfMainAndKill(_mainDcId);
-
-		Assert(!MustNotCreateSessions);
-		auto main = std::make_unique<internal::Session>(_instance, _mainDcId);
-		_mainSession = main.get();
-		_sessions.emplace(_mainDcId, std::move(main));
-		_mainSession->start();
+		_mainSession = startSession(_mainDcId);
 	}
-	InvokeQueued(_instance, [this] {
-		clearKilledSessions();
+	InvokeQueued(_instance, [=] {
+		_sessionsToDestroy.clear();
 	});
 }
 
-void Instance::Private::clearKilledSessions() {
-	_killedSessions.clear();
-}
-
 void Instance::Private::stopSession(ShiftedDcId shiftedDcId) {
-	auto it = _sessions.find(shiftedDcId);
-	if (it != _sessions.end()) {
-		if (it->second.get() != _mainSession) { // don't stop main session
-			it->second->stop();
+	if (const auto session = findSession(shiftedDcId)) {
+		if (session != _mainSession) { // don't stop main session
+			session->stop();
 		}
 	}
 }
 
 void Instance::Private::reInitConnection(DcId dcId) {
-	for (auto &session : _sessions) {
-		if (BareDcId(session.second->getDcWithShift()) == dcId) {
-			session.second->reInitConnection();
+	for (const auto &[shiftedDcId, session] : _sessions) {
+		if (BareDcId(shiftedDcId) == dcId) {
+			session->reInitConnection();
 		}
 	}
 }
 
-void Instance::Private::logout(
-		RPCDoneHandlerPtr onDone,
-		RPCFailHandlerPtr onFail) {
-	_instance->send(MTPauth_LogOut(), std::move(onDone), std::move(onFail));
+void Instance::Private::logout(Fn<void()> done) {
+	_instance->send(MTPauth_LogOut(), rpcDone([=] {
+		done();
+	}), rpcFail([=] {
+		done();
+		return true;
+	}));
 	logoutGuestDcs();
 }
 
 void Instance::Private::logoutGuestDcs() {
 	auto dcIds = std::vector<DcId>();
-	{
-		QReadLocker lock(&_keysForWriteLock);
-		dcIds.reserve(_keysForWrite.size());
-		for (auto &key : _keysForWrite) {
-			dcIds.push_back(key.first);
-		}
+	dcIds.reserve(_keysForWrite.size());
+	for (const auto &key : _keysForWrite) {
+		dcIds.push_back(key.first);
 	}
-	for (auto dcId : dcIds) {
-		if (dcId != mainDcId() && dcOptions()->dcType(dcId) != DcType::Cdn) {
-			auto shiftedDcId = MTP::logoutDcId(dcId);
-			auto requestId = _instance->send(MTPauth_LogOut(), rpcDone([this](mtpRequestId requestId) {
-				logoutGuestDone(requestId);
-			}), rpcFail([this](mtpRequestId requestId) {
-				return logoutGuestDone(requestId);
-			}), shiftedDcId);
-			_logoutGuestRequestIds.emplace(shiftedDcId, requestId);
+	for (const auto dcId : dcIds) {
+		if (dcId == mainDcId() || dcOptions()->dcType(dcId) == DcType::Cdn) {
+			continue;
 		}
+		const auto shiftedDcId = MTP::logoutDcId(dcId);
+		const auto requestId = _instance->send(MTPauth_LogOut(), rpcDone([=](
+				mtpRequestId requestId) {
+			logoutGuestDone(requestId);
+		}), rpcFail([=](mtpRequestId requestId) {
+			return logoutGuestDone(requestId);
+		}), shiftedDcId);
+		_logoutGuestRequestIds.emplace(shiftedDcId, requestId);
 	}
 }
 
@@ -655,43 +657,90 @@ bool Instance::Private::logoutGuestDone(mtpRequestId requestId) {
 	return false;
 }
 
-std::shared_ptr<internal::Dcenter> Instance::Private::getDcById(ShiftedDcId shiftedDcId) {
-	auto it = _dcenters.find(shiftedDcId);
-	if (it == _dcenters.cend()) {
-		auto dcId = BareDcId(shiftedDcId);
-		if (isTemporaryDcId(dcId)) {
-			if (auto realDcId = getRealIdFromTemporaryDcId(dcId)) {
-				dcId = realDcId;
+Dcenter *Instance::Private::findDc(ShiftedDcId shiftedDcId) {
+	const auto i = _dcenters.find(shiftedDcId);
+	return (i != _dcenters.end()) ? i->second.get() : nullptr;
+}
+
+not_null<Dcenter*> Instance::Private::addDc(
+		ShiftedDcId shiftedDcId,
+		AuthKeyPtr &&key) {
+	const auto dcId = BareDcId(shiftedDcId);
+	return _dcenters.emplace(
+		shiftedDcId,
+		std::make_unique<Dcenter>(dcId, std::move(key))
+	).first->second.get();
+}
+
+void Instance::Private::removeDc(ShiftedDcId shiftedDcId) {
+	const auto i = _dcenters.find(shiftedDcId);
+	if (i != _dcenters.end()) {
+		_dcentersToDestroy.push_back(std::move(i->second));
+		_dcenters.erase(i);
+	}
+}
+
+not_null<Dcenter*> Instance::Private::getDcById(
+		ShiftedDcId shiftedDcId) {
+	if (const auto result = findDc(shiftedDcId)) {
+		return result;
+	}
+	const auto dcId = [&] {
+		const auto result = BareDcId(shiftedDcId);
+		if (isTemporaryDcId(result)) {
+			if (const auto realDcId = getRealIdFromTemporaryDcId(result)) {
+				return realDcId;
 			}
 		}
-		it = _dcenters.find(dcId);
-		if (it == _dcenters.cend()) {
-			auto result = std::make_shared<internal::Dcenter>(_instance, dcId, AuthKeyPtr());
-			return _dcenters.emplace(dcId, std::move(result)).first->second;
+		return result;
+	}();
+	if (dcId != shiftedDcId) {
+		if (const auto result = findDc(dcId)) {
+			return result;
 		}
 	}
-	return it->second;
+	return addDc(dcId);
 }
 
-void Instance::Private::setKeyForWrite(DcId dcId, const AuthKeyPtr &key) {
+void Instance::Private::dcPersistentKeyChanged(
+		DcId dcId,
+		const AuthKeyPtr &persistentKey) {
+	dcTemporaryKeyChanged(dcId);
+
 	if (isTemporaryDcId(dcId)) {
 		return;
 	}
 
-	QWriteLocker lock(&_keysForWriteLock);
-	if (key) {
-		_keysForWrite[dcId] = key;
+	const auto i = _keysForWrite.find(dcId);
+	if (i != _keysForWrite.end() && i->second == persistentKey) {
+		return;
+	} else if (i == _keysForWrite.end() && !persistentKey) {
+		return;
+	}
+	if (!persistentKey) {
+		_keysForWrite.erase(i);
+	} else if (i != _keysForWrite.end()) {
+		i->second = persistentKey;
 	} else {
-		_keysForWrite.erase(dcId);
+		_keysForWrite.emplace(dcId, persistentKey);
 	}
+	DEBUG_LOG(("AuthKey Info: writing auth keys, called by dc %1").arg(dcId));
+	Local::writeMtpData();
+}
+
+void Instance::Private::dcTemporaryKeyChanged(DcId dcId) {
+	_dcTemporaryKeyChanged.fire_copy(dcId);
+}
+
+rpl::producer<DcId> Instance::Private::dcTemporaryKeyChanged() const {
+	return _dcTemporaryKeyChanged.events();
 }
 
 AuthKeysList Instance::Private::getKeysForWrite() const {
 	auto result = AuthKeysList();
 
-	QReadLocker lock(&_keysForWriteLock);
 	result.reserve(_keysForWrite.size());
-	for (auto &key : _keysForWrite) {
+	for (const auto &key : _keysForWrite) {
 		result.push_back(key.second);
 	}
 	return result;
@@ -701,29 +750,25 @@ void Instance::Private::addKeysForDestroy(AuthKeysList &&keys) {
 	Expects(isKeysDestroyer());
 
 	for (auto &key : keys) {
-		auto dcId = key->dcId();
+		const auto dcId = key->dcId();
 		auto shiftedDcId = MTP::destroyKeyNextDcId(dcId);
 
-		{
-			QWriteLocker lock(&_keysForWriteLock);
-			// There could be several keys for one dc if we're destroying them.
-			// Place them all in separate shiftedDcId so that they won't conflict.
-			while (_keysForWrite.find(shiftedDcId) != _keysForWrite.cend()) {
-				shiftedDcId = MTP::destroyKeyNextDcId(shiftedDcId);
-			}
-			_keysForWrite[shiftedDcId] = key;
+		// There could be several keys for one dc if we're destroying them.
+		// Place them all in separate shiftedDcId so that they won't conflict.
+		while (_keysForWrite.find(shiftedDcId) != _keysForWrite.cend()) {
+			shiftedDcId = MTP::destroyKeyNextDcId(shiftedDcId);
 		}
+		_keysForWrite[shiftedDcId] = key;
 
-		auto dc = std::make_shared<internal::Dcenter>(_instance, dcId, std::move(key));
-		_dcenters.emplace(shiftedDcId, std::move(dc));
-
-		Assert(!MustNotCreateSessions);
-		auto session = std::make_unique<internal::Session>(_instance, shiftedDcId);
-		auto it = _sessions.emplace(shiftedDcId, std::move(session)).first;
-		it->second->start();
+		addDc(shiftedDcId, std::move(key));
+		startSession(shiftedDcId);
 	}
 }
 
+rpl::producer<> Instance::Private::allKeysDestroyed() const {
+	return _allKeysDestroyed.events();
+}
+
 not_null<DcOptions*> Instance::Private::dcOptions() {
 	return _dcOptions;
 }
@@ -737,20 +782,8 @@ QString Instance::Private::systemVersion() const {
 }
 
 void Instance::Private::unpaused() {
-	for (auto &session : _sessions) {
-		session.second->unpaused();
-	}
-}
-
-void Instance::Private::queueQuittingConnection(
-		std::unique_ptr<internal::Connection> &&connection) {
-	_quittingConnections.insert(std::move(connection));
-}
-
-void Instance::Private::connectionFinished(internal::Connection *connection) {
-	auto it = _quittingConnections.find(connection);
-	if (it != _quittingConnections.end()) {
-		_quittingConnections.erase(it);
+	for (const auto &[shiftedDcId, session] : _sessions) {
+		session->unpaused();
 	}
 }
 
@@ -821,8 +854,6 @@ void Instance::Private::configLoadDone(const MTPConfig &result) {
 	_configExpiresAt = crl::now()
 		+ (data.vexpires().v - base::unixtime::now()) * crl::time(1000);
 	requestConfigIfExpired();
-
-	emit _instance->configLoaded();
 }
 
 bool Instance::Private::configLoadFail(const RPCError &error) {
@@ -873,7 +904,7 @@ void Instance::Private::checkDelayedRequests() {
 			continue;
 		}
 
-		auto request = SecureRequest();
+		auto request = SerializedRequest();
 		{
 			QReadLocker locker(&_requestMapLock);
 			auto it = _requestMap.find(requestId);
@@ -894,7 +925,7 @@ void Instance::Private::checkDelayedRequests() {
 
 void Instance::Private::sendRequest(
 		mtpRequestId requestId,
-		SecureRequest &&request,
+		SerializedRequest &&request,
 		RPCResponseHandler &&callbacks,
 		ShiftedDcId shiftedDcId,
 		crl::time msCanWait,
@@ -913,7 +944,7 @@ void Instance::Private::sendRequest(
 	if (afterRequestId) {
 		request->after = getRequest(afterRequestId);
 	}
-	request->msDate = crl::now(); // > 0 - can send without container
+	request->lastSentTime = crl::now();
 	request->needsLayer = needsLayer;
 
 	session->sendPrepared(request, msCanWait);
@@ -942,7 +973,7 @@ void Instance::Private::unregisterRequest(mtpRequestId requestId) {
 
 void Instance::Private::storeRequest(
 		mtpRequestId requestId,
-		const SecureRequest &request,
+		const SerializedRequest &request,
 		RPCResponseHandler &&callbacks) {
 	if (callbacks.onDone || callbacks.onFail) {
 		QMutexLocker locker(&_parserMapLock);
@@ -954,8 +985,8 @@ void Instance::Private::storeRequest(
 	}
 }
 
-SecureRequest Instance::Private::getRequest(mtpRequestId requestId) {
-	auto result = SecureRequest();
+SerializedRequest Instance::Private::getRequest(mtpRequestId requestId) {
+	auto result = SerializedRequest();
 	{
 		QReadLocker locker(&_requestMapLock);
 		auto it = _requestMap.find(requestId);
@@ -967,76 +998,6 @@ SecureRequest Instance::Private::getRequest(mtpRequestId requestId) {
 }
 
 
-void Instance::Private::clearCallbacks(mtpRequestId requestId, int32 errorCode) {
-	RPCResponseHandler h;
-	bool found = false;
-	{
-		QMutexLocker locker(&_parserMapLock);
-		auto it = _parserMap.find(requestId);
-		if (it != _parserMap.end()) {
-			h = it->second;
-			found = true;
-
-			_parserMap.erase(it);
-		}
-	}
-	if (errorCode && found) {
-		LOG(("API Error: callbacks cleared without handling! "
-			"Request: %1, error code: %2"
-			).arg(requestId
-			).arg(errorCode));
-		rpcErrorOccured(
-			requestId,
-			h,
-			RPCError::Local(
-				"CLEAR_CALLBACK",
-				QString("did not handle request %1, error code %2"
-				).arg(requestId
-				).arg(errorCode)));
-	}
-}
-
-void Instance::Private::clearCallbacksDelayed(
-		std::vector<RPCCallbackClear> &&ids) {
-	if (ids.empty()) {
-		return;
-	}
-
-	if (Logs::DebugEnabled()) {
-		auto idsString = QStringList();
-		idsString.reserve(ids.size());
-		for (auto &value : ids) {
-			idsString.push_back(QString::number(value.requestId));
-		}
-		DEBUG_LOG(("RPC Info: clear callbacks delayed, msgIds: %1"
-			).arg(idsString.join(", ")));
-	}
-
-	crl::on_main(_instance, [this, list = std::move(ids)] {
-		clearCallbacks(list);
-	});
-}
-
-void Instance::Private::clearCallbacks(
-		const std::vector<RPCCallbackClear> &ids) {
-	Expects(!ids.empty());
-
-	for (const auto &clearRequest : ids) {
-		if (Logs::DebugEnabled()) {
-			QMutexLocker locker(&_parserMapLock);
-			const auto hasParsers = (_parserMap.find(clearRequest.requestId)
-				!= _parserMap.end());
-			DEBUG_LOG(("RPC Info: "
-				"clearing delayed callback %1, error code %2, parsers: %3"
-				).arg(clearRequest.requestId
-				).arg(clearRequest.errorCode
-				).arg(Logs::b(hasParsers)));
-		}
-		clearCallbacks(clearRequest.requestId, clearRequest.errorCode);
-		unregisterRequest(clearRequest.requestId);
-	}
-}
-
 void Instance::Private::execCallback(
 		mtpRequestId requestId,
 		const mtpPrime *from,
@@ -1106,13 +1067,13 @@ void Instance::Private::globalCallback(const mtpPrime *from, const mtpPrime *end
 	[[maybe_unused]] bool result = (*_globalHandler.onDone)(0, from, end);
 }
 
-void Instance::Private::onStateChange(int32 dcWithShift, int32 state) {
+void Instance::Private::onStateChange(ShiftedDcId dcWithShift, int32 state) {
 	if (_stateChangedHandler) {
 		_stateChangedHandler(dcWithShift, state);
 	}
 }
 
-void Instance::Private::onSessionReset(int32 dcWithShift) {
+void Instance::Private::onSessionReset(ShiftedDcId dcWithShift) {
 	if (_sessionResetHandler) {
 		_sessionResetHandler(dcWithShift);
 	}
@@ -1120,7 +1081,9 @@ void Instance::Private::onSessionReset(int32 dcWithShift) {
 
 bool Instance::Private::rpcErrorOccured(mtpRequestId requestId, const RPCFailHandlerPtr &onFail, const RPCError &err) { // return true if need to clean request data
 	if (isDefaultHandledError(err)) {
-		if (onFail && (*onFail)(requestId, err)) return true;
+		if (onFail && (*onFail)(requestId, err)) {
+			return true;
+		}
 	}
 
 	if (onErrorDefault(requestId, err)) {
@@ -1279,7 +1242,7 @@ bool Instance::Private::onErrorDefault(mtpRequestId requestId, const RPCError &e
 			newdcWithShift = ShiftDcId(newdcWithShift, GetDcIdShift(dcWithShift));
 		}
 
-		auto request = SecureRequest();
+		auto request = SerializedRequest();
 		{
 			QReadLocker locker(&_requestMapLock);
 			auto it = _requestMap.find(requestId);
@@ -1321,7 +1284,8 @@ bool Instance::Private::onErrorDefault(mtpRequestId requestId, const RPCError &e
 		checkDelayedRequests();
 
 		return true;
-	} else if (code == 401 || (badGuestDc && _badGuestDcRequests.find(requestId) == _badGuestDcRequests.cend())) {
+	} else if ((code == 401 && err != "AUTH_KEY_PERM_EMPTY")
+		|| (badGuestDc && _badGuestDcRequests.find(requestId) == _badGuestDcRequests.cend())) {
 		auto dcWithShift = ShiftedDcId(0);
 		if (const auto shiftedDcId = queryRequestByDc(requestId)) {
 			dcWithShift = *shiftedDcId;
@@ -1350,7 +1314,7 @@ bool Instance::Private::onErrorDefault(mtpRequestId requestId, const RPCError &e
 		if (badGuestDc) _badGuestDcRequests.insert(requestId);
 		return true;
 	} else if (err == qstr("CONNECTION_NOT_INITED") || err == qstr("CONNECTION_LAYER_INVALID")) {
-		SecureRequest request;
+		SerializedRequest request;
 		{
 			QReadLocker locker(&_requestMapLock);
 			auto it = _requestMap.find(requestId);
@@ -1375,7 +1339,7 @@ bool Instance::Private::onErrorDefault(mtpRequestId requestId, const RPCError &e
 	} else if (err == qstr("CONNECTION_LANG_CODE_INVALID")) {
 		Lang::CurrentCloudManager().resetToDefault();
 	} else if (err == qstr("MSG_WAIT_FAILED")) {
-		SecureRequest request;
+		SerializedRequest request;
 		{
 			QReadLocker locker(&_requestMapLock);
 			auto it = _requestMap.find(requestId);
@@ -1394,7 +1358,7 @@ bool Instance::Private::onErrorDefault(mtpRequestId requestId, const RPCError &e
 			if (const auto afterDcId = queryRequestByDc(request->after->requestId)) {
 				dcWithShift = *shiftedDcId;
 				if (*shiftedDcId != *afterDcId) {
-					request->after = SecureRequest();
+					request->after = SerializedRequest();
 				}
 			} else {
 				LOG(("MTP Error: could not find dependent request %1 by dc").arg(request->after->requestId));
@@ -1439,24 +1403,103 @@ bool Instance::Private::onErrorDefault(mtpRequestId requestId, const RPCError &e
 	return false;
 }
 
-not_null<internal::Session*> Instance::Private::getSession(
+not_null<Session*> Instance::Private::getSession(
 		ShiftedDcId shiftedDcId) {
 	if (!shiftedDcId) {
 		Assert(_mainSession != nullptr);
 		return _mainSession;
-	}
-	if (!BareDcId(shiftedDcId)) {
+	} else if (!BareDcId(shiftedDcId)) {
 		Assert(_mainSession != nullptr);
 		shiftedDcId += BareDcId(_mainSession->getDcWithShift());
 	}
 
-	auto it = _sessions.find(shiftedDcId);
-	if (it == _sessions.cend()) {
-		Assert(!MustNotCreateSessions);
-		it = _sessions.emplace(shiftedDcId, std::make_unique<internal::Session>(_instance, shiftedDcId)).first;
-		it->second->start();
+	if (const auto session = findSession(shiftedDcId)) {
+		return session;
+	}
+	return startSession(shiftedDcId);
+}
+
+Session *Instance::Private::findSession(ShiftedDcId shiftedDcId) {
+	const auto i = _sessions.find(shiftedDcId);
+	return (i != _sessions.end()) ? i->second.get() : nullptr;
+}
+
+not_null<Session*> Instance::Private::startSession(ShiftedDcId shiftedDcId) {
+	Expects(BareDcId(shiftedDcId) != 0);
+
+	const auto dc = getDcById(shiftedDcId);
+	const auto thread = getThreadForDc(shiftedDcId);
+	const auto result = _sessions.emplace(
+		shiftedDcId,
+		std::make_unique<Session>(_instance, thread, shiftedDcId, dc)
+	).first->second.get();
+	if (isKeysDestroyer()) {
+		scheduleKeyDestroy(shiftedDcId);
+	}
+
+	return result;
+}
+
+Session *Instance::Private::removeSession(ShiftedDcId shiftedDcId) {
+	const auto i = _sessions.find(shiftedDcId);
+	if (i == _sessions.cend()) {
+		return nullptr;
 	}
-	return it->second.get();
+	i->second->kill();
+	_sessionsToDestroy.push_back(std::move(i->second));
+	_sessions.erase(i);
+	return _sessionsToDestroy.back().get();
+}
+
+
+not_null<QThread*> Instance::Private::getThreadForDc(
+		ShiftedDcId shiftedDcId) {
+	static const auto EnsureStarted = [](
+			std::unique_ptr<QThread> &thread,
+			auto name) {
+		if (!thread) {
+			thread = std::make_unique<QThread>();
+			thread->setObjectName(name());
+			thread->start();
+		}
+		return thread.get();
+	};
+	static const auto FindOne = [](
+			std::vector<std::unique_ptr<QThread>> &threads,
+			const char *prefix,
+			int index,
+			bool shift) {
+		Expects(!threads.empty());
+		Expects(!(threads.size() % 2));
+
+		const auto count = int(threads.size());
+		index %= count;
+		if (index >= count / 2) {
+			index = (count - 1) - (index - count / 2);
+		}
+		if (shift) {
+			index = (index + count / 2) % count;
+		}
+		return EnsureStarted(threads[index], [=] {
+			return QString("MTP %1 Session (%2)").arg(prefix).arg(index);
+		});
+	};
+	if (shiftedDcId == BareDcId(shiftedDcId)) {
+		return EnsureStarted(_mainSessionThread, [] {
+			return QString("MTP Main Session");
+		});
+	} else if (isDownloadDcId(shiftedDcId)) {
+		const auto index = GetDcIdShift(shiftedDcId) - kBaseDownloadDcShift;
+		const auto composed = index + BareDcId(shiftedDcId);
+		return FindOne(_fileSessionThreads, "Download", composed, false);
+	} else if (isUploadDcId(shiftedDcId)) {
+		const auto index = GetDcIdShift(shiftedDcId) - kBaseUploadDcShift;
+		const auto composed = index + BareDcId(shiftedDcId);
+		return FindOne(_fileSessionThreads, "Upload", composed, true);
+	}
+	return EnsureStarted(_otherSessionsThread, [] {
+		return QString("MTP Other Session");
+	});
 }
 
 void Instance::Private::scheduleKeyDestroy(ShiftedDcId shiftedDcId) {
@@ -1468,17 +1511,29 @@ void Instance::Private::scheduleKeyDestroy(ShiftedDcId shiftedDcId) {
 		_instance->send(MTPauth_LogOut(), rpcDone([=](const MTPBool &) {
 			performKeyDestroy(shiftedDcId);
 		}), rpcFail([=](const RPCError &error) {
-			if (isDefaultHandledError(error)) return false;
+			if (isDefaultHandledError(error)) {
+				return false;
+			}
 			performKeyDestroy(shiftedDcId);
 			return true;
 		}), shiftedDcId);
 	}
 }
 
+void Instance::Private::keyWasPossiblyDestroyed(ShiftedDcId shiftedDcId) {
+	Expects(isKeysDestroyer());
+
+	InvokeQueued(_instance, [=] {
+		LOG(("MTP Info: checkIfKeyWasDestroyed on destroying key %1, "
+			"assuming it is destroyed.").arg(shiftedDcId));
+		completedKeyDestroy(shiftedDcId);
+	});
+}
+
 void Instance::Private::performKeyDestroy(ShiftedDcId shiftedDcId) {
 	Expects(isKeysDestroyer());
 
-	_instance->send(MTPDestroy_auth_key(), rpcDone([this, shiftedDcId](const MTPDestroyAuthKeyRes &result) {
+	_instance->send(MTPDestroy_auth_key(), rpcDone([=](const MTPDestroyAuthKeyRes &result) {
 		switch (result.type()) {
 		case mtpc_destroy_auth_key_ok: LOG(("MTP Info: key %1 destroyed.").arg(shiftedDcId)); break;
 		case mtpc_destroy_auth_key_fail: {
@@ -1487,10 +1542,10 @@ void Instance::Private::performKeyDestroy(ShiftedDcId shiftedDcId) {
 		} break;
 		case mtpc_destroy_auth_key_none: LOG(("MTP Info: key %1 already destroyed.").arg(shiftedDcId)); break;
 		}
-		emit _instance->keyDestroyed(shiftedDcId);
-	}), rpcFail([this, shiftedDcId](const RPCError &error) {
+		_instance->keyWasPossiblyDestroyed(shiftedDcId);
+	}), rpcFail([=](const RPCError &error) {
 		LOG(("MTP Error: key %1 destruction resulted in error: %2").arg(shiftedDcId).arg(error.type()));
-		emit _instance->keyDestroyed(shiftedDcId);
+		_instance->keyWasPossiblyDestroyed(shiftedDcId);
 		return true;
 	}), shiftedDcId);
 }
@@ -1498,17 +1553,29 @@ void Instance::Private::performKeyDestroy(ShiftedDcId shiftedDcId) {
 void Instance::Private::completedKeyDestroy(ShiftedDcId shiftedDcId) {
 	Expects(isKeysDestroyer());
 
-	_dcenters.erase(shiftedDcId);
-	{
-		QWriteLocker lock(&_keysForWriteLock);
-		_keysForWrite.erase(shiftedDcId);
-	}
+	removeDc(shiftedDcId);
+	_keysForWrite.erase(shiftedDcId);
 	killSession(shiftedDcId);
 	if (_dcenters.empty()) {
-		emit _instance->allKeysDestroyed();
+		_allKeysDestroyed.fire({});
 	}
 }
 
+void Instance::Private::keyDestroyedOnServer(
+		ShiftedDcId shiftedDcId,
+		uint64 keyId) {
+	LOG(("Destroying key for dc: %1").arg(shiftedDcId));
+	if (const auto dc = findDc(BareDcId(shiftedDcId))) {
+		if (dc->destroyConfirmedForgottenKey(keyId)) {
+			LOG(("Key destroyed!"));
+			dcPersistentKeyChanged(BareDcId(shiftedDcId), nullptr);
+		} else {
+			LOG(("Key already is different."));
+		}
+	}
+	restart(shiftedDcId);
+}
+
 void Instance::Private::setUpdatesHandler(RPCDoneHandlerPtr onDone) {
 	_globalHandler.onDone = onDone;
 }
@@ -1538,12 +1605,27 @@ void Instance::Private::prepareToDestroy() {
 
 	requestCancellingDiscard();
 
-	for (auto &session : base::take(_sessions)) {
-		session.second->kill();
+	for (const auto &[shiftedDcId, session] : base::take(_sessions)) {
+		session->kill();
 	}
 	_mainSession = nullptr;
 
-	MustNotCreateSessions = true;
+	auto threads = std::vector<std::unique_ptr<QThread>>();
+	threads.push_back(base::take(_mainSessionThread));
+	threads.push_back(base::take(_otherSessionsThread));
+	for (auto &thread : base::take(_fileSessionThreads)) {
+		threads.push_back(std::move(thread));
+	}
+	for (const auto &thread : threads) {
+		if (thread) {
+			thread->quit();
+		}
+	}
+	for (const auto &thread : threads) {
+		if (thread) {
+			thread->wait();
+		}
+	}
 }
 
 Instance::Instance(not_null<DcOptions*> options, Mode mode, Config &&config)
@@ -1584,6 +1666,10 @@ QString Instance::langPackName() const {
 	return Lang::Current().langPackName();
 }
 
+rpl::producer<> Instance::allKeysDestroyed() const {
+	return _private->allKeysDestroyed();
+}
+
 void Instance::requestConfig() {
 	_private->requestConfig();
 }
@@ -1600,6 +1686,14 @@ void Instance::syncHttpUnixtime() {
 	_private->syncHttpUnixtime();
 }
 
+void Instance::restartedByTimeout(ShiftedDcId shiftedDcId) {
+	_private->restartedByTimeout(shiftedDcId);
+}
+
+rpl::producer<ShiftedDcId> Instance::restartsByTimeout() const {
+	return _private->restartsByTimeout();
+}
+
 void Instance::requestConfigIfOld() {
 	_private->requestConfigIfOld();
 }
@@ -1608,10 +1702,6 @@ void Instance::requestCDNConfig() {
 	_private->requestCDNConfig();
 }
 
-void Instance::connectionFinished(internal::Connection *connection) {
-	_private->connectionFinished(connection);
-}
-
 void Instance::restart() {
 	_private->restart();
 }
@@ -1652,16 +1742,22 @@ void Instance::reInitConnection(DcId dcId) {
 	_private->reInitConnection(dcId);
 }
 
-void Instance::logout(RPCDoneHandlerPtr onDone, RPCFailHandlerPtr onFail) {
-	_private->logout(onDone, onFail);
+void Instance::logout(Fn<void()> done) {
+	_private->logout(std::move(done));
+}
+
+void Instance::dcPersistentKeyChanged(
+		DcId dcId,
+		const AuthKeyPtr &persistentKey) {
+	_private->dcPersistentKeyChanged(dcId, persistentKey);
 }
 
-std::shared_ptr<internal::Dcenter> Instance::getDcById(ShiftedDcId shiftedDcId) {
-	return _private->getDcById(shiftedDcId);
+void Instance::dcTemporaryKeyChanged(DcId dcId) {
+	_private->dcTemporaryKeyChanged(dcId);
 }
 
-void Instance::setKeyForWrite(DcId dcId, const AuthKeyPtr &key) {
-	_private->setKeyForWrite(dcId, key);
+rpl::producer<DcId> Instance::dcTemporaryKeyChanged() const {
+	return _private->dcTemporaryKeyChanged();
 }
 
 AuthKeysList Instance::getKeysForWrite() const {
@@ -1688,11 +1784,6 @@ void Instance::unpaused() {
 	_private->unpaused();
 }
 
-void Instance::queueQuittingConnection(
-		std::unique_ptr<internal::Connection> &&connection) {
-	_private->queueQuittingConnection(std::move(connection));
-}
-
 void Instance::setUpdatesHandler(RPCDoneHandlerPtr onDone) {
 	_private->setUpdatesHandler(onDone);
 }
@@ -1721,10 +1812,6 @@ void Instance::onSessionReset(ShiftedDcId shiftedDcId) {
 	_private->onSessionReset(shiftedDcId);
 }
 
-void Instance::clearCallbacksDelayed(std::vector<RPCCallbackClear> &&ids) {
-	_private->clearCallbacksDelayed(std::move(ids));
-}
-
 void Instance::execCallback(mtpRequestId requestId, const mtpPrime *from, const mtpPrime *end) {
 	_private->execCallback(requestId, from, end);
 }
@@ -1745,16 +1832,17 @@ bool Instance::isKeysDestroyer() const {
 	return _private->isKeysDestroyer();
 }
 
-void Instance::scheduleKeyDestroy(ShiftedDcId shiftedDcId) {
-	_private->scheduleKeyDestroy(shiftedDcId);
+void Instance::keyWasPossiblyDestroyed(ShiftedDcId shiftedDcId) {
+	_private->keyWasPossiblyDestroyed(shiftedDcId);
 }
 
-void Instance::onKeyDestroyed(qint32 shiftedDcId) {
-	_private->completedKeyDestroy(shiftedDcId);
+void Instance::keyDestroyedOnServer(ShiftedDcId shiftedDcId, uint64 keyId) {
+	_private->keyDestroyedOnServer(shiftedDcId, keyId);
 }
+
 void Instance::sendRequest(
 		mtpRequestId requestId,
-		SecureRequest &&request,
+		SerializedRequest &&request,
 		RPCResponseHandler &&callbacks,
 		ShiftedDcId shiftedDcId,
 		crl::time msCanWait,
@@ -1771,8 +1859,7 @@ void Instance::sendRequest(
 }
 
 void Instance::sendAnything(ShiftedDcId shiftedDcId, crl::time msCanWait) {
-	const auto session = _private->getSession(shiftedDcId);
-	session->sendAnything(msCanWait);
+	_private->getSession(shiftedDcId)->sendAnything(msCanWait);
 }
 
 Instance::~Instance() {
diff --git a/Telegram/SourceFiles/mtproto/mtp_instance.h b/Telegram/SourceFiles/mtproto/mtp_instance.h
index c12d7432c..ed3797307 100644
--- a/Telegram/SourceFiles/mtproto/mtp_instance.h
+++ b/Telegram/SourceFiles/mtproto/mtp_instance.h
@@ -7,16 +7,18 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 */
 #pragma once
 
-#include <map>
-#include <set>
-#include "mtproto/rpc_sender.h"
+#include "mtproto/mtproto_rpc_sender.h"
+#include "mtproto/details/mtproto_serialized_request.h"
 
 namespace MTP {
-namespace internal {
+namespace details {
+
 class Dcenter;
 class Session;
-class Connection;
-} // namespace internal
+
+[[nodiscard]] int GetNextRequestId();
+
+} // namespace details
 
 class DcOptions;
 class AuthKey;
@@ -38,14 +40,16 @@ public:
 		QString deviceModel;
 		QString systemVersion;
 	};
+
 	enum class Mode {
 		Normal,
 		KeysDestroyer,
 	};
-	Instance(not_null<DcOptions*> options, Mode mode, Config &&config);
 
+	Instance(not_null<DcOptions*> options, Mode mode, Config &&config);
 	Instance(const Instance &other) = delete;
 	Instance &operator=(const Instance &other) = delete;
+	~Instance();
 
 	void resolveProxyDomain(const QString &host);
 	void setGoodProxyDomain(const QString &host, const QString &ip);
@@ -56,16 +60,73 @@ public:
 	[[nodiscard]] QString cloudLangCode() const;
 	[[nodiscard]] QString langPackName() const;
 
-	// Thread safe.
+	[[nodiscard]] rpl::producer<> allKeysDestroyed() const;
+
+	// Thread-safe.
 	[[nodiscard]] QString deviceModel() const;
 	[[nodiscard]] QString systemVersion() const;
 
-	void setKeyForWrite(DcId dcId, const AuthKeyPtr &key);
+	// Main thread.
+	void dcPersistentKeyChanged(DcId dcId, const AuthKeyPtr &persistentKey);
+	void dcTemporaryKeyChanged(DcId dcId);
+	[[nodiscard]] rpl::producer<DcId> dcTemporaryKeyChanged() const;
 	[[nodiscard]] AuthKeysList getKeysForWrite() const;
 	void addKeysForDestroy(AuthKeysList &&keys);
 
 	[[nodiscard]] not_null<DcOptions*> dcOptions();
 
+	void restart();
+	void restart(ShiftedDcId shiftedDcId);
+	int32 dcstate(ShiftedDcId shiftedDcId = 0);
+	QString dctransport(ShiftedDcId shiftedDcId = 0);
+	void ping();
+	void cancel(mtpRequestId requestId);
+	int32 state(mtpRequestId requestId); // < 0 means waiting for such count of ms
+
+	// Main thread.
+	void killSession(ShiftedDcId shiftedDcId);
+	void stopSession(ShiftedDcId shiftedDcId);
+	void reInitConnection(DcId dcId);
+	void logout(Fn<void()> done);
+
+	void unpaused();
+
+	void setUpdatesHandler(RPCDoneHandlerPtr onDone);
+	void setGlobalFailHandler(RPCFailHandlerPtr onFail);
+	void setStateChangedHandler(Fn<void(ShiftedDcId shiftedDcId, int32 state)> handler);
+	void setSessionResetHandler(Fn<void(ShiftedDcId shiftedDcId)> handler);
+	void clearGlobalHandlers();
+
+	void onStateChange(ShiftedDcId shiftedDcId, int32 state);
+	void onSessionReset(ShiftedDcId shiftedDcId);
+
+	void execCallback(mtpRequestId requestId, const mtpPrime *from, const mtpPrime *end);
+	bool hasCallbacks(mtpRequestId requestId);
+	void globalCallback(const mtpPrime *from, const mtpPrime *end);
+
+	// return true if need to clean request data
+	bool rpcErrorOccured(mtpRequestId requestId, const RPCFailHandlerPtr &onFail, const RPCError &err);
+
+	// Thread-safe.
+	bool isKeysDestroyer() const;
+	void keyWasPossiblyDestroyed(ShiftedDcId shiftedDcId);
+
+	// Main thread.
+	void keyDestroyedOnServer(ShiftedDcId shiftedDcId, uint64 keyId);
+
+	void requestConfig();
+	void requestConfigIfOld();
+	void requestCDNConfig();
+	void setUserPhone(const QString &phone);
+	void badConfigurationError();
+
+	void restartedByTimeout(ShiftedDcId shiftedDcId);
+	[[nodiscard]] rpl::producer<ShiftedDcId> restartsByTimeout() const;
+
+	void syncHttpUnixtime();
+
+	void sendAnything(ShiftedDcId shiftedDcId = 0, crl::time msCanWait = 0);
+
 	template <typename Request>
 	mtpRequestId send(
 			const Request &request,
@@ -73,10 +134,10 @@ public:
 			ShiftedDcId shiftedDcId = 0,
 			crl::time msCanWait = 0,
 			mtpRequestId afterRequestId = 0) {
-		const auto requestId = GetNextRequestId();
+		const auto requestId = details::GetNextRequestId();
 		sendSerialized(
 			requestId,
-			SecureRequest::Serialize(request),
+			details::SerializedRequest::Serialize(request),
 			std::move(callbacks),
 			shiftedDcId,
 			msCanWait,
@@ -104,10 +165,10 @@ public:
 	mtpRequestId sendProtocolMessage(
 			ShiftedDcId shiftedDcId,
 			const Request &request) {
-		const auto requestId = GetNextRequestId();
+		const auto requestId = details::GetNextRequestId();
 		sendRequest(
 			requestId,
-			SecureRequest::Serialize(request),
+			details::SerializedRequest::Serialize(request),
 			{},
 			shiftedDcId,
 			0,
@@ -118,7 +179,7 @@ public:
 
 	void sendSerialized(
 			mtpRequestId requestId,
-			SecureRequest &&request,
+			details::SerializedRequest &&request,
 			RPCResponseHandler &&callbacks,
 			ShiftedDcId shiftedDcId,
 			crl::time msCanWait,
@@ -134,76 +195,16 @@ public:
 			afterRequestId);
 	}
 
-	void sendAnything(ShiftedDcId shiftedDcId = 0, crl::time msCanWait = 0);
-
-	void restart();
-	void restart(ShiftedDcId shiftedDcId);
-	int32 dcstate(ShiftedDcId shiftedDcId = 0);
-	QString dctransport(ShiftedDcId shiftedDcId = 0);
-	void ping();
-	void cancel(mtpRequestId requestId);
-	int32 state(mtpRequestId requestId); // < 0 means waiting for such count of ms
-	void killSession(ShiftedDcId shiftedDcId);
-	void stopSession(ShiftedDcId shiftedDcId);
-	void reInitConnection(DcId dcId);
-	void logout(RPCDoneHandlerPtr onDone, RPCFailHandlerPtr onFail);
-
-	std::shared_ptr<internal::Dcenter> getDcById(ShiftedDcId shiftedDcId);
-	void unpaused();
-
-	void queueQuittingConnection(std::unique_ptr<internal::Connection> &&connection);
-
-	void setUpdatesHandler(RPCDoneHandlerPtr onDone);
-	void setGlobalFailHandler(RPCFailHandlerPtr onFail);
-	void setStateChangedHandler(Fn<void(ShiftedDcId shiftedDcId, int32 state)> handler);
-	void setSessionResetHandler(Fn<void(ShiftedDcId shiftedDcId)> handler);
-	void clearGlobalHandlers();
-
-	void onStateChange(ShiftedDcId shiftedDcId, int32 state);
-	void onSessionReset(ShiftedDcId shiftedDcId);
-
-	void clearCallbacksDelayed(std::vector<RPCCallbackClear> &&ids);
-
-	void execCallback(mtpRequestId requestId, const mtpPrime *from, const mtpPrime *end);
-	bool hasCallbacks(mtpRequestId requestId);
-	void globalCallback(const mtpPrime *from, const mtpPrime *end);
-
-	// return true if need to clean request data
-	bool rpcErrorOccured(mtpRequestId requestId, const RPCFailHandlerPtr &onFail, const RPCError &err);
-
-	bool isKeysDestroyer() const;
-	void scheduleKeyDestroy(ShiftedDcId shiftedDcId);
-
-	void requestConfig();
-	void requestConfigIfOld();
-	void requestCDNConfig();
-	void setUserPhone(const QString &phone);
-	void badConfigurationError();
-
-	void syncHttpUnixtime();
-
-	~Instance();
-
-public slots:
-	void connectionFinished(internal::Connection *connection);
-
 signals:
-	void configLoaded();
-	void cdnConfigLoaded();
-	void keyDestroyed(qint32 shiftedDcId);
-	void allKeysDestroyed();
 	void proxyDomainResolved(
 		QString host,
 		QStringList ips,
 		qint64 expireAt);
 
-private slots:
-	void onKeyDestroyed(qint32 shiftedDcId);
-
 private:
 	void sendRequest(
 		mtpRequestId requestId,
-		SecureRequest &&request,
+		details::SerializedRequest &&request,
 		RPCResponseHandler &&callbacks,
 		ShiftedDcId shiftedDcId,
 		crl::time msCanWait,
diff --git a/Telegram/SourceFiles/mtproto/mtproto_auth_key.cpp b/Telegram/SourceFiles/mtproto/mtproto_auth_key.cpp
new file mode 100644
index 000000000..c84d19a61
--- /dev/null
+++ b/Telegram/SourceFiles/mtproto/mtproto_auth_key.cpp
@@ -0,0 +1,189 @@
+/*
+This file is part of Telegram Desktop,
+the official desktop application for the Telegram messaging service.
+
+For license and copyright information please follow this link:
+https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+*/
+#include "mtproto/mtproto_auth_key.h"
+
+#include "base/openssl_help.h"
+
+#include <QtCore/QDataStream>
+
+namespace MTP {
+
+AuthKey::AuthKey(Type type, DcId dcId, const Data &data)
+: _type(type)
+, _dcId(dcId)
+, _key(data) {
+	countKeyId();
+	if (type == Type::Generated || type == Type::Temporary) {
+		_creationTime = crl::now();
+	}
+}
+
+AuthKey::AuthKey(const Data &data) : _type(Type::Local), _key(data) {
+	countKeyId();
+}
+
+AuthKey::Type AuthKey::type() const {
+	return _type;
+}
+
+int AuthKey::dcId() const {
+	return _dcId;
+}
+
+AuthKey::KeyId AuthKey::keyId() const {
+	return _keyId;
+}
+
+void AuthKey::prepareAES_oldmtp(const MTPint128 &msgKey, MTPint256 &aesKey, MTPint256 &aesIV, bool send) const {
+	uint32 x = send ? 0 : 8;
+
+	bytes::array<20> sha1_a, sha1_b, sha1_c, sha1_d;
+	bytes::array<16 + 32> data_a;
+	memcpy(data_a.data(), &msgKey, 16);
+	memcpy(data_a.data() + 16, _key.data() + x, 32);
+	openssl::Sha1To(sha1_a, data_a);
+
+	bytes::array<16 + 16 + 16> data_b;
+	memcpy(data_b.data(), _key.data() + 32 + x, 16);
+	memcpy(data_b.data() + 16, &msgKey, 16);
+	memcpy(data_b.data() + 32, _key.data() + 48 + x, 16);
+	openssl::Sha1To(sha1_b, data_b);
+
+	bytes::array<32 + 16> data_c;
+	memcpy(data_c.data(), _key.data() + 64 + x, 32);
+	memcpy(data_c.data() + 32, &msgKey, 16);
+	openssl::Sha1To(sha1_c, data_c);
+
+	bytes::array<16 + 32> data_d;
+	memcpy(data_d.data(), &msgKey, 16);
+	memcpy(data_d.data() + 16, _key.data() + 96 + x, 32);
+	openssl::Sha1To(sha1_d, data_d);
+
+	auto key = reinterpret_cast<bytes::type*>(&aesKey);
+	auto iv = reinterpret_cast<bytes::type*>(&aesIV);
+	memcpy(key, sha1_a.data(), 8);
+	memcpy(key + 8, sha1_b.data() + 8, 12);
+	memcpy(key + 8 + 12, sha1_c.data() + 4, 12);
+	memcpy(iv, sha1_a.data() + 8, 12);
+	memcpy(iv + 12, sha1_b.data(), 8);
+	memcpy(iv + 12 + 8, sha1_c.data() + 16, 4);
+	memcpy(iv + 12 + 8 + 4, sha1_d.data(), 8);
+}
+
+void AuthKey::prepareAES(const MTPint128 &msgKey, MTPint256 &aesKey, MTPint256 &aesIV, bool send) const {
+	uint32 x = send ? 0 : 8;
+
+	bytes::array<32> sha256_a, sha256_b;
+	bytes::array<16 + 36> data_a;
+	memcpy(data_a.data(), &msgKey, 16);
+	memcpy(data_a.data() + 16, _key.data() + x, 36);
+	openssl::Sha256To(sha256_a, data_a);
+
+	bytes::array<36 + 16> data_b;
+	memcpy(data_b.data(), _key.data() + 40 + x, 36);
+	memcpy(data_b.data() + 36, &msgKey, 16);
+	openssl::Sha256To(sha256_b, data_b);
+
+	auto key = reinterpret_cast<uchar*>(&aesKey);
+	auto iv = reinterpret_cast<uchar*>(&aesIV);
+	memcpy(key, sha256_a.data(), 8);
+	memcpy(key + 8, sha256_b.data() + 8, 16);
+	memcpy(key + 8 + 16, sha256_a.data() + 24, 8);
+	memcpy(iv, sha256_b.data(), 8);
+	memcpy(iv + 8, sha256_a.data() + 8, 16);
+	memcpy(iv + 8 + 16, sha256_b.data() + 24, 8);
+}
+
+const void *AuthKey::partForMsgKey(bool send) const {
+	return _key.data() + 88 + (send ? 0 : 8);
+}
+
+void AuthKey::write(QDataStream &to) const {
+	to.writeRawData(reinterpret_cast<const char*>(_key.data()), _key.size());
+}
+
+bytes::const_span AuthKey::data() const {
+	return _key;
+}
+
+bool AuthKey::equals(const std::shared_ptr<AuthKey> &other) const {
+	return other ? (_key == other->_key) : false;
+}
+
+crl::time AuthKey::creationTime() const {
+	return _creationTime;
+}
+
+TimeId AuthKey::expiresAt() const {
+	return _expiresAt;
+}
+
+void AuthKey::setExpiresAt(TimeId expiresAt) {
+	Expects(_type == Type::Temporary);
+
+	_expiresAt = expiresAt;
+}
+
+void AuthKey::FillData(Data &authKey, bytes::const_span computedAuthKey) {
+	auto computedAuthKeySize = computedAuthKey.size();
+	Assert(computedAuthKeySize <= kSize);
+	auto authKeyBytes = gsl::make_span(authKey);
+	if (computedAuthKeySize < kSize) {
+		bytes::set_with_const(authKeyBytes.subspan(0, kSize - computedAuthKeySize), gsl::byte());
+		bytes::copy(authKeyBytes.subspan(kSize - computedAuthKeySize), computedAuthKey);
+	} else {
+		bytes::copy(authKeyBytes, computedAuthKey);
+	}
+}
+
+void AuthKey::countKeyId() {
+	const auto hash = openssl::Sha1(_key);
+
+	// Lower 64 bits = 8 bytes of 20 byte SHA1 hash.
+	_keyId = *reinterpret_cast<const KeyId*>(hash.data() + 12);
+}
+
+void aesIgeEncryptRaw(const void *src, void *dst, uint32 len, const void *key, const void *iv) {
+	uchar aes_key[32], aes_iv[32];
+	memcpy(aes_key, key, 32);
+	memcpy(aes_iv, iv, 32);
+
+	AES_KEY aes;
+	AES_set_encrypt_key(aes_key, 256, &aes);
+	AES_ige_encrypt(static_cast<const uchar*>(src), static_cast<uchar*>(dst), len, &aes, aes_iv, AES_ENCRYPT);
+}
+
+void aesIgeDecryptRaw(const void *src, void *dst, uint32 len, const void *key, const void *iv) {
+	uchar aes_key[32], aes_iv[32];
+	memcpy(aes_key, key, 32);
+	memcpy(aes_iv, iv, 32);
+
+	AES_KEY aes;
+	AES_set_decrypt_key(aes_key, 256, &aes);
+	AES_ige_encrypt(static_cast<const uchar*>(src), static_cast<uchar*>(dst), len, &aes, aes_iv, AES_DECRYPT);
+}
+
+void aesCtrEncrypt(bytes::span data, const void *key, CTRState *state) {
+	AES_KEY aes;
+	AES_set_encrypt_key(static_cast<const uchar*>(key), 256, &aes);
+
+	static_assert(CTRState::IvecSize == AES_BLOCK_SIZE, "Wrong size of ctr ivec!");
+	static_assert(CTRState::EcountSize == AES_BLOCK_SIZE, "Wrong size of ctr ecount!");
+
+	CRYPTO_ctr128_encrypt(
+		reinterpret_cast<const uchar*>(data.data()),
+		reinterpret_cast<uchar*>(data.data()),
+		data.size(),
+		&aes,
+		state->ivec,
+		state->ecount,
+		&state->num,
+		(block128_f)AES_encrypt);
+}
+
+} // namespace MTP
diff --git a/Telegram/SourceFiles/mtproto/auth_key.h b/Telegram/SourceFiles/mtproto/mtproto_auth_key.h
similarity index 73%
rename from Telegram/SourceFiles/mtproto/auth_key.h
rename to Telegram/SourceFiles/mtproto/mtproto_auth_key.h
index cf8f7169e..31d0e3db3 100644
--- a/Telegram/SourceFiles/mtproto/auth_key.h
+++ b/Telegram/SourceFiles/mtproto/mtproto_auth_key.h
@@ -7,9 +7,9 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 */
 #pragma once
 
+#include "base/bytes.h"
 #include <array>
 #include <memory>
-#include "base/bytes.h"
 
 namespace MTP {
 
@@ -21,73 +21,44 @@ public:
 
 	enum class Type {
 		Generated,
+		Temporary,
 		ReadFromFile,
 		Local,
 	};
-	AuthKey(Type type, DcId dcId, const Data &data) : _type(type), _dcId(dcId), _key(data) {
-		countKeyId();
-	}
-	AuthKey(const Data &data) : _type(Type::Local), _key(data) {
-		countKeyId();
-	}
+	AuthKey(Type type, DcId dcId, const Data &data);
+	explicit AuthKey(const Data &data);
 
 	AuthKey(const AuthKey &other) = delete;
 	AuthKey &operator=(const AuthKey &other) = delete;
 
-	Type type() const {
-		return _type;
-	}
-
-	int dcId() const {
-		return _dcId;
-	}
-
-	KeyId keyId() const {
-		return _keyId;
-	}
+	[[nodiscard]] Type type() const;
+	[[nodiscard]] int dcId() const;
+	[[nodiscard]] KeyId keyId() const;
 
 	void prepareAES_oldmtp(const MTPint128 &msgKey, MTPint256 &aesKey, MTPint256 &aesIV, bool send) const;
 	void prepareAES(const MTPint128 &msgKey, MTPint256 &aesKey, MTPint256 &aesIV, bool send) const;
 
-	const void *partForMsgKey(bool send) const {
-		return _key.data() + 88 + (send ? 0 : 8);
-	}
-
-	void write(QDataStream &to) const {
-		to.writeRawData(reinterpret_cast<const char*>(_key.data()), _key.size());
-	}
-	bytes::const_span data() const {
-		return _key;
-	}
-
-	bool equals(const std::shared_ptr<AuthKey> &other) const {
-		return other ? (_key == other->_key) : false;
-	}
-
-	static void FillData(Data &authKey, bytes::const_span computedAuthKey) {
-		auto computedAuthKeySize = computedAuthKey.size();
-		Assert(computedAuthKeySize <= kSize);
-		auto authKeyBytes = gsl::make_span(authKey);
-		if (computedAuthKeySize < kSize) {
-			bytes::set_with_const(authKeyBytes.subspan(0, kSize - computedAuthKeySize), gsl::byte());
-			bytes::copy(authKeyBytes.subspan(kSize - computedAuthKeySize), computedAuthKey);
-		} else {
-			bytes::copy(authKeyBytes, computedAuthKey);
-		}
-	}
+	[[nodiscard]] const void *partForMsgKey(bool send) const;
 
-private:
-	void countKeyId() {
-		auto sha1 = hashSha1(_key.data(), _key.size());
+	void write(QDataStream &to) const;
+	[[nodiscard]] bytes::const_span data() const;
+	[[nodiscard]] bool equals(const std::shared_ptr<AuthKey> &other) const;
+
+	[[nodiscard]] crl::time creationTime() const; // > 0 if known.
+	[[nodiscard]] TimeId expiresAt() const;
+	void setExpiresAt(TimeId expiresAt);
 
-		// Lower 64 bits = 8 bytes of 20 byte SHA1 hash.
-		_keyId = *reinterpret_cast<KeyId*>(sha1.data() + 12);
-	}
+	static void FillData(Data &authKey, bytes::const_span computedAuthKey);
+
+private:
+	void countKeyId();
 
 	Type _type = Type::Generated;
 	DcId _dcId = 0;
 	Data _key = { { gsl::byte{} } };
 	KeyId _keyId = 0;
+	crl::time _creationTime = 0;
+	TimeId _expiresAt = 0;
 
 };
 
diff --git a/Telegram/SourceFiles/mtproto/concurrent_sender.cpp b/Telegram/SourceFiles/mtproto/mtproto_concurrent_sender.cpp
similarity index 96%
rename from Telegram/SourceFiles/mtproto/concurrent_sender.cpp
rename to Telegram/SourceFiles/mtproto/mtproto_concurrent_sender.cpp
index a17e7031f..b211cda30 100644
--- a/Telegram/SourceFiles/mtproto/concurrent_sender.cpp
+++ b/Telegram/SourceFiles/mtproto/mtproto_concurrent_sender.cpp
@@ -5,10 +5,11 @@ the official desktop application for the Telegram messaging service.
 For license and copyright information please follow this link:
 https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 */
-#include "mtproto/concurrent_sender.h"
+#include "mtproto/mtproto_concurrent_sender.h"
 
 #include "mtproto/mtp_instance.h"
-#include "mtproto/rpc_sender.h"
+#include "mtproto/mtproto_rpc_sender.h"
+#include "mtproto/facade.h"
 
 namespace MTP {
 
@@ -110,7 +111,7 @@ auto ConcurrentSender::with_instance(Method &&method)
 
 ConcurrentSender::RequestBuilder::RequestBuilder(
 	not_null<ConcurrentSender*> sender,
-	SecureRequest &&serialized) noexcept
+	details::SerializedRequest &&serialized) noexcept
 : _sender(sender)
 , _serialized(std::move(serialized)) {
 }
@@ -134,7 +135,7 @@ void ConcurrentSender::RequestBuilder::setAfter(
 }
 
 mtpRequestId ConcurrentSender::RequestBuilder::send() {
-	const auto requestId = GetNextRequestId();
+	const auto requestId = details::GetNextRequestId();
 	const auto dcId = _dcId;
 	const auto msCanWait = _canWait;
 	const auto afterRequestId = _afterRequestId;
diff --git a/Telegram/SourceFiles/mtproto/concurrent_sender.h b/Telegram/SourceFiles/mtproto/mtproto_concurrent_sender.h
similarity index 98%
rename from Telegram/SourceFiles/mtproto/concurrent_sender.h
rename to Telegram/SourceFiles/mtproto/mtproto_concurrent_sender.h
index 5929f800c..74c1c4482 100644
--- a/Telegram/SourceFiles/mtproto/concurrent_sender.h
+++ b/Telegram/SourceFiles/mtproto/mtproto_concurrent_sender.h
@@ -7,11 +7,13 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 */
 #pragma once
 
-#include <rpl/details/callable.h>
 #include "base/bytes.h"
 #include "base/weak_ptr.h"
 #include "base/flat_map.h"
 #include "mtproto/core_types.h"
+#include "mtproto/details/mtproto_serialized_request.h"
+
+#include <rpl/details/callable.h>
 
 #ifndef _DEBUG
 #define MTP_SENDER_USE_GENERIC_HANDLERS
@@ -61,7 +63,7 @@ class ConcurrentSender : public base::has_weak_ptr {
 	protected:
 		RequestBuilder(
 			not_null<ConcurrentSender*> sender,
-			SecureRequest &&serialized) noexcept;
+			details::SerializedRequest &&serialized) noexcept;
 
 		void setToDC(ShiftedDcId dcId) noexcept;
 		void setCanWait(crl::time ms) noexcept;
@@ -74,7 +76,7 @@ class ConcurrentSender : public base::has_weak_ptr {
 
 	private:
 		not_null<ConcurrentSender*> _sender;
-		SecureRequest _serialized;
+		details::SerializedRequest _serialized;
 		ShiftedDcId _dcId = 0;
 		crl::time _canWait = 0;
 
@@ -224,8 +226,8 @@ void ConcurrentSender::RequestBuilder::setFailHandler(
 template <typename Request>
 ConcurrentSender::SpecificRequestBuilder<Request>::SpecificRequestBuilder(
 	not_null<ConcurrentSender*> sender,
-	Request &&request
-) noexcept : RequestBuilder(sender, SecureRequest::Serialize(request)) {
+	Request &&request) noexcept
+: RequestBuilder(sender, details::SerializedRequest::Serialize(request)) {
 }
 
 template <typename Request>
diff --git a/Telegram/SourceFiles/mtproto/mtproto_dh_utils.cpp b/Telegram/SourceFiles/mtproto/mtproto_dh_utils.cpp
new file mode 100644
index 000000000..9c136eb1d
--- /dev/null
+++ b/Telegram/SourceFiles/mtproto/mtproto_dh_utils.cpp
@@ -0,0 +1,173 @@
+/*
+This file is part of Telegram Desktop,
+the official desktop application for the Telegram messaging service.
+
+For license and copyright information please follow this link:
+https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+*/
+#include "mtproto/mtproto_dh_utils.h"
+
+namespace MTP {
+namespace {
+
+constexpr auto kMaxModExpSize = 256;
+
+bool IsPrimeAndGoodCheck(const openssl::BigNum &prime, int g) {
+	constexpr auto kGoodPrimeBitsCount = 2048;
+
+	if (prime.failed()
+		|| prime.isNegative()
+		|| prime.bitsSize() != kGoodPrimeBitsCount) {
+		LOG(("MTP Error: Bad prime bits count %1, expected %2."
+			).arg(prime.bitsSize()
+			).arg(kGoodPrimeBitsCount));
+		return false;
+	}
+
+	const auto context = openssl::Context();
+	if (!prime.isPrime(context)) {
+		LOG(("MTP Error: Bad prime."));
+		return false;
+	}
+
+	switch (g) {
+	case 2: {
+		const auto mod8 = prime.countModWord(8);
+		if (mod8 != 7) {
+			LOG(("BigNum PT Error: bad g value: %1, mod8: %2").arg(g).arg(mod8));
+			return false;
+		}
+	} break;
+	case 3: {
+		const auto mod3 = prime.countModWord(3);
+		if (mod3 != 2) {
+			LOG(("BigNum PT Error: bad g value: %1, mod3: %2").arg(g).arg(mod3));
+			return false;
+		}
+	} break;
+	case 4: break;
+	case 5: {
+		const auto mod5 = prime.countModWord(5);
+		if (mod5 != 1 && mod5 != 4) {
+			LOG(("BigNum PT Error: bad g value: %1, mod5: %2").arg(g).arg(mod5));
+			return false;
+		}
+	} break;
+	case 6: {
+		const auto mod24 = prime.countModWord(24);
+		if (mod24 != 19 && mod24 != 23) {
+			LOG(("BigNum PT Error: bad g value: %1, mod24: %2").arg(g).arg(mod24));
+			return false;
+		}
+	} break;
+	case 7: {
+		const auto mod7 = prime.countModWord(7);
+		if (mod7 != 3 && mod7 != 5 && mod7 != 6) {
+			LOG(("BigNum PT Error: bad g value: %1, mod7: %2").arg(g).arg(mod7));
+			return false;
+		}
+	} break;
+	default: {
+		LOG(("BigNum PT Error: bad g value: %1").arg(g));
+		return false;
+	} break;
+	}
+
+	if (!openssl::BigNum(prime).subWord(1).divWord(2).isPrime(context)) {
+		LOG(("MTP Error: Bad (prime - 1) / 2."));
+		return false;
+	}
+
+	return true;
+}
+
+} // namespace
+
+bool IsGoodModExpFirst(
+		const openssl::BigNum &modexp,
+		const openssl::BigNum &prime) {
+	const auto diff = openssl::BigNum::Sub(prime, modexp);
+	if (modexp.failed() || prime.failed() || diff.failed()) {
+		return false;
+	}
+	constexpr auto kMinDiffBitsCount = 2048 - 64;
+	if (diff.isNegative()
+		|| diff.bitsSize() < kMinDiffBitsCount
+		|| modexp.bitsSize() < kMinDiffBitsCount
+		|| modexp.bytesSize() > kMaxModExpSize) {
+		return false;
+	}
+	return true;
+}
+
+bool IsPrimeAndGood(bytes::const_span primeBytes, int g) {
+	static constexpr unsigned char GoodPrime[] = {
+		0xC7, 0x1C, 0xAE, 0xB9, 0xC6, 0xB1, 0xC9, 0x04, 0x8E, 0x6C, 0x52, 0x2F, 0x70, 0xF1, 0x3F, 0x73,
+		0x98, 0x0D, 0x40, 0x23, 0x8E, 0x3E, 0x21, 0xC1, 0x49, 0x34, 0xD0, 0x37, 0x56, 0x3D, 0x93, 0x0F,
+		0x48, 0x19, 0x8A, 0x0A, 0xA7, 0xC1, 0x40, 0x58, 0x22, 0x94, 0x93, 0xD2, 0x25, 0x30, 0xF4, 0xDB,
+		0xFA, 0x33, 0x6F, 0x6E, 0x0A, 0xC9, 0x25, 0x13, 0x95, 0x43, 0xAE, 0xD4, 0x4C, 0xCE, 0x7C, 0x37,
+		0x20, 0xFD, 0x51, 0xF6, 0x94, 0x58, 0x70, 0x5A, 0xC6, 0x8C, 0xD4, 0xFE, 0x6B, 0x6B, 0x13, 0xAB,
+		0xDC, 0x97, 0x46, 0x51, 0x29, 0x69, 0x32, 0x84, 0x54, 0xF1, 0x8F, 0xAF, 0x8C, 0x59, 0x5F, 0x64,
+		0x24, 0x77, 0xFE, 0x96, 0xBB, 0x2A, 0x94, 0x1D, 0x5B, 0xCD, 0x1D, 0x4A, 0xC8, 0xCC, 0x49, 0x88,
+		0x07, 0x08, 0xFA, 0x9B, 0x37, 0x8E, 0x3C, 0x4F, 0x3A, 0x90, 0x60, 0xBE, 0xE6, 0x7C, 0xF9, 0xA4,
+		0xA4, 0xA6, 0x95, 0x81, 0x10, 0x51, 0x90, 0x7E, 0x16, 0x27, 0x53, 0xB5, 0x6B, 0x0F, 0x6B, 0x41,
+		0x0D, 0xBA, 0x74, 0xD8, 0xA8, 0x4B, 0x2A, 0x14, 0xB3, 0x14, 0x4E, 0x0E, 0xF1, 0x28, 0x47, 0x54,
+		0xFD, 0x17, 0xED, 0x95, 0x0D, 0x59, 0x65, 0xB4, 0xB9, 0xDD, 0x46, 0x58, 0x2D, 0xB1, 0x17, 0x8D,
+		0x16, 0x9C, 0x6B, 0xC4, 0x65, 0xB0, 0xD6, 0xFF, 0x9C, 0xA3, 0x92, 0x8F, 0xEF, 0x5B, 0x9A, 0xE4,
+		0xE4, 0x18, 0xFC, 0x15, 0xE8, 0x3E, 0xBE, 0xA0, 0xF8, 0x7F, 0xA9, 0xFF, 0x5E, 0xED, 0x70, 0x05,
+		0x0D, 0xED, 0x28, 0x49, 0xF4, 0x7B, 0xF9, 0x59, 0xD9, 0x56, 0x85, 0x0C, 0xE9, 0x29, 0x85, 0x1F,
+		0x0D, 0x81, 0x15, 0xF6, 0x35, 0xB1, 0x05, 0xEE, 0x2E, 0x4E, 0x15, 0xD0, 0x4B, 0x24, 0x54, 0xBF,
+		0x6F, 0x4F, 0xAD, 0xF0, 0x34, 0xB1, 0x04, 0x03, 0x11, 0x9C, 0xD8, 0xE3, 0xB9, 0x2F, 0xCC, 0x5B };
+
+	if (!bytes::compare(bytes::make_span(GoodPrime), primeBytes)) {
+		if (g == 3 || g == 4 || g == 5 || g == 7) {
+			return true;
+		}
+	}
+
+	return IsPrimeAndGoodCheck(openssl::BigNum(primeBytes), g);
+}
+
+ModExpFirst CreateModExp(
+		int g,
+		bytes::const_span primeBytes,
+		bytes::const_span randomSeed) {
+	Expects(randomSeed.size() == ModExpFirst::kRandomPowerSize);
+
+	using namespace openssl;
+
+	BigNum prime(primeBytes);
+	auto result = ModExpFirst();
+	result.randomPower.resize(ModExpFirst::kRandomPowerSize);
+	while (true) {
+		bytes::set_random(result.randomPower);
+		for (auto i = 0; i != ModExpFirst::kRandomPowerSize; ++i) {
+			result.randomPower[i] ^= randomSeed[i];
+		}
+		const auto modexp = BigNum::ModExp(
+			BigNum(g),
+			BigNum(result.randomPower),
+			prime);
+		if (IsGoodModExpFirst(modexp, prime)) {
+			result.modexp = modexp.getBytes();
+			return result;
+		}
+	}
+}
+
+bytes::vector CreateAuthKey(
+		bytes::const_span firstBytes,
+		bytes::const_span randomBytes,
+		bytes::const_span primeBytes) {
+	using openssl::BigNum;
+
+	const auto first = BigNum(firstBytes);
+	const auto prime = BigNum(primeBytes);
+	if (!IsGoodModExpFirst(first, prime)) {
+		LOG(("AuthKey Error: Bad first prime in CreateAuthKey()."));
+		return {};
+	}
+	return BigNum::ModExp(first, BigNum(randomBytes), prime).getBytes();
+}
+
+} // namespace MTP
diff --git a/Telegram/SourceFiles/mtproto/mtproto_dh_utils.h b/Telegram/SourceFiles/mtproto/mtproto_dh_utils.h
new file mode 100644
index 000000000..2860bf02c
--- /dev/null
+++ b/Telegram/SourceFiles/mtproto/mtproto_dh_utils.h
@@ -0,0 +1,35 @@
+/*
+This file is part of Telegram Desktop,
+the official desktop application for the Telegram messaging service.
+
+For license and copyright information please follow this link:
+https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+*/
+#pragma once
+
+#include "base/bytes.h"
+#include "base/openssl_help.h"
+
+namespace MTP {
+
+struct ModExpFirst {
+	static constexpr auto kRandomPowerSize = 256;
+
+	bytes::vector modexp;
+	bytes::vector randomPower;
+};
+
+[[nodiscard]] bool IsPrimeAndGood(bytes::const_span primeBytes, int g);
+[[nodiscard]] bool IsGoodModExpFirst(
+	const openssl::BigNum &modexp,
+	const openssl::BigNum &prime);
+[[nodiscard]] ModExpFirst CreateModExp(
+	int g,
+	bytes::const_span primeBytes,
+	bytes::const_span randomSeed);
+[[nodiscard]] bytes::vector CreateAuthKey(
+	bytes::const_span firstBytes,
+	bytes::const_span randomBytes,
+	bytes::const_span primeBytes);
+
+} // namespace MTP
diff --git a/Telegram/SourceFiles/mtproto/mtp_pch.cpp b/Telegram/SourceFiles/mtproto/mtproto_pch.cpp
similarity index 89%
rename from Telegram/SourceFiles/mtproto/mtp_pch.cpp
rename to Telegram/SourceFiles/mtproto/mtproto_pch.cpp
index 3194b80c1..bdad25fc3 100644
--- a/Telegram/SourceFiles/mtproto/mtp_pch.cpp
+++ b/Telegram/SourceFiles/mtproto/mtproto_pch.cpp
@@ -5,6 +5,6 @@ the official desktop application for the Telegram messaging service.
 For license and copyright information please follow this link:
 https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 */
-#include "mtproto/mtp_pch.h"
+#include "mtproto/mtproto_pch.h"
 
 // Precompiled header helper.
diff --git a/Telegram/SourceFiles/mtproto/mtp_pch.h b/Telegram/SourceFiles/mtproto/mtproto_pch.h
similarity index 100%
rename from Telegram/SourceFiles/mtproto/mtp_pch.h
rename to Telegram/SourceFiles/mtproto/mtproto_pch.h
diff --git a/Telegram/SourceFiles/mtproto/mtproto_proxy_data.cpp b/Telegram/SourceFiles/mtproto/mtproto_proxy_data.cpp
new file mode 100644
index 000000000..cb401a589
--- /dev/null
+++ b/Telegram/SourceFiles/mtproto/mtproto_proxy_data.cpp
@@ -0,0 +1,238 @@
+/*
+This file is part of Telegram Desktop,
+the official desktop application for the Telegram messaging service.
+
+For license and copyright information please follow this link:
+https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+*/
+#include "mtproto/mtproto_proxy_data.h"
+
+#include "base/qthelp_url.h"
+
+namespace MTP {
+namespace {
+
+[[nodiscard]] bool IsHexMtprotoPassword(const QString &password) {
+	const auto size = password.size();
+	if (size < 32 || size % 2 == 1) {
+		return false;
+	}
+	const auto bad = [](QChar ch) {
+		const auto code = ch.unicode();
+		return (code < 'a' || code > 'f')
+			&& (code < 'A' || code > 'F')
+			&& (code < '0' || code > '9');
+	};
+	const auto i = std::find_if(password.begin(), password.end(), bad);
+	return (i == password.end());
+}
+
+[[nodiscard]] ProxyData::Status HexMtprotoPasswordStatus(
+		const QString &password) {
+	const auto size = password.size() / 2;
+	const auto valid = (size == 16)
+		|| (size == 17 && (password[0] == 'd') && (password[1] == 'd'))
+		|| (size >= 21 && (password[0] == 'e') && (password[1] == 'e'));
+	if (valid) {
+		return ProxyData::Status::Valid;
+	} else if (size < 16) {
+		return ProxyData::Status::Invalid;
+	}
+	return ProxyData::Status::Unsupported;
+}
+
+[[nodiscard]] bytes::vector SecretFromHexMtprotoPassword(
+		const QString &password) {
+	Expects(password.size() % 2 == 0);
+
+	const auto size = password.size() / 2;
+	const auto fromHex = [](QChar ch) -> int {
+		const auto code = int(ch.unicode());
+		if (code >= '0' && code <= '9') {
+			return (code - '0');
+		} else if (code >= 'A' && code <= 'F') {
+			return 10 + (code - 'A');
+		} else if (ch >= 'a' && ch <= 'f') {
+			return 10 + (code - 'a');
+		}
+		Unexpected("Code in ProxyData fromHex.");
+	};
+	auto result = bytes::vector(size);
+	for (auto i = 0; i != size; ++i) {
+		const auto high = fromHex(password[2 * i]);
+		const auto low = fromHex(password[2 * i + 1]);
+		if (high < 0 || low < 0) {
+			return {};
+		}
+		result[i] = static_cast<bytes::type>(high * 16 + low);
+	}
+	return result;
+}
+
+[[nodiscard]] QStringRef Base64UrlInner(const QString &password) {
+	Expects(password.size() > 2);
+
+	// Skip one or two '=' at the end of the string.
+	return password.midRef(0, [&] {
+		auto result = password.size();
+		for (auto i = 0; i != 2; ++i) {
+			const auto prev = result - 1;
+			if (password[prev] != '=') {
+				break;
+			}
+			result = prev;
+		}
+		return result;
+	}());
+}
+
+[[nodiscard]] bool IsBase64UrlMtprotoPassword(const QString &password) {
+	const auto size = password.size();
+	if (size < 22 || size % 4 == 1) {
+		return false;
+	}
+	const auto bad = [](QChar ch) {
+		const auto code = ch.unicode();
+		return (code < 'a' || code > 'z')
+			&& (code < 'A' || code > 'Z')
+			&& (code < '0' || code > '9')
+			&& (code != '_')
+			&& (code != '-');
+	};
+	const auto inner = Base64UrlInner(password);
+	const auto begin = inner.data();
+	const auto end = begin + inner.size();
+	return (std::find_if(begin, end, bad) == end);
+}
+
+[[nodiscard]] ProxyData::Status Base64UrlMtprotoPasswordStatus(
+		const QString &password) {
+	const auto inner = Base64UrlInner(password);
+	const auto size = (inner.size() * 3) / 4;
+	const auto valid = (size == 16)
+		|| (size == 17
+			&& (password[0] == '3')
+			&& ((password[1] >= 'Q' && password[1] <= 'Z')
+				|| (password[1] >= 'a' && password[1] <= 'f')))
+		|| (size >= 21
+			&& (password[0] == '7')
+			&& (password[1] >= 'g')
+			&& (password[1] <= 'v'));
+	if (size < 16) {
+		return ProxyData::Status::Invalid;
+	} else if (valid) {
+		return ProxyData::Status::Valid;
+	}
+	return ProxyData::Status::Unsupported;
+}
+
+[[nodiscard]] bytes::vector SecretFromBase64UrlMtprotoPassword(
+		const QString &password) {
+	const auto result = QByteArray::fromBase64(
+		password.toLatin1(),
+		QByteArray::Base64UrlEncoding);
+	return bytes::make_vector(bytes::make_span(result));
+}
+
+} // namespace
+
+bool ProxyData::valid() const {
+	return status() == Status::Valid;
+}
+
+ProxyData::Status ProxyData::status() const {
+	if (type == Type::None || host.isEmpty() || !port) {
+		return Status::Invalid;
+	} else if (type == Type::Mtproto) {
+		return MtprotoPasswordStatus(password);
+	}
+	return Status::Valid;
+}
+
+bool ProxyData::supportsCalls() const {
+	return (type == Type::Socks5);
+}
+
+bool ProxyData::tryCustomResolve() const {
+	return (type == Type::Socks5 || type == Type::Mtproto)
+		&& !qthelp::is_ipv6(host)
+		&& !QRegularExpression(
+			QStringLiteral("^\\d+\\.\\d+\\.\\d+\\.\\d+$")
+		).match(host).hasMatch();
+}
+
+bytes::vector ProxyData::secretFromMtprotoPassword() const {
+	Expects(type == Type::Mtproto);
+
+	if (IsHexMtprotoPassword(password)) {
+		return SecretFromHexMtprotoPassword(password);
+	} else if (IsBase64UrlMtprotoPassword(password)) {
+		return SecretFromBase64UrlMtprotoPassword(password);
+	}
+	return {};
+}
+
+ProxyData::operator bool() const {
+	return valid();
+}
+
+bool ProxyData::operator==(const ProxyData &other) const {
+	if (!valid()) {
+		return !other.valid();
+	}
+	return (type == other.type)
+		&& (host == other.host)
+		&& (port == other.port)
+		&& (user == other.user)
+		&& (password == other.password);
+}
+
+bool ProxyData::operator!=(const ProxyData &other) const {
+	return !(*this == other);
+}
+
+bool ProxyData::ValidMtprotoPassword(const QString &password) {
+	return MtprotoPasswordStatus(password) == Status::Valid;
+}
+
+ProxyData::Status ProxyData::MtprotoPasswordStatus(const QString &password) {
+	if (IsHexMtprotoPassword(password)) {
+		return HexMtprotoPasswordStatus(password);
+	} else if (IsBase64UrlMtprotoPassword(password)) {
+		return Base64UrlMtprotoPasswordStatus(password);
+	}
+	return Status::Invalid;
+}
+
+ProxyData ToDirectIpProxy(const ProxyData &proxy, int ipIndex) {
+	if (!proxy.tryCustomResolve()
+		|| ipIndex < 0
+		|| ipIndex >= proxy.resolvedIPs.size()) {
+		return proxy;
+	}
+	return {
+		proxy.type,
+		proxy.resolvedIPs[ipIndex],
+		proxy.port,
+		proxy.user,
+		proxy.password
+	};
+}
+
+QNetworkProxy ToNetworkProxy(const ProxyData &proxy) {
+	if (proxy.type == ProxyData::Type::None) {
+		return QNetworkProxy::DefaultProxy;
+	} else if (proxy.type == ProxyData::Type::Mtproto) {
+		return QNetworkProxy::NoProxy;
+	}
+	return QNetworkProxy(
+		(proxy.type == ProxyData::Type::Socks5
+			? QNetworkProxy::Socks5Proxy
+			: QNetworkProxy::HttpProxy),
+		proxy.host,
+		proxy.port,
+		proxy.user,
+		proxy.password);
+}
+
+} // namespace MTP
diff --git a/Telegram/SourceFiles/mtproto/mtproto_proxy_data.h b/Telegram/SourceFiles/mtproto/mtproto_proxy_data.h
new file mode 100644
index 000000000..52acf6661
--- /dev/null
+++ b/Telegram/SourceFiles/mtproto/mtproto_proxy_data.h
@@ -0,0 +1,58 @@
+/*
+This file is part of Telegram Desktop,
+the official desktop application for the Telegram messaging service.
+
+For license and copyright information please follow this link:
+https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+*/
+#pragma once
+
+namespace MTP {
+
+struct ProxyData {
+	enum class Settings {
+		System,
+		Enabled,
+		Disabled,
+	};
+	enum class Type {
+		None,
+		Socks5,
+		Http,
+		Mtproto,
+	};
+	enum class Status {
+		Valid,
+		Unsupported,
+		Invalid,
+	};
+
+	Type type = Type::None;
+	QString host;
+	uint32 port = 0;
+	QString user, password;
+
+	std::vector<QString> resolvedIPs;
+	crl::time resolvedExpireAt = 0;
+
+	[[nodiscard]] bool valid() const;
+	[[nodiscard]] Status status() const;
+	[[nodiscard]] bool supportsCalls() const;
+	[[nodiscard]] bool tryCustomResolve() const;
+	[[nodiscard]] bytes::vector secretFromMtprotoPassword() const;
+	[[nodiscard]] explicit operator bool() const;
+	[[nodiscard]] bool operator==(const ProxyData &other) const;
+	[[nodiscard]] bool operator!=(const ProxyData &other) const;
+
+	[[nodiscard]] static bool ValidMtprotoPassword(const QString &password);
+	[[nodiscard]] static Status MtprotoPasswordStatus(
+		const QString &password);
+
+};
+
+[[nodiscard]] ProxyData ToDirectIpProxy(
+	const ProxyData &proxy,
+	int ipIndex = 0);
+[[nodiscard]] QNetworkProxy ToNetworkProxy(const ProxyData &proxy);
+
+} // namespace MTP
diff --git a/Telegram/SourceFiles/mtproto/rpc_sender.cpp b/Telegram/SourceFiles/mtproto/mtproto_rpc_sender.cpp
similarity index 78%
rename from Telegram/SourceFiles/mtproto/rpc_sender.cpp
rename to Telegram/SourceFiles/mtproto/mtproto_rpc_sender.cpp
index a3859ec4f..b723fd292 100644
--- a/Telegram/SourceFiles/mtproto/rpc_sender.cpp
+++ b/Telegram/SourceFiles/mtproto/mtproto_rpc_sender.cpp
@@ -5,25 +5,28 @@ the official desktop application for the Telegram messaging service.
 For license and copyright information please follow this link:
 https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 */
-#include "mtproto/rpc_sender.h"
+#include "mtproto/mtproto_rpc_sender.h"
+
+#include <QtCore/QRegularExpression>
 
 RPCError::RPCError(const MTPrpcError &error)
 : _code(error.c_rpc_error().verror_code().v) {
 	QString text = qs(error.c_rpc_error().verror_message());
 	if (_code < 0 || _code >= 500) {
-		_type = qsl("INTERNAL_SERVER_ERROR");
+		_type = "INTERNAL_SERVER_ERROR";
 		_description = text;
 	} else {
 		const auto expression = QRegularExpression(
 			"^([A-Z0-9_]+)(: .*)?$",
-			reMultiline);
+			(QRegularExpression::DotMatchesEverythingOption
+				| QRegularExpression::MultilineOption));
 		const auto match = expression.match(text);
 		if (match.hasMatch()) {
 			_type = match.captured(1);
 			_description = match.captured(2).mid(2);
 		} else {
-			_type = qsl("CLIENT_BAD_RPC_ERROR");
-			_description = qsl("Bad rpc error received, text = '") + text + '\'';
+			_type = "CLIENT_BAD_RPC_ERROR";
+			_description = "Bad rpc error received, text = '" + text + '\'';
 		}
 	}
 }
diff --git a/Telegram/SourceFiles/mtproto/rpc_sender.h b/Telegram/SourceFiles/mtproto/mtproto_rpc_sender.h
similarity index 99%
rename from Telegram/SourceFiles/mtproto/rpc_sender.h
rename to Telegram/SourceFiles/mtproto/mtproto_rpc_sender.h
index 068bd4d32..c3ae32324 100644
--- a/Telegram/SourceFiles/mtproto/rpc_sender.h
+++ b/Telegram/SourceFiles/mtproto/mtproto_rpc_sender.h
@@ -8,8 +8,6 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #pragma once
 
 #include "base/flat_set.h"
-#include "core/utils.h"
-#include <rpl/details/callable.h>
 
 class RPCError {
 public:
@@ -261,13 +259,13 @@ private:
 };
 
 struct RPCCallbackClear {
-	RPCCallbackClear(mtpRequestId id , int32 code = RPCError::NoError)
+	RPCCallbackClear(mtpRequestId id, int32 code = RPCError::NoError)
 	: requestId(id)
 	, errorCode(code) {
 	}
 
-	mtpRequestId requestId;
-	int32 errorCode;
+	mtpRequestId requestId = 0;
+	int32 errorCode = 0;
 
 };
 
diff --git a/Telegram/SourceFiles/mtproto/rsa_public_key.cpp b/Telegram/SourceFiles/mtproto/rsa_public_key.cpp
deleted file mode 100644
index 3188fb65f..000000000
--- a/Telegram/SourceFiles/mtproto/rsa_public_key.cpp
+++ /dev/null
@@ -1,271 +0,0 @@
-/*
-This file is part of Telegram Desktop,
-the official desktop application for the Telegram messaging service.
-
-For license and copyright information please follow this link:
-https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
-*/
-#include "mtproto/rsa_public_key.h"
-
-#include "base/openssl_help.h"
-
-extern "C" {
-#include <openssl/rsa.h>
-#include <openssl/pem.h>
-#include <openssl/bio.h>
-#include <openssl/err.h>
-} // extern "C"
-
-namespace MTP {
-namespace internal {
-namespace {
-#if OPENSSL_VERSION_NUMBER < 0x10100000L || (defined(LIBRESSL_VERSION_NUMBER) && LIBRESSL_VERSION_NUMBER < 0x2070000fL)
-
-// This is a key setter for compatibility with OpenSSL 1.0
-int RSA_set0_key(RSA *r, BIGNUM *n, BIGNUM *e, BIGNUM *d) {
-	if ((r->n == nullptr && n == nullptr) || (r->e == nullptr && e == nullptr)) {
-		return 0;
-	}
-	if (n != nullptr) {
-		BN_free(r->n);
-		r->n = n;
-	}
-	if (e != nullptr) {
-		BN_free(r->e);
-		r->e = e;
-	}
-	if (d != nullptr) {
-		BN_free(r->d);
-		r->d = d;
-	}
-	return 1;
-}
-
-// This is a key getter for compatibility with OpenSSL 1.0
-void RSA_get0_key(const RSA *r, const BIGNUM **n, const BIGNUM **e, const BIGNUM **d) {
-	if (n != nullptr) {
-		*n = r->n;
-	}
-	if (e != nullptr) {
-		*e = r->e;
-	}
-	if (d != nullptr) {
-		*d = r->d;
-	}
-}
-
-#endif
-
-enum class Format {
-	RSAPublicKey,
-	RSA_PUBKEY,
-	Unknown,
-};
-
-Format GuessFormat(bytes::const_span key) {
-	const auto array = QByteArray::fromRawData(
-		reinterpret_cast<const char*>(key.data()),
-		key.size());
-	if (array.indexOf("BEGIN RSA PUBLIC KEY") >= 0) {
-		return Format::RSAPublicKey;
-	} else if (array.indexOf("BEGIN PUBLIC KEY") >= 0) {
-		return Format::RSA_PUBKEY;
-	}
-	return Format::Unknown;
-}
-
-RSA *CreateRaw(bytes::const_span key) {
-	const auto format = GuessFormat(key);
-	const auto bio = BIO_new_mem_buf(
-		const_cast<gsl::byte*>(key.data()),
-		key.size());
-	switch (format) {
-	case Format::RSAPublicKey:
-		return PEM_read_bio_RSAPublicKey(bio, nullptr, nullptr, nullptr);
-	case Format::RSA_PUBKEY:
-		return PEM_read_bio_RSA_PUBKEY(bio, nullptr, nullptr, nullptr);
-	}
-	Unexpected("format in RSAPublicKey::Private::Create.");
-}
-
-} // namespace
-
-class RSAPublicKey::Private {
-public:
-	Private(bytes::const_span key)
-	: _rsa(CreateRaw(key)) {
-		if (_rsa) {
-			computeFingerprint();
-		}
-	}
-	Private(bytes::const_span nBytes, bytes::const_span eBytes)
-	: _rsa(RSA_new()) {
-		if (_rsa) {
-			const auto n = openssl::BigNum(nBytes).takeRaw();
-			const auto e = openssl::BigNum(eBytes).takeRaw();
-			const auto valid = (n != nullptr) && (e != nullptr);
-			// We still pass both values to RSA_set0_key() so that even
-			// if only one of them is valid RSA would take ownership of it.
-			if (!RSA_set0_key(_rsa, n, e, nullptr) || !valid) {
-				RSA_free(base::take(_rsa));
-			} else {
-				computeFingerprint();
-			}
-		}
-	}
-	bytes::vector getN() const {
-		Expects(isValid());
-
-		const BIGNUM *n;
-		RSA_get0_key(_rsa, &n, nullptr, nullptr);
-		return toBytes(n);
-	}
-	bytes::vector getE() const {
-		Expects(isValid());
-
-		const BIGNUM *e;
-		RSA_get0_key(_rsa, nullptr, &e, nullptr);
-		return toBytes(e);
-	}
-	uint64 getFingerPrint() const {
-		return _fingerprint;
-	}
-	bool isValid() const {
-		return _rsa != nullptr;
-	}
-	bytes::vector encrypt(bytes::const_span data) const {
-		Expects(isValid());
-
-		constexpr auto kEncryptSize = 256;
-		auto result = bytes::vector(kEncryptSize, gsl::byte {});
-		auto res = RSA_public_encrypt(kEncryptSize, reinterpret_cast<const unsigned char*>(data.data()), reinterpret_cast<unsigned char*>(result.data()), _rsa, RSA_NO_PADDING);
-		if (res < 0 || res > kEncryptSize) {
-			ERR_load_crypto_strings();
-			LOG(("RSA Error: RSA_public_encrypt failed, key fp: %1, result: %2, error: %3").arg(getFingerPrint()).arg(res).arg(ERR_error_string(ERR_get_error(), 0)));
-			return {};
-		} else if (auto zeroBytes = kEncryptSize - res) {
-			auto resultBytes = gsl::make_span(result);
-			bytes::move(resultBytes.subspan(zeroBytes, res), resultBytes.subspan(0, res));
-			bytes::set_with_const(resultBytes.subspan(0, zeroBytes), gsl::byte {});
-		}
-		return result;
-	}
-	bytes::vector decrypt(bytes::const_span data) const {
-		Expects(isValid());
-
-		constexpr auto kDecryptSize = 256;
-		auto result = bytes::vector(kDecryptSize, gsl::byte {});
-		auto res = RSA_public_decrypt(kDecryptSize, reinterpret_cast<const unsigned char*>(data.data()), reinterpret_cast<unsigned char*>(result.data()), _rsa, RSA_NO_PADDING);
-		if (res < 0 || res > kDecryptSize) {
-			ERR_load_crypto_strings();
-			LOG(("RSA Error: RSA_public_encrypt failed, key fp: %1, result: %2, error: %3").arg(getFingerPrint()).arg(res).arg(ERR_error_string(ERR_get_error(), 0)));
-			return {};
-		} else if (auto zeroBytes = kDecryptSize - res) {
-			auto resultBytes = gsl::make_span(result);
-			bytes::move(resultBytes.subspan(zeroBytes - res, res), resultBytes.subspan(0, res));
-			bytes::set_with_const(resultBytes.subspan(0, zeroBytes - res), gsl::byte {});
-		}
-		return result;
-	}
-	bytes::vector encryptOAEPpadding(bytes::const_span data) const {
-		Expects(isValid());
-
-		const auto resultSize = RSA_size(_rsa);
-		auto result = bytes::vector(resultSize, gsl::byte{});
-		const auto encryptedSize = RSA_public_encrypt(
-			data.size(),
-			reinterpret_cast<const unsigned char*>(data.data()),
-			reinterpret_cast<unsigned char*>(result.data()),
-			_rsa,
-			RSA_PKCS1_OAEP_PADDING);
-		if (encryptedSize != resultSize) {
-			ERR_load_crypto_strings();
-			LOG(("RSA Error: RSA_public_encrypt failed, "
-				"key fp: %1, result: %2, error: %3"
-				).arg(getFingerPrint()
-				).arg(encryptedSize
-				).arg(ERR_error_string(ERR_get_error(), 0)
-				));
-			return {};
-		}
-		return result;
-	}
-	~Private() {
-		RSA_free(_rsa);
-	}
-
-private:
-	void computeFingerprint() {
-		Expects(isValid());
-
-		const BIGNUM *n, *e;
-		mtpBuffer string;
-		RSA_get0_key(_rsa, &n, &e, nullptr);
-		MTP_bytes(toBytes(n)).write(string);
-		MTP_bytes(toBytes(e)).write(string);
-
-		uchar sha1Buffer[20];
-		_fingerprint = *(uint64*)(hashSha1(&string[0], string.size() * sizeof(mtpPrime), sha1Buffer) + 3);
-	}
-	static bytes::vector toBytes(const BIGNUM *number) {
-		auto size = BN_num_bytes(number);
-		auto result = bytes::vector(size, gsl::byte {});
-		BN_bn2bin(number, reinterpret_cast<unsigned char*>(result.data()));
-		return result;
-	}
-
-	RSA *_rsa = nullptr;
-	uint64 _fingerprint = 0;
-
-};
-
-RSAPublicKey::RSAPublicKey(bytes::const_span key)
-: _private(std::make_shared<Private>(key)) {
-}
-
-RSAPublicKey::RSAPublicKey(
-	bytes::const_span nBytes,
-	bytes::const_span eBytes)
-: _private(std::make_shared<Private>(nBytes, eBytes)) {
-}
-
-bool RSAPublicKey::isValid() const {
-	return _private && _private->isValid();
-}
-
-uint64 RSAPublicKey::getFingerPrint() const {
-	Expects(isValid());
-	return _private->getFingerPrint();
-}
-
-bytes::vector RSAPublicKey::getN() const {
-	Expects(isValid());
-
-	return _private->getN();
-}
-
-bytes::vector RSAPublicKey::getE() const {
-	Expects(isValid());
-
-	return _private->getE();
-}
-
-bytes::vector RSAPublicKey::encrypt(bytes::const_span data) const {
-	Expects(isValid());
-
-	return _private->encrypt(data);
-}
-
-bytes::vector RSAPublicKey::decrypt(bytes::const_span data) const {
-	Expects(isValid());
-
-	return _private->decrypt(data);
-}
-
-bytes::vector RSAPublicKey::encryptOAEPpadding(
-		bytes::const_span data) const {
-	return _private->encryptOAEPpadding(data);
-}
-
-} // namespace internal
-} // namespace MTP
diff --git a/Telegram/SourceFiles/mtproto/sender.h b/Telegram/SourceFiles/mtproto/sender.h
index 37210d3fa..6d91b2914 100644
--- a/Telegram/SourceFiles/mtproto/sender.h
+++ b/Telegram/SourceFiles/mtproto/sender.h
@@ -8,12 +8,12 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #pragma once
 
 #include "base/variant.h"
+#include "mtproto/mtproto_rpc_sender.h"
+#include "mtproto/mtp_instance.h"
+#include "mtproto/facade.h"
 
 namespace MTP {
 
-class Instance;
-Instance *MainInstance();
-
 class Sender {
 	class RequestBuilder {
 	public:
@@ -101,11 +101,11 @@ class Sender {
 
 			bool operator()(mtpRequestId requestId, const RPCError &error) override {
 				if (_skipPolicy == FailSkipPolicy::Simple) {
-					if (MTP::isDefaultHandledError(error)) {
+					if (isDefaultHandledError(error)) {
 						return false;
 					}
 				} else if (_skipPolicy == FailSkipPolicy::HandleFlood) {
-					if (MTP::isDefaultHandledError(error) && !MTP::isFloodError(error)) {
+					if (isDefaultHandledError(error) && !isFloodError(error)) {
 						return false;
 					}
 				}
@@ -192,7 +192,12 @@ class Sender {
 	};
 
 public:
-	Sender() noexcept {
+	explicit Sender(not_null<Instance*> instance) noexcept
+	: _instance(instance) {
+	}
+
+	[[nodiscard]] not_null<Instance*> instance() const {
+		return _instance;
 	}
 
 	template <typename Request>
@@ -242,7 +247,7 @@ public:
 		}
 
 		mtpRequestId send() {
-			const auto id = MainInstance()->send(
+			const auto id = sender()->instance()->send(
 				_request,
 				takeOnDone(),
 				takeOnFail(),
@@ -290,16 +295,13 @@ public:
 	}
 
 	void requestSendDelayed() {
-		MainInstance()->sendAnything();
+		_instance->sendAnything();
 	}
 	void requestCancellingDiscard() {
 		for (auto &request : _requests) {
 			request.handled();
 		}
 	}
-	not_null<Instance*> requestMTP() const {
-		return MainInstance();
-	}
 
 private:
 	class RequestWrap {
@@ -389,6 +391,7 @@ private:
 		}
 	}
 
+	const not_null<Instance*> _instance;
 	base::flat_set<RequestWrap, RequestWrapComparator> _requests;
 
 };
diff --git a/Telegram/SourceFiles/mtproto/session.cpp b/Telegram/SourceFiles/mtproto/session.cpp
index f6f381f05..f850e9956 100644
--- a/Telegram/SourceFiles/mtproto/session.cpp
+++ b/Telegram/SourceFiles/mtproto/session.cpp
@@ -7,43 +7,17 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 */
 #include "mtproto/session.h"
 
-#include "mtproto/connection.h"
-#include "mtproto/dcenter.h"
-#include "mtproto/auth_key.h"
+#include "mtproto/details/mtproto_dcenter.h"
+#include "mtproto/session_private.h"
+#include "mtproto/mtproto_auth_key.h"
 #include "base/unixtime.h"
-#include "core/crash_reports.h"
+#include "base/openssl_help.h"
 #include "facades.h"
 
 namespace MTP {
-namespace internal {
-namespace {
+namespace details {
 
-// How much time passed from send till we resend request or check its state.
-constexpr auto kCheckResendTimeout = crl::time(10000);
-
-// How much time to wait for some more requests,
-// when resending request or checking its state.
-constexpr auto kCheckResendWaiting = crl::time(1000);
-
-// How much ints should message contain for us not to resend,
-// but instead to check its state.
-constexpr auto kResendThreshold = 1;
-
-// Container lives 10 minutes in haveSent map.
-constexpr auto kContainerLives = 600;
-
-QString LogIds(const QVector<uint64> &ids) {
-	if (!ids.size()) return "[]";
-	auto idsStr = QString("[%1").arg(*ids.cbegin());
-	for (const auto id : ids) {
-		idsStr += QString(", %2").arg(id);
-	}
-	return idsStr + "]";
-}
-
-} // namespace
-
-ConnectionOptions::ConnectionOptions(
+SessionOptions::SessionOptions(
 	const QString &systemLangCode,
 	const QString &cloudLangCode,
 	const QString &langPackName,
@@ -62,113 +36,193 @@ ConnectionOptions::ConnectionOptions(
 , useTcp(useTcp) {
 }
 
-void SessionData::setKey(const AuthKeyPtr &key) {
-	if (_authKey != key) {
-		uint64 session = rand_value<uint64>();
-		_authKey = key;
-
-		DEBUG_LOG(("MTP Info: new auth key set in SessionData, id %1, setting random server_session %2").arg(key ? key->keyId() : 0).arg(session));
-		QWriteLocker locker(&_lock);
-		if (_session != session) {
-			_session = session;
-			_messagesSent = 0;
+template <typename Callback>
+void SessionData::withSession(Callback &&callback) {
+	QMutexLocker lock(&_ownerMutex);
+	if (const auto session = _owner) {
+		InvokeQueued(session, [
+			session,
+			callback = std::forward<Callback>(callback)
+		] {
+			callback(session);
+		});
+	}
+}
+
+void SessionData::notifyConnectionInited(const SessionOptions &options) {
+	// #TODO race
+	const auto current = this->options();
+	if (current.cloudLangCode == _options.cloudLangCode
+		&& current.systemLangCode == _options.systemLangCode
+		&& current.langPackName == _options.langPackName
+		&& current.proxy == _options.proxy) {
+		QMutexLocker lock(&_ownerMutex);
+		if (_owner) {
+			_owner->notifyDcConnectionInited();
 		}
-		_layerInited = false;
 	}
 }
 
-void SessionData::notifyConnectionInited(const ConnectionOptions &options) {
-	QWriteLocker locker(&_lock);
-	if (options.cloudLangCode == _options.cloudLangCode
-		&& options.systemLangCode == _options.systemLangCode
-		&& options.langPackName == _options.langPackName
-		&& options.proxy == _options.proxy
-		&& !_options.inited) {
-		_options.inited = true;
+void SessionData::queueTryToReceive() {
+	withSession([](not_null<Session*> session) {
+		session->tryToReceive();
+	});
+}
 
-		locker.unlock();
-		owner()->notifyDcConnectionInited();
-	}
+void SessionData::queueNeedToResumeAndSend() {
+	withSession([](not_null<Session*> session) {
+		session->needToResumeAndSend();
+	});
 }
 
-void SessionData::clear(Instance *instance) {
-	auto clearCallbacks = std::vector<RPCCallbackClear>();
-	{
-		QReadLocker locker1(haveSentMutex()), locker2(toResendMutex()), locker3(haveReceivedMutex()), locker4(wereAckedMutex());
-		auto receivedResponsesEnd = _receivedResponses.cend();
-		clearCallbacks.reserve(_haveSent.size() + _wereAcked.size());
-		for (auto i = _haveSent.cbegin(), e = _haveSent.cend(); i != e; ++i) {
-			auto requestId = i.value()->requestId;
-			if (!_receivedResponses.contains(requestId)) {
-				clearCallbacks.push_back(requestId);
-			}
-		}
-		for (auto i = _toResend.cbegin(), e = _toResend.cend(); i != e; ++i) {
-			auto requestId = i.value();
-			if (!_receivedResponses.contains(requestId)) {
-				clearCallbacks.push_back(requestId);
-			}
-		}
-		for (auto i = _wereAcked.cbegin(), e = _wereAcked.cend(); i != e; ++i) {
-			auto requestId = i.value();
-			if (!_receivedResponses.contains(requestId)) {
-				clearCallbacks.push_back(requestId);
-			}
-		}
-	}
-	{
-		QWriteLocker locker(haveSentMutex());
-		_haveSent.clear();
-	}
-	{
-		QWriteLocker locker(toResendMutex());
-		_toResend.clear();
-	}
-	{
-		QWriteLocker locker(wereAckedMutex());
-		_wereAcked.clear();
-	}
-	{
-		QWriteLocker locker(receivedIdsMutex());
-		_receivedIds.clear();
-	}
-	instance->clearCallbacksDelayed(std::move(clearCallbacks));
+void SessionData::queueConnectionStateChange(int newState) {
+	withSession([=](not_null<Session*> session) {
+		session->connectionStateChange(newState);
+	});
 }
 
-Session::Session(not_null<Instance*> instance, ShiftedDcId shiftedDcId) : QObject()
-, _instance(instance)
-, data(this)
-, dcWithShift(shiftedDcId)
-, sender([=] { needToResumeAndSend(); }) {
-	connect(&timeouter, SIGNAL(timeout()), this, SLOT(checkRequestsByTimer()));
-	timeouter.start(1000);
+void SessionData::queueResetDone() {
+	withSession([](not_null<Session*> session) {
+		session->resetDone();
+	});
+}
 
-	refreshOptions();
+void SessionData::queueSendAnything(crl::time msCanWait) {
+	withSession([=](not_null<Session*> session) {
+		session->sendAnything(msCanWait);
+	});
 }
 
-void Session::start() {
-	createDcData();
-	_connection = std::make_unique<Connection>(_instance);
-	_connection->start(&data, dcWithShift);
-	if (_instance->isKeysDestroyer()) {
-		_instance->scheduleKeyDestroy(dcWithShift);
+bool SessionData::connectionInited() const {
+	QMutexLocker lock(&_ownerMutex);
+	return _owner ? _owner->connectionInited() : false;
+}
+
+AuthKeyPtr SessionData::getTemporaryKey(TemporaryKeyType type) const {
+	QMutexLocker lock(&_ownerMutex);
+	return _owner ? _owner->getTemporaryKey(type) : nullptr;
+}
+
+AuthKeyPtr SessionData::getPersistentKey() const {
+	QMutexLocker lock(&_ownerMutex);
+	return _owner ? _owner->getPersistentKey() : nullptr;
+}
+
+CreatingKeyType SessionData::acquireKeyCreation(DcType type) {
+	QMutexLocker lock(&_ownerMutex);
+	return _owner ? _owner->acquireKeyCreation(type) : CreatingKeyType::None;
+}
+
+bool SessionData::releaseKeyCreationOnDone(
+		const AuthKeyPtr &temporaryKey,
+		const AuthKeyPtr &persistentKeyUsedForBind) {
+	QMutexLocker lock(&_ownerMutex);
+	return _owner
+		? _owner->releaseKeyCreationOnDone(
+			temporaryKey,
+			persistentKeyUsedForBind)
+		: false;
+}
+
+bool SessionData::releaseCdnKeyCreationOnDone(
+		const AuthKeyPtr &temporaryKey) {
+	QMutexLocker lock(&_ownerMutex);
+	return _owner
+		? _owner->releaseCdnKeyCreationOnDone(temporaryKey)
+		: false;
+}
+
+void SessionData::releaseKeyCreationOnFail() {
+	QMutexLocker lock(&_ownerMutex);
+	if (_owner) {
+		_owner->releaseKeyCreationOnFail();
 	}
 }
 
-void Session::createDcData() {
-	if (dc) {
-		return;
+void SessionData::destroyTemporaryKey(uint64 keyId) {
+	QMutexLocker lock(&_ownerMutex);
+	if (_owner) {
+		_owner->destroyTemporaryKey(keyId);
 	}
-	dc = _instance->getDcById(dcWithShift);
+}
+
+void SessionData::detach() {
+	QMutexLocker lock(&_ownerMutex);
+	_owner = nullptr;
+}
+
+Session::Session(
+	not_null<Instance*> instance,
+	not_null<QThread*> thread,
+	ShiftedDcId shiftedDcId,
+	not_null<Dcenter*> dc)
+: _instance(instance)
+, _shiftedDcId(shiftedDcId)
+, _dc(dc)
+, _data(std::make_shared<SessionData>(this))
+, _thread(thread)
+, _sender([=] { needToResumeAndSend(); }) {
+	_timeouter.callEach(1000);
+	refreshOptions();
+	watchDcKeyChanges();
+	watchDcOptionsChanges();
+	start();
+}
 
-	if (auto lock = ReadLockerAttempt(keyMutex())) {
-		data.setKey(dc->getKey());
-		if (dc->connectionInited()) {
-			data.setConnectionInited();
+Session::~Session() {
+	Expects(!_private);
+
+	if (_myKeyCreation != CreatingKeyType::None) {
+		releaseKeyCreationOnFail();
+	}
+}
+
+void Session::watchDcKeyChanges() {
+	_instance->dcTemporaryKeyChanged(
+	) | rpl::filter([=](DcId dcId) {
+		return (dcId == _shiftedDcId) || (dcId == BareDcId(_shiftedDcId));
+	}) | rpl::start_with_next([=] {
+		DEBUG_LOG(("AuthKey Info: dcTemporaryKeyChanged in Session %1"
+			).arg(_shiftedDcId));
+		if (const auto captured = _private) {
+			InvokeQueued(captured, [=] {
+				DEBUG_LOG(("AuthKey Info: calling Connection::updateAuthKey in Session %1"
+					).arg(_shiftedDcId));
+				captured->updateAuthKey();
+			});
 		}
+	}, _lifetime);
+}
+
+void Session::watchDcOptionsChanges() {
+	_instance->dcOptions()->changed(
+	) | rpl::filter([=](DcId dcId) {
+		return (BareDcId(_shiftedDcId) == dcId) && (_private != nullptr);
+	}) | rpl::start_with_next([=] {
+		InvokeQueued(_private, [captured = _private] {
+			captured->dcOptionsChanged();
+		});
+	}, _lifetime);
+
+	if (_instance->dcOptions()->dcType(_shiftedDcId) == DcType::Cdn) {
+		_instance->dcOptions()->cdnConfigChanged(
+		) | rpl::filter([=] {
+			return (_private != nullptr);
+		}) | rpl::start_with_next([=] {
+			InvokeQueued(_private, [captured = _private] {
+				captured->cdnConfigChanged();
+			});
+		}, _lifetime);
 	}
-	connect(dc.get(), SIGNAL(authKeyCreated()), this, SLOT(authKeyCreatedForDC()), Qt::QueuedConnection);
-	connect(dc.get(), SIGNAL(connectionWasInited()), this, SLOT(connectionWasInitedForDC()), Qt::QueuedConnection);
+}
+
+void Session::start() {
+	killConnection();
+	_private = new SessionPrivate(
+		_instance,
+		_thread.get(),
+		_data,
+		_shiftedDcId);
 }
 
 bool Session::rpcErrorOccured(
@@ -184,7 +238,11 @@ void Session::restart() {
 		return;
 	}
 	refreshOptions();
-	emit needToRestart();
+	if (const auto captured = _private) {
+		InvokeQueued(captured, [=] {
+			captured->restartNow();
+		});
+	}
 }
 
 void Session::refreshOptions() {
@@ -197,7 +255,7 @@ void Session::refreshOptions() {
 	const auto useHttp = (proxyType != ProxyData::Type::Mtproto);
 	const auto useIPv4 = true;
 	const auto useIPv6 = Global::TryIPv6();
-	data.applyConnectionOptions(ConnectionOptions(
+	_data->setOptions(SessionOptions(
 		_instance->systemLangCode(),
 		_instance->cloudLangCode(),
 		_instance->langPackName(),
@@ -211,62 +269,61 @@ void Session::refreshOptions() {
 }
 
 void Session::reInitConnection() {
-	dc->setConnectionInited(false);
-	data.setConnectionInited(false);
+	_dc->setConnectionInited(false);
 	restart();
 }
 
 void Session::stop() {
 	if (_killed) {
-		DEBUG_LOG(("Session Error: can't kill a killed session"));
+		DEBUG_LOG(("Session Error: can't stop a killed session"));
 		return;
 	}
-	DEBUG_LOG(("Session Info: stopping session dcWithShift %1").arg(dcWithShift));
-	if (_connection) {
-		_connection->kill();
-		_instance->queueQuittingConnection(std::move(_connection));
-	}
+	DEBUG_LOG(("Session Info: stopping session dcWithShift %1").arg(_shiftedDcId));
+	killConnection();
 }
 
 void Session::kill() {
 	stop();
 	_killed = true;
-	DEBUG_LOG(("Session Info: marked session dcWithShift %1 as killed").arg(dcWithShift));
+	_data->detach();
+	DEBUG_LOG(("Session Info: marked session dcWithShift %1 as killed").arg(_shiftedDcId));
 }
 
 void Session::unpaused() {
 	if (_needToReceive) {
 		_needToReceive = false;
-		QTimer::singleShot(0, this, SLOT(tryToReceive()));
+		InvokeQueued(this, [=] {
+			tryToReceive();
+		});
 	}
 }
 
-void Session::sendAnything(qint64 msCanWait) {
+void Session::sendAnything(crl::time msCanWait) {
 	if (_killed) {
 		DEBUG_LOG(("Session Error: can't send anything in a killed session"));
 		return;
 	}
-	auto ms = crl::now();
-	if (msSendCall) {
-		if (ms > msSendCall + msWait) {
-			msWait = 0;
+	const auto ms = crl::now();
+	if (_msSendCall) {
+		if (ms > _msSendCall + _msWait) {
+			_msWait = 0;
 		} else {
-			msWait = (msSendCall + msWait) - ms;
-			if (msWait > msCanWait) {
-				msWait = msCanWait;
+			_msWait = (_msSendCall + _msWait) - ms;
+			if (_msWait > msCanWait) {
+				_msWait = msCanWait;
 			}
 		}
 	} else {
-		msWait = msCanWait;
+		_msWait = msCanWait;
 	}
-	if (msWait) {
-		DEBUG_LOG(("MTP Info: dcWithShift %1 can wait for %2ms from current %3").arg(dcWithShift).arg(msWait).arg(msSendCall));
-		msSendCall = ms;
-		sender.callOnce(msWait);
+	if (_msWait) {
+		DEBUG_LOG(("MTP Info: dcWithShift %1 can wait for %2ms from current %3").arg(_shiftedDcId).arg(_msWait).arg(_msSendCall));
+		_msSendCall = ms;
+		_sender.callOnce(_msWait);
 	} else {
-		DEBUG_LOG(("MTP Info: dcWithShift %1 stopped send timer, can wait for %2ms from current %3").arg(dcWithShift).arg(msWait).arg(msSendCall));
-		sender.cancel();
-		msSendCall = 0;
+		DEBUG_LOG(("MTP Info: dcWithShift %1 stopped send timer, can wait for %2ms from current %3").arg(_shiftedDcId).arg(_msWait).arg(_msSendCall));
+		_sender.cancel();
+		_msSendCall = 0;
 		needToResumeAndSend();
 	}
 }
@@ -276,134 +333,51 @@ void Session::needToResumeAndSend() {
 		DEBUG_LOG(("Session Info: can't resume a killed session"));
 		return;
 	}
-	if (!_connection) {
-		DEBUG_LOG(("Session Info: resuming session dcWithShift %1").arg(dcWithShift));
-		createDcData();
-		_connection = std::make_unique<Connection>(_instance);
-		_connection->start(&data, dcWithShift);
-	}
-	if (_ping) {
-		_ping = false;
-		emit needToPing();
-	} else {
-		emit needToSend();
-	}
-}
-
-void Session::sendPong(quint64 msgId, quint64 pingId) {
-	_instance->sendProtocolMessage(
-		dcWithShift,
-		MTPPong(MTP_pong(MTP_long(msgId), MTP_long(pingId))));
-}
-
-void Session::sendMsgsStateInfo(quint64 msgId, QByteArray data) {
-	auto info = bytes::vector();
-	if (!data.isEmpty()) {
-		info.resize(data.size());
-		bytes::copy(info, bytes::make_span(data));
-	}
-	_instance->sendProtocolMessage(
-		dcWithShift,
-		MTPMsgsStateInfo(
-			MTP_msgs_state_info(MTP_long(msgId), MTP_bytes(data))));
-}
-
-void Session::checkRequestsByTimer() {
-	QVector<mtpMsgId> resendingIds;
-	QVector<mtpMsgId> removingIds; // remove very old (10 minutes) containers and resend requests
-	QVector<mtpMsgId> stateRequestIds;
-
-	{
-		QReadLocker locker(data.haveSentMutex());
-		auto &haveSent = data.haveSentMap();
-		const auto haveSentCount = haveSent.size();
-		auto ms = crl::now();
-		for (auto i = haveSent.begin(), e = haveSent.end(); i != e; ++i) {
-			auto &req = i.value();
-			if (req->msDate > 0) {
-				if (req->msDate + kCheckResendTimeout < ms) { // need to resend or check state
-					if (req.messageSize() < kResendThreshold) { // resend
-						resendingIds.reserve(haveSentCount);
-						resendingIds.push_back(i.key());
-					} else {
-						req->msDate = ms;
-						stateRequestIds.reserve(haveSentCount);
-						stateRequestIds.push_back(i.key());
-					}
-				}
-			} else if (base::unixtime::now()
-					> int32(i.key() >> 32) + kContainerLives) {
-				removingIds.reserve(haveSentCount);
-				removingIds.push_back(i.key());
-			}
-		}
-	}
-
-	if (stateRequestIds.size()) {
-		DEBUG_LOG(("MTP Info: requesting state of msgs: %1").arg(LogIds(stateRequestIds)));
-		{
-			QWriteLocker locker(data.stateRequestMutex());
-			for (uint32 i = 0, l = stateRequestIds.size(); i < l; ++i) {
-				data.stateRequestMap().insert(stateRequestIds[i], true);
-			}
-		}
-		sendAnything(kCheckResendWaiting);
+	if (!_private) {
+		DEBUG_LOG(("Session Info: resuming session dcWithShift %1").arg(_shiftedDcId));
+		start();
 	}
-	if (!resendingIds.isEmpty()) {
-		for (uint32 i = 0, l = resendingIds.size(); i < l; ++i) {
-			DEBUG_LOG(("MTP Info: resending request %1").arg(resendingIds[i]));
-			resend(resendingIds[i], kCheckResendWaiting);
-		}
-	}
-	if (!removingIds.isEmpty()) {
-		auto clearCallbacks = std::vector<RPCCallbackClear>();
-		{
-			QWriteLocker locker(data.haveSentMutex());
-			auto &haveSent = data.haveSentMap();
-			for (uint32 i = 0, l = removingIds.size(); i < l; ++i) {
-				auto j = haveSent.find(removingIds[i]);
-				if (j != haveSent.cend()) {
-					if (j.value()->requestId) {
-						clearCallbacks.push_back(j.value()->requestId);
-					}
-					haveSent.erase(j);
-				}
-			}
+	const auto captured = _private;
+	const auto ping = base::take(_ping);
+	InvokeQueued(captured, [=] {
+		if (ping) {
+			captured->sendPingForce();
+		} else {
+			captured->tryToSend();
 		}
-		_instance->clearCallbacksDelayed(std::move(clearCallbacks));
-	}
+	});
 }
 
-void Session::onConnectionStateChange(qint32 newState) {
-	_instance->onStateChange(dcWithShift, newState);
+void Session::connectionStateChange(int newState) {
+	_instance->onStateChange(_shiftedDcId, newState);
 }
 
-void Session::onResetDone() {
-	_instance->onSessionReset(dcWithShift);
+void Session::resetDone() {
+	_instance->onSessionReset(_shiftedDcId);
 }
 
 void Session::cancel(mtpRequestId requestId, mtpMsgId msgId) {
 	if (requestId) {
-		QWriteLocker locker(data.toSendMutex());
-		data.toSendMap().remove(requestId);
+		QWriteLocker locker(_data->toSendMutex());
+		_data->toSendMap().remove(requestId);
 	}
 	if (msgId) {
-		QWriteLocker locker(data.haveSentMutex());
-		data.haveSentMap().remove(msgId);
+		QWriteLocker locker(_data->haveSentMutex());
+		_data->haveSentMap().remove(msgId);
 	}
 }
 
 void Session::ping() {
 	_ping = true;
-	sendAnything(0);
+	sendAnything();
 }
 
 int32 Session::requestState(mtpRequestId requestId) const {
 	int32 result = MTP::RequestSent;
 
 	bool connected = false;
-	if (_connection) {
-		int32 s = _connection->state();
+	if (_private) {
+		const auto s = _private->getState();
 		if (s == ConnectedState) {
 			connected = true;
 		} else if (s == ConnectingState || s == DisconnectedState) {
@@ -418,24 +392,21 @@ int32 Session::requestState(mtpRequestId requestId) const {
 	}
 	if (!connected) {
 		return result;
-	}
-	if (!requestId) return MTP::RequestSent;
-
-	QWriteLocker locker(data.toSendMutex());
-	const auto &toSend = data.toSendMap();
-	const auto i = toSend.constFind(requestId);
-	if (i != toSend.cend()) {
-		return MTP::RequestSending;
-	} else {
+	} else if (!requestId) {
 		return MTP::RequestSent;
 	}
+
+	QWriteLocker locker(_data->toSendMutex());
+	return _data->toSendMap().contains(requestId)
+		? MTP::RequestSending
+		: MTP::RequestSent;
 }
 
 int32 Session::getState() const {
 	int32 result = -86400000;
 
-	if (_connection) {
-		int32 s = _connection->state();
+	if (_private) {
+		const auto s = _private->getState();
 		if (s == ConnectedState) {
 			return s;
 		} else if (s == ConnectingState || s == DisconnectedState) {
@@ -455,139 +426,127 @@ int32 Session::getState() const {
 }
 
 QString Session::transport() const {
-	return _connection ? _connection->transport() : QString();
+	return _private ? _private->transport() : QString();
 }
 
-mtpRequestId Session::resend(quint64 msgId, qint64 msCanWait, bool forceContainer, bool sendMsgStateInfo) {
-	SecureRequest request;
+void Session::sendPrepared(
+		const SerializedRequest &request,
+		crl::time msCanWait) {
+	DEBUG_LOG(("MTP Info: adding request to toSendMap, msCanWait %1"
+		).arg(msCanWait));
 	{
-		QWriteLocker locker(data.haveSentMutex());
-		auto &haveSent = data.haveSentMap();
-
-		auto i = haveSent.find(msgId);
-		if (i == haveSent.end()) {
-			if (sendMsgStateInfo) {
-				char cantResend[2] = {1, 0};
-				DEBUG_LOG(("Message Info: cant resend %1, request not found").arg(msgId));
-
-				auto info = std::string(cantResend, cantResend + 1);
-				return _instance->sendProtocolMessage(
-					dcWithShift,
-					MTPMsgsStateInfo(
-						MTP_msgs_state_info(
-							MTP_long(msgId),
-							MTP_string(std::move(info)))));
-			}
-			return 0;
-		}
-
-		request = i.value();
-		haveSent.erase(i);
+		QWriteLocker locker(_data->toSendMutex());
+		_data->toSendMap().emplace(request->requestId, request);
+		*(mtpMsgId*)(request->data() + 4) = 0;
+		*(request->data() + 6) = 0;
 	}
-	if (request.isSentContainer()) { // for container just resend all messages we can
-		DEBUG_LOG(("Message Info: resending container from haveSent, msgId %1").arg(msgId));
-		const mtpMsgId *ids = (const mtpMsgId *)(request->constData() + 8);
-		for (uint32 i = 0, l = (request->size() - 8) >> 1; i < l; ++i) {
-			resend(ids[i], 10, true);
-		}
-		return 0xFFFFFFFF;
-	} else if (!request.isStateRequest()) {
-		request->msDate = forceContainer ? 0 : crl::now();
-		sendPrepared(request, msCanWait, false);
-		{
-			QWriteLocker locker(data.toResendMutex());
-			data.toResendMap().insert(msgId, request->requestId);
-		}
-		return request->requestId;
-	} else {
-		return 0;
+
+	DEBUG_LOG(("MTP Info: added, requestId %1").arg(request->requestId));
+	if (msCanWait >= 0) {
+		InvokeQueued(this, [=] {
+			sendAnything(msCanWait);
+		});
 	}
 }
 
-void Session::resendMany(QVector<quint64> msgIds, qint64 msCanWait, bool forceContainer, bool sendMsgStateInfo) {
-	for (int32 i = 0, l = msgIds.size(); i < l; ++i) {
-		resend(msgIds.at(i), msCanWait, forceContainer, sendMsgStateInfo);
-	}
+CreatingKeyType Session::acquireKeyCreation(DcType type) {
+	Expects(_myKeyCreation == CreatingKeyType::None);
+
+	_myKeyCreation = _dc->acquireKeyCreation(type);
+	return _myKeyCreation;
 }
 
-void Session::resendAll() {
-	QVector<mtpMsgId> toResend;
-	{
-		QReadLocker locker(data.haveSentMutex());
-		const auto &haveSent = data.haveSentMap();
-		toResend.reserve(haveSent.size());
-		for (auto i = haveSent.cbegin(), e = haveSent.cend(); i != e; ++i) {
-			if (i.value()->requestId) {
-				toResend.push_back(i.key());
-			}
-		}
-	}
-	for (uint32 i = 0, l = toResend.size(); i < l; ++i) {
-		resend(toResend[i], 10, true);
-	}
+bool Session::releaseKeyCreationOnDone(
+		const AuthKeyPtr &temporaryKey,
+		const AuthKeyPtr &persistentKeyUsedForBind) {
+	Expects(_myKeyCreation != CreatingKeyType::None);
+	Expects(persistentKeyUsedForBind != nullptr);
+
+	return releaseGenericKeyCreationOnDone(
+		temporaryKey,
+		persistentKeyUsedForBind);
 }
 
-void Session::sendPrepared(
-		const SecureRequest &request,
-		crl::time msCanWait,
-		bool newRequest) {
-	DEBUG_LOG(("MTP Info: adding request to toSendMap, msCanWait %1"
-		).arg(msCanWait));
-	{
-		QWriteLocker locker(data.toSendMutex());
-		data.toSendMap().insert(request->requestId, request);
+bool Session::releaseCdnKeyCreationOnDone(
+		const AuthKeyPtr &temporaryKey) {
+	Expects(_myKeyCreation == CreatingKeyType::TemporaryRegular);
 
-		if (newRequest) {
-			*(mtpMsgId*)(request->data() + 4) = 0;
-			*(request->data() + 6) = 0;
-		}
+	return releaseGenericKeyCreationOnDone(temporaryKey, nullptr);
+}
+
+bool Session::releaseGenericKeyCreationOnDone(
+		const AuthKeyPtr &temporaryKey,
+		const AuthKeyPtr &persistentKeyUsedForBind) {
+	const auto wasKeyCreation = std::exchange(
+		_myKeyCreation,
+		CreatingKeyType::None);
+	const auto result = _dc->releaseKeyCreationOnDone(
+		wasKeyCreation,
+		temporaryKey,
+		persistentKeyUsedForBind);
+
+	if (!result) {
+		DEBUG_LOG(("AuthKey Info: Persistent key changed "
+			"while binding temporary, dcWithShift %1"
+			).arg(_shiftedDcId));
+		return false;
 	}
 
-	DEBUG_LOG(("MTP Info: added, requestId %1").arg(request->requestId));
+	DEBUG_LOG(("AuthKey Info: Session key bound, setting, dcWithShift %1"
+		).arg(_shiftedDcId));
 
-	sendAnything(msCanWait);
+	const auto dcId = _dc->id();
+	const auto instance = _instance;
+	InvokeQueued(instance, [=] {
+		if (wasKeyCreation == CreatingKeyType::Persistent) {
+			instance->dcPersistentKeyChanged(dcId, persistentKeyUsedForBind);
+		} else {
+			instance->dcTemporaryKeyChanged(dcId);
+		}
+	});
+	return true;
 }
 
-QReadWriteLock *Session::keyMutex() const {
-	return dc->keyMutex();
-}
+void Session::releaseKeyCreationOnFail() {
+	Expects(_myKeyCreation != CreatingKeyType::None);
 
-void Session::authKeyCreatedForDC() {
-	DEBUG_LOG(("AuthKey Info: Session::authKeyCreatedForDC slot, emitting authKeyCreated(), dcWithShift %1").arg(dcWithShift));
-	data.setKey(dc->getKey());
-	emit authKeyCreated();
+	const auto wasKeyCreation = std::exchange(
+		_myKeyCreation,
+		CreatingKeyType::None);
+	_dc->releaseKeyCreationOnFail(wasKeyCreation);
 }
 
-void Session::notifyKeyCreated(AuthKeyPtr &&key) {
-	DEBUG_LOG(("AuthKey Info: Session::keyCreated(), setting, dcWithShift %1").arg(dcWithShift));
-	dc->setKey(std::move(key));
+void Session::notifyDcConnectionInited() {
+	DEBUG_LOG(("MTP Info: MTProtoDC::connectionWasInited(), dcWithShift %1"
+		).arg(_shiftedDcId));
+	_dc->setConnectionInited();
 }
 
-void Session::connectionWasInitedForDC() {
-	DEBUG_LOG(("MTP Info: Session::connectionWasInitedForDC slot, dcWithShift %1").arg(dcWithShift));
-	data.setConnectionInited();
+void Session::destroyTemporaryKey(uint64 keyId) {
+	if (!_dc->destroyTemporaryKey(keyId)) {
+		return;
+	}
+	const auto dcId = _dc->id();
+	const auto instance = _instance;
+	InvokeQueued(instance, [=] {
+		instance->dcTemporaryKeyChanged(dcId);
+	});
 }
 
-void Session::notifyDcConnectionInited() {
-	DEBUG_LOG(("MTP Info: emitting MTProtoDC::connectionWasInited(), dcWithShift %1").arg(dcWithShift));
-	dc->setConnectionInited();
-	emit dc->connectionWasInited();
+int32 Session::getDcWithShift() const {
+	return _shiftedDcId;
 }
 
-void Session::destroyKey() {
-	if (!dc) return;
+AuthKeyPtr Session::getTemporaryKey(TemporaryKeyType type) const {
+	return _dc->getTemporaryKey(type);
+}
 
-	if (data.getKey()) {
-		DEBUG_LOG(("MTP Info: destroying auth_key for dcWithShift %1").arg(dcWithShift));
-		if (data.getKey() == dc->getKey()) {
-			dc->destroyKey();
-		}
-		data.setKey(AuthKeyPtr());
-	}
+AuthKeyPtr Session::getPersistentKey() const {
+	return _dc->getPersistentKey();
 }
 
-int32 Session::getDcWithShift() const {
-	return dcWithShift;
+bool Session::connectionInited() const {
+	return _dc->connectionInited();
 }
 
 void Session::tryToReceive() {
@@ -600,42 +559,40 @@ void Session::tryToReceive() {
 		return;
 	}
 	while (true) {
-		auto requestId = mtpRequestId(0);
-		auto isUpdate = false;
-		auto message = SerializedMessage();
-		{
-			QWriteLocker locker(data.haveReceivedMutex());
-			auto &responses = data.haveReceivedResponses();
-			auto response = responses.begin();
-			if (response == responses.cend()) {
-				auto &updates = data.haveReceivedUpdates();
-				auto update = updates.begin();
-				if (update == updates.cend()) {
-					return;
-				} else {
-					message = std::move(*update);
-					isUpdate = true;
-					updates.pop_front();
-				}
-			} else {
-				requestId = response.key();
-				message = std::move(response.value());
-				responses.erase(response);
-			}
+		auto lock = QWriteLocker(_data->haveReceivedMutex());
+		const auto responses = base::take(_data->haveReceivedResponses());
+		const auto updates = base::take(_data->haveReceivedUpdates());
+		lock.unlock();
+		if (responses.empty() && updates.empty()) {
+			break;
 		}
-		if (isUpdate) {
-			if (dcWithShift == BareDcId(dcWithShift)) { // call globalCallback only in main session
-				_instance->globalCallback(message.constData(), message.constData() + message.size());
+		for (const auto &[requestId, response] : responses) {
+			_instance->execCallback(
+				requestId,
+				response.constData(),
+				response.constData() + response.size());
+		}
+
+		// Call globalCallback only in main session.
+		if (_shiftedDcId == BareDcId(_shiftedDcId)) {
+			for (const auto &update : updates) {
+				_instance->globalCallback(
+					update.constData(),
+					update.constData() + update.size());
 			}
-		} else {
-			_instance->execCallback(requestId, message.constData(), message.constData() + message.size());
 		}
 	}
 }
 
-Session::~Session() {
-	Assert(_connection == nullptr);
+void Session::killConnection() {
+	if (!_private) {
+		return;
+	}
+
+	base::take(_private)->deleteLater();
+
+	Ensures(_private == nullptr);
 }
 
-} // namespace internal
+} // namespace details
 } // namespace MTP
diff --git a/Telegram/SourceFiles/mtproto/session.h b/Telegram/SourceFiles/mtproto/session.h
index 061bac330..dc8b152c6 100644
--- a/Telegram/SourceFiles/mtproto/session.h
+++ b/Telegram/SourceFiles/mtproto/session.h
@@ -8,7 +8,9 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #pragma once
 
 #include "base/timer.h"
-#include "mtproto/rpc_sender.h"
+#include "mtproto/mtproto_rpc_sender.h"
+#include "mtproto/mtproto_proxy_data.h"
+#include "mtproto/details/mtproto_serialized_request.h"
 
 #include <QtCore/QTimer>
 
@@ -17,100 +19,19 @@ namespace MTP {
 class Instance;
 class AuthKey;
 using AuthKeyPtr = std::shared_ptr<AuthKey>;
+enum class DcType;
 
-namespace internal {
-
-// Received msgIds and wereAcked msgIds count stored.
-constexpr auto kIdsBufferSize = 400;
+namespace details {
 
 class Dcenter;
-class Connection;
-
-using PreRequestMap = QMap<mtpRequestId, SecureRequest>;
-using RequestMap = QMap<mtpMsgId, SecureRequest>;
-
-class RequestIdsMap : public QMap<mtpMsgId, mtpRequestId> {
-public:
-	using ParentType = QMap<mtpMsgId, mtpRequestId>;
-
-	mtpMsgId min() const {
-		return size() ? cbegin().key() : 0;
-	}
+class SessionPrivate;
 
-	mtpMsgId max() const {
-		ParentType::const_iterator e(cend());
-		return size() ? (--e).key() : 0;
-	}
-
-};
-
-class ReceivedMsgIds {
-public:
-	bool registerMsgId(mtpMsgId msgId, bool needAck) {
-		auto i = _idsNeedAck.constFind(msgId);
-		if (i == _idsNeedAck.cend()) {
-			if (_idsNeedAck.size() < kIdsBufferSize || msgId > min()) {
-				_idsNeedAck.insert(msgId, needAck);
-				return true;
-			}
-			MTP_LOG(-1, ("No need to handle - %1 < min = %2").arg(msgId).arg(min()));
-		} else {
-			MTP_LOG(-1, ("No need to handle - %1 already is in map").arg(msgId));
-		}
-		return false;
-	}
+enum class TemporaryKeyType;
+enum class CreatingKeyType;
 
-	mtpMsgId min() const {
-		return _idsNeedAck.isEmpty() ? 0 : _idsNeedAck.cbegin().key();
-	}
-
-	mtpMsgId max() const {
-		auto end = _idsNeedAck.cend();
-		return _idsNeedAck.isEmpty() ? 0 : (--end).key();
-	}
-
-	void shrink() {
-		auto size = _idsNeedAck.size();
-		while (size-- > kIdsBufferSize) {
-			_idsNeedAck.erase(_idsNeedAck.begin());
-		}
-	}
-
-	enum class State {
-		NotFound,
-		NeedsAck,
-		NoAckNeeded,
-	};
-	State lookup(mtpMsgId msgId) const {
-		auto i = _idsNeedAck.constFind(msgId);
-		if (i == _idsNeedAck.cend()) {
-			return State::NotFound;
-		}
-		return i.value() ? State::NeedsAck : State::NoAckNeeded;
-	}
-
-	void clear() {
-		_idsNeedAck.clear();
-	}
-
-private:
-	QMap<mtpMsgId, bool> _idsNeedAck;
-
-};
-
-using SerializedMessage = mtpBuffer;
-
-inline bool ResponseNeedsAck(const SerializedMessage &response) {
-	if (response.size() < 8) {
-		return false;
-	}
-	auto seqNo = *(uint32*)(response.constData() + 6);
-	return (seqNo & 0x01) ? true : false;
-}
-
-struct ConnectionOptions {
-	ConnectionOptions() = default;
-	ConnectionOptions(
+struct SessionOptions {
+	SessionOptions() = default;
+	SessionOptions(
 		const QString &systemLangCode,
 		const QString &cloudLangCode,
 		const QString &langPackName,
@@ -119,8 +40,6 @@ struct ConnectionOptions {
 		bool useIPv6,
 		bool useHttp,
 		bool useTcp);
-	ConnectionOptions(const ConnectionOptions &other) = default;
-	ConnectionOptions &operator=(const ConnectionOptions &other) = default;
 
 	QString systemLangCode;
 	QString cloudLangCode;
@@ -130,282 +49,183 @@ struct ConnectionOptions {
 	bool useIPv6 = true;
 	bool useHttp = true;
 	bool useTcp = true;
-	bool inited = false;
 
 };
 
 class Session;
-class SessionData {
+class SessionData final {
 public:
-	SessionData(not_null<Session*> creator) : _owner(creator) {
+	explicit SessionData(not_null<Session*> creator) : _owner(creator) {
 	}
 
-	void setSession(uint64 session) {
-		DEBUG_LOG(("MTP Info: setting server_session: %1").arg(session));
-
-		QWriteLocker locker(&_lock);
-		if (_session != session) {
-			_session = session;
-			_messagesSent = 0;
-		}
-	}
-	uint64 getSession() const {
-		QReadLocker locker(&_lock);
-		return _session;
-	}
-	void setConnectionInited(bool inited = true) {
-		QWriteLocker locker(&_lock);
-		_options.inited = inited;
-	}
-	void notifyConnectionInited(const ConnectionOptions &options);
-	void applyConnectionOptions(ConnectionOptions options) {
-		QWriteLocker locker(&_lock);
-		const auto inited = _options.inited;
+	void notifyConnectionInited(const SessionOptions &options);
+	void setOptions(SessionOptions options) {
+		QWriteLocker locker(&_optionsLock);
 		_options = options;
-		_options.inited = inited;
 	}
-	ConnectionOptions connectionOptions() const {
-		QReadLocker locker(&_lock);
+	[[nodiscard]] SessionOptions options() const {
+		QReadLocker locker(&_optionsLock);
 		return _options;
 	}
 
-	void setSalt(uint64 salt) {
-		QWriteLocker locker(&_lock);
-		_salt = salt;
-	}
-	uint64 getSalt() const {
-		QReadLocker locker(&_lock);
-		return _salt;
-	}
-
-	const AuthKeyPtr &getKey() const {
-		return _authKey;
-	}
-	void setKey(const AuthKeyPtr &key);
-
-	bool isCheckedKey() const {
-		QReadLocker locker(&_lock);
-		return _keyChecked;
-	}
-	void setCheckedKey(bool checked) {
-		QWriteLocker locker(&_lock);
-		_keyChecked = checked;
-	}
-
-	not_null<QReadWriteLock*> keyMutex() const;
-
-	not_null<QReadWriteLock*> toSendMutex() const {
+	not_null<QReadWriteLock*> toSendMutex() {
 		return &_toSendLock;
 	}
-	not_null<QReadWriteLock*> haveSentMutex() const {
+	not_null<QReadWriteLock*> haveSentMutex() {
 		return &_haveSentLock;
 	}
-	not_null<QReadWriteLock*> toResendMutex() const {
-		return &_toResendLock;
-	}
-	not_null<QReadWriteLock*> wereAckedMutex() const {
-		return &_wereAckedLock;
-	}
-	not_null<QReadWriteLock*> receivedIdsMutex() const {
-		return &_receivedIdsLock;
-	}
-	not_null<QReadWriteLock*> haveReceivedMutex() const {
+	not_null<QReadWriteLock*> haveReceivedMutex() {
 		return &_haveReceivedLock;
 	}
-	not_null<QReadWriteLock*> stateRequestMutex() const {
-		return &_stateRequestLock;
-	}
 
-	PreRequestMap &toSendMap() {
-		return _toSend;
-	}
-	const PreRequestMap &toSendMap() const {
+	base::flat_map<mtpRequestId, SerializedRequest> &toSendMap() {
 		return _toSend;
 	}
-	RequestMap &haveSentMap() {
+	base::flat_map<mtpMsgId, SerializedRequest> &haveSentMap() {
 		return _haveSent;
 	}
-	const RequestMap &haveSentMap() const {
-		return _haveSent;
-	}
-	RequestIdsMap &toResendMap() { // msgId -> requestId, on which toSend: requestId -> request for resended requests
-		return _toResend;
-	}
-	const RequestIdsMap &toResendMap() const {
-		return _toResend;
-	}
-	ReceivedMsgIds &receivedIdsSet() {
-		return _receivedIds;
-	}
-	const ReceivedMsgIds &receivedIdsSet() const {
-		return _receivedIds;
-	}
-	RequestIdsMap &wereAckedMap() {
-		return _wereAcked;
-	}
-	const RequestIdsMap &wereAckedMap() const {
-		return _wereAcked;
-	}
-	QMap<mtpRequestId, SerializedMessage> &haveReceivedResponses() {
+	base::flat_map<mtpRequestId, mtpBuffer> &haveReceivedResponses() {
 		return _receivedResponses;
 	}
-	const QMap<mtpRequestId, SerializedMessage> &haveReceivedResponses() const {
-		return _receivedResponses;
-	}
-	QList<SerializedMessage> &haveReceivedUpdates() {
-		return _receivedUpdates;
-	}
-	const QList<SerializedMessage> &haveReceivedUpdates() const {
+	std::vector<mtpBuffer> &haveReceivedUpdates() {
 		return _receivedUpdates;
 	}
-	QMap<mtpMsgId, bool> &stateRequestMap() {
-		return _stateRequest;
-	}
-	const QMap<mtpMsgId, bool> &stateRequestMap() const {
-		return _stateRequest;
-	}
 
-	not_null<Session*> owner() {
-		return _owner;
-	}
-	not_null<const Session*> owner() const {
-		return _owner;
-	}
+	// SessionPrivate -> Session interface.
+	void queueTryToReceive();
+	void queueNeedToResumeAndSend();
+	void queueConnectionStateChange(int newState);
+	void queueResetDone();
+	void queueSendAnything(crl::time msCanWait = 0);
 
-	uint32 nextRequestSeqNumber(bool needAck = true) {
-		QWriteLocker locker(&_lock);
-		auto result = _messagesSent;
-		_messagesSent += (needAck ? 1 : 0);
-		return result * 2 + (needAck ? 1 : 0);
-	}
+	[[nodiscard]] bool connectionInited() const;
+	[[nodiscard]] AuthKeyPtr getPersistentKey() const;
+	[[nodiscard]] AuthKeyPtr getTemporaryKey(TemporaryKeyType type) const;
+	[[nodiscard]] CreatingKeyType acquireKeyCreation(DcType type);
+	[[nodiscard]] bool releaseKeyCreationOnDone(
+		const AuthKeyPtr &temporaryKey,
+		const AuthKeyPtr &persistentKeyUsedForBind);
+	[[nodiscard]] bool releaseCdnKeyCreationOnDone(
+		const AuthKeyPtr &temporaryKey);
+	void releaseKeyCreationOnFail();
+	void destroyTemporaryKey(uint64 keyId);
 
-	void clear(Instance *instance);
+	void detach();
 
 private:
-	uint64 _session = 0;
-	uint64 _salt = 0;
-
-	uint32 _messagesSent = 0;
-
-	not_null<Session*> _owner;
-
-	AuthKeyPtr _authKey;
-	bool _keyChecked = false;
-	bool _layerInited = false;
-	ConnectionOptions _options;
-
-	PreRequestMap _toSend; // map of request_id -> request, that is waiting to be sent
-	RequestMap _haveSent; // map of msg_id -> request, that was sent, msDate = 0 for msgs_state_req (no resend / state req), msDate = 0, seqNo = 0 for containers
-	RequestIdsMap _toResend; // map of msg_id -> request_id, that request_id -> request lies in toSend and is waiting to be resent
-	ReceivedMsgIds _receivedIds; // set of received msg_id's, for checking new msg_ids
-	RequestIdsMap _wereAcked; // map of msg_id -> request_id, this msg_ids already were acked or do not need ack
-	QMap<mtpMsgId, bool> _stateRequest; // set of msg_id's, whose state should be requested
-
-	QMap<mtpRequestId, SerializedMessage> _receivedResponses; // map of request_id -> response that should be processed in the main thread
-	QList<SerializedMessage> _receivedUpdates; // list of updates that should be processed in the main thread
-
-	// mutexes
-	mutable QReadWriteLock _lock;
-	mutable QReadWriteLock _toSendLock;
-	mutable QReadWriteLock _haveSentLock;
-	mutable QReadWriteLock _toResendLock;
-	mutable QReadWriteLock _receivedIdsLock;
-	mutable QReadWriteLock _wereAckedLock;
-	mutable QReadWriteLock _haveReceivedLock;
-	mutable QReadWriteLock _stateRequestLock;
+	template <typename Callback>
+	void withSession(Callback &&callback);
 
-};
+	Session *_owner = nullptr;
+	mutable QMutex _ownerMutex;
+
+	SessionOptions _options;
+	mutable QReadWriteLock _optionsLock;
 
-class Session : public QObject {
-	Q_OBJECT
+	base::flat_map<mtpRequestId, SerializedRequest> _toSend; // map of request_id -> request, that is waiting to be sent
+	QReadWriteLock _toSendLock;
 
+	base::flat_map<mtpMsgId, SerializedRequest> _haveSent; // map of msg_id -> request, that was sent
+	QReadWriteLock _haveSentLock;
+
+	base::flat_map<mtpRequestId, mtpBuffer> _receivedResponses; // map of request_id -> response that should be processed in the main thread
+	std::vector<mtpBuffer> _receivedUpdates; // list of updates that should be processed in the main thread
+	QReadWriteLock _haveReceivedLock;
+
+};
+
+class Session final : public QObject {
 public:
-	Session(not_null<Instance*> instance, ShiftedDcId shiftedDcId);
+	// Main thread.
+	Session(
+		not_null<Instance*> instance,
+		not_null<QThread*> thread,
+		ShiftedDcId shiftedDcId,
+		not_null<Dcenter*> dc);
+	~Session();
 
 	void start();
+	void reInitConnection();
+
 	void restart();
 	void refreshOptions();
-	void reInitConnection();
 	void stop();
 	void kill();
 
 	void unpaused();
 
-	ShiftedDcId getDcWithShift() const;
+	// Thread-safe.
+	[[nodiscard]] ShiftedDcId getDcWithShift() const;
+	[[nodiscard]] AuthKeyPtr getPersistentKey() const;
+	[[nodiscard]] AuthKeyPtr getTemporaryKey(TemporaryKeyType type) const;
+	[[nodiscard]] bool connectionInited() const;
+	void sendPrepared(
+		const SerializedRequest &request,
+		crl::time msCanWait = 0);
+
+	// SessionPrivate thread.
+	[[nodiscard]] CreatingKeyType acquireKeyCreation(DcType type);
+	[[nodiscard]] bool releaseKeyCreationOnDone(
+		const AuthKeyPtr &temporaryKey,
+		const AuthKeyPtr &persistentKeyUsedForBind);
+	[[nodiscard]] bool releaseCdnKeyCreationOnDone(const AuthKeyPtr &temporaryKey);
+	void releaseKeyCreationOnFail();
+	void destroyTemporaryKey(uint64 keyId);
 
-	QReadWriteLock *keyMutex() const;
-	void notifyKeyCreated(AuthKeyPtr &&key);
-	void destroyKey();
 	void notifyDcConnectionInited();
 
 	void ping();
 	void cancel(mtpRequestId requestId, mtpMsgId msgId);
-	int32 requestState(mtpRequestId requestId) const;
-	int32 getState() const;
+	int requestState(mtpRequestId requestId) const;
+	int getState() const;
 	QString transport() const;
 
-	// Nulls msgId and seqNo in request, if newRequest = true.
-	void sendPrepared(
-		const SecureRequest &request,
-		crl::time msCanWait = 0,
-		bool newRequest = true);
-
-	~Session();
-
-signals:
-	void authKeyCreated();
-	void needToSend();
-	void needToPing();
-	void needToRestart();
-
-public slots:
+	void tryToReceive();
 	void needToResumeAndSend();
+	void connectionStateChange(int newState);
+	void resetDone();
+	void sendAnything(crl::time msCanWait = 0);
 
-	mtpRequestId resend(quint64 msgId, qint64 msCanWait = 0, bool forceContainer = false, bool sendMsgStateInfo = false);
-	void resendMany(QVector<quint64> msgIds, qint64 msCanWait, bool forceContainer, bool sendMsgStateInfo);
-	void resendAll(); // after connection restart
+private:
+	void watchDcKeyChanges();
+	void watchDcOptionsChanges();
 
-	void authKeyCreatedForDC();
-	void connectionWasInitedForDC();
+	void killConnection();
 
-	void tryToReceive();
-	void checkRequestsByTimer();
-	void onConnectionStateChange(qint32 newState);
-	void onResetDone();
+	bool rpcErrorOccured(
+		mtpRequestId requestId,
+		const RPCFailHandlerPtr &onFail,
+		const RPCError &err);
 
-	void sendAnything(qint64 msCanWait = 0);
-	void sendPong(quint64 msgId, quint64 pingId);
-	void sendMsgsStateInfo(quint64 msgId, QByteArray data);
+	[[nodiscard]] bool releaseGenericKeyCreationOnDone(
+		const AuthKeyPtr &temporaryKey,
+		const AuthKeyPtr &persistentKeyUsedForBind);
 
-private:
-	void createDcData();
-
-	bool rpcErrorOccured(mtpRequestId requestId, const RPCFailHandlerPtr &onFail, const RPCError &err);
+	const not_null<Instance*> _instance;
+	const ShiftedDcId _shiftedDcId = 0;
+	const not_null<Dcenter*> _dc;
+	const std::shared_ptr<SessionData> _data;
+	const not_null<QThread*> _thread;
 
-	not_null<Instance*> _instance;
-	std::unique_ptr<Connection> _connection;
+	SessionPrivate *_private = nullptr;
 
 	bool _killed = false;
 	bool _needToReceive = false;
 
-	SessionData data;
-
-	ShiftedDcId dcWithShift = 0;
-	std::shared_ptr<Dcenter> dc;
+	AuthKeyPtr _dcKeyForCheck;
+	CreatingKeyType _myKeyCreation = CreatingKeyType();
 
-	crl::time msSendCall = 0;
-	crl::time msWait = 0;
+	crl::time _msSendCall = 0;
+	crl::time _msWait = 0;
 
 	bool _ping = false;
 
-	QTimer timeouter;
-	base::Timer sender;
+	base::Timer _timeouter;
+	base::Timer _sender;
 
-};
+	rpl::lifetime _lifetime;
 
-inline not_null<QReadWriteLock*> SessionData::keyMutex() const {
-	return _owner->keyMutex();
-}
+};
 
-} // namespace internal
+} // namespace details
 } // namespace MTP
diff --git a/Telegram/SourceFiles/mtproto/session_private.cpp b/Telegram/SourceFiles/mtproto/session_private.cpp
new file mode 100644
index 000000000..57c8de37a
--- /dev/null
+++ b/Telegram/SourceFiles/mtproto/session_private.cpp
@@ -0,0 +1,2609 @@
+/*
+This file is part of Telegram Desktop,
+the official desktop application for the Telegram messaging service.
+
+For license and copyright information please follow this link:
+https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+*/
+#include "mtproto/session_private.h"
+
+#include "mtproto/details/mtproto_bound_key_creator.h"
+#include "mtproto/details/mtproto_dcenter.h"
+#include "mtproto/details/mtproto_dump_to_text.h"
+#include "mtproto/details/mtproto_rsa_public_key.h"
+#include "mtproto/session.h"
+#include "mtproto/mtproto_rpc_sender.h"
+#include "mtproto/dc_options.h"
+#include "mtproto/connection_abstract.h"
+#include "base/openssl_help.h"
+#include "base/qthelp_url.h"
+#include "base/unixtime.h"
+#include "zlib.h"
+
+namespace MTP {
+namespace details {
+namespace {
+
+constexpr auto kIntSize = static_cast<int>(sizeof(mtpPrime));
+constexpr auto kWaitForBetterTimeout = crl::time(2000);
+constexpr auto kMinConnectedTimeout = crl::time(1000);
+constexpr auto kMaxConnectedTimeout = crl::time(8000);
+constexpr auto kMinReceiveTimeout = crl::time(4000);
+constexpr auto kMaxReceiveTimeout = crl::time(64000);
+constexpr auto kMarkConnectionOldTimeout = crl::time(192000);
+constexpr auto kPingDelayDisconnect = 60;
+constexpr auto kPingSendAfter = 30 * crl::time(1000);
+constexpr auto kPingSendAfterForce = 45 * crl::time(1000);
+constexpr auto kTemporaryExpiresIn = TimeId(86400);
+constexpr auto kBindKeyAdditionalExpiresTimeout = TimeId(30);
+constexpr auto kTestModeDcIdShift = 10000;
+constexpr auto kCheckSentRequestsEach = 1 * crl::time(1000);
+constexpr auto kKeyOldEnoughForDestroy = 60 * crl::time(1000);
+constexpr auto kSentContainerLives = 600 * crl::time(1000);
+
+// If we can't connect for this time we will ask _instance to update config.
+constexpr auto kRequestConfigTimeout = 8 * crl::time(1000);
+
+// Don't try to handle messages larger than this size.
+constexpr auto kMaxMessageLength = 16 * 1024 * 1024;
+
+// How much time passed from send till we resend request or check its state.
+constexpr auto kCheckSentRequestTimeout = 10 * crl::time(1000);
+
+// How much time to wait for some more requests,
+// when resending request or checking its state.
+constexpr auto kSendStateRequestWaiting = crl::time(1000);
+
+// How much time to wait for some more requests, when sending msg acks.
+constexpr auto kAckSendWaiting = 10 * crl::time(1000);
+
+using namespace details;
+
+[[nodiscard]] QString LogIdsVector(const QVector<MTPlong> &ids) {
+	if (!ids.size()) return "[]";
+	auto idsStr = QString("[%1").arg(ids.cbegin()->v);
+	for (const auto &id : ids) {
+		idsStr += QString(", %2").arg(id.v);
+	}
+	return idsStr + "]";
+}
+
+[[nodiscard]] QString LogIds(const QVector<uint64> &ids) {
+	if (!ids.size()) return "[]";
+	auto idsStr = QString("[%1").arg(*ids.cbegin());
+	for (const auto id : ids) {
+		idsStr += QString(", %2").arg(id);
+	}
+	return idsStr + "]";
+}
+
+void WrapInvokeAfter(
+		SerializedRequest &to,
+		const SerializedRequest &from,
+		const base::flat_map<mtpMsgId, SerializedRequest> &haveSent,
+		int32 skipBeforeRequest = 0) {
+	const auto afterId = *(mtpMsgId*)(from->after->data() + 4);
+	const auto i = afterId ? haveSent.find(afterId) : haveSent.end();
+	int32 size = to->size(), lenInInts = (tl::count_length(from) >> 2), headlen = 4, fulllen = headlen + lenInInts;
+	if (i == haveSent.end()) { // no invoke after or such msg was not sent or was completed recently
+		to->resize(size + fulllen + skipBeforeRequest);
+		if (skipBeforeRequest) {
+			memcpy(to->data() + size, from->constData() + 4, headlen * sizeof(mtpPrime));
+			memcpy(to->data() + size + headlen + skipBeforeRequest, from->constData() + 4 + headlen, lenInInts * sizeof(mtpPrime));
+		} else {
+			memcpy(to->data() + size, from->constData() + 4, fulllen * sizeof(mtpPrime));
+		}
+	} else {
+		to->resize(size + fulllen + skipBeforeRequest + 3);
+		memcpy(to->data() + size, from->constData() + 4, headlen * sizeof(mtpPrime));
+		(*to)[size + 3] += 3 * sizeof(mtpPrime);
+		*((mtpTypeId*)&((*to)[size + headlen + skipBeforeRequest])) = mtpc_invokeAfterMsg;
+		memcpy(to->data() + size + headlen + skipBeforeRequest + 1, &afterId, 2 * sizeof(mtpPrime));
+		memcpy(to->data() + size + headlen + skipBeforeRequest + 3, from->constData() + 4 + headlen, lenInInts * sizeof(mtpPrime));
+		if (size + 3 != 7) (*to)[7] += 3 * sizeof(mtpPrime);
+	}
+}
+
+} // namespace
+
+SessionPrivate::SessionPrivate(
+	not_null<Instance*> instance,
+	not_null<QThread*> thread,
+	std::shared_ptr<SessionData> data,
+	ShiftedDcId shiftedDcId)
+: QObject(nullptr)
+, _instance(instance)
+, _shiftedDcId(shiftedDcId)
+, _realDcType(_instance->dcOptions()->dcType(_shiftedDcId))
+, _currentDcType(_realDcType)
+, _state(DisconnectedState)
+, _retryTimer(thread, [=] { retryByTimer(); })
+, _oldConnectionTimer(thread, [=] { markConnectionOld(); })
+, _waitForConnectedTimer(thread, [=] { waitConnectedFailed(); })
+, _waitForReceivedTimer(thread, [=] { waitReceivedFailed(); })
+, _waitForBetterTimer(thread, [=] { waitBetterFailed(); })
+, _waitForReceived(kMinReceiveTimeout)
+, _waitForConnected(kMinConnectedTimeout)
+, _pingSender(thread, [=] { sendPingByTimer(); })
+, _checkSentRequestsTimer(thread, [=] { checkSentRequests(); })
+, _sessionData(std::move(data)) {
+	Expects(_shiftedDcId != 0);
+
+	moveToThread(thread);
+
+	InvokeQueued(this, [=] {
+		_checkSentRequestsTimer.callEach(kCheckSentRequestsEach);
+		connectToServer();
+	});
+}
+
+SessionPrivate::~SessionPrivate() {
+	releaseKeyCreationOnFail();
+	doDisconnect();
+
+	Expects(!_connection);
+	Expects(_testConnections.empty());
+}
+
+void SessionPrivate::appendTestConnection(
+		DcOptions::Variants::Protocol protocol,
+		const QString &ip,
+		int port,
+		const bytes::vector &protocolSecret) {
+	QWriteLocker lock(&_stateMutex);
+
+	const auto priority = (qthelp::is_ipv6(ip) ? 0 : 1)
+		+ (protocol == DcOptions::Variants::Tcp ? 1 : 0)
+		+ (protocolSecret.empty() ? 0 : 1);
+	_testConnections.push_back({
+		AbstractConnection::Create(
+			_instance,
+			protocol,
+			thread(),
+			protocolSecret,
+			_options->proxy),
+		priority
+	});
+	const auto weak = _testConnections.back().data.get();
+	connect(weak, &AbstractConnection::error, [=](int errorCode) {
+		onError(weak, errorCode);
+	});
+	connect(weak, &AbstractConnection::receivedSome, [=] {
+		onReceivedSome();
+	});
+	_firstSentAt = 0;
+	if (_oldConnection) {
+		_oldConnection = false;
+		DEBUG_LOG(("This connection marked as not old!"));
+	}
+	_oldConnectionTimer.callOnce(kMarkConnectionOldTimeout);
+	connect(weak, &AbstractConnection::connected, [=] {
+		onConnected(weak);
+	});
+	connect(weak, &AbstractConnection::disconnected, [=] {
+		onDisconnected(weak);
+	});
+	connect(weak, &AbstractConnection::syncTimeRequest, [=] {
+		InvokeQueued(_instance, [instance = _instance] {
+			instance->syncHttpUnixtime();
+		});
+	});
+
+	InvokeQueued(_testConnections.back().data, [=] {
+		weak->connectToServer(ip, port, protocolSecret, getProtocolDcId());
+	});
+}
+
+int16 SessionPrivate::getProtocolDcId() const {
+	const auto dcId = BareDcId(_shiftedDcId);
+	const auto simpleDcId = isTemporaryDcId(dcId)
+		? getRealIdFromTemporaryDcId(dcId)
+		: dcId;
+	const auto testedDcId = cTestMode()
+		? (kTestModeDcIdShift + simpleDcId)
+		: simpleDcId;
+	return (_currentDcType == DcType::MediaCluster)
+		? -testedDcId
+		: testedDcId;
+}
+
+void SessionPrivate::checkSentRequests() {
+	clearOldContainers();
+
+	const auto now = crl::now();
+	if (_bindMsgId && _bindMessageSent + kCheckSentRequestTimeout < now) {
+		DEBUG_LOG(("MTP Info: "
+			"Request state while key is not bound, restarting."));
+		restart();
+		return;
+	}
+	auto requesting = false;
+	{
+		QReadLocker locker(_sessionData->haveSentMutex());
+		auto &haveSent = _sessionData->haveSentMap();
+		const auto haveSentCount = haveSent.size();
+		const auto checkAfter = kCheckSentRequestTimeout;
+		for (const auto &[msgId, request] : haveSent) {
+			if (request->lastSentTime + checkAfter < now) {
+				// Need to check state.
+				request->lastSentTime = now;
+				if (_stateRequestData.emplace(msgId).second) {
+					requesting = true;
+				}
+			}
+		}
+	}
+	if (requesting) {
+		_sessionData->queueSendAnything(kSendStateRequestWaiting);
+	}
+}
+
+void SessionPrivate::clearOldContainers() {
+	auto resent = false;
+	const auto now = crl::now();
+	for (auto i = _sentContainers.begin(); i != _sentContainers.end();) {
+		if (now > i->second.sent + kSentContainerLives) {
+			DEBUG_LOG(("MTP Info: Removing old container with resending %1, "
+				"sent: %2, now: %3, current unixtime: %4"
+				).arg(i->first
+				).arg(i->second.sent
+				).arg(now
+				).arg(base::unixtime::now()));
+
+			const auto ids = std::move(i->second.messages);
+			i = _sentContainers.erase(i);
+
+			resent = resent || !ids.empty();
+			for (const auto innerMsgId : ids) {
+				resend(innerMsgId, -1, true);
+			}
+		} else {
+			++i;
+		}
+	}
+	if (resent) {
+		_sessionData->queueNeedToResumeAndSend();
+	}
+}
+
+void SessionPrivate::destroyAllConnections() {
+	clearUnboundKeyCreator();
+	_waitForBetterTimer.cancel();
+	_waitForReceivedTimer.cancel();
+	_waitForConnectedTimer.cancel();
+	_testConnections.clear();
+	_connection = nullptr;
+}
+
+void SessionPrivate::cdnConfigChanged() {
+	connectToServer(true);
+}
+
+int32 SessionPrivate::getShiftedDcId() const {
+	return _shiftedDcId;
+}
+
+void SessionPrivate::dcOptionsChanged() {
+	_retryTimeout = 1;
+	connectToServer(true);
+}
+
+int32 SessionPrivate::getState() const {
+	QReadLocker lock(&_stateMutex);
+	int32 result = _state;
+	if (_state < 0) {
+		if (_retryTimer.isActive()) {
+			result = int32(crl::now() - _retryWillFinish);
+			if (result >= 0) {
+				result = -1;
+			}
+		}
+	}
+	return result;
+}
+
+QString SessionPrivate::transport() const {
+	QReadLocker lock(&_stateMutex);
+	if (!_connection || (_state < 0)) {
+		return QString();
+	}
+
+	Assert(_options != nullptr);
+	return _connection->transport();
+}
+
+bool SessionPrivate::setState(int state, int ifState) {
+	if (ifState != kUpdateStateAlways) {
+		QReadLocker lock(&_stateMutex);
+		if (_state != ifState) {
+			return false;
+		}
+	}
+
+	QWriteLocker lock(&_stateMutex);
+	if (_state == state) {
+		return false;
+	}
+	_state = state;
+	if (state < 0) {
+		_retryTimeout = -state;
+		_retryTimer.callOnce(_retryTimeout);
+		_retryWillFinish = crl::now() + _retryTimeout;
+	}
+	lock.unlock();
+
+	_sessionData->queueConnectionStateChange(state);
+	return true;
+}
+
+void SessionPrivate::resetSession() {
+	MTP_LOG(_shiftedDcId, ("Resetting session!"));
+	_needSessionReset = false;
+
+	DEBUG_LOG(("MTP Info: creating new session in resetSession."));
+	changeSessionId();
+
+	_sessionData->queueResetDone();
+}
+
+void SessionPrivate::changeSessionId() {
+	auto sessionId = _sessionId;
+	do {
+		sessionId = openssl::RandomValue<uint64>();
+	} while (_sessionId == sessionId);
+
+	DEBUG_LOG(("MTP Info: setting server_session: %1").arg(sessionId));
+
+	_sessionId = sessionId;
+	_messagesCounter = 0;
+	_sessionMarkedAsStarted = false;
+	_ackRequestData.clear();
+	_resendRequestData.clear();
+	_stateRequestData.clear();
+	_receivedMessageIds.clear();
+}
+
+uint32 SessionPrivate::nextRequestSeqNumber(bool needAck) {
+	const auto result = _messagesCounter;
+	_messagesCounter += (needAck ? 1 : 0);
+	return result * 2 + (needAck ? 1 : 0);
+}
+
+bool SessionPrivate::realDcTypeChanged() {
+	const auto now = _instance->dcOptions()->dcType(_shiftedDcId);
+	if (_realDcType == now) {
+		return false;
+	}
+	_realDcType = now;
+	return true;
+}
+
+bool SessionPrivate::markSessionAsStarted() {
+	if (_sessionMarkedAsStarted) {
+		return false;
+	}
+	_sessionMarkedAsStarted = true;
+	return true;
+}
+
+mtpMsgId SessionPrivate::prepareToSend(
+		SerializedRequest &request,
+		mtpMsgId currentLastId,
+		bool forceNewMsgId) {
+	Expects(request->size() > 8);
+
+	if (const auto msgId = request.getMsgId()) {
+		// resending this request
+		const auto i = _resendingIds.find(msgId);
+		if (i != _resendingIds.cend()) {
+			_resendingIds.erase(i);
+		}
+
+		return (forceNewMsgId || msgId > currentLastId)
+			? replaceMsgId(request, currentLastId)
+			: msgId;
+	}
+	request.setMsgId(currentLastId);
+	request.setSeqNo(nextRequestSeqNumber(request.needAck()));
+	if (request->requestId) {
+		MTP_LOG(_shiftedDcId, ("[r%1] msg_id 0 -> %2").arg(request->requestId).arg(currentLastId));
+	}
+	return currentLastId;
+}
+
+mtpMsgId SessionPrivate::replaceMsgId(SerializedRequest &request, mtpMsgId newId) {
+	Expects(request->size() > 8);
+
+	const auto oldMsgId = request.getMsgId();
+	if (oldMsgId == newId) {
+		return newId;
+	}
+	// haveSentMutex() was locked in tryToSend()
+	auto &haveSent = _sessionData->haveSentMap();
+
+	while (_resendingIds.contains(newId)
+		|| _ackedIds.contains(newId)
+		|| haveSent.contains(newId)) {
+		newId = base::unixtime::mtproto_msg_id();
+	}
+
+	MTP_LOG(_shiftedDcId, ("[r%1] msg_id %2 -> %3"
+		).arg(request->requestId
+		).arg(oldMsgId
+		).arg(newId));
+
+	const auto i = _resendingIds.find(oldMsgId);
+	if (i != _resendingIds.end()) {
+		const auto requestId = i->second;
+		_resendingIds.erase(i);
+		_resendingIds.emplace(newId, requestId);
+	}
+
+	const auto j = _ackedIds.find(oldMsgId);
+	if (j != _ackedIds.end()) {
+		const auto requestId = j->second;
+		_ackedIds.erase(j);
+		_ackedIds.emplace(newId, requestId);
+	}
+
+	const auto k = haveSent.find(oldMsgId);
+	if (k != haveSent.end()) {
+		const auto request = k->second;
+		haveSent.erase(k);
+		haveSent.emplace(newId, request);
+	}
+	for (auto &[msgId, container] : _sentContainers) {
+		for (auto &innerMsgId : container.messages) {
+			if (innerMsgId == oldMsgId) {
+				innerMsgId = newId;
+			}
+		}
+	}
+	request.setMsgId(newId);
+	request.setSeqNo(nextRequestSeqNumber(request.needAck()));
+	return newId;
+}
+
+mtpMsgId SessionPrivate::placeToContainer(
+		SerializedRequest &toSendRequest,
+		mtpMsgId &bigMsgId,
+		bool forceNewMsgId,
+		SerializedRequest &req) {
+	const auto msgId = prepareToSend(req, bigMsgId, forceNewMsgId);
+	if (msgId >= bigMsgId) {
+		bigMsgId = base::unixtime::mtproto_msg_id();
+	}
+
+	uint32 from = toSendRequest->size(), len = req.messageSize();
+	toSendRequest->resize(from + len);
+	memcpy(toSendRequest->data() + from, req->constData() + 4, len * sizeof(mtpPrime));
+
+	return msgId;
+}
+
+void SessionPrivate::tryToSend() {
+	DEBUG_LOG(("MTP Info: tryToSend for dc %1.").arg(_shiftedDcId));
+	if (!_connection) {
+		DEBUG_LOG(("MTP Info: not yet connected in dc %1.").arg(_shiftedDcId));
+		return;
+	} else if (!_keyId) {
+		DEBUG_LOG(("MTP Info: not yet with auth key in dc %1.").arg(_shiftedDcId));
+		return;
+	}
+
+	const auto needsLayer = !_sessionData->connectionInited();
+	const auto state = getState();
+	const auto sendOnlyFirstPing = (state != ConnectedState);
+	const auto sendAll = !sendOnlyFirstPing && !_keyCreator;
+	const auto isMainSession = (GetDcIdShift(_shiftedDcId) == 0);
+	if (sendOnlyFirstPing && !_pingIdToSend) {
+		DEBUG_LOG(("MTP Info: dc %1 not sending, waiting for Connected state, state: %2").arg(_shiftedDcId).arg(state));
+		return; // just do nothing, if is not connected yet
+	} else if (isMainSession
+		&& !sendOnlyFirstPing
+		&& !_pingIdToSend
+		&& !_pingId
+		&& _pingSendAt <= crl::now()) {
+		_pingIdToSend = openssl::RandomValue<mtpPingId>();
+	}
+	const auto forceNewMsgId = sendAll && markSessionAsStarted();
+	if (forceNewMsgId && _keyCreator) {
+		_keyCreator->restartBinder();
+	}
+
+	auto pingRequest = SerializedRequest();
+	auto ackRequest = SerializedRequest();
+	auto resendRequest = SerializedRequest();
+	auto stateRequest = SerializedRequest();
+	auto httpWaitRequest = SerializedRequest();
+	auto bindDcKeyRequest = SerializedRequest();
+	if (_pingIdToSend) {
+		if (sendOnlyFirstPing || !isMainSession) {
+			DEBUG_LOG(("MTP Info: sending ping, ping_id: %1"
+				).arg(_pingIdToSend));
+			pingRequest = SerializedRequest::Serialize(MTPPing(
+				MTP_long(_pingIdToSend)
+			));
+		} else {
+			DEBUG_LOG(("MTP Info: sending ping_delay_disconnect, "
+				"ping_id: %1").arg(_pingIdToSend));
+			pingRequest = SerializedRequest::Serialize(MTPPing_delay_disconnect(
+				MTP_long(_pingIdToSend),
+				MTP_int(kPingDelayDisconnect)));
+			_pingSender.callOnce(kPingSendAfterForce);
+		}
+		_pingSendAt = pingRequest->lastSentTime + kPingSendAfter;
+		_pingId = base::take(_pingIdToSend);
+	} else if (!sendAll) {
+		DEBUG_LOG(("MTP Info: dc %1 sending only service or bind."
+			).arg(_shiftedDcId));
+	} else {
+		DEBUG_LOG(("MTP Info: dc %1 trying to send after ping, state: %2"
+			).arg(_shiftedDcId
+			).arg(state));
+	}
+
+	if (!sendOnlyFirstPing) {
+		if (!_ackRequestData.isEmpty()) {
+			ackRequest = SerializedRequest::Serialize(MTPMsgsAck(
+				MTP_msgs_ack(MTP_vector<MTPlong>(
+					base::take(_ackRequestData)))));
+		}
+		if (!_resendRequestData.isEmpty()) {
+			resendRequest = SerializedRequest::Serialize(MTPMsgResendReq(
+				MTP_msg_resend_req(MTP_vector<MTPlong>(
+					base::take(_resendRequestData)))));
+		}
+		if (!_stateRequestData.empty()) {
+			auto ids = QVector<MTPlong>();
+			ids.reserve(_stateRequestData.size());
+			for (const auto id : base::take(_stateRequestData)) {
+				ids.push_back(MTP_long(id));
+			}
+			stateRequest = SerializedRequest::Serialize(MTPMsgsStateReq(
+				MTP_msgs_state_req(MTP_vector<MTPlong>(ids))));
+		}
+		if (_connection->usingHttpWait()) {
+			httpWaitRequest = SerializedRequest::Serialize(MTPHttpWait(
+				MTP_http_wait(MTP_int(100), MTP_int(30), MTP_int(25000))));
+		}
+		if (!_bindMsgId && _keyCreator && _keyCreator->readyToBind()) {
+			bindDcKeyRequest = _keyCreator->prepareBindRequest(
+				_encryptionKey,
+				_sessionId);
+
+			// This is a special request with msgId used inside the message
+			// body, so it is prepared already with a msgId and we place
+			// seqNo for it manually here.
+			bindDcKeyRequest.setSeqNo(
+				nextRequestSeqNumber(bindDcKeyRequest.needAck()));
+		}
+	}
+
+	MTPInitConnection<SerializedRequest> initWrapper;
+	int32 initSize = 0, initSizeInInts = 0;
+	if (needsLayer) {
+		Assert(_options != nullptr);
+		const auto systemLangCode = _options->systemLangCode;
+		const auto cloudLangCode = _options->cloudLangCode;
+		const auto langPackName = _options->langPackName;
+		const auto deviceModel = (_currentDcType == DcType::Cdn)
+			? "n/a"
+			: _instance->deviceModel();
+		const auto systemVersion = (_currentDcType == DcType::Cdn)
+			? "n/a"
+			: _instance->systemVersion();
+#if defined OS_MAC_STORE
+		const auto appVersion = QString::fromLatin1(AppVersionStr)
+			+ " mac store";
+#elif defined OS_WIN_STORE // OS_MAC_STORE
+		const auto appVersion = QString::fromLatin1(AppVersionStr)
+			+ " win store";
+#else // OS_MAC_STORE || OS_WIN_STORE
+		const auto appVersion = QString::fromLatin1(AppVersionStr);
+#endif // OS_MAC_STORE || OS_WIN_STORE
+		const auto proxyType = _options->proxy.type;
+		const auto mtprotoProxy = (proxyType == ProxyData::Type::Mtproto);
+		const auto clientProxyFields = mtprotoProxy
+			? MTP_inputClientProxy(
+				MTP_string(_options->proxy.host),
+				MTP_int(_options->proxy.port))
+			: MTPInputClientProxy();
+		using Flag = MTPInitConnection<SerializedRequest>::Flag;
+		initWrapper = MTPInitConnection<SerializedRequest>(
+			MTP_flags(mtprotoProxy ? Flag::f_proxy : Flag(0)),
+			MTP_int(ApiId),
+			MTP_string(deviceModel),
+			MTP_string(systemVersion),
+			MTP_string(appVersion),
+			MTP_string(systemLangCode),
+			MTP_string(langPackName),
+			MTP_string(cloudLangCode),
+			clientProxyFields,
+			SerializedRequest());
+		initSizeInInts = (tl::count_length(initWrapper) >> 2) + 2;
+		initSize = initSizeInInts * sizeof(mtpPrime);
+	}
+
+	bool needAnyResponse = false;
+	SerializedRequest toSendRequest;
+	{
+		QWriteLocker locker1(_sessionData->toSendMutex());
+
+		auto toSendDummy = base::flat_map<mtpRequestId, SerializedRequest>();
+		auto &toSend = sendAll
+			? _sessionData->toSendMap()
+			: toSendDummy;
+		if (!sendAll) {
+			locker1.unlock();
+		}
+
+		uint32 toSendCount = toSend.size();
+		if (pingRequest) ++toSendCount;
+		if (ackRequest) ++toSendCount;
+		if (resendRequest) ++toSendCount;
+		if (stateRequest) ++toSendCount;
+		if (httpWaitRequest) ++toSendCount;
+		if (bindDcKeyRequest) ++toSendCount;
+
+		if (!toSendCount) {
+			return; // nothing to send
+		}
+
+		const auto first = pingRequest
+			? pingRequest
+			: ackRequest
+			? ackRequest
+			: resendRequest
+			? resendRequest
+			: stateRequest
+			? stateRequest
+			: httpWaitRequest
+			? httpWaitRequest
+			: bindDcKeyRequest
+			? bindDcKeyRequest
+			: toSend.begin()->second;
+		if (toSendCount == 1 && !first->forceSendInContainer) {
+			toSendRequest = first;
+			if (sendAll) {
+				toSend.clear();
+				locker1.unlock();
+			}
+
+			const auto msgId = prepareToSend(
+				toSendRequest,
+				base::unixtime::mtproto_msg_id(),
+				forceNewMsgId && !bindDcKeyRequest);
+			if (bindDcKeyRequest) {
+				_bindMsgId = msgId;
+				_bindMessageSent = crl::now();
+				needAnyResponse = true;
+			} else if (pingRequest) {
+				_pingMsgId = msgId;
+				needAnyResponse = true;
+			} else if (stateRequest || resendRequest) {
+				_stateAndResendRequests.emplace(
+					msgId,
+					stateRequest ? stateRequest : resendRequest);
+				needAnyResponse = true;
+			}
+
+			if (toSendRequest->requestId) {
+				if (toSendRequest.needAck()) {
+					toSendRequest->lastSentTime = crl::now();
+
+					QWriteLocker locker2(_sessionData->haveSentMutex());
+					auto &haveSent = _sessionData->haveSentMap();
+					haveSent.emplace(msgId, toSendRequest);
+
+					const auto wrapLayer = needsLayer && toSendRequest->needsLayer;
+					if (toSendRequest->after) {
+						const auto toSendSize = tl::count_length(toSendRequest) >> 2;
+						auto wrappedRequest = SerializedRequest::Prepare(
+							toSendSize,
+							toSendSize + 3);
+						wrappedRequest->resize(4);
+						memcpy(wrappedRequest->data(), toSendRequest->constData(), 4 * sizeof(mtpPrime));
+						WrapInvokeAfter(wrappedRequest, toSendRequest, haveSent);
+						toSendRequest = std::move(wrappedRequest);
+					}
+					if (wrapLayer) {
+						const auto noWrapSize = (tl::count_length(toSendRequest) >> 2);
+						const auto toSendSize = noWrapSize + initSizeInInts;
+						auto wrappedRequest = SerializedRequest::Prepare(toSendSize);
+						memcpy(wrappedRequest->data(), toSendRequest->constData(), 7 * sizeof(mtpPrime)); // all except length
+						wrappedRequest->push_back(mtpc_invokeWithLayer);
+						wrappedRequest->push_back(kCurrentLayer);
+						initWrapper.write<mtpBuffer>(*wrappedRequest);
+						wrappedRequest->resize(wrappedRequest->size() + noWrapSize);
+						memcpy(wrappedRequest->data() + wrappedRequest->size() - noWrapSize, toSendRequest->constData() + 8, noWrapSize * sizeof(mtpPrime));
+						toSendRequest = std::move(wrappedRequest);
+					}
+
+					needAnyResponse = true;
+				} else {
+					_ackedIds.emplace(msgId, toSendRequest->requestId);
+				}
+			}
+		} else { // send in container
+			bool willNeedInit = false;
+			uint32 containerSize = 1 + 1; // cons + vector size
+			if (pingRequest) containerSize += pingRequest.messageSize();
+			if (ackRequest) containerSize += ackRequest.messageSize();
+			if (resendRequest) containerSize += resendRequest.messageSize();
+			if (stateRequest) containerSize += stateRequest.messageSize();
+			if (httpWaitRequest) containerSize += httpWaitRequest.messageSize();
+			if (bindDcKeyRequest) containerSize += bindDcKeyRequest.messageSize();
+			for (const auto &[requestId, request] : toSend) {
+				containerSize += request.messageSize();
+				if (needsLayer && request->needsLayer) {
+					containerSize += initSizeInInts;
+					willNeedInit = true;
+				}
+			}
+			mtpBuffer initSerialized;
+			if (willNeedInit) {
+				initSerialized.reserve(initSizeInInts);
+				initSerialized.push_back(mtpc_invokeWithLayer);
+				initSerialized.push_back(kCurrentLayer);
+				initWrapper.write<mtpBuffer>(initSerialized);
+			}
+			// prepare container + each in invoke after
+			toSendRequest = SerializedRequest::Prepare(
+				containerSize,
+				containerSize + 3 * toSend.size());
+			toSendRequest->push_back(mtpc_msg_container);
+			toSendRequest->push_back(toSendCount);
+
+			// check for a valid container
+			auto bigMsgId = base::unixtime::mtproto_msg_id();
+
+			// the fact of this lock is used in replaceMsgId()
+			QWriteLocker locker2(_sessionData->haveSentMutex());
+			auto &haveSent = _sessionData->haveSentMap();
+
+			// prepare sent container
+			auto sentIdsWrap = SentContainer();
+			sentIdsWrap.sent = crl::now();
+			sentIdsWrap.messages.reserve(toSendCount);
+
+			if (bindDcKeyRequest) {
+				_bindMsgId = placeToContainer(
+					toSendRequest,
+					bigMsgId,
+					false,
+					bindDcKeyRequest);
+				_bindMessageSent = crl::now();
+				needAnyResponse = true;
+			}
+			if (pingRequest) {
+				_pingMsgId = placeToContainer(
+					toSendRequest,
+					bigMsgId,
+					forceNewMsgId,
+					pingRequest);
+				needAnyResponse = true;
+			}
+
+			for (auto &[requestId, request] : toSend) {
+				const auto msgId = prepareToSend(
+					request,
+					bigMsgId,
+					forceNewMsgId);
+				if (msgId >= bigMsgId) {
+					bigMsgId = base::unixtime::mtproto_msg_id();
+				}
+				bool added = false;
+				if (request->requestId) {
+					if (request.needAck()) {
+						request->lastSentTime = crl::now();
+						int32 reqNeedsLayer = (needsLayer && request->needsLayer) ? toSendRequest->size() : 0;
+						if (request->after) {
+							WrapInvokeAfter(toSendRequest, request, haveSent, reqNeedsLayer ? initSizeInInts : 0);
+							if (reqNeedsLayer) {
+								memcpy(toSendRequest->data() + reqNeedsLayer + 4, initSerialized.constData(), initSize);
+								*(toSendRequest->data() + reqNeedsLayer + 3) += initSize;
+							}
+							added = true;
+						} else if (reqNeedsLayer) {
+							toSendRequest->resize(reqNeedsLayer + initSizeInInts + request.messageSize());
+							memcpy(toSendRequest->data() + reqNeedsLayer, request->constData() + 4, 4 * sizeof(mtpPrime));
+							memcpy(toSendRequest->data() + reqNeedsLayer + 4, initSerialized.constData(), initSize);
+							memcpy(toSendRequest->data() + reqNeedsLayer + 4 + initSizeInInts, request->constData() + 8, tl::count_length(request));
+							*(toSendRequest->data() + reqNeedsLayer + 3) += initSize;
+							added = true;
+						}
+
+						// #TODO rewrite so that it will always hold.
+						//Assert(!haveSent.contains(msgId));
+						haveSent.emplace(msgId, request);
+						sentIdsWrap.messages.push_back(msgId);
+						needAnyResponse = true;
+					} else {
+						_ackedIds.emplace(msgId, request->requestId);
+					}
+				}
+				if (!added) {
+					uint32 from = toSendRequest->size(), len = request.messageSize();
+					toSendRequest->resize(from + len);
+					memcpy(toSendRequest->data() + from, request->constData() + 4, len * sizeof(mtpPrime));
+				}
+			}
+			toSend.clear();
+
+			if (stateRequest) {
+				const auto msgId = placeToContainer(
+					toSendRequest,
+					bigMsgId,
+					forceNewMsgId,
+					stateRequest);
+				_stateAndResendRequests.emplace(msgId, stateRequest);
+				needAnyResponse = true;
+			}
+			if (resendRequest) {
+				const auto msgId = placeToContainer(
+					toSendRequest,
+					bigMsgId,
+					forceNewMsgId,
+					resendRequest);
+				_stateAndResendRequests.emplace(msgId, resendRequest);
+				needAnyResponse = true;
+			}
+			if (ackRequest) {
+				placeToContainer(
+					toSendRequest,
+					bigMsgId,
+					forceNewMsgId,
+					ackRequest);
+			}
+			if (httpWaitRequest) {
+				placeToContainer(
+					toSendRequest,
+					bigMsgId,
+					forceNewMsgId,
+					httpWaitRequest);
+			}
+
+			const auto containerMsgId = prepareToSend(
+				toSendRequest,
+				bigMsgId,
+				forceNewMsgId);
+			_sentContainers.emplace(containerMsgId, std::move(sentIdsWrap));
+		}
+	}
+	sendSecureRequest(std::move(toSendRequest), needAnyResponse);
+}
+
+void SessionPrivate::retryByTimer() {
+	if (_retryTimeout < 3) {
+		++_retryTimeout;
+	} else if (_retryTimeout == 3) {
+		_retryTimeout = 1000;
+	} else if (_retryTimeout < 64000) {
+		_retryTimeout *= 2;
+	}
+	connectToServer();
+}
+
+void SessionPrivate::restartNow() {
+	_retryTimeout = 1;
+	_retryTimer.cancel();
+	restart();
+}
+
+void SessionPrivate::connectToServer(bool afterConfig) {
+	if (afterConfig && (!_testConnections.empty() || _connection)) {
+		return;
+	}
+
+	destroyAllConnections();
+
+	if (realDcTypeChanged() && _keyCreator) {
+		destroyTemporaryKey();
+		return;
+	}
+
+	_options = std::make_unique<SessionOptions>(_sessionData->options());
+
+	const auto bareDc = BareDcId(_shiftedDcId);
+
+	_currentDcType = tryAcquireKeyCreation();
+	if (_currentDcType == DcType::Cdn && !_instance->isKeysDestroyer()) {
+		if (!_instance->dcOptions()->hasCDNKeysForDc(bareDc)) {
+			requestCDNConfig();
+			return;
+		}
+	}
+	if (_options->proxy.type == ProxyData::Type::Mtproto) {
+		// host, port, secret for mtproto proxy are taken from proxy.
+		appendTestConnection(DcOptions::Variants::Tcp, {}, 0, {});
+	} else {
+		using Variants = DcOptions::Variants;
+		const auto special = (_currentDcType == DcType::Temporary);
+		const auto variants = _instance->dcOptions()->lookup(
+			bareDc,
+			_currentDcType,
+			_options->proxy.type != ProxyData::Type::None);
+		const auto useIPv4 = special ? true : _options->useIPv4;
+		const auto useIPv6 = special ? false : _options->useIPv6;
+		const auto useTcp = special ? true : _options->useTcp;
+		const auto useHttp = special ? false : _options->useHttp;
+		const auto skipAddress = !useIPv4
+			? Variants::IPv4
+			: !useIPv6
+			? Variants::IPv6
+			: Variants::AddressTypeCount;
+		const auto skipProtocol = !useTcp
+			? Variants::Tcp
+			: !useHttp
+			? Variants::Http
+			: Variants::ProtocolCount;
+		for (auto address = 0; address != Variants::AddressTypeCount; ++address) {
+			if (address == skipAddress) {
+				continue;
+			}
+			for (auto protocol = 0; protocol != Variants::ProtocolCount; ++protocol) {
+				if (protocol == skipProtocol) {
+					continue;
+				}
+				for (const auto &endpoint : variants.data[address][protocol]) {
+					appendTestConnection(
+						static_cast<Variants::Protocol>(protocol),
+						QString::fromStdString(endpoint.ip),
+						endpoint.port,
+						endpoint.secret);
+				}
+			}
+		}
+	}
+	if (_testConnections.empty()) {
+		if (_instance->isKeysDestroyer()) {
+			LOG(("MTP Error: DC %1 options for not found for auth key destruction!").arg(_shiftedDcId));
+			_instance->keyWasPossiblyDestroyed(_shiftedDcId);
+			return;
+		} else if (afterConfig) {
+			LOG(("MTP Error: DC %1 options for not found right after config load!").arg(_shiftedDcId));
+			return restart();
+		}
+		DEBUG_LOG(("MTP Info: DC %1 options not found, waiting for config").arg(_shiftedDcId));
+		InvokeQueued(_instance, [instance = _instance] {
+			instance->requestConfig();
+		});
+		return;
+	}
+	DEBUG_LOG(("Connection Info: Connecting to %1 with %2 test connections."
+		).arg(_shiftedDcId
+		).arg(_testConnections.size()));
+
+	if (!_startedConnectingAt) {
+		_startedConnectingAt = crl::now();
+	} else if (crl::now() - _startedConnectingAt > kRequestConfigTimeout) {
+		InvokeQueued(_instance, [instance = _instance] {
+			instance->requestConfigIfOld();
+		});
+	}
+
+	_retryTimer.cancel();
+	_waitForConnectedTimer.cancel();
+
+	setState(ConnectingState);
+
+	_bindMsgId = 0;
+	_pingId = _pingMsgId = _pingIdToSend = _pingSendAt = 0;
+	_pingSender.cancel();
+
+	_waitForConnectedTimer.callOnce(_waitForConnected);
+}
+
+void SessionPrivate::restart() {
+	DEBUG_LOG(("MTP Info: restarting Connection"));
+
+	_waitForReceivedTimer.cancel();
+	_waitForConnectedTimer.cancel();
+
+	doDisconnect();
+
+	if (_needSessionReset) {
+		resetSession();
+	}
+	if (_retryTimer.isActive()) {
+		return;
+	}
+
+	DEBUG_LOG(("MTP Info: restart timeout: %1ms").arg(_retryTimeout));
+
+	setState(-_retryTimeout);
+}
+
+void SessionPrivate::onSentSome(uint64 size) {
+	if (!_waitForReceivedTimer.isActive()) {
+		auto remain = static_cast<uint64>(_waitForReceived);
+		if (!_oldConnection) {
+			// 8kb / sec, so 512 kb give 64 sec
+			auto remainBySize = size * _waitForReceived / 8192;
+			remain = snap(remainBySize, remain, uint64(kMaxReceiveTimeout));
+			if (remain != _waitForReceived) {
+				DEBUG_LOG(("Checking connect for request with size %1 bytes, delay will be %2").arg(size).arg(remain));
+			}
+		}
+		if (isUploadDcId(_shiftedDcId)) {
+			remain *= cNetUploadSessionsCount();
+		}
+		_waitForReceivedTimer.callOnce(remain);
+	}
+	if (!_firstSentAt) {
+		_firstSentAt = crl::now();
+	}
+}
+
+void SessionPrivate::onReceivedSome() {
+	if (_oldConnection) {
+		_oldConnection = false;
+		DEBUG_LOG(("This connection marked as not old!"));
+	}
+	_oldConnectionTimer.callOnce(kMarkConnectionOldTimeout);
+	_waitForReceivedTimer.cancel();
+	if (_firstSentAt > 0) {
+		const auto ms = crl::now() - _firstSentAt;
+		DEBUG_LOG(("MTP Info: response in %1ms, _waitForReceived: %2ms"
+			).arg(ms
+			).arg(_waitForReceived));
+
+		if (ms > 0 && ms * 2 < _waitForReceived) {
+			_waitForReceived = qMax(ms * 2, kMinReceiveTimeout);
+		}
+		_firstSentAt = -1;
+	}
+}
+
+void SessionPrivate::markConnectionOld() {
+	_oldConnection = true;
+	_waitForReceived = kMinReceiveTimeout;
+	DEBUG_LOG(("This connection marked as old! _waitForReceived now %1ms"
+		).arg(_waitForReceived));
+}
+
+void SessionPrivate::sendPingByTimer() {
+	if (_pingId) {
+		// _pingSendAt: when to send next ping (lastPingAt + kPingSendAfter)
+		// could be equal to zero.
+		const auto now = crl::now();
+		const auto mustSendTill = _pingSendAt
+			+ kPingSendAfterForce
+			- kPingSendAfter;
+		if (mustSendTill < now + 1000) {
+			LOG(("Could not send ping for some seconds, restarting..."));
+			return restart();
+		} else {
+			_pingSender.callOnce(mustSendTill - now);
+		}
+	} else {
+		_sessionData->queueNeedToResumeAndSend();
+	}
+}
+
+void SessionPrivate::sendPingForce() {
+	DEBUG_LOG(("MTP Info: send ping force for dcWithShift %1.").arg(_shiftedDcId));
+	if (!_pingId) {
+		_pingSendAt = 0;
+		DEBUG_LOG(("Will send ping!"));
+		tryToSend();
+	}
+}
+
+void SessionPrivate::waitReceivedFailed() {
+	Expects(_options != nullptr);
+
+	DEBUG_LOG(("MTP Info: bad connection, _waitForReceived: %1ms").arg(_waitForReceived));
+	if (_waitForReceived < kMaxReceiveTimeout) {
+		_waitForReceived *= 2;
+	}
+	doDisconnect();
+	if (_retryTimer.isActive()) {
+		return;
+	}
+
+	DEBUG_LOG(("MTP Info: immediate restart!"));
+	InvokeQueued(this, [=] { connectToServer(); });
+
+	const auto instance = _instance;
+	const auto shiftedDcId = _shiftedDcId;
+	InvokeQueued(instance, [=] {
+		instance->restartedByTimeout(shiftedDcId);
+	});
+}
+
+void SessionPrivate::waitConnectedFailed() {
+	DEBUG_LOG(("MTP Info: can't connect in %1ms").arg(_waitForConnected));
+	auto maxTimeout = kMaxConnectedTimeout;
+	for (const auto &connection : _testConnections) {
+		accumulate_max(maxTimeout, connection.data->fullConnectTimeout());
+	}
+	if (_waitForConnected < maxTimeout) {
+		_waitForConnected = std::min(maxTimeout, 2 * _waitForConnected);
+	}
+
+	connectingTimedOut();
+
+	DEBUG_LOG(("MTP Info: immediate restart!"));
+	InvokeQueued(this, [=] { connectToServer(); });
+}
+
+void SessionPrivate::waitBetterFailed() {
+	confirmBestConnection();
+}
+
+void SessionPrivate::connectingTimedOut() {
+	for (const auto &connection : _testConnections) {
+		connection.data->timedOut();
+	}
+	doDisconnect();
+}
+
+void SessionPrivate::doDisconnect() {
+	destroyAllConnections();
+	setState(DisconnectedState);
+}
+
+void SessionPrivate::requestCDNConfig() {
+	InvokeQueued(_instance, [instance = _instance] {
+		instance->requestCDNConfig();
+	});
+}
+
+void SessionPrivate::handleReceived() {
+	Expects(_encryptionKey != nullptr);
+
+	onReceivedSome();
+
+	while (!_connection->received().empty()) {
+		auto intsBuffer = std::move(_connection->received().front());
+		_connection->received().pop_front();
+
+		constexpr auto kExternalHeaderIntsCount = 6U; // 2 auth_key_id, 4 msg_key
+		constexpr auto kEncryptedHeaderIntsCount = 8U; // 2 salt, 2 session, 2 msg_id, 1 seq_no, 1 length
+		constexpr auto kMinimalEncryptedIntsCount = kEncryptedHeaderIntsCount + 4U; // + 1 data + 3 padding
+		constexpr auto kMinimalIntsCount = kExternalHeaderIntsCount + kMinimalEncryptedIntsCount;
+		auto intsCount = uint32(intsBuffer.size());
+		auto ints = intsBuffer.constData();
+		if ((intsCount < kMinimalIntsCount) || (intsCount > kMaxMessageLength / kIntSize)) {
+			LOG(("TCP Error: bad message received, len %1").arg(intsCount * kIntSize));
+			TCP_LOG(("TCP Error: bad message %1").arg(Logs::mb(ints, intsCount * kIntSize).str()));
+
+			return restart();
+		}
+		if (_keyId != *(uint64*)ints) {
+			LOG(("TCP Error: bad auth_key_id %1 instead of %2 received").arg(_keyId).arg(*(uint64*)ints));
+			TCP_LOG(("TCP Error: bad message %1").arg(Logs::mb(ints, intsCount * kIntSize).str()));
+
+			return restart();
+		}
+
+		auto encryptedInts = ints + kExternalHeaderIntsCount;
+		auto encryptedIntsCount = (intsCount - kExternalHeaderIntsCount) & ~0x03U;
+		auto encryptedBytesCount = encryptedIntsCount * kIntSize;
+		auto decryptedBuffer = QByteArray(encryptedBytesCount, Qt::Uninitialized);
+		auto msgKey = *(MTPint128*)(ints + 2);
+
+#ifdef TDESKTOP_MTPROTO_OLD
+		aesIgeDecrypt_oldmtp(encryptedInts, decryptedBuffer.data(), encryptedBytesCount, _encryptionKey, msgKey);
+#else // TDESKTOP_MTPROTO_OLD
+		aesIgeDecrypt(encryptedInts, decryptedBuffer.data(), encryptedBytesCount, _encryptionKey, msgKey);
+#endif // TDESKTOP_MTPROTO_OLD
+
+		auto decryptedInts = reinterpret_cast<const mtpPrime*>(decryptedBuffer.constData());
+		auto serverSalt = *(uint64*)&decryptedInts[0];
+		auto session = *(uint64*)&decryptedInts[2];
+		auto msgId = *(uint64*)&decryptedInts[4];
+		auto seqNo = *(uint32*)&decryptedInts[6];
+		auto needAck = ((seqNo & 0x01) != 0);
+
+		auto messageLength = *(uint32*)&decryptedInts[7];
+		if (messageLength > kMaxMessageLength) {
+			LOG(("TCP Error: bad messageLength %1").arg(messageLength));
+			TCP_LOG(("TCP Error: bad message %1").arg(Logs::mb(ints, intsCount * kIntSize).str()));
+
+			return restart();
+
+		}
+		auto fullDataLength = kEncryptedHeaderIntsCount * kIntSize + messageLength; // Without padding.
+
+		// Can underflow, but it is an unsigned type, so we just check the range later.
+		auto paddingSize = static_cast<uint32>(encryptedBytesCount) - static_cast<uint32>(fullDataLength);
+
+#ifdef TDESKTOP_MTPROTO_OLD
+		constexpr auto kMinPaddingSize_oldmtp = 0U;
+		constexpr auto kMaxPaddingSize_oldmtp = 15U;
+		auto badMessageLength = (/*paddingSize < kMinPaddingSize_oldmtp || */paddingSize > kMaxPaddingSize_oldmtp);
+
+		auto hashedDataLength = badMessageLength ? encryptedBytesCount : fullDataLength;
+		auto sha1ForMsgKeyCheck = hashSha1(decryptedInts, hashedDataLength);
+
+		constexpr auto kMsgKeyShift_oldmtp = 4U;
+		if (memcmp(&msgKey, sha1ForMsgKeyCheck.data() + kMsgKeyShift_oldmtp, sizeof(msgKey)) != 0) {
+			LOG(("TCP Error: bad SHA1 hash after aesDecrypt in message."));
+			TCP_LOG(("TCP Error: bad message %1").arg(Logs::mb(encryptedInts, encryptedBytesCount).str()));
+
+			return restart();
+		}
+#else // TDESKTOP_MTPROTO_OLD
+		constexpr auto kMinPaddingSize = 12U;
+		constexpr auto kMaxPaddingSize = 1024U;
+		auto badMessageLength = (paddingSize < kMinPaddingSize || paddingSize > kMaxPaddingSize);
+
+		std::array<uchar, 32> sha256Buffer = { { 0 } };
+
+		SHA256_CTX msgKeyLargeContext;
+		SHA256_Init(&msgKeyLargeContext);
+		SHA256_Update(&msgKeyLargeContext, _encryptionKey->partForMsgKey(false), 32);
+		SHA256_Update(&msgKeyLargeContext, decryptedInts, encryptedBytesCount);
+		SHA256_Final(sha256Buffer.data(), &msgKeyLargeContext);
+
+		constexpr auto kMsgKeyShift = 8U;
+		if (memcmp(&msgKey, sha256Buffer.data() + kMsgKeyShift, sizeof(msgKey)) != 0) {
+			LOG(("TCP Error: bad SHA256 hash after aesDecrypt in message"));
+			TCP_LOG(("TCP Error: bad message %1").arg(Logs::mb(encryptedInts, encryptedBytesCount).str()));
+
+			return restart();
+		}
+#endif // TDESKTOP_MTPROTO_OLD
+
+		if (badMessageLength || (messageLength & 0x03)) {
+			LOG(("TCP Error: bad msg_len received %1, data size: %2").arg(messageLength).arg(encryptedBytesCount));
+			TCP_LOG(("TCP Error: bad message %1").arg(Logs::mb(encryptedInts, encryptedBytesCount).str()));
+
+			return restart();
+		}
+
+		TCP_LOG(("TCP Info: decrypted message %1,%2,%3 is %4 len").arg(msgId).arg(seqNo).arg(Logs::b(needAck)).arg(fullDataLength));
+
+		if (session != _sessionId) {
+			LOG(("MTP Error: bad server session received"));
+			TCP_LOG(("MTP Error: bad server session %1 instead of %2 in message received").arg(session).arg(_sessionId));
+
+			return restart();
+		}
+
+		const auto serverTime = int32(msgId >> 32);
+		const auto isReply = ((msgId & 0x03) == 1);
+		if (!isReply && ((msgId & 0x03) != 3)) {
+			LOG(("MTP Error: bad msg_id %1 in message received").arg(msgId));
+
+			return restart();
+		}
+
+		const auto clientTime = base::unixtime::now();
+		const auto badTime = (serverTime > clientTime + 60)
+			|| (serverTime + 300 < clientTime);
+		if (badTime) {
+			DEBUG_LOG(("MTP Info: bad server time from msg_id: %1, my time: %2").arg(serverTime).arg(clientTime));
+		}
+
+		bool wasConnected = (getState() == ConnectedState);
+		if (serverSalt != _sessionSalt) {
+			if (!badTime) {
+				DEBUG_LOG(("MTP Info: other salt received... received: %1, my salt: %2, updating...").arg(serverSalt).arg(_sessionSalt));
+				_sessionSalt = serverSalt;
+
+				if (setState(ConnectedState, ConnectingState)) {
+					resendAll();
+				}
+			} else {
+				DEBUG_LOG(("MTP Info: other salt received... received: %1, my salt: %2").arg(serverSalt).arg(_sessionSalt));
+			}
+		} else {
+			serverSalt = 0; // dont pass to handle method, so not to lock in setSalt()
+		}
+
+		if (needAck) _ackRequestData.push_back(MTP_long(msgId));
+
+		auto res = HandleResult::Success; // if no need to handle, then succeed
+		auto from = decryptedInts + kEncryptedHeaderIntsCount;
+		auto end = from + (messageLength / kIntSize);
+		auto sfrom = decryptedInts + 4U; // msg_id + seq_no + length + message
+		MTP_LOG(_shiftedDcId, ("Recv: ")
+			+ DumpToText(sfrom, end)
+			+ QString(" (protocolDcId:%1,key:%2)"
+			).arg(getProtocolDcId()
+			).arg(_encryptionKey->keyId()));
+
+		if (_receivedMessageIds.registerMsgId(msgId, needAck)) {
+			res = handleOneReceived(from, end, msgId, serverTime, serverSalt, badTime);
+		}
+		_receivedMessageIds.shrink();
+
+		// send acks
+		if (const auto toAckSize = _ackRequestData.size()) {
+			DEBUG_LOG(("MTP Info: will send %1 acks, ids: %2").arg(toAckSize).arg(LogIdsVector(_ackRequestData)));
+			_sessionData->queueSendAnything(kAckSendWaiting);
+		}
+
+		auto lock = QReadLocker(_sessionData->haveReceivedMutex());
+		const auto tryToReceive = !_sessionData->haveReceivedResponses().empty()
+			|| !_sessionData->haveReceivedUpdates().empty();
+		lock.unlock();
+
+		if (tryToReceive) {
+			DEBUG_LOG(("MTP Info: queueTryToReceive() - need to parse in another thread, %1 responses, %2 updates.").arg(_sessionData->haveReceivedResponses().size()).arg(_sessionData->haveReceivedUpdates().size()));
+			_sessionData->queueTryToReceive();
+		}
+
+		if (res != HandleResult::Success && res != HandleResult::Ignored) {
+			if (res == HandleResult::DestroyTemporaryKey) {
+				destroyTemporaryKey();
+			} else if (res == HandleResult::ResetSession) {
+				_needSessionReset = true;
+			}
+			return restart();
+		}
+		_retryTimeout = 1; // reset restart() timer
+
+		_startedConnectingAt = crl::time(0);
+
+		if (!wasConnected) {
+			if (getState() == ConnectedState) {
+				_sessionData->queueNeedToResumeAndSend();
+			}
+		}
+	}
+	if (_connection->needHttpWait()) {
+		_sessionData->queueSendAnything();
+	}
+}
+
+SessionPrivate::HandleResult SessionPrivate::handleOneReceived(
+		const mtpPrime *from,
+		const mtpPrime *end,
+		uint64 msgId,
+		int32 serverTime,
+		uint64 serverSalt,
+		bool badTime) {
+	Expects(from < end);
+
+	switch (mtpTypeId(*from)) {
+
+	case mtpc_gzip_packed: {
+		DEBUG_LOG(("Message Info: gzip container"));
+		mtpBuffer response = ungzip(++from, end);
+		if (response.empty()) {
+			return HandleResult::RestartConnection;
+		}
+		return handleOneReceived(response.data(), response.data() + response.size(), msgId, serverTime, serverSalt, badTime);
+	}
+
+	case mtpc_msg_container: {
+		if (++from >= end) {
+			return HandleResult::ParseError;
+		}
+
+		const mtpPrime *otherEnd;
+		const auto msgsCount = (uint32)*(from++);
+		DEBUG_LOG(("Message Info: container received, count: %1").arg(msgsCount));
+		for (uint32 i = 0; i < msgsCount; ++i) {
+			if (from + 4 >= end) {
+				return HandleResult::ParseError;
+			}
+			otherEnd = from + 4;
+
+			MTPlong inMsgId;
+			if (!inMsgId.read(from, otherEnd)) {
+				return HandleResult::ParseError;
+			}
+			bool isReply = ((inMsgId.v & 0x03) == 1);
+			if (!isReply && ((inMsgId.v & 0x03) != 3)) {
+				LOG(("Message Error: bad msg_id %1 in contained message received").arg(inMsgId.v));
+				return HandleResult::RestartConnection;
+			}
+
+			MTPint inSeqNo;
+			if (!inSeqNo.read(from, otherEnd)) {
+				return HandleResult::ParseError;
+			}
+			MTPint bytes;
+			if (!bytes.read(from, otherEnd)) {
+				return HandleResult::ParseError;
+			}
+			if ((bytes.v & 0x03) || bytes.v < 4) {
+				LOG(("Message Error: bad length %1 of contained message received").arg(bytes.v));
+				return HandleResult::RestartConnection;
+			}
+
+			bool needAck = (inSeqNo.v & 0x01);
+			if (needAck) _ackRequestData.push_back(inMsgId);
+
+			DEBUG_LOG(("Message Info: message from container, msg_id: %1, needAck: %2").arg(inMsgId.v).arg(Logs::b(needAck)));
+
+			otherEnd = from + (bytes.v >> 2);
+			if (otherEnd > end) {
+				return HandleResult::ParseError;
+			}
+
+			auto res = HandleResult::Success; // if no need to handle, then succeed
+			if (_receivedMessageIds.registerMsgId(inMsgId.v, needAck)) {
+				res = handleOneReceived(from, otherEnd, inMsgId.v, serverTime, serverSalt, badTime);
+				badTime = false;
+			}
+			if (res != HandleResult::Success) {
+				return res;
+			}
+
+			from = otherEnd;
+		}
+	} return HandleResult::Success;
+
+	case mtpc_msgs_ack: {
+		MTPMsgsAck msg;
+		if (!msg.read(from, end)) {
+			return HandleResult::ParseError;
+		}
+		const auto &ids = msg.c_msgs_ack().vmsg_ids().v;
+		DEBUG_LOG(("Message Info: acks received, ids: %1"
+			).arg(LogIdsVector(ids)));
+		if (ids.isEmpty()) {
+			return badTime ? HandleResult::Ignored : HandleResult::Success;
+		}
+
+		if (badTime && !requestsFixTimeSalt(ids, serverTime, serverSalt)) {
+			return HandleResult::Ignored;
+		}
+		requestsAcked(ids);
+	} return HandleResult::Success;
+
+	case mtpc_bad_msg_notification: {
+		MTPBadMsgNotification msg;
+		if (!msg.read(from, end)) {
+			return HandleResult::ParseError;
+		}
+		const auto &data(msg.c_bad_msg_notification());
+		LOG(("Message Info: bad message notification received (error_code %3) for msg_id = %1, seq_no = %2").arg(data.vbad_msg_id().v).arg(data.vbad_msg_seqno().v).arg(data.verror_code().v));
+
+		const auto resendId = data.vbad_msg_id().v;
+		const auto errorCode = data.verror_code().v;
+		if (false
+			|| errorCode == 16
+			|| errorCode == 17
+			|| errorCode == 32
+			|| errorCode == 33
+			|| errorCode == 64) { // can handle
+			const auto needResend = false
+				|| (errorCode == 16) // bad msg_id
+				|| (errorCode == 17) // bad msg_id
+				|| (errorCode == 64); // bad container
+			if (errorCode == 64) { // bad container!
+				if (Logs::DebugEnabled()) {
+					const auto i = _sentContainers.find(resendId);
+					if (i == _sentContainers.end()) {
+						LOG(("Message Error: Container not found!"));
+					} else {
+						auto idsList = QStringList();
+						for (const auto innerMsgId : i->second.messages) {
+							idsList.push_back(QString::number(innerMsgId));
+						}
+						LOG(("Message Info: bad container received! messages: %1").arg(idsList.join(',')));
+					}
+				}
+			}
+
+			if (!wasSent(resendId)) {
+				DEBUG_LOG(("Message Error: "
+					"such message was not sent recently %1").arg(resendId));
+				return badTime
+					? HandleResult::Ignored
+					: HandleResult::Success;
+			}
+
+			if (needResend) { // bad msg_id or bad container
+				if (serverSalt) {
+					_sessionSalt = serverSalt;
+				}
+				base::unixtime::update(serverTime, true);
+
+				DEBUG_LOG(("Message Info: unixtime updated, now %1, resending in container...").arg(serverTime));
+
+				resend(resendId, 0, true);
+			} else { // must create new session, because msg_id and msg_seqno are inconsistent
+				if (badTime) {
+					if (serverSalt) {
+						_sessionSalt = serverSalt;
+					}
+					base::unixtime::update(serverTime, true);
+					badTime = false;
+				}
+				LOG(("Message Info: bad message notification received, msgId %1, error_code %2").arg(data.vbad_msg_id().v).arg(errorCode));
+				return HandleResult::ResetSession;
+			}
+		} else { // fatal (except 48, but it must not get here)
+			const auto badMsgId = mtpMsgId(data.vbad_msg_id().v);
+			const auto requestId = wasSent(resendId);
+			if (requestId) {
+				LOG(("Message Error: "
+					"fatal bad message notification received, "
+					"msgId %1, error_code %2, requestId: %3"
+					).arg(badMsgId
+					).arg(errorCode
+					).arg(requestId));
+				auto response = mtpBuffer();
+				MTPRpcError(MTP_rpc_error(
+					MTP_int(500),
+					MTP_string("PROTOCOL_ERROR")
+				)).write(response);
+
+				// Save rpc_error for processing in the main thread.
+				QWriteLocker locker(_sessionData->haveReceivedMutex());
+				_sessionData->haveReceivedResponses().emplace(requestId, response);
+			} else {
+				DEBUG_LOG(("Message Error: "
+					"such message was not sent recently %1").arg(badMsgId));
+			}
+			return badTime
+				? HandleResult::Ignored
+				: HandleResult::Success;
+		}
+	} return HandleResult::Success;
+
+	case mtpc_bad_server_salt: {
+		MTPBadMsgNotification msg;
+		if (!msg.read(from, end)) {
+			return HandleResult::ParseError;
+		}
+		const auto &data = msg.c_bad_server_salt();
+		DEBUG_LOG(("Message Info: bad server salt received (error_code %4) for msg_id = %1, seq_no = %2, new salt: %3").arg(data.vbad_msg_id().v).arg(data.vbad_msg_seqno().v).arg(data.vnew_server_salt().v).arg(data.verror_code().v));
+
+		const auto resendId = data.vbad_msg_id().v;
+		if (!wasSent(resendId)) {
+			DEBUG_LOG(("Message Error: such message was not sent recently %1").arg(resendId));
+			return (badTime ? HandleResult::Ignored : HandleResult::Success);
+		}
+
+		_sessionSalt = data.vnew_server_salt().v;
+		base::unixtime::update(serverTime);
+
+		if (setState(ConnectedState, ConnectingState)) {
+			resendAll();
+		}
+
+		badTime = false;
+
+		DEBUG_LOG(("Message Info: unixtime updated, now %1, server_salt updated, now %2, resending...").arg(serverTime).arg(serverSalt));
+		resend(resendId);
+	} return HandleResult::Success;
+
+	case mtpc_msgs_state_info: {
+		MTPMsgsStateInfo msg;
+		if (!msg.read(from, end)) {
+			return HandleResult::ParseError;
+		}
+		auto &data = msg.c_msgs_state_info();
+
+		auto reqMsgId = data.vreq_msg_id().v;
+		auto &states = data.vinfo().v;
+
+		DEBUG_LOG(("Message Info: msg state received, msgId %1, reqMsgId: %2, HEX states %3").arg(msgId).arg(reqMsgId).arg(Logs::mb(states.data(), states.length()).str()));
+		const auto i = _stateAndResendRequests.find(reqMsgId);
+		if (i == _stateAndResendRequests.end()) {
+			DEBUG_LOG(("Message Error: such message was not sent recently %1").arg(reqMsgId));
+			return (badTime ? HandleResult::Ignored : HandleResult::Success);
+		}
+		if (badTime) {
+			if (serverSalt) {
+				_sessionSalt = serverSalt; // requestsFixTimeSalt with no lookup
+			}
+			base::unixtime::update(serverTime, true);
+
+			DEBUG_LOG(("Message Info: unixtime updated from mtpc_msgs_state_info, now %1").arg(serverTime));
+
+			badTime = false;
+		}
+		const auto originalRequest = i->second;
+		Assert(originalRequest->size() > 8);
+
+		requestsAcked(QVector<MTPlong>(1, MTP_long(reqMsgId)), true);
+
+		auto rFrom = originalRequest->constData() + 8;
+		const auto rEnd = originalRequest->constData() + originalRequest->size();
+		auto toAck = QVector<MTPlong>();
+		if (mtpTypeId(*rFrom) == mtpc_msgs_state_req) {
+			MTPMsgsStateReq request;
+			if (!request.read(rFrom, rEnd)) {
+				LOG(("Message Error: could not parse sent msgs_state_req"));
+				return HandleResult::ParseError;
+			}
+			handleMsgsStates(request.c_msgs_state_req().vmsg_ids().v, states);
+		} else {
+			MTPMsgResendReq request;
+			if (!request.read(rFrom, rEnd)) {
+				LOG(("Message Error: could not parse sent msgs_resend_req"));
+				return HandleResult::ParseError;
+			}
+			handleMsgsStates(request.c_msg_resend_req().vmsg_ids().v, states);
+		}
+	} return HandleResult::Success;
+
+	case mtpc_msgs_all_info: {
+		if (badTime) {
+			DEBUG_LOG(("Message Info: skipping with bad time..."));
+			return HandleResult::Ignored;
+		}
+
+		MTPMsgsAllInfo msg;
+		if (!msg.read(from, end)) {
+			return HandleResult::ParseError;
+		}
+		auto &data = msg.c_msgs_all_info();
+		auto &ids = data.vmsg_ids().v;
+		auto &states = data.vinfo().v;
+
+		DEBUG_LOG(("Message Info: msgs all info received, msgId %1, reqMsgIds: %2, states %3").arg(msgId).arg(LogIdsVector(ids)).arg(Logs::mb(states.data(), states.length()).str()));
+		handleMsgsStates(ids, states);
+	} return HandleResult::Success;
+
+	case mtpc_msg_detailed_info: {
+		MTPMsgDetailedInfo msg;
+		if (!msg.read(from, end)) {
+			return HandleResult::ParseError;
+		}
+		const auto &data(msg.c_msg_detailed_info());
+
+		DEBUG_LOG(("Message Info: msg detailed info, sent msgId %1, answerId %2, status %3, bytes %4").arg(data.vmsg_id().v).arg(data.vanswer_msg_id().v).arg(data.vstatus().v).arg(data.vbytes().v));
+
+		QVector<MTPlong> ids(1, data.vmsg_id());
+		if (badTime) {
+			if (requestsFixTimeSalt(ids, serverTime, serverSalt)) {
+				badTime = false;
+			} else {
+				DEBUG_LOG(("Message Info: error, such message was not sent recently %1").arg(data.vmsg_id().v));
+				return HandleResult::Ignored;
+			}
+		}
+		requestsAcked(ids);
+
+		const auto resMsgId = data.vanswer_msg_id();
+		if (_receivedMessageIds.lookup(resMsgId.v) != ReceivedIdsManager::State::NotFound) {
+			_ackRequestData.push_back(resMsgId);
+		} else {
+			DEBUG_LOG(("Message Info: answer message %1 was not received, requesting...").arg(resMsgId.v));
+			_resendRequestData.push_back(resMsgId);
+		}
+	} return HandleResult::Success;
+
+	case mtpc_msg_new_detailed_info: {
+		if (badTime) {
+			DEBUG_LOG(("Message Info: skipping msg_new_detailed_info with bad time..."));
+			return HandleResult::Ignored;
+		}
+		MTPMsgDetailedInfo msg;
+		if (!msg.read(from, end)) {
+			return HandleResult::ParseError;
+		}
+		const auto &data(msg.c_msg_new_detailed_info());
+
+		DEBUG_LOG(("Message Info: msg new detailed info, answerId %2, status %3, bytes %4").arg(data.vanswer_msg_id().v).arg(data.vstatus().v).arg(data.vbytes().v));
+
+		const auto resMsgId = data.vanswer_msg_id();
+		if (_receivedMessageIds.lookup(resMsgId.v) != ReceivedIdsManager::State::NotFound) {
+			_ackRequestData.push_back(resMsgId);
+		} else {
+			DEBUG_LOG(("Message Info: answer message %1 was not received, requesting...").arg(resMsgId.v));
+			_resendRequestData.push_back(resMsgId);
+		}
+	} return HandleResult::Success;
+
+	case mtpc_rpc_result: {
+		if (from + 3 > end) {
+			return HandleResult::ParseError;
+		}
+		auto response = mtpBuffer();
+
+		MTPlong reqMsgId;
+		if (!reqMsgId.read(++from, end)) {
+			return HandleResult::ParseError;
+		}
+		const auto requestMsgId = reqMsgId.v;
+
+		DEBUG_LOG(("RPC Info: response received for %1, queueing...").arg(requestMsgId));
+
+		QVector<MTPlong> ids(1, reqMsgId);
+		if (badTime) {
+			if (requestsFixTimeSalt(ids, serverTime, serverSalt)) {
+				badTime = false;
+			} else {
+				DEBUG_LOG(("Message Info: error, such message was not sent recently %1").arg(requestMsgId));
+				return HandleResult::Ignored;
+			}
+		}
+
+		mtpTypeId typeId = from[0];
+		if (typeId == mtpc_gzip_packed) {
+			DEBUG_LOG(("RPC Info: gzip container"));
+			response = ungzip(++from, end);
+			if (response.empty()) {
+				return HandleResult::RestartConnection;
+			}
+			typeId = response[0];
+		} else {
+			response.resize(end - from);
+			memcpy(response.data(), from, (end - from) * sizeof(mtpPrime));
+		}
+		if (typeId == mtpc_rpc_error) {
+			if (IsDestroyedTemporaryKeyError(response)) {
+				return HandleResult::DestroyTemporaryKey;
+			}
+			// An error could be some RPC_CALL_FAIL or other error inside
+			// the initConnection, so we're not sure yet that it was inited.
+			// Wait till a good response is received.
+		} else {
+			_sessionData->notifyConnectionInited(*_options);
+		}
+		requestsAcked(ids, true);
+
+		const auto bindResult = handleBindResponse(requestMsgId, response);
+		if (bindResult != HandleResult::Ignored) {
+			return bindResult;
+		}
+		const auto requestId = wasSent(requestMsgId);
+		if (requestId && requestId != mtpRequestId(0xFFFFFFFF)) {
+			// Save rpc_result for processing in the main thread.
+			QWriteLocker locker(_sessionData->haveReceivedMutex());
+			_sessionData->haveReceivedResponses().emplace(requestId, response);
+		} else {
+			DEBUG_LOG(("RPC Info: requestId not found for msgId %1").arg(requestMsgId));
+		}
+	} return HandleResult::Success;
+
+	case mtpc_new_session_created: {
+		const mtpPrime *start = from;
+		MTPNewSession msg;
+		if (!msg.read(from, end)) {
+			return HandleResult::ParseError;
+		}
+		const auto &data(msg.c_new_session_created());
+
+		if (badTime) {
+			if (requestsFixTimeSalt(QVector<MTPlong>(1, data.vfirst_msg_id()), serverTime, serverSalt)) {
+				badTime = false;
+			} else {
+				DEBUG_LOG(("Message Info: error, such message was not sent recently %1").arg(data.vfirst_msg_id().v));
+				return HandleResult::Ignored;
+			}
+		}
+
+		DEBUG_LOG(("Message Info: new server session created, unique_id %1, first_msg_id %2, server_salt %3").arg(data.vunique_id().v).arg(data.vfirst_msg_id().v).arg(data.vserver_salt().v));
+		_sessionSalt = data.vserver_salt().v;
+
+		mtpMsgId firstMsgId = data.vfirst_msg_id().v;
+		QVector<quint64> toResend;
+		{
+			QReadLocker locker(_sessionData->haveSentMutex());
+			const auto &haveSent = _sessionData->haveSentMap();
+			toResend.reserve(haveSent.size());
+			for (const auto &[msgId, request] : haveSent) {
+				if (msgId >= firstMsgId) {
+					break;
+				} else if (request->requestId) {
+					toResend.push_back(msgId);
+				}
+			}
+		}
+		for (const auto msgId : toResend) {
+			resend(msgId, 10, true);
+		}
+
+		mtpBuffer update(from - start);
+		if (from > start) memcpy(update.data(), start, (from - start) * sizeof(mtpPrime));
+
+		// Notify main process about new session - need to get difference.
+		QWriteLocker locker(_sessionData->haveReceivedMutex());
+		_sessionData->haveReceivedUpdates().push_back(mtpBuffer(update));
+	} return HandleResult::Success;
+
+	case mtpc_pong: {
+		MTPPong msg;
+		if (!msg.read(from, end)) {
+			return HandleResult::ParseError;
+		}
+		const auto &data(msg.c_pong());
+		DEBUG_LOG(("Message Info: pong received, msg_id: %1, ping_id: %2").arg(data.vmsg_id().v).arg(data.vping_id().v));
+
+		if (!wasSent(data.vmsg_id().v)) {
+			DEBUG_LOG(("Message Error: such msg_id %1 ping_id %2 was not sent recently").arg(data.vmsg_id().v).arg(data.vping_id().v));
+			return HandleResult::Ignored;
+		}
+		if (data.vping_id().v == _pingId) {
+			_pingId = 0;
+		} else {
+			DEBUG_LOG(("Message Info: just pong..."));
+		}
+
+		QVector<MTPlong> ids(1, data.vmsg_id());
+		if (badTime) {
+			if (requestsFixTimeSalt(ids, serverTime, serverSalt)) {
+				badTime = false;
+			} else {
+				return HandleResult::Ignored;
+			}
+		}
+		requestsAcked(ids, true);
+	} return HandleResult::Success;
+
+	}
+
+	if (badTime) {
+		DEBUG_LOG(("Message Error: bad time in updates cons, must create new session"));
+		return HandleResult::ResetSession;
+	}
+
+	if (_currentDcType == DcType::Regular) {
+		mtpBuffer update(end - from);
+		if (end > from) {
+			memcpy(update.data(), from, (end - from) * sizeof(mtpPrime));
+		}
+
+		// Notify main process about the new updates.
+		QWriteLocker locker(_sessionData->haveReceivedMutex());
+		_sessionData->haveReceivedUpdates().push_back(mtpBuffer(update));
+	} else {
+		LOG(("Message Error: unexpected updates in dcType: %1"
+			).arg(static_cast<int>(_currentDcType)));
+	}
+
+	return HandleResult::Success;
+}
+
+SessionPrivate::HandleResult SessionPrivate::handleBindResponse(
+		mtpMsgId requestMsgId,
+		const mtpBuffer &response) {
+	if (!_keyCreator || !_bindMsgId || _bindMsgId != requestMsgId) {
+		return HandleResult::Ignored;
+	}
+	_bindMsgId = 0;
+
+	const auto result = _keyCreator->handleBindResponse(response);
+	switch (result) {
+	case DcKeyBindState::Success:
+		if (!_sessionData->releaseKeyCreationOnDone(
+			_encryptionKey,
+			base::take(_keyCreator)->bindPersistentKey())) {
+			return HandleResult::DestroyTemporaryKey;
+		}
+		_sessionData->queueNeedToResumeAndSend();
+		return HandleResult::Success;
+	case DcKeyBindState::DefinitelyDestroyed:
+		if (destroyOldEnoughPersistentKey()) {
+			return HandleResult::DestroyTemporaryKey;
+		}
+		[[fallthrough]];
+	case DcKeyBindState::Failed:
+		_sessionData->queueNeedToResumeAndSend();
+		return HandleResult::Success;
+	}
+	Unexpected("Result of BoundKeyCreator::handleBindResponse.");
+}
+
+mtpBuffer SessionPrivate::ungzip(const mtpPrime *from, const mtpPrime *end) const {
+	mtpBuffer result; // * 4 because of mtpPrime type
+	result.resize(0);
+
+	MTPstring packed;
+	if (!packed.read(from, end)) { // read packed string as serialized mtp string type
+		LOG(("RPC Error: could not read gziped bytes."));
+		return result;
+	}
+	uint32 packedLen = packed.v.size(), unpackedChunk = packedLen, unpackedLen = 0;
+
+	z_stream stream;
+	stream.zalloc = 0;
+	stream.zfree = 0;
+	stream.opaque = 0;
+	stream.avail_in = 0;
+	stream.next_in = 0;
+	int res = inflateInit2(&stream, 16 + MAX_WBITS);
+	if (res != Z_OK) {
+		LOG(("RPC Error: could not init zlib stream, code: %1").arg(res));
+		return result;
+	}
+	stream.avail_in = packedLen;
+	stream.next_in = reinterpret_cast<Bytef*>(packed.v.data());
+
+	stream.avail_out = 0;
+	while (!stream.avail_out) {
+		result.resize(result.size() + unpackedChunk);
+		stream.avail_out = unpackedChunk * sizeof(mtpPrime);
+		stream.next_out = (Bytef*)&result[result.size() - unpackedChunk];
+		int res = inflate(&stream, Z_NO_FLUSH);
+		if (res != Z_OK && res != Z_STREAM_END) {
+			inflateEnd(&stream);
+			LOG(("RPC Error: could not unpack gziped data, code: %1").arg(res));
+			DEBUG_LOG(("RPC Error: bad gzip: %1").arg(Logs::mb(packed.v.constData(), packedLen).str()));
+			return mtpBuffer();
+		}
+	}
+	if (stream.avail_out & 0x03) {
+		uint32 badSize = result.size() * sizeof(mtpPrime) - stream.avail_out;
+		LOG(("RPC Error: bad length of unpacked data %1").arg(badSize));
+		DEBUG_LOG(("RPC Error: bad unpacked data %1").arg(Logs::mb(result.data(), badSize).str()));
+		return mtpBuffer();
+	}
+	result.resize(result.size() - (stream.avail_out >> 2));
+	inflateEnd(&stream);
+	if (!result.size()) {
+		LOG(("RPC Error: bad length of unpacked data 0"));
+	}
+	return result;
+}
+
+bool SessionPrivate::requestsFixTimeSalt(const QVector<MTPlong> &ids, int32 serverTime, uint64 serverSalt) {
+	uint32 idsCount = ids.size();
+
+	for (uint32 i = 0; i < idsCount; ++i) {
+		if (wasSent(ids[i].v)) {// found such msg_id in recent acked requests or in recent sent requests
+			if (serverSalt) {
+				_sessionSalt = serverSalt;
+			}
+			base::unixtime::update(serverTime, true);
+			return true;
+		}
+	}
+	return false;
+}
+
+void SessionPrivate::requestsAcked(const QVector<MTPlong> &ids, bool byResponse) {
+	uint32 idsCount = ids.size();
+
+	DEBUG_LOG(("Message Info: requests acked, ids %1").arg(LogIdsVector(ids)));
+
+	QVector<MTPlong> toAckMore;
+	{
+		QWriteLocker locker2(_sessionData->haveSentMutex());
+		auto &haveSent = _sessionData->haveSentMap();
+
+		for (const auto &wrappedMsgId : ids) {
+			const auto msgId = wrappedMsgId.v;
+			if (const auto i = _sentContainers.find(msgId); i != end(_sentContainers)) {
+				DEBUG_LOG(("Message Info: container ack received, msgId %1").arg(msgId));
+				const auto &list = i->second.messages;
+				toAckMore.reserve(toAckMore.size() + list.size());
+				for (const auto msgId : list) {
+					toAckMore.push_back(MTP_long(msgId));
+				}
+				_sentContainers.erase(i);
+				continue;
+			}
+			if (const auto i = _stateAndResendRequests.find(msgId); i != end(_stateAndResendRequests)) {
+				_stateAndResendRequests.erase(i);
+				continue;
+			}
+			if (const auto i = haveSent.find(msgId); i != end(haveSent)) {
+				const auto requestId = i->second->requestId;
+
+				if (!byResponse && _instance->hasCallbacks(requestId)) {
+					DEBUG_LOG(("Message Info: ignoring ACK for msgId %1 because request %2 requires a response").arg(msgId).arg(requestId));
+					continue;
+				}
+				haveSent.erase(i);
+
+				_ackedIds.emplace(msgId, requestId);
+				continue;
+			}
+			DEBUG_LOG(("Message Info: msgId %1 was not found in recent sent, while acking requests, searching in resend...").arg(msgId));
+			if (const auto i = _resendingIds.find(msgId); i != end(_resendingIds)) {
+				const auto requestId = i->second;
+
+				if (!byResponse && _instance->hasCallbacks(requestId)) {
+					DEBUG_LOG(("Message Info: ignoring ACK for msgId %1 because request %2 requires a response").arg(msgId).arg(requestId));
+					continue;
+				}
+				_resendingIds.erase(i);
+
+				QWriteLocker locker4(_sessionData->toSendMutex());
+				auto &toSend = _sessionData->toSendMap();
+				const auto j = toSend.find(requestId);
+				if (j == end(toSend)) {
+					DEBUG_LOG(("Message Info: msgId %1 was found in recent resent, requestId %2 was not found in prepared to send").arg(msgId).arg(requestId));
+					continue;
+				}
+				if (j->second->requestId != requestId) {
+					DEBUG_LOG(("Message Error: for msgId %1 found resent request, requestId %2, contains requestId %3").arg(msgId).arg(requestId).arg(j->second->requestId));
+				} else {
+					DEBUG_LOG(("Message Info: acked msgId %1 that was prepared to resend, requestId %2").arg(msgId).arg(requestId));
+				}
+				toSend.erase(j);
+
+				_ackedIds.emplace(msgId, j->second->requestId);
+				continue;
+			}
+			DEBUG_LOG(("Message Info: msgId %1 was not found in recent resent either").arg(msgId));
+		}
+	}
+
+	auto ackedCount = _ackedIds.size();
+	if (ackedCount > kIdsBufferSize) {
+		DEBUG_LOG(("Message Info: removing some old acked sent msgIds %1").arg(ackedCount - kIdsBufferSize));
+		while (ackedCount-- > kIdsBufferSize) {
+			_ackedIds.erase(_ackedIds.begin());
+		}
+	}
+
+	if (toAckMore.size()) {
+		requestsAcked(toAckMore);
+	}
+}
+
+void SessionPrivate::handleMsgsStates(const QVector<MTPlong> &ids, const QByteArray &states) {
+	const auto idsCount = ids.size();
+	if (!idsCount) {
+		DEBUG_LOG(("Message Info: void ids vector in handleMsgsStates()"));
+		return;
+	}
+	if (states.size() != idsCount) {
+		LOG(("Message Error: got less states than required ids count."));
+		return;
+	}
+
+	auto acked = QVector<MTPlong>();
+	acked.reserve(idsCount);
+	for (auto i = 0; i != idsCount; ++i) {
+		const auto state = states[i];
+		const auto requestMsgId = ids[i].v;
+		{
+			QReadLocker locker(_sessionData->haveSentMutex());
+			if (!_sessionData->haveSentMap().contains(requestMsgId)) {
+				DEBUG_LOG(("Message Info: state was received for msgId %1, but request is not found, looking in resent requests...").arg(requestMsgId));
+				const auto reqIt = _resendingIds.find(requestMsgId);
+				if (reqIt != _resendingIds.cend()) {
+					if ((state & 0x07) != 0x04) { // was received
+						DEBUG_LOG(("Message Info: state was received for msgId %1, state %2, already resending in container").arg(requestMsgId).arg((int32)state));
+					} else {
+						DEBUG_LOG(("Message Info: state was received for msgId %1, state %2, ack, cancelling resend").arg(requestMsgId).arg((int32)state));
+						acked.push_back(MTP_long(requestMsgId)); // will remove from resend in requestsAcked
+					}
+				} else {
+					DEBUG_LOG(("Message Info: msgId %1 was not found in recent resent either").arg(requestMsgId));
+				}
+				continue;
+			}
+		}
+		if ((state & 0x07) != 0x04) { // was received
+			DEBUG_LOG(("Message Info: state was received for msgId %1, state %2, resending in container").arg(requestMsgId).arg((int32)state));
+			resend(requestMsgId, 10, true);
+		} else {
+			DEBUG_LOG(("Message Info: state was received for msgId %1, state %2, ack").arg(requestMsgId).arg((int32)state));
+			acked.push_back(MTP_long(requestMsgId));
+		}
+	}
+	requestsAcked(acked);
+}
+
+void SessionPrivate::clearSpecialMsgId(mtpMsgId msgId) {
+	if (msgId == _pingMsgId) {
+		_pingMsgId = 0;
+		_pingId = 0;
+	} else if (msgId == _bindMsgId) {
+		_bindMsgId = 0;
+	}
+}
+
+void SessionPrivate::resend(
+		mtpMsgId msgId,
+		crl::time msCanWait,
+		bool forceContainer) {
+	const auto guard = gsl::finally([&] {
+		clearSpecialMsgId(msgId);
+		if (msCanWait >= 0) {
+			_sessionData->queueSendAnything(msCanWait);
+		}
+	});
+
+	if (const auto i = _sentContainers.find(msgId); i != end(_sentContainers)) {
+		DEBUG_LOG(("Message Info: resending container, msgId %1").arg(msgId));
+		const auto ids = std::move(i->second.messages);
+		_sentContainers.erase(i);
+
+		for (const auto innerMsgId : ids) {
+			resend(innerMsgId, -1, true);
+		}
+		return;
+	}
+	auto lock = QWriteLocker(_sessionData->haveSentMutex());
+	auto &haveSent = _sessionData->haveSentMap();
+	auto i = haveSent.find(msgId);
+	if (i == haveSent.end()) {
+		return;
+	}
+	auto request = i->second;
+	haveSent.erase(i);
+	lock.unlock();
+
+	request->lastSentTime = crl::now();
+	request->forceSendInContainer = forceContainer;
+	_resendingIds.emplace(msgId, request->requestId);
+	{
+		QWriteLocker locker(_sessionData->toSendMutex());
+		_sessionData->toSendMap().emplace(request->requestId, request);
+	}
+}
+
+void SessionPrivate::resendAll() {
+	auto lock = QWriteLocker(_sessionData->haveSentMutex());
+	auto haveSent = base::take(_sessionData->haveSentMap());
+	lock.unlock();
+	{
+		auto lock = QWriteLocker(_sessionData->toSendMutex());
+		auto &toSend = _sessionData->toSendMap();
+		const auto now = crl::now();
+		for (auto &[msgId, request] : haveSent) {
+			const auto requestId = request->requestId;
+			request->lastSentTime = now;
+			request->forceSendInContainer = true;
+			_resendingIds.emplace(msgId, requestId);
+			toSend.emplace(requestId, std::move(request));
+		}
+	}
+
+	_sessionData->queueSendAnything();
+}
+
+void SessionPrivate::onConnected(
+		not_null<AbstractConnection*> connection) {
+	disconnect(connection, &AbstractConnection::connected, nullptr, nullptr);
+	if (!connection->isConnected()) {
+		LOG(("Connection Error: not connected in onConnected(), "
+			"state: %1").arg(connection->debugState()));
+		return restart();
+	}
+
+	_waitForConnected = kMinConnectedTimeout;
+	_waitForConnectedTimer.cancel();
+
+	const auto i = ranges::find(
+		_testConnections,
+		connection.get(),
+		[](const TestConnection &test) { return test.data.get(); });
+	Assert(i != end(_testConnections));
+	const auto my = i->priority;
+	const auto j = ranges::find_if(
+		_testConnections,
+		[&](const TestConnection &test) { return test.priority > my; });
+	if (j != end(_testConnections)) {
+		DEBUG_LOG(("MTP Info: connection %1 succeed, "
+			"waiting for %2.").arg(i->data->tag()).arg(j->data->tag()));
+		_waitForBetterTimer.callOnce(kWaitForBetterTimeout);
+	} else {
+		DEBUG_LOG(("MTP Info: connection through IPv4 succeed."));
+		_waitForBetterTimer.cancel();
+		_connection = std::move(i->data);
+		_testConnections.clear();
+		checkAuthKey();
+	}
+}
+
+void SessionPrivate::onDisconnected(
+		not_null<AbstractConnection*> connection) {
+	removeTestConnection(connection);
+
+	if (_testConnections.empty()) {
+		destroyAllConnections();
+		restart();
+	} else {
+		confirmBestConnection();
+	}
+}
+
+void SessionPrivate::confirmBestConnection() {
+	if (_waitForBetterTimer.isActive()) {
+		return;
+	}
+	const auto i = ranges::max_element(
+		_testConnections,
+		std::less<>(),
+		[](const TestConnection &test) {
+			return test.data->isConnected() ? test.priority : -1;
+		});
+	Assert(i != end(_testConnections));
+	if (!i->data->isConnected()) {
+		return;
+	}
+
+	DEBUG_LOG(("MTP Info: can't connect through better, using %1."
+		).arg(i->data->tag()));
+
+	_connection = std::move(i->data);
+	_testConnections.clear();
+
+	checkAuthKey();
+}
+
+void SessionPrivate::removeTestConnection(
+		not_null<AbstractConnection*> connection) {
+	_testConnections.erase(
+		ranges::remove(
+			_testConnections,
+			connection.get(),
+			[](const TestConnection &test) { return test.data.get(); }),
+		end(_testConnections));
+}
+
+void SessionPrivate::checkAuthKey() {
+	if (_keyId) {
+		authKeyChecked();
+	} else if (_instance->isKeysDestroyer()) {
+		applyAuthKey(_sessionData->getPersistentKey());
+	} else {
+		applyAuthKey(_sessionData->getTemporaryKey(
+			TemporaryKeyTypeByDcType(_currentDcType)));
+	}
+}
+
+void SessionPrivate::updateAuthKey() {
+	if (_instance->isKeysDestroyer() || _keyCreator || !_connection) {
+		return;
+	}
+
+	DEBUG_LOG(("AuthKey Info: Connection updating key from Session, dc %1"
+		).arg(_shiftedDcId));
+	applyAuthKey(_sessionData->getTemporaryKey(
+		TemporaryKeyTypeByDcType(_currentDcType)));
+}
+
+void SessionPrivate::setCurrentKeyId(uint64 newKeyId) {
+	if (_keyId == newKeyId) {
+		return;
+	}
+	_keyId = newKeyId;
+
+	DEBUG_LOG(("MTP Info: auth key id set to id %1").arg(newKeyId));
+	changeSessionId();
+}
+
+void SessionPrivate::applyAuthKey(AuthKeyPtr &&encryptionKey) {
+	_encryptionKey = std::move(encryptionKey);
+	const auto newKeyId = _encryptionKey ? _encryptionKey->keyId() : 0;
+	if (_keyId) {
+		if (_keyId == newKeyId) {
+			return;
+		}
+		setCurrentKeyId(0);
+		DEBUG_LOG(("MTP Info: auth_key id for dc %1 changed, restarting..."
+			).arg(_shiftedDcId));
+		if (_connection) {
+			restart();
+		}
+		return;
+	}
+	if (!_connection) {
+		return;
+	}
+	setCurrentKeyId(newKeyId);
+	Assert(!_connection->sentEncryptedWithKeyId());
+
+	DEBUG_LOG(("AuthKey Info: Connection update key from Session, "
+		"dc %1 result: %2"
+		).arg(_shiftedDcId
+		).arg(Logs::mb(&_keyId, sizeof(_keyId)).str()));
+	if (_keyId) {
+		return authKeyChecked();
+	}
+
+	if (_instance->isKeysDestroyer()) {
+		// We are here to destroy an old key, so we're done.
+		LOG(("MTP Error: No key %1 in updateAuthKey() for destroying."
+			).arg(_shiftedDcId));
+		_instance->keyWasPossiblyDestroyed(_shiftedDcId);
+	} else if (noMediaKeyWithExistingRegularKey()) {
+		DEBUG_LOG(("AuthKey Info: No key in updateAuthKey() for media, "
+			"but someone has created regular, trying to acquire."));
+		const auto dcType = tryAcquireKeyCreation();
+		if (_keyCreator && dcType != _currentDcType) {
+			DEBUG_LOG(("AuthKey Info: "
+				"Dc type changed for creation, restarting."));
+			restart();
+			return;
+		}
+	}
+	if (_keyCreator) {
+		DEBUG_LOG(("AuthKey Info: No key in updateAuthKey(), creating."));
+		_keyCreator->start(
+			BareDcId(_shiftedDcId),
+			getProtocolDcId(),
+			_connection.get(),
+			_instance->dcOptions());
+	} else {
+		DEBUG_LOG(("AuthKey Info: No key in updateAuthKey(), "
+			"but someone is creating already, waiting."));
+	}
+}
+
+bool SessionPrivate::noMediaKeyWithExistingRegularKey() const {
+	return (TemporaryKeyTypeByDcType(_currentDcType)
+			== TemporaryKeyType::MediaCluster)
+		&& _sessionData->getTemporaryKey(TemporaryKeyType::Regular);
+}
+
+bool SessionPrivate::destroyOldEnoughPersistentKey() {
+	Expects(_keyCreator != nullptr);
+
+	const auto key = _keyCreator->bindPersistentKey();
+	Assert(key != nullptr);
+
+	const auto created = key->creationTime();
+	if (created > 0 && crl::now() - created < kKeyOldEnoughForDestroy) {
+		return false;
+	}
+	const auto instance = _instance;
+	const auto shiftedDcId = _shiftedDcId;
+	const auto keyId = key->keyId();
+	InvokeQueued(instance, [=] {
+		instance->keyDestroyedOnServer(shiftedDcId, keyId);
+	});
+	return true;
+}
+
+DcType SessionPrivate::tryAcquireKeyCreation() {
+	if (_keyCreator) {
+		return _currentDcType;
+	} else if (_instance->isKeysDestroyer()) {
+		return _realDcType;
+	}
+
+	const auto acquired = _sessionData->acquireKeyCreation(_realDcType);
+	if (acquired == CreatingKeyType::None) {
+		return _realDcType;
+	}
+
+	using Result = DcKeyResult;
+	using Error = DcKeyError;
+	auto delegate = BoundKeyCreator::Delegate();
+	delegate.unboundReady = [=](base::expected<Result, Error> result) {
+		if (!result) {
+			releaseKeyCreationOnFail();
+			if (result.error() == Error::UnknownPublicKey) {
+				if (_realDcType == DcType::Cdn) {
+					LOG(("Warning: CDN public RSA key not found"));
+					requestCDNConfig();
+					return;
+				}
+				LOG(("AuthKey Error: could not choose public RSA key"));
+			}
+			restart();
+			return;
+		}
+		DEBUG_LOG(("AuthKey Info: unbound key creation succeed, "
+			"ids: (%1, %2) server salts: (%3, %4)"
+			).arg(result->temporaryKey
+				? result->temporaryKey->keyId()
+				: 0
+			).arg(result->persistentKey
+				? result->persistentKey->keyId()
+				: 0
+			).arg(result->temporaryServerSalt
+			).arg(result->persistentServerSalt));
+
+		_sessionSalt = result->temporaryServerSalt;
+		result->temporaryKey->setExpiresAt(base::unixtime::now()
+			+ kTemporaryExpiresIn
+			+ kBindKeyAdditionalExpiresTimeout);
+		if (_realDcType != DcType::Cdn) {
+			auto key = result->persistentKey
+				? std::move(result->persistentKey)
+				: _sessionData->getPersistentKey();
+			if (!key) {
+				releaseKeyCreationOnFail();
+				restart();
+				return;
+			}
+			_keyCreator->bind(std::move(key));
+		}
+		applyAuthKey(std::move(result->temporaryKey));
+		if (_realDcType == DcType::Cdn) {
+			_keyCreator = nullptr;
+			if (!_sessionData->releaseCdnKeyCreationOnDone(_encryptionKey)) {
+				restart();
+			} else {
+				_sessionData->queueNeedToResumeAndSend();
+			}
+		}
+	};
+	delegate.sentSome = [=](uint64 size) {
+		onSentSome(size);
+	};
+	delegate.receivedSome = [=] {
+		onReceivedSome();
+	};
+
+	auto request = DcKeyRequest();
+	request.persistentNeeded = (acquired == CreatingKeyType::Persistent);
+	request.temporaryExpiresIn = kTemporaryExpiresIn;
+	_keyCreator = std::make_unique<BoundKeyCreator>(
+		request,
+		std::move(delegate));
+	const auto forceUseRegular = (_realDcType == DcType::MediaCluster)
+		&& (acquired != CreatingKeyType::TemporaryMediaCluster);
+	return forceUseRegular ? DcType::Regular : _realDcType;
+}
+
+void SessionPrivate::authKeyChecked() {
+	connect(_connection, &AbstractConnection::receivedData, [=] {
+		handleReceived();
+	});
+
+	if (_sessionSalt && setState(ConnectedState)) {
+		resendAll();
+	} // else receive salt in bad_server_salt first, then try to send all the requests
+
+	_pingIdToSend = rand_value<uint64>(); // get server_salt
+	_sessionData->queueNeedToResumeAndSend();
+}
+
+void SessionPrivate::onError(
+		not_null<AbstractConnection*> connection,
+		qint32 errorCode) {
+	if (errorCode == -429) {
+		LOG(("Protocol Error: -429 flood code returned!"));
+	} else if (errorCode == -444) {
+		LOG(("Protocol Error: -444 bad dc_id code returned!"));
+		InvokeQueued(_instance, [instance = _instance] {
+			instance->badConfigurationError();
+		});
+	}
+	removeTestConnection(connection);
+
+	if (_testConnections.empty()) {
+		handleError(errorCode);
+	} else {
+		confirmBestConnection();
+	}
+}
+
+void SessionPrivate::handleError(int errorCode) {
+	destroyAllConnections();
+	_waitForConnectedTimer.cancel();
+
+	if (errorCode == -404) {
+		destroyTemporaryKey();
+	} else {
+		MTP_LOG(_shiftedDcId, ("Restarting after error in connection, error code: %1...").arg(errorCode));
+		return restart();
+	}
+}
+
+void SessionPrivate::destroyTemporaryKey() {
+	if (_instance->isKeysDestroyer()) {
+		LOG(("MTP Info: -404 error received in destroyer %1, assuming key was destroyed.").arg(_shiftedDcId));
+		_instance->keyWasPossiblyDestroyed(_shiftedDcId);
+		return;
+	}
+	LOG(("MTP Info: -404 error received in %1 with temporary key, assuming it was destroyed.").arg(_shiftedDcId));
+	releaseKeyCreationOnFail();
+	if (_encryptionKey) {
+		_sessionData->destroyTemporaryKey(_encryptionKey->keyId());
+	}
+	applyAuthKey(nullptr);
+	restart();
+}
+
+bool SessionPrivate::sendSecureRequest(
+		SerializedRequest &&request,
+		bool needAnyResponse) {
+#ifdef TDESKTOP_MTPROTO_OLD
+	const auto oldPadding = true;
+#else // TDESKTOP_MTPROTO_OLD
+	const auto oldPadding = false;
+#endif // TDESKTOP_MTPROTO_OLD
+	request.addPadding(_connection->requiresExtendedPadding(), oldPadding);
+
+	uint32 fullSize = request->size();
+	if (fullSize < 9) {
+		return false;
+	}
+
+	auto messageSize = request.messageSize();
+	if (messageSize < 5 || fullSize < messageSize + 4) {
+		return false;
+	}
+
+	memcpy(request->data() + 0, &_sessionSalt, 2 * sizeof(mtpPrime));
+	memcpy(request->data() + 2, &_sessionId, 2 * sizeof(mtpPrime));
+
+	auto from = request->constData() + 4;
+	MTP_LOG(_shiftedDcId, ("Send: ")
+		+ DumpToText(from, from + messageSize)
+		+ QString(" (protocolDcId:%1,key:%2)"
+		).arg(getProtocolDcId()
+		).arg(_encryptionKey->keyId()));
+
+#ifdef TDESKTOP_MTPROTO_OLD
+	uint32 padding = fullSize - 4 - messageSize;
+
+	uchar encryptedSHA[20];
+	MTPint128 &msgKey(*(MTPint128*)(encryptedSHA + 4));
+	hashSha1(
+		request->constData(),
+		(fullSize - padding) * sizeof(mtpPrime),
+		encryptedSHA);
+
+	auto packet = _connection->prepareSecurePacket(_keyId, msgKey, fullSize);
+	const auto prefix = packet.size();
+	packet.resize(prefix + fullSize);
+
+	aesIgeEncrypt_oldmtp(
+		request->constData(),
+		&packet[prefix],
+		fullSize * sizeof(mtpPrime),
+		_encryptionKey,
+		msgKey);
+#else // TDESKTOP_MTPROTO_OLD
+	uchar encryptedSHA256[32];
+	MTPint128 &msgKey(*(MTPint128*)(encryptedSHA256 + 8));
+
+	SHA256_CTX msgKeyLargeContext;
+	SHA256_Init(&msgKeyLargeContext);
+	SHA256_Update(&msgKeyLargeContext, _encryptionKey->partForMsgKey(true), 32);
+	SHA256_Update(&msgKeyLargeContext, request->constData(), fullSize * sizeof(mtpPrime));
+	SHA256_Final(encryptedSHA256, &msgKeyLargeContext);
+
+	auto packet = _connection->prepareSecurePacket(_keyId, msgKey, fullSize);
+	const auto prefix = packet.size();
+	packet.resize(prefix + fullSize);
+
+	aesIgeEncrypt(
+		request->constData(),
+		&packet[prefix],
+		fullSize * sizeof(mtpPrime),
+		_encryptionKey,
+		msgKey);
+#endif // TDESKTOP_MTPROTO_OLD
+
+	DEBUG_LOG(("MTP Info: sending request, size: %1, num: %2, time: %3").arg(fullSize + 6).arg((*request)[4]).arg((*request)[5]));
+
+	_connection->setSentEncryptedWithKeyId(_keyId);
+	_connection->sendData(std::move(packet));
+
+	if (needAnyResponse) {
+		onSentSome((prefix + fullSize) * sizeof(mtpPrime));
+	}
+
+	return true;
+}
+
+mtpRequestId SessionPrivate::wasSent(mtpMsgId msgId) const {
+	if (msgId == _pingMsgId || msgId == _bindMsgId) {
+		return mtpRequestId(0xFFFFFFFF);
+	}
+	if (const auto i = _resendingIds.find(msgId); i != end(_resendingIds)) {
+		return i->second;
+	}
+	if (const auto i = _ackedIds.find(msgId); i != end(_ackedIds)) {
+		return i->second;
+	}
+	if (const auto i = _sentContainers.find(msgId); i != end(_sentContainers)) {
+		return mtpRequestId(0xFFFFFFFF);
+	}
+
+	{
+		QReadLocker locker(_sessionData->haveSentMutex());
+		const auto &haveSent = _sessionData->haveSentMap();
+		const auto i = haveSent.find(msgId);
+		if (i != haveSent.end()) {
+			return i->second->requestId
+				? i->second->requestId
+				: mtpRequestId(0xFFFFFFFF);
+		}
+	}
+	return 0;
+}
+
+void SessionPrivate::clearUnboundKeyCreator() {
+	if (_keyCreator) {
+		_keyCreator->stop();
+	}
+}
+
+void SessionPrivate::releaseKeyCreationOnFail() {
+	if (!_keyCreator) {
+		return;
+	}
+	_keyCreator = nullptr;
+	_sessionData->releaseKeyCreationOnFail();
+}
+
+} // namespace details
+} // namespace MTP
diff --git a/Telegram/SourceFiles/mtproto/session_private.h b/Telegram/SourceFiles/mtproto/session_private.h
new file mode 100644
index 000000000..91cfe4c61
--- /dev/null
+++ b/Telegram/SourceFiles/mtproto/session_private.h
@@ -0,0 +1,230 @@
+/*
+This file is part of Telegram Desktop,
+the official desktop application for the Telegram messaging service.
+
+For license and copyright information please follow this link:
+https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+*/
+#pragma once
+
+#include "mtproto/details/mtproto_received_ids_manager.h"
+#include "mtproto/details/mtproto_serialized_request.h"
+#include "mtproto/mtproto_auth_key.h"
+#include "mtproto/dc_options.h"
+#include "mtproto/connection_abstract.h"
+#include "mtproto/facade.h"
+#include "base/openssl_help.h"
+#include "base/timer.h"
+
+namespace MTP {
+namespace details {
+class BoundKeyCreator;
+} // namespace details
+
+class Instance;
+
+namespace details {
+
+class AbstractConnection;
+class SessionData;
+class RSAPublicKey;
+struct SessionOptions;
+
+class SessionPrivate final : public QObject {
+public:
+	SessionPrivate(
+		not_null<Instance*> instance,
+		not_null<QThread*> thread,
+		std::shared_ptr<SessionData> data,
+		ShiftedDcId shiftedDcId);
+	~SessionPrivate();
+
+	[[nodiscard]] int32 getShiftedDcId() const;
+	void dcOptionsChanged();
+	void cdnConfigChanged();
+
+	[[nodiscard]] int32 getState() const;
+	[[nodiscard]] QString transport() const;
+
+	void updateAuthKey();
+	void restartNow();
+	void sendPingForce();
+	void tryToSend();
+
+private:
+	static constexpr auto kUpdateStateAlways = 666;
+
+	struct TestConnection {
+		ConnectionPointer data;
+		int priority = 0;
+	};
+	struct SentContainer {
+		crl::time sent = 0;
+		std::vector<mtpMsgId> messages;
+	};
+	enum class HandleResult {
+		Success,
+		Ignored,
+		RestartConnection,
+		ResetSession,
+		DestroyTemporaryKey,
+		ParseError,
+	};
+
+	void connectToServer(bool afterConfig = false);
+	void connectingTimedOut();
+	void doDisconnect();
+	void restart();
+	void requestCDNConfig();
+	void handleError(int errorCode);
+	void onError(
+		not_null<AbstractConnection*> connection,
+		qint32 errorCode);
+	void onConnected(not_null<AbstractConnection*> connection);
+	void onDisconnected(not_null<AbstractConnection*> connection);
+	void onSentSome(uint64 size);
+	void onReceivedSome();
+
+	void handleReceived();
+
+	void retryByTimer();
+	void waitConnectedFailed();
+	void waitReceivedFailed();
+	void waitBetterFailed();
+	void markConnectionOld();
+	void sendPingByTimer();
+	void destroyAllConnections();
+
+	void confirmBestConnection();
+	void removeTestConnection(not_null<AbstractConnection*> connection);
+	[[nodiscard]] int16 getProtocolDcId() const;
+
+	void checkSentRequests();
+	void clearOldContainers();
+
+	mtpMsgId placeToContainer(
+		SerializedRequest &toSendRequest,
+		mtpMsgId &bigMsgId,
+		bool forceNewMsgId,
+		SerializedRequest &req);
+	mtpMsgId prepareToSend(
+		SerializedRequest &request,
+		mtpMsgId currentLastId,
+		bool forceNewMsgId);
+	mtpMsgId replaceMsgId(
+		SerializedRequest &request,
+		mtpMsgId newId);
+
+	bool sendSecureRequest(
+		SerializedRequest &&request,
+		bool needAnyResponse);
+	mtpRequestId wasSent(mtpMsgId msgId) const;
+
+	[[nodiscard]] HandleResult handleOneReceived(const mtpPrime *from, const mtpPrime *end, uint64 msgId, int32 serverTime, uint64 serverSalt, bool badTime);
+	[[nodiscard]] HandleResult handleBindResponse(
+		mtpMsgId requestMsgId,
+		const mtpBuffer &response);
+	mtpBuffer ungzip(const mtpPrime *from, const mtpPrime *end) const;
+	void handleMsgsStates(const QVector<MTPlong> &ids, const QByteArray &states);
+
+	// _sessionDataMutex must be locked for read.
+	bool setState(int state, int ifState = kUpdateStateAlways);
+
+	void appendTestConnection(
+		DcOptions::Variants::Protocol protocol,
+		const QString &ip,
+		int port,
+		const bytes::vector &protocolSecret);
+
+	// if badTime received - search for ids in sessionData->haveSent and sessionData->wereAcked and sync time/salt, return true if found
+	bool requestsFixTimeSalt(const QVector<MTPlong> &ids, int32 serverTime, uint64 serverSalt);
+
+	// remove msgs with such ids from sessionData->haveSent, add to sessionData->wereAcked
+	void requestsAcked(const QVector<MTPlong> &ids, bool byResponse = false);
+
+	void resend(
+		mtpMsgId msgId,
+		crl::time msCanWait = 0,
+		bool forceContainer = false);
+	void resendAll();
+	void clearSpecialMsgId(mtpMsgId msgId);
+
+	[[nodiscard]] DcType tryAcquireKeyCreation();
+	void resetSession();
+	void checkAuthKey();
+	void authKeyChecked();
+	void destroyTemporaryKey();
+	void clearUnboundKeyCreator();
+	void releaseKeyCreationOnFail();
+	void applyAuthKey(AuthKeyPtr &&encryptionKey);
+	[[nodiscard]] bool noMediaKeyWithExistingRegularKey() const;
+	bool destroyOldEnoughPersistentKey();
+
+	void setCurrentKeyId(uint64 newKeyId);
+	void changeSessionId();
+	[[nodiscard]] bool markSessionAsStarted();
+	[[nodiscard]] uint32 nextRequestSeqNumber(bool needAck);
+
+	[[nodiscard]] bool realDcTypeChanged();
+
+	const not_null<Instance*> _instance;
+	const ShiftedDcId _shiftedDcId = 0;
+	DcType _realDcType = DcType();
+	DcType _currentDcType = DcType();
+
+	mutable QReadWriteLock _stateMutex;
+	int _state = DisconnectedState;
+
+	bool _needSessionReset = false;
+
+	ConnectionPointer _connection;
+	std::vector<TestConnection> _testConnections;
+	crl::time _startedConnectingAt = 0;
+
+	base::Timer _retryTimer; // exp retry timer
+	int _retryTimeout = 1;
+	qint64 _retryWillFinish = 0;
+
+	base::Timer _oldConnectionTimer;
+	bool _oldConnection = true;
+
+	base::Timer _waitForConnectedTimer;
+	base::Timer _waitForReceivedTimer;
+	base::Timer _waitForBetterTimer;
+	crl::time _waitForReceived = 0;
+	crl::time _waitForConnected = 0;
+	crl::time _firstSentAt = -1;
+
+	mtpPingId _pingId = 0;
+	mtpPingId _pingIdToSend = 0;
+	crl::time _pingSendAt = 0;
+	mtpMsgId _pingMsgId = 0;
+	base::Timer _pingSender;
+	base::Timer _checkSentRequestsTimer;
+
+	std::shared_ptr<SessionData> _sessionData;
+	std::unique_ptr<SessionOptions> _options;
+	AuthKeyPtr _encryptionKey;
+	uint64 _keyId = 0;
+	uint64 _sessionId = 0;
+	uint64 _sessionSalt = 0;
+	uint32 _messagesCounter = 0;
+	bool _sessionMarkedAsStarted = false;
+
+	QVector<MTPlong> _ackRequestData;
+	QVector<MTPlong> _resendRequestData;
+	base::flat_set<mtpMsgId> _stateRequestData;
+	ReceivedIdsManager _receivedMessageIds;
+	base::flat_map<mtpMsgId, mtpRequestId> _resendingIds;
+	base::flat_map<mtpMsgId, mtpRequestId> _ackedIds;
+	base::flat_map<mtpMsgId, SerializedRequest> _stateAndResendRequests;
+	base::flat_map<mtpMsgId, SentContainer> _sentContainers;
+
+	std::unique_ptr<BoundKeyCreator> _keyCreator;
+	mtpMsgId _bindMsgId = 0;
+	crl::time _bindMessageSent = 0;
+
+};
+
+} // namespace details
+} // namespace MTP
diff --git a/Telegram/SourceFiles/mtproto/special_config_request.cpp b/Telegram/SourceFiles/mtproto/special_config_request.cpp
index 362a21d7a..29f0fc7ee 100644
--- a/Telegram/SourceFiles/mtproto/special_config_request.cpp
+++ b/Telegram/SourceFiles/mtproto/special_config_request.cpp
@@ -7,9 +7,9 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 */
 #include "mtproto/special_config_request.h"
 
-#include "mtproto/rsa_public_key.h"
+#include "mtproto/details/mtproto_rsa_public_key.h"
 #include "mtproto/dc_options.h"
-#include "mtproto/auth_key.h"
+#include "mtproto/mtproto_auth_key.h"
 #include "base/unixtime.h"
 #include "base/openssl_help.h"
 #include "base/call_delayed.h"
@@ -19,16 +19,10 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include <QtCore/QJsonArray>
 #include <QtCore/QJsonObject>
 
-extern "C" {
-#include <openssl/aes.h>
-} // extern "C"
-
-namespace MTP {
+namespace MTP::details {
 namespace {
 
 constexpr auto kSendNextTimeout = crl::time(800);
-constexpr auto kMinTimeToLive = 10 * crl::time(1000);
-constexpr auto kMaxTimeToLive = 300 * crl::time(1000);
 
 constexpr auto kPublicKey = str_const("\
 -----BEGIN RSA PUBLIC KEY-----\n\
@@ -41,9 +35,6 @@ Y1hZCxdv6cs5UnW9+PWvS+WIbkh+GaWYxwIDAQAB\n\
 -----END RSA PUBLIC KEY-----\
 ");
 
-constexpr auto kUserAgent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
-"AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36";
-
 const auto kRemoteProject = "peak-vista-421";
 const auto kFireProject = "reserve-5a846";
 const auto kConfigKey = "ipconfig";
@@ -51,21 +42,6 @@ const auto kConfigSubKey = "v3";
 const auto kApiKey = "AIzaSyC2-kAkpDsroixRXw-sTw-Wfqo4NxjMwwM";
 const auto kAppId = "1:560508485281:web:4ee13a6af4e84d49e67ae0";
 
-struct DnsEntry {
-	QString data;
-	crl::time TTL = 0;
-};
-
-const std::vector<QString> &DnsDomains() {
-	static auto result = std::vector<QString>{
-		qsl("google.com"),
-		qsl("www.google.com"),
-		qsl("google.ru"),
-		qsl("www.google.ru"),
-	};
-	return result;
-}
-
 QString ApiDomain(const QString &service) {
 	return service + ".googleapis.com";
 }
@@ -103,99 +79,6 @@ bool CheckPhoneByPrefixesRules(const QString &phone, const QString &rules) {
 	return result;
 }
 
-QString GenerateRandomPadding() {
-	constexpr char kValid[] = "abcdefghijklmnopqrstuvwxyz"
-		"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
-
-	auto result = QString();
-	const auto count = [&] {
-		constexpr auto kMinPadding = 13;
-		constexpr auto kMaxPadding = 128;
-		while (true) {
-			const auto result = 1 + (rand_value<uchar>() / 2);
-			Assert(result <= kMaxPadding);
-			if (result >= kMinPadding) {
-				return result;
-			}
-		}
-	}();
-	result.resize(count);
-	for (auto &ch : result) {
-		ch = kValid[rand_value<uchar>() % (sizeof(kValid) - 1)];
-	}
-	return result;
-}
-
-std::vector<DnsEntry> ParseDnsResponse(
-		const QByteArray &bytes,
-		std::optional<int> typeRestriction = std::nullopt) {
-	// Read and store to "result" all the data bytes from the response:
-	// { ..,
-	//   "Answer": [
-	//     { .., "data": "bytes1", "TTL": int, .. },
-	//     { .., "data": "bytes2", "TTL": int, .. }
-	//   ],
-	// .. }
-	auto error = QJsonParseError{ 0, QJsonParseError::NoError };
-	const auto document = QJsonDocument::fromJson(bytes, &error);
-	if (error.error != QJsonParseError::NoError) {
-		LOG(("Config Error: Failed to parse dns response JSON, error: %1"
-			).arg(error.errorString()));
-		return {};
-	} else if (!document.isObject()) {
-		LOG(("Config Error: Not an object received in dns response JSON."));
-		return {};
-	}
-	const auto response = document.object();
-	const auto answerIt = response.find(qsl("Answer"));
-	if (answerIt == response.constEnd()) {
-		LOG(("Config Error: Could not find Answer in dns response JSON."));
-		return {};
-	} else if (!(*answerIt).isArray()) {
-		LOG(("Config Error: Not an array received "
-			"in Answer in dns response JSON."));
-		return {};
-	}
-
-	auto result = std::vector<DnsEntry>();
-	for (const auto elem : (*answerIt).toArray()) {
-		if (!elem.isObject()) {
-			LOG(("Config Error: Not an object found "
-				"in Answer array in dns response JSON."));
-			continue;
-		}
-		const auto object = elem.toObject();
-		if (typeRestriction) {
-			const auto typeIt = object.find(qsl("type"));
-			const auto type = int(std::round((*typeIt).toDouble()));
-			if (!(*typeIt).isDouble()) {
-				LOG(("Config Error: Not a number in type field "
-					"in Answer array in dns response JSON."));
-				continue;
-			} else if (type != *typeRestriction) {
-				continue;
-			}
-		}
-		const auto dataIt = object.find(qsl("data"));
-		if (dataIt == object.constEnd()) {
-			LOG(("Config Error: Could not find data "
-				"in Answer array entry in dns response JSON."));
-			continue;
-		} else if (!(*dataIt).isString()) {
-			LOG(("Config Error: Not a string data found "
-				"in Answer array entry in dns response JSON."));
-			continue;
-		}
-
-		const auto ttlIt = object.find(qsl("TTL"));
-		const auto ttl = (ttlIt != object.constEnd())
-			? crl::time(std::round((*ttlIt).toDouble()))
-			: crl::time(0);
-		result.push_back({ (*dataIt).toString(), ttl });
-	}
-	return result;
-}
-
 QByteArray ConcatenateDnsTxtFields(const std::vector<DnsEntry> &response) {
 	auto entries = QMap<int, QString>();
 	for (const auto &entry : response) {
@@ -299,40 +182,6 @@ QByteArray ParseRealtimeResponse(const QByteArray &bytes) {
 
 } // namespace
 
-ServiceWebRequest::ServiceWebRequest(not_null<QNetworkReply*> reply)
-: reply(reply.get()) {
-}
-
-ServiceWebRequest::ServiceWebRequest(ServiceWebRequest &&other)
-: reply(base::take(other.reply)) {
-}
-
-ServiceWebRequest &ServiceWebRequest::operator=(ServiceWebRequest &&other) {
-	if (reply != other.reply) {
-		destroy();
-		reply = base::take(other.reply);
-	}
-	return *this;
-}
-
-void ServiceWebRequest::destroy() {
-	if (const auto value = base::take(reply)) {
-		value->disconnect(
-			value,
-			&QNetworkReply::finished,
-			nullptr,
-			nullptr);
-		value->abort();
-		value->deleteLater();
-	}
-}
-
-ServiceWebRequest::~ServiceWebRequest() {
-	if (reply) {
-		reply->deleteLater();
-	}
-}
-
 SpecialConfigRequest::SpecialConfigRequest(
 	Fn<void(
 		DcId dcId,
@@ -435,7 +284,7 @@ void SpecialConfigRequest::performRequest(const Attempt &attempt) {
 		url.setPath(qsl("/dns-query"));
 		url.setQuery(qsl("name=%1&type=16&random_padding=%2"
 		).arg(Global::TxtDomainString()
-		).arg(GenerateRandomPadding()));
+		).arg(GenerateDnsRandomPadding()));
 		request.setRawHeader("accept", "application/dns-json");
 	} break;
 	case Type::Google: {
@@ -443,7 +292,7 @@ void SpecialConfigRequest::performRequest(const Attempt &attempt) {
 		url.setPath(qsl("/resolve"));
 		url.setQuery(qsl("name=%1&type=ANY&random_padding=%2"
 		).arg(Global::TxtDomainString()
-		).arg(GenerateRandomPadding()));
+		).arg(GenerateDnsRandomPadding()));
 		if (!attempt.host.isEmpty()) {
 			const auto host = attempt.host + ".google.com";
 			request.setRawHeader("Host", host.toLatin1());
@@ -479,7 +328,7 @@ void SpecialConfigRequest::performRequest(const Attempt &attempt) {
 	default: Unexpected("Type in SpecialConfigRequest::performRequest.");
 	}
 	request.setUrl(url);
-	request.setRawHeader("User-Agent", kUserAgent);
+	request.setRawHeader("User-Agent", DnsUserAgent());
 	const auto reply = _requests.emplace_back(payload.isEmpty()
 		? _manager.get(request)
 		: _manager.post(request, payload)
@@ -587,7 +436,7 @@ bool SpecialConfigRequest::decryptSimpleConfig(const QByteArray &bytes) {
 		return false;
 	}
 
-	auto publicKey = internal::RSAPublicKey(bytes::make_span(
+	auto publicKey = details::RSAPublicKey(bytes::make_span(
 		kPublicKey.c_str(),
 		kPublicKey.size()));
 	auto decrypted = publicKey.decrypt(bytes::make_span(decodedBytes));
@@ -693,190 +542,4 @@ void SpecialConfigRequest::handleResponse(const QByteArray &bytes) {
 	_callback(0, std::string(), 0, {});
 }
 
-DomainResolver::DomainResolver(Fn<void(
-	const QString &host,
-	const QStringList &ips,
-	crl::time expireAt)> callback)
-: _callback(std::move(callback)) {
-	_manager.setProxy(QNetworkProxy::NoProxy);
-}
-
-void DomainResolver::resolve(const QString &domain) {
-	resolve({ domain, false });
-	resolve({ domain, true });
-}
-
-void DomainResolver::resolve(const AttemptKey &key) {
-	if (_attempts.find(key) != end(_attempts)) {
-		return;
-	} else if (_requests.find(key) != end(_requests)) {
-		return;
-	}
-	const auto i = _cache.find(key);
-	_lastTimestamp = crl::now();
-	if (i != end(_cache) && i->second.expireAt > _lastTimestamp) {
-		checkExpireAndPushResult(key.domain);
-		return;
-	}
-
-	auto attempts = std::vector<Attempt>();
-	auto domains = DnsDomains();
-	std::random_device rd;
-	ranges::shuffle(domains, std::mt19937(rd()));
-	const auto takeDomain = [&] {
-		const auto result = domains.back();
-		domains.pop_back();
-		return result;
-	};
-	const auto shuffle = [&](int from, int till) {
-		Expects(till > from);
-
-		ranges::shuffle(
-			begin(attempts) + from,
-			begin(attempts) + till,
-			std::mt19937(rd()));
-	};
-
-	attempts.push_back({ Type::Google, "dns.google.com" });
-	attempts.push_back({ Type::Google, takeDomain(), "dns" });
-	attempts.push_back({ Type::Mozilla, "mozilla.cloudflare-dns.com" });
-	while (!domains.empty()) {
-		attempts.push_back({ Type::Google, takeDomain(), "dns" });
-	}
-
-	shuffle(0, 2);
-
-	ranges::reverse(attempts); // We go from last to first.
-
-	_attempts.emplace(key, Attempts{ std::move(attempts) });
-	sendNextRequest(key);
-}
-
-void DomainResolver::checkExpireAndPushResult(const QString &domain) {
-	const auto ipv4 = _cache.find({ domain, false });
-	if (ipv4 == end(_cache) || ipv4->second.expireAt <= _lastTimestamp) {
-		return;
-	}
-	auto result = ipv4->second;
-	const auto ipv6 = _cache.find({ domain, true });
-	if (ipv6 != end(_cache) && ipv6->second.expireAt > _lastTimestamp) {
-		result.ips.append(ipv6->second.ips);
-		accumulate_min(result.expireAt, ipv6->second.expireAt);
-	}
-	InvokeQueued(this, [=] {
-		_callback(domain, result.ips, result.expireAt);
-	});
-}
-
-void DomainResolver::sendNextRequest(const AttemptKey &key) {
-	auto i = _attempts.find(key);
-	if (i == end(_attempts)) {
-		return;
-	}
-	auto &attempts = i->second;
-	auto &list = attempts.list;
-	const auto attempt = list.back();
-	list.pop_back();
-
-	if (!list.empty()) {
-		base::call_delayed(kSendNextTimeout, &attempts.guard, [=] {
-			sendNextRequest(key);
-		});
-	}
-	performRequest(key, attempt);
-}
-
-void DomainResolver::performRequest(
-		const AttemptKey &key,
-		const Attempt &attempt) {
-	auto url = QUrl();
-	url.setScheme(qsl("https"));
-	auto request = QNetworkRequest();
-	switch (attempt.type) {
-	case Type::Mozilla: {
-		url.setHost(attempt.data);
-		url.setPath(qsl("/dns-query"));
-		url.setQuery(qsl("name=%1&type=%2&random_padding=%3"
-		).arg(key.domain
-		).arg(key.ipv6 ? 28 : 1
-		).arg(GenerateRandomPadding()));
-		request.setRawHeader("accept", "application/dns-json");
-	} break;
-	case Type::Google: {
-		url.setHost(attempt.data);
-		url.setPath(qsl("/resolve"));
-		url.setQuery(qsl("name=%1&type=%2&random_padding=%3"
-		).arg(key.domain
-		).arg(key.ipv6 ? 28 : 1
-		).arg(GenerateRandomPadding()));
-		if (!attempt.host.isEmpty()) {
-			const auto host = attempt.host + ".google.com";
-			request.setRawHeader("Host", host.toLatin1());
-		}
-	} break;
-	default: Unexpected("Type in SpecialConfigRequest::performRequest.");
-	}
-	request.setUrl(url);
-	request.setRawHeader("User-Agent", kUserAgent);
-	const auto i = _requests.emplace(
-		key,
-		std::vector<ServiceWebRequest>()).first;
-	const auto reply = i->second.emplace_back(
-		_manager.get(request)
-	).reply;
-	connect(reply, &QNetworkReply::finished, this, [=] {
-		requestFinished(key, reply);
-	});
-}
-
-void DomainResolver::requestFinished(
-		const AttemptKey &key,
-		not_null<QNetworkReply*> reply) {
-	const auto result = finalizeRequest(key, reply);
-	const auto response = ParseDnsResponse(result);
-	if (response.empty()) {
-		return;
-	}
-	_requests.erase(key);
-	_attempts.erase(key);
-
-	auto entry = CacheEntry();
-	auto ttl = kMaxTimeToLive;
-	for (const auto &item : response) {
-		entry.ips.push_back(item.data);
-		accumulate_min(ttl, std::max(
-			item.TTL * crl::time(1000),
-			kMinTimeToLive));
-	}
-	_lastTimestamp = crl::now();
-	entry.expireAt = _lastTimestamp + ttl;
-	_cache[key] = std::move(entry);
-
-	checkExpireAndPushResult(key.domain);
-}
-
-QByteArray DomainResolver::finalizeRequest(
-		const AttemptKey &key,
-		not_null<QNetworkReply*> reply) {
-	if (reply->error() != QNetworkReply::NoError) {
-		LOG(("Resolve Error: Failed to get response, error: %2 (%3)"
-			).arg(reply->errorString()
-			).arg(reply->error()));
-	}
-	const auto result = reply->readAll();
-	const auto i = _requests.find(key);
-	if (i != end(_requests)) {
-		auto &requests = i->second;
-		const auto from = ranges::remove(
-			requests,
-			reply,
-			[](const ServiceWebRequest &request) { return request.reply; });
-		requests.erase(from, end(requests));
-		if (requests.empty()) {
-			_requests.erase(i);
-		}
-	}
-	return result;
-}
-
-} // namespace MTP
+} // namespace MTP::details
diff --git a/Telegram/SourceFiles/mtproto/special_config_request.h b/Telegram/SourceFiles/mtproto/special_config_request.h
index 7826c66b1..da4d27f4d 100644
--- a/Telegram/SourceFiles/mtproto/special_config_request.h
+++ b/Telegram/SourceFiles/mtproto/special_config_request.h
@@ -7,24 +7,15 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 */
 #pragma once
 
+#include "mtproto/details/mtproto_domain_resolver.h"
 #include "base/bytes.h"
+#include "base/weak_ptr.h"
 
+#include <QtCore/QPointer>
 #include <QtNetwork/QNetworkReply>
 #include <QtNetwork/QNetworkAccessManager>
 
-namespace MTP {
-
-struct ServiceWebRequest {
-    ServiceWebRequest(not_null<QNetworkReply*> reply);
-    ServiceWebRequest(ServiceWebRequest &&other);
-    ServiceWebRequest &operator=(ServiceWebRequest &&other);
-    ~ServiceWebRequest();
-
-    void destroy();
-
-    QPointer<QNetworkReply> reply;
-
-};
+namespace MTP::details {
 
 class SpecialConfigRequest : public QObject {
 public:
@@ -83,71 +74,4 @@ private:
 
 };
 
-class DomainResolver : public QObject {
-public:
-	DomainResolver(Fn<void(
-		const QString &domain,
-		const QStringList &ips,
-		crl::time expireAt)> callback);
-
-	void resolve(const QString &domain);
-
-private:
-	enum class Type {
-		Mozilla,
-		Google,
-	};
-	struct Attempt {
-		Type type;
-		QString data;
-		QString host;
-	};
-	struct AttemptKey {
-		QString domain;
-		bool ipv6 = false;
-
-		inline bool operator<(const AttemptKey &other) const {
-			return (domain < other.domain)
-				|| (domain == other.domain && !ipv6 && other.ipv6);
-		}
-		inline bool operator==(const AttemptKey &other) const {
-			return (domain == other.domain) && (ipv6 == other.ipv6);
-		}
-
-	};
-	struct CacheEntry {
-		QStringList ips;
-		crl::time expireAt = 0;
-
-	};
-	struct Attempts {
-		std::vector<Attempt> list;
-		base::has_weak_ptr guard;
-
-	};
-
-	void resolve(const AttemptKey &key);
-	void sendNextRequest(const AttemptKey &key);
-	void performRequest(const AttemptKey &key, const Attempt &attempt);
-	void checkExpireAndPushResult(const QString &domain);
-	void requestFinished(
-		const AttemptKey &key,
-		not_null<QNetworkReply*> reply);
-	QByteArray finalizeRequest(
-		const AttemptKey &key,
-		not_null<QNetworkReply*> reply);
-
-	Fn<void(
-		const QString &domain,
-		const QStringList &ips,
-		crl::time expireAt)> _callback;
-
-	QNetworkAccessManager _manager;
-	std::map<AttemptKey, Attempts> _attempts;
-	std::map<AttemptKey, std::vector<ServiceWebRequest>> _requests;
-	std::map<AttemptKey, CacheEntry> _cache;
-	crl::time _lastTimestamp = 0;
-
-};
-
-} // namespace MTP
+} // namespace MTP::details
diff --git a/Telegram/SourceFiles/mtproto/type_utils.h b/Telegram/SourceFiles/mtproto/type_utils.h
index 77e2478e8..182431fc2 100644
--- a/Telegram/SourceFiles/mtproto/type_utils.h
+++ b/Telegram/SourceFiles/mtproto/type_utils.h
@@ -7,7 +7,6 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 */
 #pragma once
 
-#include "scheme.h"
 #include "base/flags.h"
 
 inline MTPbool MTP_bool(bool v) {
diff --git a/Telegram/SourceFiles/overview/overview_layout.cpp b/Telegram/SourceFiles/overview/overview_layout.cpp
index cf08a6048..32bce8c2b 100644
--- a/Telegram/SourceFiles/overview/overview_layout.cpp
+++ b/Telegram/SourceFiles/overview/overview_layout.cpp
@@ -12,6 +12,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "data/data_web_page.h"
 #include "data/data_media_types.h"
 #include "data/data_peer.h"
+#include "data/data_file_origin.h"
 #include "styles/style_overview.h"
 #include "styles/style_history.h"
 #include "core/file_utilities.h"
@@ -428,7 +429,6 @@ void Video::paint(Painter &p, const QRect &clip, TextSelection selection, const
 	const auto thumbLoaded = _data->hasThumbnail()
 		&& _data->thumbnail()->loaded();
 
-	_data->automaticLoad(parent()->fullId(), parent());
 	bool loaded = _data->loaded(), displayLoading = _data->displayLoading();
 	if (displayLoading) {
 		ensureRadial();
@@ -620,8 +620,6 @@ void Voice::initDimensions() {
 
 void Voice::paint(Painter &p, const QRect &clip, TextSelection selection, const PaintContext *context) {
 	bool selected = (selection == FullSelection);
-
-	_data->automaticLoad(parent()->fullId(), parent());
 	bool loaded = _data->loaded(), displayLoading = _data->displayLoading();
 
 	if (displayLoading) {
diff --git a/Telegram/SourceFiles/passport/passport_encryption.cpp b/Telegram/SourceFiles/passport/passport_encryption.cpp
index c37e53872..4d9b3520e 100644
--- a/Telegram/SourceFiles/passport/passport_encryption.cpp
+++ b/Telegram/SourceFiles/passport/passport_encryption.cpp
@@ -8,7 +8,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "passport/passport_encryption.h"
 
 #include "base/openssl_help.h"
-#include "mtproto/rsa_public_key.h"
+#include "mtproto/details/mtproto_rsa_public_key.h"
 
 #include <QtCore/QJsonDocument>
 #include <QtCore/QJsonArray>
@@ -429,7 +429,7 @@ uint64 CountSecureSecretId(bytes::const_span secret) {
 bytes::vector EncryptCredentialsSecret(
 		bytes::const_span secret,
 		bytes::const_span publicKey) {
-	const auto key = MTP::internal::RSAPublicKey(publicKey);
+	const auto key = MTP::details::RSAPublicKey(publicKey);
 	return key.encryptOAEPpadding(secret);
 }
 
diff --git a/Telegram/SourceFiles/passport/passport_form_controller.cpp b/Telegram/SourceFiles/passport/passport_form_controller.cpp
index d43349366..05b3c88b1 100644
--- a/Telegram/SourceFiles/passport/passport_form_controller.cpp
+++ b/Telegram/SourceFiles/passport/passport_form_controller.cpp
@@ -28,8 +28,9 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "storage/localimageloader.h"
 #include "storage/localstorage.h"
 #include "storage/file_upload.h"
-#include "storage/file_download.h"
+#include "storage/file_download_mtproto.h"
 #include "app.h"
+#include "apiwrap.h"
 
 #include <QtCore/QJsonDocument>
 #include <QtCore/QJsonArray>
@@ -620,6 +621,7 @@ FormController::FormController(
 	not_null<Window::SessionController*> controller,
 	const FormRequest &request)
 : _controller(controller)
+, _api(_controller->session().api().instance())
 , _request(PreprocessRequest(request))
 , _shortPollTimer([=] { reloadPassword(); })
 , _view(std::make_unique<PanelController>(this)) {
@@ -741,7 +743,7 @@ std::vector<not_null<const Value*>> FormController::submitGetErrors() {
 		credentialsEncryptedData.secret,
 		bytes::make_span(_request.publicKey.toUtf8()));
 
-	_submitRequestId = request(MTPaccount_AcceptAuthorization(
+	_submitRequestId = _api.request(MTPaccount_AcceptAuthorization(
 		MTP_int(_request.botId),
 		MTP_string(_request.scope),
 		MTP_string(_request.publicKey),
@@ -808,8 +810,8 @@ void FormController::requestPasswordData(mtpRequestId &guard) {
 		return passwordServerError();
 	}
 
-	request(base::take(guard)).cancel();
-	guard = request(
+	_api.request(base::take(guard)).cancel();
+	guard = _api.request(
 		MTPaccount_GetPassword()
 	).done([=, &guard](const MTPaccount_Password &result) {
 		guard = 0;
@@ -843,7 +845,7 @@ void FormController::submitPassword(
 		const Core::CloudPasswordResult &check,
 		const QByteArray &password,
 		bool submitSaved) {
-	_passwordCheckRequestId = request(MTPaccount_GetPasswordSettings(
+	_passwordCheckRequestId = _api.request(MTPaccount_GetPasswordSettings(
 		check.result
 	)).handleFloodErrors(
 	).done([=](const MTPaccount_PasswordSettings &result) {
@@ -936,7 +938,7 @@ void FormController::checkSavedPasswordSettings(
 void FormController::checkSavedPasswordSettings(
 		const Core::CloudPasswordResult &check,
 		const SavedCredentials &credentials) {
-	_passwordCheckRequestId = request(MTPaccount_GetPasswordSettings(
+	_passwordCheckRequestId = _api.request(MTPaccount_GetPasswordSettings(
 		check.result
 	)).done([=](const MTPaccount_PasswordSettings &result) {
 		Expects(result.type() == mtpc_account_passwordSettings);
@@ -982,7 +984,7 @@ void FormController::recoverPassword() {
 	} else if (_recoverRequestId) {
 		return;
 	}
-	_recoverRequestId = request(MTPauth_RequestPasswordRecovery(
+	_recoverRequestId = _api.request(MTPauth_RequestPasswordRecovery(
 	)).done([=](const MTPauth_PasswordRecovery &result) {
 		Expects(result.type() == mtpc_auth_passwordRecovery);
 
@@ -1024,7 +1026,7 @@ void FormController::cancelPassword() {
 	if (_passwordRequestId) {
 		return;
 	}
-	_passwordRequestId = request(MTPaccount_CancelPasswordEmail(
+	_passwordRequestId = _api.request(MTPaccount_CancelPasswordEmail(
 	)).done([=](const MTPBool &result) {
 		_passwordRequestId = 0;
 		reloadPassword();
@@ -1093,7 +1095,7 @@ void FormController::resetSecret(
 		const Core::CloudPasswordResult &check,
 		const bytes::vector &password) {
 	using Flag = MTPDaccount_passwordInputSettings::Flag;
-	_saveSecretRequestId = request(MTPaccount_UpdatePasswordSettings(
+	_saveSecretRequestId = _api.request(MTPaccount_UpdatePasswordSettings(
 		check.result,
 		MTP_account_passwordInputSettings(
 			MTP_flags(Flag::f_new_secure_settings),
@@ -1625,7 +1627,7 @@ void FormController::verify(
 	nonconst->verification.requestId = [&] {
 		switch (nonconst->type) {
 		case Value::Type::Phone:
-			return request(MTPaccount_VerifyPhone(
+			return _api.request(MTPaccount_VerifyPhone(
 				MTP_string(getPhoneFromValue(nonconst)),
 				MTP_string(nonconst->verification.phoneCodeHash),
 				MTP_string(prepared)
@@ -1643,7 +1645,7 @@ void FormController::verify(
 				}
 			}).send();
 		case Value::Type::Email:
-			return request(MTPaccount_VerifyEmail(
+			return _api.request(MTPaccount_VerifyEmail(
 				MTP_string(getEmailFromValue(nonconst)),
 				MTP_string(prepared)
 			)).done([=](const MTPBool &result) {
@@ -1825,7 +1827,7 @@ void FormController::cancelValueVerification(not_null<const Value*> value) {
 void FormController::clearValueVerification(not_null<Value*> value) {
 	const auto was = (value->verification.codeLength != 0);
 	if (const auto requestId = base::take(value->verification.requestId)) {
-		request(requestId).cancel();
+		_api.request(requestId).cancel();
 	}
 	value->verification = Verification();
 	if (was) {
@@ -1872,7 +1874,7 @@ void FormController::deleteValueEdit(not_null<const Value*> value) {
 	}
 
 	const auto nonconst = findValue(value);
-	nonconst->saveRequestId = request(MTPaccount_DeleteSecureValue(
+	nonconst->saveRequestId = _api.request(MTPaccount_DeleteSecureValue(
 		MTP_vector<MTPSecureValueType>(1, ConvertType(nonconst->type))
 	)).done([=](const MTPBool &result) {
 		resetValue(*nonconst);
@@ -2019,7 +2021,7 @@ void FormController::sendSaveRequest(
 		const MTPInputSecureValue &data) {
 	Expects(value->saveRequestId == 0);
 
-	value->saveRequestId = request(MTPaccount_SaveSecureValue(
+	value->saveRequestId = _api.request(MTPaccount_SaveSecureValue(
 		data,
 		MTP_long(_secretId)
 	)).done([=](const MTPSecureValue &result) {
@@ -2092,7 +2094,7 @@ QString FormController::getPlainTextFromValue(
 }
 
 void FormController::startPhoneVerification(not_null<Value*> value) {
-	value->verification.requestId = request(MTPaccount_SendVerifyPhoneCode(
+	value->verification.requestId = _api.request(MTPaccount_SendVerifyPhoneCode(
 		MTP_string(getPhoneFromValue(value)),
 		MTP_codeSettings(MTP_flags(0))
 	)).done([=](const MTPauth_SentCode &result) {
@@ -2149,7 +2151,7 @@ void FormController::startPhoneVerification(not_null<Value*> value) {
 }
 
 void FormController::startEmailVerification(not_null<Value*> value) {
-	value->verification.requestId = request(MTPaccount_SendVerifyEmailCode(
+	value->verification.requestId = _api.request(MTPaccount_SendVerifyEmailCode(
 		MTP_string(getEmailFromValue(value))
 	)).done([=](const MTPaccount_SentEmailCode &result) {
 		Expects(result.type() == mtpc_account_sentEmailCode);
@@ -2171,7 +2173,7 @@ void FormController::requestPhoneCall(not_null<Value*> value) {
 
 	value->verification.call->setStatus(
 		{ SentCodeCall::State::Calling, 0 });
-	request(MTPauth_ResendCode(
+	_api.request(MTPauth_ResendCode(
 		MTP_string(getPhoneFromValue(value)),
 		MTP_string(value->verification.phoneCodeHash)
 	)).done([=](const MTPauth_SentCode &code) {
@@ -2222,7 +2224,7 @@ void FormController::saveSecret(
 		saved.hashForSecret);
 
 	using Flag = MTPDaccount_passwordInputSettings::Flag;
-	_saveSecretRequestId = request(MTPaccount_UpdatePasswordSettings(
+	_saveSecretRequestId = _api.request(MTPaccount_UpdatePasswordSettings(
 		check.result,
 		MTP_account_passwordInputSettings(
 			MTP_flags(Flag::f_new_secure_settings),
@@ -2270,7 +2272,7 @@ void FormController::requestForm() {
 		formFail(NonceNameByScope(_request.scope).toUpper() + "_EMPTY");
 		return;
 	}
-	_formRequestId = request(MTPaccount_GetAuthorizationForm(
+	_formRequestId = _api.request(MTPaccount_GetAuthorizationForm(
 		MTP_int(_request.botId),
 		MTP_string(_request.scope),
 		MTP_string(_request.publicKey)
@@ -2478,7 +2480,7 @@ void FormController::formDone(const MTPaccount_AuthorizationForm &result) {
 
 void FormController::requestConfig() {
 	const auto hash = ConfigInstance().hash;
-	_configRequestId = request(MTPhelp_GetPassportConfig(
+	_configRequestId = _api.request(MTPhelp_GetPassportConfig(
 		MTP_int(hash)
 	)).done([=](const MTPhelp_PassportConfig &result) {
 		_configRequestId = 0;
@@ -2555,7 +2557,7 @@ void FormController::requestPassword() {
 	if (_passwordRequestId) {
 		return;
 	}
-	_passwordRequestId = request(MTPaccount_GetPassword(
+	_passwordRequestId = _api.request(MTPaccount_GetPassword(
 	)).done([=](const MTPaccount_Password &result) {
 		_passwordRequestId = 0;
 		passwordDone(result);
diff --git a/Telegram/SourceFiles/passport/passport_form_controller.h b/Telegram/SourceFiles/passport/passport_form_controller.h
index b7f56d467..4ae25ac65 100644
--- a/Telegram/SourceFiles/passport/passport_form_controller.h
+++ b/Telegram/SourceFiles/passport/passport_form_controller.h
@@ -318,7 +318,7 @@ struct FileKey {
 
 };
 
-class FormController : private MTP::Sender, public base::has_weak_ptr {
+class FormController : public base::has_weak_ptr {
 public:
 	FormController(
 		not_null<Window::SessionController*> controller,
@@ -512,6 +512,7 @@ private:
 	void shortPollEmailConfirmation();
 
 	not_null<Window::SessionController*> _controller;
+	MTP::Sender _api;
 	FormRequest _request;
 	UserData *_bot = nullptr;
 
diff --git a/Telegram/SourceFiles/passport/passport_panel_controller.cpp b/Telegram/SourceFiles/passport/passport_panel_controller.cpp
index 560428125..92bfeb983 100644
--- a/Telegram/SourceFiles/passport/passport_panel_controller.cpp
+++ b/Telegram/SourceFiles/passport/passport_panel_controller.cpp
@@ -1192,7 +1192,7 @@ void PanelController::startScopeEdit(
 			_panelHasUnsavedChanges = [=] {
 				return weak ? weak->hasUnsavedChanges() : false;
 			};
-			return std::move(result);
+			return result;
 		} break;
 		case Scope::Type::PersonalDetails:
 		case Scope::Type::AddressDetails: {
@@ -1210,7 +1210,7 @@ void PanelController::startScopeEdit(
 			_panelHasUnsavedChanges = [=] {
 				return weak ? weak->hasUnsavedChanges() : false;
 			};
-			return std::move(result);
+			return result;
 		} break;
 		case Scope::Type::Phone:
 		case Scope::Type::Email: {
diff --git a/Telegram/SourceFiles/platform/linux/file_utilities_linux.cpp b/Telegram/SourceFiles/platform/linux/file_utilities_linux.cpp
index 823cccaaf..5bb691f23 100644
--- a/Telegram/SourceFiles/platform/linux/file_utilities_linux.cpp
+++ b/Telegram/SourceFiles/platform/linux/file_utilities_linux.cpp
@@ -18,7 +18,10 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "facades.h"
 
 #include <QtCore/QProcess>
+
+#ifndef TDESKTOP_DISABLE_GTK_INTEGRATION
 #include <private/qguiapplication_p.h>
+#endif // TDESKTOP_DISABLE_GTK_INTEGRATION
 
 QStringList qt_make_filter_list(const QString &filter);
 
diff --git a/Telegram/SourceFiles/platform/linux/linux_libnotify.cpp b/Telegram/SourceFiles/platform/linux/linux_libnotify.cpp
deleted file mode 100644
index 657c46075..000000000
--- a/Telegram/SourceFiles/platform/linux/linux_libnotify.cpp
+++ /dev/null
@@ -1,110 +0,0 @@
-/*
-This file is part of Telegram Desktop,
-the official desktop application for the Telegram messaging service.
-
-For license and copyright information please follow this link:
-https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
-*/
-#include "platform/linux/linux_libnotify.h"
-
-#include "platform/linux/linux_libs.h"
-
-namespace Platform {
-namespace Libs {
-namespace {
-
-bool loadLibrary(QLibrary &lib, const char *name, int version) {
-    DEBUG_LOG(("Loading '%1' with version %2...").arg(QLatin1String(name)).arg(version));
-    lib.setFileNameAndVersion(QLatin1String(name), version);
-    if (lib.load()) {
-        DEBUG_LOG(("Loaded '%1' with version %2!").arg(QLatin1String(name)).arg(version));
-        return true;
-    }
-    lib.setFileNameAndVersion(QLatin1String(name), QString());
-    if (lib.load()) {
-        DEBUG_LOG(("Loaded '%1' without version!").arg(QLatin1String(name)));
-        return true;
-    }
-    LOG(("Could not load '%1' with version %2 :(").arg(QLatin1String(name)).arg(version));
-    return false;
-}
-
-} // namespace
-
-#ifndef TDESKTOP_DISABLE_GTK_INTEGRATION
-f_notify_init notify_init = nullptr;
-f_notify_uninit notify_uninit = nullptr;
-f_notify_is_initted notify_is_initted = nullptr;
-//f_notify_get_app_name notify_get_app_name = nullptr;
-//f_notify_set_app_name notify_set_app_name = nullptr;
-f_notify_get_server_caps notify_get_server_caps = nullptr;
-f_notify_get_server_info notify_get_server_info = nullptr;
-
-f_notify_notification_new notify_notification_new = nullptr;
-//f_notify_notification_update notify_notification_update = nullptr;
-f_notify_notification_show notify_notification_show = nullptr;
-//f_notify_notification_set_app_name notify_notification_set_app_name = nullptr;
-f_notify_notification_set_timeout notify_notification_set_timeout = nullptr;
-//f_notify_notification_set_category notify_notification_set_category = nullptr;
-//f_notify_notification_set_urgency notify_notification_set_urgency = nullptr;
-//f_notify_notification_set_icon_from_pixbuf notify_notification_set_icon_from_pixbuf = nullptr;
-f_notify_notification_set_image_from_pixbuf notify_notification_set_image_from_pixbuf = nullptr;
-//f_notify_notification_set_hint notify_notification_set_hint = nullptr;
-//f_notify_notification_set_hint_int32 notify_notification_set_hint_int32 = nullptr;
-//f_notify_notification_set_hint_uint32 notify_notification_set_hint_uint32 = nullptr;
-//f_notify_notification_set_hint_double notify_notification_set_hint_double = nullptr;
-f_notify_notification_set_hint_string notify_notification_set_hint_string = nullptr;
-//f_notify_notification_set_hint_byte notify_notification_set_hint_byte = nullptr;
-//f_notify_notification_set_hint_byte_array notify_notification_set_hint_byte_array = nullptr;
-//f_notify_notification_clear_hints notify_notification_clear_hints = nullptr;
-f_notify_notification_add_action notify_notification_add_action = nullptr;
-f_notify_notification_clear_actions notify_notification_clear_actions = nullptr;
-f_notify_notification_close notify_notification_close = nullptr;
-f_notify_notification_get_closed_reason notify_notification_get_closed_reason = nullptr;
-
-void startLibNotify() {
-	DEBUG_LOG(("Loading libnotify"));
-
-	QLibrary lib_notify;
-	if (!loadLibrary(lib_notify, "notify", 4)) {
-		if (!loadLibrary(lib_notify, "notify", 5)) {
-			if (!loadLibrary(lib_notify, "notify", 1)) {
-				return;
-			}
-		}
-	}
-
-	load(lib_notify, "notify_init", notify_init);
-	load(lib_notify, "notify_uninit", notify_uninit);
-	load(lib_notify, "notify_is_initted", notify_is_initted);
-//	load(lib_notify, "notify_get_app_name", notify_get_app_name);
-//	load(lib_notify, "notify_set_app_name", notify_set_app_name);
-	load(lib_notify, "notify_get_server_caps", notify_get_server_caps);
-	load(lib_notify, "notify_get_server_info", notify_get_server_info);
-
-	load(lib_notify, "notify_notification_new", notify_notification_new);
-//	load(lib_notify, "notify_notification_update", notify_notification_update);
-	load(lib_notify, "notify_notification_show", notify_notification_show);
-//	load(lib_notify, "notify_notification_set_app_name", notify_notification_set_app_name);
-	load(lib_notify, "notify_notification_set_timeout", notify_notification_set_timeout);
-//	load(lib_notify, "notify_notification_set_category", notify_notification_set_category);
-//	load(lib_notify, "notify_notification_set_urgency", notify_notification_set_urgency);
-//	load(lib_notify, "notify_notification_set_icon_from_pixbuf", notify_notification_set_icon_from_pixbuf);
-	load(lib_notify, "notify_notification_set_image_from_pixbuf", notify_notification_set_image_from_pixbuf);
-//	load(lib_notify, "notify_notification_set_hint", notify_notification_set_hint);
-//	load(lib_notify, "notify_notification_set_hint_int32", notify_notification_set_hint_int32);
-//	load(lib_notify, "notify_notification_set_hint_uint32", notify_notification_set_hint_uint32);
-//	load(lib_notify, "notify_notification_set_hint_double", notify_notification_set_hint_double);
-	load(lib_notify, "notify_notification_set_hint_string", notify_notification_set_hint_string);
-//	load(lib_notify, "notify_notification_set_hint_byte", notify_notification_set_hint_byte);
-//	load(lib_notify, "notify_notification_set_hint_byte_array", notify_notification_set_hint_byte_array);
-//	load(lib_notify, "notify_notification_clear_hints", notify_notification_clear_hints);
-	load(lib_notify, "notify_notification_add_action", notify_notification_add_action);
-	load(lib_notify, "notify_notification_clear_actions", notify_notification_clear_actions);
-	load(lib_notify, "notify_notification_close", notify_notification_close);
-	load(lib_notify, "notify_notification_get_closed_reason", notify_notification_get_closed_reason);
-}
-#endif // !TDESKTOP_DISABLE_GTK_INTEGRATION
-
-} // namespace Libs
-} // namespace Platform
diff --git a/Telegram/SourceFiles/platform/linux/linux_libnotify.h b/Telegram/SourceFiles/platform/linux/linux_libnotify.h
deleted file mode 100644
index 6dcfd676a..000000000
--- a/Telegram/SourceFiles/platform/linux/linux_libnotify.h
+++ /dev/null
@@ -1,120 +0,0 @@
-/*
-This file is part of Telegram Desktop,
-the official desktop application for the Telegram messaging service.
-
-For license and copyright information please follow this link:
-https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
-*/
-#pragma once
-
-#ifndef TDESKTOP_DISABLE_GTK_INTEGRATION
-extern "C" {
-#undef signals
-#include <gtk/gtk.h>
-#define signals public
-} // extern "C"
-
-namespace Platform {
-namespace Libs {
-
-void startLibNotify();
-
-constexpr gint NOTIFY_EXPIRES_DEFAULT = -1;
-constexpr gint NOTIFY_EXPIRES_NEVER = 0;
-
-struct NotifyNotification;
-typedef enum {
-        NOTIFY_URGENCY_LOW,
-        NOTIFY_URGENCY_NORMAL,
-        NOTIFY_URGENCY_CRITICAL,
-} NotifyUrgency;
-
-using NotifyActionCallback = void (*)(NotifyNotification *notification, char *action, gpointer user_data);
-
-using f_notify_init = gboolean (*)(const char *app_name);
-extern f_notify_init notify_init;
-
-using f_notify_uninit = void (*)(void);
-extern f_notify_uninit notify_uninit;
-
-using f_notify_is_initted = gboolean (*)(void);
-extern f_notify_is_initted notify_is_initted;
-
-//using f_notify_get_app_name = const char* (*)(void);
-//extern f_notify_get_app_name notify_get_app_name;
-
-//using f_notify_set_app_name = void (*)(const char *app_name);
-//extern f_notify_set_app_name notify_set_app_name;
-
-using f_notify_get_server_caps = GList* (*)(void);
-extern f_notify_get_server_caps notify_get_server_caps;
-
-using f_notify_get_server_info = gboolean (*)(char **ret_name, char **ret_vendor, char **ret_version, char **ret_spec_version);
-extern f_notify_get_server_info notify_get_server_info;
-
-using f_notify_notification_new = NotifyNotification* (*)(const char *summary, const char *body, const char *icon);
-extern f_notify_notification_new notify_notification_new;
-
-//using f_notify_notification_update = gboolean (*)(NotifyNotification *notification, const char *summary, const char *body, const char *icon);
-//extern f_notify_notification_update notify_notification_update;
-
-using f_notify_notification_show = gboolean (*)(NotifyNotification *notification, GError **error);
-extern f_notify_notification_show notify_notification_show;
-
-//using f_notify_notification_set_app_name = void (*)(NotifyNotification *notification, const char *app_name);
-//extern f_notify_notification_set_app_name notify_notification_set_app_name;
-
-using f_notify_notification_set_timeout = void (*)(NotifyNotification *notification, gint timeout);
-extern f_notify_notification_set_timeout notify_notification_set_timeout;
-
-//using f_notify_notification_set_category = void (*)(NotifyNotification *notification, const char *category);
-//extern f_notify_notification_set_category notify_notification_set_category;
-
-//using f_notify_notification_set_urgency = void (*)(NotifyNotification *notification, NotifyUrgency urgency);
-//extern f_notify_notification_set_urgency notify_notification_set_urgency;
-
-//using f_notify_notification_set_icon_from_pixbuf = void (*)(NotifyNotification *notification, GdkPixbuf *icon);
-//extern f_notify_notification_set_icon_from_pixbuf notify_notification_set_icon_from_pixbuf;
-
-using f_notify_notification_set_image_from_pixbuf = void (*)(NotifyNotification *notification, GdkPixbuf *pixbuf);
-extern f_notify_notification_set_image_from_pixbuf notify_notification_set_image_from_pixbuf;
-
-//using f_notify_notification_set_hint = void (*)(NotifyNotification *notification, const char *key, GVariant *value);
-//extern f_notify_notification_set_hint notify_notification_set_hint;
-
-//using f_notify_notification_set_hint_int32 = void (*)(NotifyNotification *notification, const char *key, gint value);
-//extern f_notify_notification_set_hint_int32 notify_notification_set_hint_int32;
-
-//using f_notify_notification_set_hint_uint32 = void (*)(NotifyNotification *notification, const char *key, guint value);
-//extern f_notify_notification_set_hint_uint32 notify_notification_set_hint_uint32;
-
-//using f_notify_notification_set_hint_double = void (*)(NotifyNotification *notification, const char *key, gdouble value);
-//extern f_notify_notification_set_hint_double notify_notification_set_hint_double;
-
-using f_notify_notification_set_hint_string = void (*)(NotifyNotification *notification, const char *key, const char *value);
-extern f_notify_notification_set_hint_string notify_notification_set_hint_string;
-
-//using f_notify_notification_set_hint_byte = void (*)(NotifyNotification *notification, const char *key, guchar value);
-//extern f_notify_notification_set_hint_byte notify_notification_set_hint_byte;
-
-//using f_notify_notification_set_hint_byte_array = void (*)(NotifyNotification *notification, const char *key, const guchar *value, gsize len);
-//extern f_notify_notification_set_hint_byte_array notify_notification_set_hint_byte_array;
-
-//using f_notify_notification_clear_hints = void (*)(NotifyNotification *notification);
-//extern f_notify_notification_clear_hints notify_notification_clear_hints;
-
-using f_notify_notification_add_action = void (*)(NotifyNotification *notification, const char *action, const char *label, NotifyActionCallback callback, gpointer user_data, GFreeFunc free_func);
-extern f_notify_notification_add_action notify_notification_add_action;
-
-using f_notify_notification_clear_actions = void (*)(NotifyNotification *notification);
-extern f_notify_notification_clear_actions notify_notification_clear_actions;
-
-using f_notify_notification_close = gboolean (*)(NotifyNotification *notification, GError **error);
-extern f_notify_notification_close notify_notification_close;
-
-using f_notify_notification_get_closed_reason = gint (*)(const NotifyNotification *notification);
-extern f_notify_notification_get_closed_reason notify_notification_get_closed_reason;
-
-} // namespace Libs
-} // namespace Platform
-#endif // !TDESKTOP_DISABLE_GTK_INTEGRATION
diff --git a/Telegram/SourceFiles/platform/linux/linux_libs.cpp b/Telegram/SourceFiles/platform/linux/linux_libs.cpp
index 5071d63d1..d60734e7c 100644
--- a/Telegram/SourceFiles/platform/linux/linux_libs.cpp
+++ b/Telegram/SourceFiles/platform/linux/linux_libs.cpp
@@ -8,7 +8,6 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "platform/linux/linux_libs.h"
 
 #include "platform/linux/linux_gdk_helper.h"
-#include "platform/linux/linux_libnotify.h"
 #include "platform/linux/linux_desktop_environment.h"
 
 #include <QtGui/QGuiApplication>
@@ -290,10 +289,6 @@ void start() {
 	} else {
 		LOG(("Could not load gtk-x11-2.0!"));
 	}
-
-	if (gtkLoaded) {
-		startLibNotify();
-	}
 #endif // !TDESKTOP_DISABLE_GTK_INTEGRATION
 }
 
diff --git a/Telegram/SourceFiles/platform/linux/main_window_linux.cpp b/Telegram/SourceFiles/platform/linux/main_window_linux.cpp
index d076b90f3..13c9d20aa 100644
--- a/Telegram/SourceFiles/platform/linux/main_window_linux.cpp
+++ b/Telegram/SourceFiles/platform/linux/main_window_linux.cpp
@@ -264,13 +264,6 @@ void MainWindow::psSetupTrayIcon() {
 			}
 			trayIcon->setIcon(icon);
 
-			// This is very important for native notifications via libnotify!
-			// Some notification servers compose several notifications with a "Reply"
-			// action into one and after that a click on "Reply" button does not call
-			// the specified callback from any of the sent notification - libnotify
-			// just ignores ibus messages, but Qt tray icon at least emits this signal.
-			connect(trayIcon, SIGNAL(messageClicked()), this, SLOT(showFromTray()));
-
 			attachToTrayIcon(trayIcon);
 		}
 		updateIconCounters();
diff --git a/Telegram/SourceFiles/platform/linux/notifications_manager_linux.cpp b/Telegram/SourceFiles/platform/linux/notifications_manager_linux.cpp
index 9b0dc1d65..f93941021 100644
--- a/Telegram/SourceFiles/platform/linux/notifications_manager_linux.cpp
+++ b/Telegram/SourceFiles/platform/linux/notifications_manager_linux.cpp
@@ -7,389 +7,309 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 */
 #include "platform/linux/notifications_manager_linux.h"
 
-#include "window/notifications_utilities.h"
-#include "platform/linux/linux_libnotify.h"
-#include "platform/linux/linux_libs.h"
 #include "history/history.h"
 #include "lang/lang_keys.h"
 #include "facades.h"
 
+#include <QtCore/QBuffer>
+#include <QtDBus/QDBusConnection>
+#include <QtDBus/QDBusReply>
+#include <QtDBus/QDBusMetaType>
+
 namespace Platform {
 namespace Notifications {
-#ifndef TDESKTOP_DISABLE_GTK_INTEGRATION
 namespace {
 
-bool LibNotifyLoaded() {
-	return (Libs::notify_init != nullptr)
-		&& (Libs::notify_uninit != nullptr)
-		&& (Libs::notify_is_initted != nullptr)
-//		&& (Libs::notify_get_app_name != nullptr)
-//		&& (Libs::notify_set_app_name != nullptr)
-		&& (Libs::notify_get_server_caps != nullptr)
-		&& (Libs::notify_get_server_info != nullptr)
-		&& (Libs::notify_notification_new != nullptr)
-//		&& (Libs::notify_notification_update != nullptr)
-		&& (Libs::notify_notification_show != nullptr)
-//		&& (Libs::notify_notification_set_app_name != nullptr)
-		&& (Libs::notify_notification_set_timeout != nullptr)
-//		&& (Libs::notify_notification_set_category != nullptr)
-//		&& (Libs::notify_notification_set_urgency != nullptr)
-//		&& (Libs::notify_notification_set_icon_from_pixbuf != nullptr)
-		&& (Libs::notify_notification_set_image_from_pixbuf != nullptr)
-//		&& (Libs::notify_notification_set_hint != nullptr)
-//		&& (Libs::notify_notification_set_hint_int32 != nullptr)
-//		&& (Libs::notify_notification_set_hint_uint32 != nullptr)
-//		&& (Libs::notify_notification_set_hint_double != nullptr)
-		&& (Libs::notify_notification_set_hint_string != nullptr)
-//		&& (Libs::notify_notification_set_hint_byte != nullptr)
-//		&& (Libs::notify_notification_set_hint_byte_array != nullptr)
-//		&& (Libs::notify_notification_clear_hints != nullptr)
-		&& (Libs::notify_notification_add_action != nullptr)
-		&& (Libs::notify_notification_clear_actions != nullptr)
-		&& (Libs::notify_notification_close != nullptr)
-		&& (Libs::notify_notification_get_closed_reason != nullptr)
-		&& (Libs::g_object_ref_sink != nullptr)
-		&& (Libs::g_object_unref != nullptr)
-		&& (Libs::g_list_free_full != nullptr)
-		&& (Libs::g_error_free != nullptr)
-		&& (Libs::g_signal_connect_data != nullptr)
-		&& (Libs::g_signal_handler_disconnect != nullptr)
-//		&& (Libs::gdk_pixbuf_new_from_data != nullptr)
-		&& (Libs::gdk_pixbuf_new_from_file != nullptr);
-}
-
-QString escapeHtml(const QString &text) {
-	auto result = QString();
-	auto copyFrom = 0, textSize = text.size();
-	auto data = text.constData();
-	for (auto i = 0; i != textSize; ++i) {
-		auto ch = data[i];
-		if (ch == '<' || ch == '>' || ch == '&') {
-			if (!copyFrom) {
-				result.reserve(textSize * 5);
-			}
-			if (i > copyFrom) {
-				result.append(data + copyFrom, i - copyFrom);
+constexpr auto kService = str_const("org.freedesktop.Notifications");
+constexpr auto kObjectPath = str_const("/org/freedesktop/Notifications");
+constexpr auto kInterface = kService;
+
+std::vector<QString> GetServerInformation(
+		const std::shared_ptr<QDBusInterface> &notificationInterface) {
+	std::vector<QString> serverInformation;
+	auto serverInformationReply = notificationInterface
+		->call("GetServerInformation");
+
+	if (serverInformationReply.type() == QDBusMessage::ReplyMessage) {
+		for (const auto &arg : serverInformationReply.arguments()) {
+			if (static_cast<QMetaType::Type>(arg.type())
+					== QMetaType::QString) {
+				serverInformation.push_back(arg.toString());
+			} else {
+				LOG(("Native notification error: "
+					"all elements in GetServerInformation "
+					"should be strings"));
 			}
-			switch (ch.unicode()) {
-			case '<': result.append(qstr("&lt;")); break;
-			case '>': result.append(qstr("&gt;")); break;
-			case '&': result.append(qstr("&amp;")); break;
-			}
-			copyFrom = i + 1;
 		}
+	} else if (serverInformationReply.type() == QDBusMessage::ErrorMessage) {
+		LOG(("Native notification error: %1")
+			.arg(QDBusError(serverInformationReply).message()));
+	} else {
+		LOG(("Native notification error: "
+			"error while getting information about notification daemon"));
 	}
-	if (copyFrom > 0) {
-		result.append(data + copyFrom, textSize - copyFrom);
-		return result;
-	}
-	return text;
+
+	return serverInformation;
 }
 
-class NotificationData {
-public:
-	NotificationData(const std::shared_ptr<Manager*> &guarded, const QString &title, const QString &body, const QStringList &capabilities, PeerId peerId, MsgId msgId)
-	: _data(Libs::notify_notification_new(title.toUtf8().constData(), body.toUtf8().constData(), nullptr)) {
-		if (valid()) {
-			init(guarded, capabilities, peerId, msgId);
-		}
-	}
-	bool valid() const {
-		return (_data != nullptr);
-	}
-	NotificationData(const NotificationData &other) = delete;
-	NotificationData &operator=(const NotificationData &other) = delete;
-	NotificationData(NotificationData &&other) = delete;
-	NotificationData &operator=(NotificationData &&other) = delete;
-
-	void setImage(const QString &imagePath) {
-		auto imagePathNative = QFile::encodeName(imagePath);
-		if (auto pixbuf = Libs::gdk_pixbuf_new_from_file(imagePathNative.constData(), nullptr)) {
-			Libs::notify_notification_set_image_from_pixbuf(_data, pixbuf);
-			Libs::g_object_unref(Libs::g_object_cast(pixbuf));
-		}
+std::vector<QString> GetCapabilities(
+		const std::shared_ptr<QDBusInterface> &notificationInterface) {
+	QDBusReply<QStringList> capabilitiesReply = notificationInterface
+		->call("GetCapabilities");
+
+	if (capabilitiesReply.isValid()) {
+		return capabilitiesReply.value().toVector().toStdVector();
+	} else {
+		LOG(("Native notification error: %1")
+			.arg(capabilitiesReply.error().message()));
 	}
-	bool show() {
-		if (valid()) {
-			GError *error = nullptr;
 
-			Libs::notify_notification_show(_data, &error);
-			if (!error) {
-				return true;
-			}
+	return std::vector<QString>();
+}
 
-			logError(error);
-		}
-		return false;
+QVersionNumber ParseSpecificationVersion(
+		const std::vector<QString> &serverInformation) {
+	if (serverInformation.size() >= 4) {
+		return QVersionNumber::fromString(serverInformation[3]);
+	} else {
+		LOG(("Native notification error: "
+			"server information should have 4 elements"));
 	}
 
-	bool close() {
-		if (valid()) {
-			GError *error = nullptr;
-			Libs::notify_notification_close(_data, &error);
-			if (!error) {
-				return true;
-			}
+	return QVersionNumber();
+}
 
-			logError(error);
-		}
-		return false;
-	}
+}
 
-	~NotificationData() {
-		if (valid()) {
-//			if (_handlerId > 0) {
-//				Libs::g_signal_handler_disconnect(Libs::g_object_cast(_data), _handlerId);
-//			}
-//			Libs::notify_notification_clear_actions(_data);
-			Libs::g_object_unref(Libs::g_object_cast(_data));
-		}
+NotificationData::NotificationData(
+		const std::shared_ptr<QDBusInterface> &notificationInterface,
+		const base::weak_ptr<Manager> &manager,
+		const QString &title, const QString &subtitle,
+		const QString &msg, PeerId peerId, MsgId msgId)
+: _notificationInterface(notificationInterface)
+, _manager(manager)
+, _title(title)
+, _peerId(peerId)
+, _msgId(msgId) {
+	auto capabilities = GetCapabilities(_notificationInterface);
+	auto capabilitiesEnd = capabilities.end();
+
+	if (ranges::find(capabilities, qsl("body-markup")) != capabilitiesEnd) {
+		_body = subtitle.isEmpty()
+				? msg.toHtmlEscaped()
+				: qsl("<b>%1</b>\n%2").arg(subtitle.toHtmlEscaped())
+									.arg(msg.toHtmlEscaped());
+	} else {
+		_body = subtitle.isEmpty()
+				? msg
+				: qsl("%1\n%2").arg(subtitle).arg(msg);
 	}
 
-private:
-	void init(const std::shared_ptr<Manager*> &guarded, const QStringList &capabilities, PeerId peerId, MsgId msgId) {
-		if (capabilities.contains(qsl("append"))) {
-			Libs::notify_notification_set_hint_string(_data, "append", "true");
-		} else if (capabilities.contains(qsl("x-canonical-append"))) {
-			Libs::notify_notification_set_hint_string(_data, "x-canonical-append", "true");
-		}
+	if (ranges::find(capabilities, qsl("actions")) != capabilitiesEnd) {
+		// icon name according to https://specifications.freedesktop.org/icon-naming-spec/icon-naming-spec-latest.html
+		_actions << "mail-reply-sender"
+				<< tr::lng_notification_reply(tr::now);
 
-		Libs::notify_notification_set_hint_string(_data, "desktop-entry", "kotatogramdesktop");
-
-		auto signalReceiver = Libs::g_object_cast(_data);
-		auto signalHandler = G_CALLBACK(NotificationData::notificationClosed);
-		auto signalName = "closed";
-		auto signalDataFreeMethod = &NotificationData::notificationDataFreeClosure;
-		auto signalData = new NotificationDataStruct(guarded, peerId, msgId);
-		_handlerId = Libs::g_signal_connect_helper(signalReceiver, signalName, signalHandler, signalData, signalDataFreeMethod);
-
-		Libs::notify_notification_set_timeout(_data, Libs::NOTIFY_EXPIRES_DEFAULT);
-
-		if ((*guarded)->hasActionsSupport()) {
-			auto label = tr::lng_notification_reply(tr::now).toUtf8();
-			auto actionReceiver = _data;
-			auto actionHandler = &NotificationData::notificationClicked;
-			auto actionLabel = label.constData();
-			auto actionName = "default";
-			auto actionDataFreeMethod = &NotificationData::notificationDataFree;
-			auto actionData = new NotificationDataStruct(guarded, peerId, msgId);
-			Libs::notify_notification_add_action(actionReceiver, actionName, actionLabel, actionHandler, actionData, actionDataFreeMethod);
-		}
+		connect(_notificationInterface.get(),
+				SIGNAL(ActionInvoked(uint, QString)),
+				this, SLOT(notificationClicked(uint)));
 	}
 
-	void logError(GError *error) {
-		LOG(("LibNotify Error: domain %1, code %2, message '%3'").arg(error->domain).arg(error->code).arg(QString::fromUtf8(error->message)));
-		Libs::g_error_free(error);
+	if (ranges::find(capabilities, qsl("action-icons")) != capabilitiesEnd) {
+		_hints["action-icons"] = true;
 	}
 
-	struct NotificationDataStruct {
-		NotificationDataStruct(const std::shared_ptr<Manager*> &guarded, PeerId peerId, MsgId msgId)
-		: weak(guarded)
-		, peerId(peerId)
-		, msgId(msgId) {
+	// suppress system sound if telegram sound activated, otherwise use system sound
+	if (ranges::find(capabilities, qsl("sound")) != capabilitiesEnd) {
+		if (Global::SoundNotify()) {
+			_hints["suppress-sound"] = true;
+		} else {
+			// sound name according to http://0pointer.de/public/sound-naming-spec.html
+			_hints["sound-name"] = "message-new-instant";
 		}
-
-		std::weak_ptr<Manager*> weak;
-		PeerId peerId = 0;
-		MsgId msgId = 0;
-	};
-	static void performOnMainQueue(NotificationDataStruct *data, FnMut<void(Manager *manager)> task) {
-		const auto weak = data->weak;
-		crl::on_main(weak, [=, task = std::move(task)]() mutable {
-			task(*weak.lock());
-		});
-	}
-	static void notificationDataFree(gpointer data) {
-		auto notificationData = static_cast<NotificationDataStruct*>(data);
-		delete notificationData;
-	}
-	static void notificationDataFreeClosure(gpointer data, GClosure *closure) {
-		auto notificationData = static_cast<NotificationDataStruct*>(data);
-		delete notificationData;
 	}
-	static void notificationClosed(Libs::NotifyNotification *notification, gpointer data) {
-		auto closedReason = Libs::notify_notification_get_closed_reason(notification);
-		auto notificationData = static_cast<NotificationDataStruct*>(data);
-		performOnMainQueue(notificationData, [peerId = notificationData->peerId, msgId = notificationData->msgId](Manager *manager) {
-			manager->clearNotification(peerId, msgId);
-		});
-	}
-	static void notificationClicked(Libs::NotifyNotification *notification, char *action, gpointer data) {
-		auto notificationData = static_cast<NotificationDataStruct*>(data);
-		performOnMainQueue(notificationData, [peerId = notificationData->peerId, msgId = notificationData->msgId](Manager *manager) {
-			manager->notificationActivated(peerId, msgId);
-		});
+
+	if (ranges::find(capabilities, qsl("x-canonical-append"))
+			!= capabilitiesEnd) {
+		_hints["x-canonical-append"] = "true";
 	}
 
-	Libs::NotifyNotification *_data = nullptr;
-	gulong _handlerId = 0;
+	_hints["category"] = "im.received";
+	_hints["desktop-entry"] = "kotatogramdesktop";
 
-};
+	connect(_notificationInterface.get(),
+			SIGNAL(NotificationClosed(uint, uint)),
+			this, SLOT(notificationClosed(uint)));
+}
 
-using Notification = std::shared_ptr<NotificationData>;
+bool NotificationData::show() {
+	QDBusReply<uint> notifyReply = _notificationInterface->call("Notify",
+		str_const_toString(AppName), uint(0), "kotatogram", _title, _body,
+		_actions, _hints, -1);
 
-QString GetServerName() {
-	if (!LibNotifyLoaded()) {
-		return QString();
-	}
-	if (!Libs::notify_is_initted() && !Libs::notify_init("Kotatogram Desktop")) {
-		LOG(("LibNotify Error: failed to init!"));
-		return QString();
+	if (notifyReply.isValid()) {
+		_notificationId = notifyReply.value();
+	} else {
+		LOG(("Native notification error: %1")
+			.arg(notifyReply.error().message()));
 	}
 
-	gchar *name = nullptr;
-	auto guard = gsl::finally([&name] {
-		if (name) Libs::g_free(name);
-	});
+	return notifyReply.isValid();
+}
+
+bool NotificationData::close() {
+	QDBusReply<void> closeReply = _notificationInterface
+		->call("CloseNotification", _notificationId);
 
-	if (!Libs::notify_get_server_info(&name, nullptr, nullptr, nullptr)) {
-		LOG(("LibNotify Error: could not get server name!"));
-		return QString();
-	}
-	if (!name) {
-		LOG(("LibNotify Error: successfully got empty server name!"));
-		return QString();
+	if (!closeReply.isValid()) {
+		LOG(("Native notification error: %1")
+			.arg(closeReply.error().message()));
 	}
 
-	auto result = QString::fromUtf8(static_cast<const char*>(name));
-	LOG(("Notifications Server: %1").arg(result));
-
-	return result;
+	return closeReply.isValid();
 }
 
-auto LibNotifyServerName = QString();
+void NotificationData::setImage(const QString &imagePath) {
+	auto specificationVersion = ParseSpecificationVersion(
+		GetServerInformation(_notificationInterface));
 
-} // namespace
-#endif // !TDESKTOP_DISABLE_GTK_INTEGRATION
+	QString imageKey;
 
-bool Supported() {
-#ifndef TDESKTOP_DISABLE_GTK_INTEGRATION
-	static auto Checked = false;
-	if (!Checked) {
-		Checked = true;
-		LibNotifyServerName = GetServerName();
+	if (!specificationVersion.isNull()) {
+		const auto majorVersion = specificationVersion.majorVersion();
+		const auto minorVersion = specificationVersion.minorVersion();
+
+		if ((majorVersion == 1 && minorVersion >= 2) || majorVersion > 1) {
+			imageKey = "image-data";
+		} else if (majorVersion == 1 && minorVersion) {
+			imageKey = "image_data";
+		} else if ((majorVersion == 1 && minorVersion < 1)
+									|| majorVersion < 1) {
+			imageKey = "icon_data";
+		} else {
+			LOG(("Native notification error: unknown specification version"));
+			return;
+		}
+	} else {
+		LOG(("Native notification error: specification version is null"));
+		return;
 	}
 
-	return !LibNotifyServerName.isEmpty();
-#else
-	return false;
-#endif // !TDESKTOP_DISABLE_GTK_INTEGRATION
+	auto image = QImage(imagePath).convertToFormat(QImage::Format_RGBA8888);
+	QByteArray imageBytes((const char*)image.constBits(),
+						image.sizeInBytes());
+
+	ImageData imageData;
+	imageData.width = image.width();
+	imageData.height = image.height();
+	imageData.rowStride = image.bytesPerLine();
+	imageData.hasAlpha = true;
+	imageData.bitsPerSample = 8;
+	imageData.channels = 4;
+	imageData.data = imageBytes;
+
+	_hints[imageKey] = QVariant::fromValue(imageData);
 }
 
-std::unique_ptr<Window::Notifications::Manager> Create(Window::Notifications::System *system) {
-#ifndef TDESKTOP_DISABLE_GTK_INTEGRATION
-	if (Global::NativeNotifications() && Supported()) {
-		return std::make_unique<Manager>(system);
+void NotificationData::notificationClosed(uint id) {
+	if (id == _notificationId) {
+		const auto manager = _manager;
+		crl::on_main(manager, [=] {
+			manager->clearNotification(_peerId, _msgId);
+		});
 	}
-#endif // !TDESKTOP_DISABLE_GTK_INTEGRATION
-	return nullptr;
 }
 
-void Finish() {
-#ifndef TDESKTOP_DISABLE_GTK_INTEGRATION
-	if (Libs::notify_is_initted && Libs::notify_uninit) {
-		if (Libs::notify_is_initted()) {
-			Libs::notify_uninit();
-		}
+void NotificationData::notificationClicked(uint id) {
+	if (id == _notificationId) {
+		const auto manager = _manager;
+		crl::on_main(manager, [=] {
+			manager->notificationActivated(_peerId, _msgId);
+		});
 	}
-#endif // !TDESKTOP_DISABLE_GTK_INTEGRATION
 }
 
-#ifndef TDESKTOP_DISABLE_GTK_INTEGRATION
-class Manager::Private {
-public:
-	using Type = Window::Notifications::CachedUserpics::Type;
-	explicit Private(Type type)
-	: _cachedUserpics(type) {
-	}
+QDBusArgument &operator<<(QDBusArgument &argument,
+		const NotificationData::ImageData &imageData) {
+	argument.beginStructure();
+	argument << imageData.width
+			<< imageData.height
+			<< imageData.rowStride
+			<< imageData.hasAlpha
+			<< imageData.bitsPerSample
+			<< imageData.channels
+			<< imageData.data;
+	argument.endStructure();
+	return argument;
+}
 
-	void init(Manager *manager);
+const QDBusArgument &operator>>(const QDBusArgument &argument,
+		NotificationData::ImageData &imageData) {
+	argument.beginStructure();
+	argument >> imageData.width
+			>> imageData.height
+			>> imageData.rowStride
+			>> imageData.hasAlpha
+			>> imageData.bitsPerSample
+			>> imageData.channels
+			>> imageData.data;
+	argument.endStructure();
+	return argument;
+}
 
-	void showNotification(
-		not_null<PeerData*> peer,
-		MsgId msgId,
-		const QString &title,
-		const QString &subtitle,
-		const QString &msg,
-		bool hideNameAndPhoto,
-		bool hideReplyButton);
-	void clearAll();
-	void clearFromHistory(not_null<History*> history);
-	void clearNotification(PeerId peerId, MsgId msgId);
+bool Supported() {
+	static auto Checked = false;
+	static auto NotificationDaemonRunning = false;
 
-	bool hasPoorSupport() const {
-		return _poorSupported;
-	}
-	bool hasActionsSupport() const {
-		return _actionsSupported;
+	if (!Checked) {
+		Checked = true;
+		NotificationDaemonRunning = QDBusInterface(
+			str_const_toString(kService),
+			str_const_toString(kObjectPath),
+			str_const_toString(kInterface)).isValid();
 	}
 
-	~Private();
-
-private:
-	QString escapeNotificationText(const QString &text) const;
-	void showNextNotification();
-
-	struct QueuedNotification {
-		PeerData *peer = nullptr;
-		MsgId msgId = 0;
-		QString title;
-		QString body;
-		bool hideNameAndPhoto = false;
-	};
-
-	QString _serverName;
-	QStringList _capabilities;
-
-	using QueuedNotifications = QList<QueuedNotification>;
-	QueuedNotifications _queuedNotifications;
-
-	using Notifications = QMap<PeerId, QMap<MsgId, Notification>>;
-	Notifications _notifications;
+	return NotificationDaemonRunning;
+}
 
-	Window::Notifications::CachedUserpics _cachedUserpics;
-	bool _actionsSupported = false;
-	bool _markupSupported = false;
-	bool _poorSupported = false;
+std::unique_ptr<Window::Notifications::Manager> Create(
+		Window::Notifications::System *system) {
+	if (Global::NativeNotifications() && Supported()) {
+		return std::make_unique<Manager>(system);
+	}
+	return nullptr;
+}
 
-	std::shared_ptr<Manager*> _guarded;
+Manager::Private::Private(Manager *manager, Type type)
+: _cachedUserpics(type)
+, _manager(manager)
+, _notificationInterface(std::make_shared<QDBusInterface>(
+							str_const_toString(kService),
+							str_const_toString(kObjectPath),
+							str_const_toString(kInterface))) {
+	qDBusRegisterMetaType<NotificationData::ImageData>();
 
-};
-#endif // !TDESKTOP_DISABLE_GTK_INTEGRATION
+	auto specificationVersion = ParseSpecificationVersion(
+		GetServerInformation(_notificationInterface));
 
-#ifndef TDESKTOP_DISABLE_GTK_INTEGRATION
-void Manager::Private::init(Manager *manager) {
-	_guarded = std::make_shared<Manager*>(manager);
+	auto capabilities = GetCapabilities(_notificationInterface);
 
-	if (auto capabilities = Libs::notify_get_server_caps()) {
-		for (auto capability = capabilities; capability; capability = capability->next) {
-			auto capabilityText = QString::fromUtf8(static_cast<const char*>(capability->data));
-			_capabilities.push_back(capabilityText);
-		}
-		Libs::g_list_free_full(capabilities, g_free);
-
-		LOG(("LibNotify capabilities: %1").arg(_capabilities.join(qstr(", "))));
-		if (_capabilities.contains(qsl("actions"))) {
-			_actionsSupported = true;
-		} else if (_capabilities.contains(qsl("body-markup"))) {
-			_markupSupported = true;
-		}
-	} else {
-		LOG(("LibNotify Error: could not get capabilities!"));
+	if (!specificationVersion.isNull()) {
+		LOG(("Notification daemon specification version: %1")
+			.arg(specificationVersion.toString()));
 	}
 
-	// Unity and other Notify OSD users handle desktop notifications
-	// extremely poor, even without the ability to close() them.
-	_serverName = LibNotifyServerName;
-	Assert(!_serverName.isEmpty());
-	if (_serverName == qstr("notify-osd")) {
-//		_poorSupported = true;
-		_actionsSupported = false;
-	}
-}
+	if (!capabilities.empty()) {
+		const auto capabilitiesString = std::accumulate(
+			capabilities.begin(),
+			capabilities.end(),
+			QString{},
+			[](auto &s, auto &p) {
+				return s + (p + qstr(", "));
+			}).chopped(2);
 
-QString Manager::Private::escapeNotificationText(const QString &text) const {
-	return _markupSupported ? escapeHtml(text) : text;
+		LOG(("Notification daemon capabilities: %1").arg(capabilitiesString));
+	}
 }
 
 void Manager::Private::showNotification(
@@ -400,93 +320,44 @@ void Manager::Private::showNotification(
 		const QString &msg,
 		bool hideNameAndPhoto,
 		bool hideReplyButton) {
-	auto titleText = escapeNotificationText(title);
-	auto subtitleText = escapeNotificationText(subtitle);
-	auto msgText = escapeNotificationText(msg);
-	if (_markupSupported && !subtitleText.isEmpty()) {
-		subtitleText = qstr("<b>") + subtitleText + qstr("</b>");
-	}
-	auto bodyText = subtitleText.isEmpty() ? msgText : (subtitleText + '\n' + msgText);
-
-	QueuedNotification notification;
-	notification.peer = peer;
-	notification.msgId = msgId;
-	notification.title = titleText;
-	notification.body = bodyText;
-	notification.hideNameAndPhoto = hideNameAndPhoto;
-	_queuedNotifications.push_back(notification);
-
-	showNextNotification();
-}
-
-void Manager::Private::showNextNotification() {
-	// Show only one notification at a time in Unity / Notify OSD.
-	if (_poorSupported) {
-		for (auto b = _notifications.begin(); !_notifications.isEmpty() && b->isEmpty();) {
-			_notifications.erase(b);
-		}
-		if (!_notifications.isEmpty()) {
-			return;
-		}
-	}
-
-	QueuedNotification data;
-	while (!_queuedNotifications.isEmpty()) {
-		data = _queuedNotifications.front();
-		_queuedNotifications.pop_front();
-		if (data.peer) {
-			break;
-		}
-	}
-	if (!data.peer) {
-		return;
-	}
-
-	auto peerId = data.peer->id;
-	auto msgId = data.msgId;
 	auto notification = std::make_shared<NotificationData>(
-		_guarded,
-		data.title,
-		data.body,
-		_capabilities,
-		peerId,
+		_notificationInterface,
+		_manager,
+		title,
+		subtitle,
+		msg,
+		peer->id,
 		msgId);
-	if (!notification->valid()) {
-		return;
-	}
 
-	const auto key = data.hideNameAndPhoto
+	const auto key = hideNameAndPhoto
 		? InMemoryKey()
-		: data.peer->userpicUniqueKey();
-	notification->setImage(_cachedUserpics.get(key, data.peer));
+		:peer->userpicUniqueKey();
+	notification->setImage(_cachedUserpics.get(key, peer));
 
-	auto i = _notifications.find(peerId);
+	auto i = _notifications.find(peer->id);
 	if (i != _notifications.cend()) {
 		auto j = i->find(msgId);
 		if (j != i->cend()) {
 			auto oldNotification = j.value();
 			i->erase(j);
 			oldNotification->close();
-			i = _notifications.find(peerId);
+			i = _notifications.find(peer->id);
 		}
 	}
 	if (i == _notifications.cend()) {
-		i = _notifications.insert(peerId, QMap<MsgId, Notification>());
+		i = _notifications.insert(peer->id, QMap<MsgId, Notification>());
 	}
-	_notifications[peerId].insert(msgId, notification);
+	_notifications[peer->id].insert(msgId, notification);
 	if (!notification->show()) {
-		i = _notifications.find(peerId);
+		i = _notifications.find(peer->id);
 		if (i != _notifications.cend()) {
 			i->remove(msgId);
 			if (i->isEmpty()) _notifications.erase(i);
 		}
-		showNextNotification();
 	}
 }
 
 void Manager::Private::clearAll() {
-	_queuedNotifications.clear();
-
 	auto temp = base::take(_notifications);
 	for_const (auto &notifications, temp) {
 		for_const (auto notification, notifications) {
@@ -496,14 +367,6 @@ void Manager::Private::clearAll() {
 }
 
 void Manager::Private::clearFromHistory(not_null<History*> history) {
-	for (auto i = _queuedNotifications.begin(); i != _queuedNotifications.end();) {
-		if (i->peer == history->peer) {
-			i = _queuedNotifications.erase(i);
-		} else {
-			++i;
-		}
-	}
-
 	auto i = _notifications.find(history->peer->id);
 	if (i != _notifications.cend()) {
 		auto temp = base::take(i.value());
@@ -513,8 +376,6 @@ void Manager::Private::clearFromHistory(not_null<History*> history) {
 			notification->close();
 		}
 	}
-
-	showNextNotification();
 }
 
 void Manager::Private::clearNotification(PeerId peerId, MsgId msgId) {
@@ -525,31 +386,21 @@ void Manager::Private::clearNotification(PeerId peerId, MsgId msgId) {
 			_notifications.erase(i);
 		}
 	}
-
-	showNextNotification();
 }
 
 Manager::Private::~Private() {
 	clearAll();
 }
 
-Manager::Manager(Window::Notifications::System *system) : NativeManager(system)
-, _private(std::make_unique<Private>(Private::Type::Rounded)) {
-	_private->init(this);
+Manager::Manager(Window::Notifications::System *system)
+: NativeManager(system)
+, _private(std::make_unique<Private>(this, Private::Type::Rounded)) {
 }
 
 void Manager::clearNotification(PeerId peerId, MsgId msgId) {
 	_private->clearNotification(peerId, msgId);
 }
 
-bool Manager::hasPoorSupport() const {
-	return _private->hasPoorSupport();
-}
-
-bool Manager::hasActionsSupport() const {
-	return _private->hasActionsSupport();
-}
-
 Manager::~Manager() = default;
 
 void Manager::doShowNativeNotification(
@@ -577,7 +428,6 @@ void Manager::doClearAllFast() {
 void Manager::doClearFromHistory(not_null<History*> history) {
 	_private->clearFromHistory(history);
 }
-#endif // !TDESKTOP_DISABLE_GTK_INTEGRATION
 
 } // namespace Notifications
 } // namespace Platform
diff --git a/Telegram/SourceFiles/platform/linux/notifications_manager_linux.h b/Telegram/SourceFiles/platform/linux/notifications_manager_linux.h
index f40204a56..b5bcc726d 100644
--- a/Telegram/SourceFiles/platform/linux/notifications_manager_linux.h
+++ b/Telegram/SourceFiles/platform/linux/notifications_manager_linux.h
@@ -8,6 +8,11 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #pragma once
 
 #include "platform/platform_notifications_manager.h"
+#include "window/notifications_utilities.h"
+#include "base/weak_ptr.h"
+
+#include <QtDBus/QDBusInterface>
+#include <QtDBus/QDBusArgument>
 
 namespace Platform {
 namespace Notifications {
@@ -23,16 +28,64 @@ inline bool SkipToast() {
 inline void FlashBounce() {
 }
 
-void Finish();
+class NotificationData : public QObject {
+	Q_OBJECT
 
-class Manager : public Window::Notifications::NativeManager {
 public:
-	Manager(Window::Notifications::System *system);
+	NotificationData(
+		const std::shared_ptr<QDBusInterface> &notificationInterface,
+		const base::weak_ptr<Manager> &manager,
+		const QString &title, const QString &subtitle,
+		const QString &msg, PeerId peerId, MsgId msgId);
 
-	void clearNotification(PeerId peerId, MsgId msgId);
-	bool hasPoorSupport() const;
-	bool hasActionsSupport() const;
+	NotificationData(const NotificationData &other) = delete;
+	NotificationData &operator=(const NotificationData &other) = delete;
+	NotificationData(NotificationData &&other) = delete;
+	NotificationData &operator=(NotificationData &&other) = delete;
+
+	bool show();
+	bool close();
+	void setImage(const QString &imagePath);
+
+	struct ImageData {
+		int width, height, rowStride;
+		bool hasAlpha;
+		int bitsPerSample, channels;
+		QByteArray data;
+	};
+
+private:
+	std::shared_ptr<QDBusInterface> _notificationInterface;
+	base::weak_ptr<Manager> _manager;
+
+	QString _title;
+	QString _body;
+	QStringList _actions;
+	QVariantMap _hints;
+
+	uint _notificationId;
+	PeerId _peerId;
+	MsgId _msgId;
 
+private slots:
+	void notificationClosed(uint id);
+	void notificationClicked(uint id);
+};
+
+using Notification = std::shared_ptr<NotificationData>;
+
+QDBusArgument &operator<<(QDBusArgument &argument,
+	const NotificationData::ImageData &imageData);
+
+const QDBusArgument &operator>>(const QDBusArgument &argument,
+	NotificationData::ImageData &imageData);
+
+class Manager
+	: public Window::Notifications::NativeManager
+	, public base::has_weak_ptr {
+public:
+	Manager(Window::Notifications::System *system);
+	void clearNotification(PeerId peerId, MsgId msgId);
 	~Manager();
 
 protected:
@@ -53,5 +106,35 @@ private:
 
 };
 
+class Manager::Private {
+public:
+	using Type = Window::Notifications::CachedUserpics::Type;
+	explicit Private(Manager *manager, Type type);
+
+	void showNotification(
+		not_null<PeerData*> peer,
+		MsgId msgId,
+		const QString &title,
+		const QString &subtitle,
+		const QString &msg,
+		bool hideNameAndPhoto,
+		bool hideReplyButton);
+	void clearAll();
+	void clearFromHistory(not_null<History*> history);
+	void clearNotification(PeerId peerId, MsgId msgId);
+
+	~Private();
+
+private:
+	using Notifications = QMap<PeerId, QMap<MsgId, Notification>>;
+	Notifications _notifications;
+
+	Window::Notifications::CachedUserpics _cachedUserpics;
+	base::weak_ptr<Manager> _manager;
+	std::shared_ptr<QDBusInterface> _notificationInterface;
+};
+
 } // namespace Notifications
 } // namespace Platform
+
+Q_DECLARE_METATYPE(Platform::Notifications::NotificationData::ImageData)
diff --git a/Telegram/SourceFiles/platform/linux/specific_linux.cpp b/Telegram/SourceFiles/platform/linux/specific_linux.cpp
index 68d07a55b..cc70426a1 100644
--- a/Telegram/SourceFiles/platform/linux/specific_linux.cpp
+++ b/Telegram/SourceFiles/platform/linux/specific_linux.cpp
@@ -229,7 +229,6 @@ void start() {
 }
 
 void finish() {
-	Notifications::Finish();
 }
 
 void RegisterCustomScheme() {
diff --git a/Telegram/SourceFiles/platform/mac/mac_touchbar.mm b/Telegram/SourceFiles/platform/mac/mac_touchbar.mm
index fdfbf8578..302e4bdbf 100644
--- a/Telegram/SourceFiles/platform/mac/mac_touchbar.mm
+++ b/Telegram/SourceFiles/platform/mac/mac_touchbar.mm
@@ -29,7 +29,7 @@
 #include "mainwindow.h"
 #include "observer_peer.h"
 #include "base/platform/mac/base_utilities_mac.h"
-#include "stickers.h"
+#include "chat_helpers/stickers.h"
 #include "styles/style_dialogs.h"
 #include "styles/style_media_player.h"
 #include "styles/style_settings.h"
diff --git a/Telegram/SourceFiles/platform/mac/main_window_mac.h b/Telegram/SourceFiles/platform/mac/main_window_mac.h
index 933c0e84c..f02027294 100644
--- a/Telegram/SourceFiles/platform/mac/main_window_mac.h
+++ b/Telegram/SourceFiles/platform/mac/main_window_mac.h
@@ -49,6 +49,7 @@ public slots:
 	void psMacPaste();
 	void psMacDelete();
 	void psMacSelectAll();
+	void psMacEmojiAndSymbols();
 
 	void psMacBold();
 	void psMacItalic();
diff --git a/Telegram/SourceFiles/platform/mac/main_window_mac.mm b/Telegram/SourceFiles/platform/mac/main_window_mac.mm
index 0f4abea06..ce6fbd35f 100644
--- a/Telegram/SourceFiles/platform/mac/main_window_mac.mm
+++ b/Telegram/SourceFiles/platform/mac/main_window_mac.mm
@@ -716,6 +716,9 @@ void MainWindow::createGlobalMenu() {
 	edit->addSeparator();
 	psSelectAll = edit->addAction(tr::lng_mac_menu_select_all(tr::now), this, SLOT(psMacSelectAll()), QKeySequence::SelectAll);
 
+	edit->addSeparator();
+	edit->addAction(tr::lng_mac_menu_emoji_and_symbols(tr::now).replace('&', "&&"), this, SLOT(psMacEmojiAndSymbols()), QKeySequence(Qt::MetaModifier | Qt::ControlModifier | Qt::Key_Space));
+
 	QMenu *window = psMainMenu.addMenu(tr::lng_mac_menu_window(tr::now));
 	psContacts = window->addAction(tr::lng_mac_menu_contacts(tr::now));
 	connect(psContacts, &QAction::triggered, psContacts, crl::guard(this, [=] {
@@ -768,6 +771,10 @@ void MainWindow::psMacSelectAll() {
 	SendKeySequence(Qt::Key_A, Qt::ControlModifier);
 }
 
+void MainWindow::psMacEmojiAndSymbols() {
+	[NSApp orderFrontCharacterPalette:nil];
+}
+
 void MainWindow::psMacBold() {
 	SendKeySequence(Qt::Key_B, Qt::ControlModifier);
 }
diff --git a/Telegram/SourceFiles/platform/mac/window_title_mac.mm b/Telegram/SourceFiles/platform/mac/window_title_mac.mm
index 8eae95b8e..3645bbc1e 100644
--- a/Telegram/SourceFiles/platform/mac/window_title_mac.mm
+++ b/Telegram/SourceFiles/platform/mac/window_title_mac.mm
@@ -185,6 +185,7 @@ void PreviewWindowFramePaint(QImage &preview, const style::palette &palette, QRe
 	corners[3] = roundMask.copy(retinaRadius, retinaRadius, retinaRadius, retinaRadius);
 	auto rounded = preview.copy(inner.x() * retina, inner.y() * retina, inner.width() * retina, inner.height() * retina);
 	Images::prepareRound(rounded, corners);
+	rounded.setDevicePixelRatio(cRetinaFactor());
 	preview.fill(st::themePreviewBg->c);
 
 	auto topLeft = st::macWindowShadowTopLeft.instance(QColor(0, 0, 0), 100);
diff --git a/Telegram/SourceFiles/settings.cpp b/Telegram/SourceFiles/settings.cpp
index 7d5ce1318..94993822b 100644
--- a/Telegram/SourceFiles/settings.cpp
+++ b/Telegram/SourceFiles/settings.cpp
@@ -238,7 +238,6 @@ bool gShowChatId = true;
 
 int gNetSpeedBoost = 0;
 int gNetRequestsCount = 2;
-int gNetDownloadSessionsCount = 2;
 int gNetUploadSessionsCount = 2;
 int gNetMaxFileQueries = 16;
 int gNetUploadRequestInterval = 500;
diff --git a/Telegram/SourceFiles/settings.h b/Telegram/SourceFiles/settings.h
index 389724f7d..7fb03dc1f 100644
--- a/Telegram/SourceFiles/settings.h
+++ b/Telegram/SourceFiles/settings.h
@@ -198,7 +198,6 @@ DeclareSetting(bool, ShowChatId);
 
 DeclareSetting(int, NetSpeedBoost);
 DeclareSetting(int, NetRequestsCount);
-DeclareSetting(int, NetDownloadSessionsCount);
 DeclareSetting(int, NetUploadSessionsCount);
 DeclareSetting(int, NetMaxFileQueries);
 DeclareSetting(int, NetUploadRequestInterval);
@@ -213,7 +212,6 @@ inline void SetNetworkBoost(int boost) {
 	}
 
 	cSetNetRequestsCount(2 + (2 * cNetSpeedBoost()));
-	cSetNetDownloadSessionsCount(2 + (2 * cNetSpeedBoost()));
 	cSetNetUploadSessionsCount(2 + (2 * cNetSpeedBoost()));
 	cSetNetMaxFileQueries(16 + (16 * cNetSpeedBoost()));
 	cSetNetUploadRequestInterval(500 - (100 * cNetSpeedBoost()));
diff --git a/Telegram/SourceFiles/settings/settings_advanced.cpp b/Telegram/SourceFiles/settings/settings_advanced.cpp
index 0a41abef7..b417e0bcc 100644
--- a/Telegram/SourceFiles/settings/settings_advanced.cpp
+++ b/Telegram/SourceFiles/settings/settings_advanced.cpp
@@ -32,6 +32,10 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "app.h"
 #include "styles/style_settings.h"
 
+#ifndef TDESKTOP_DISABLE_SPELLCHECK
+#include "spellcheck/platform/platform_spellcheck.h"
+#endif // !TDESKTOP_DISABLE_SPELLCHECK
+
 namespace Settings {
 
 bool HasConnectionType() {
@@ -48,7 +52,7 @@ void SetupConnectionType(not_null<Ui::VerticalLayout*> container) {
 #ifndef TDESKTOP_DISABLE_NETWORK_PROXY
 	const auto connectionType = [] {
 		const auto transport = MTP::dctransport();
-		if (Global::ProxySettings() != ProxyData::Settings::Enabled) {
+		if (Global::ProxySettings() != MTP::ProxyData::Settings::Enabled) {
 			return transport.isEmpty()
 				? tr::lng_connection_auto_connecting(tr::now)
 				: tr::lng_connection_auto(tr::now, lt_transport, transport);
@@ -246,9 +250,9 @@ void SetupUpdate(not_null<Ui::VerticalLayout*> container) {
 bool HasSystemSpellchecker() {
 #ifdef TDESKTOP_DISABLE_SPELLCHECK
 	return false;
+#else
+	return Platform::Spellchecker::IsAvailable();
 #endif // TDESKTOP_DISABLE_SPELLCHECK
-	return (Platform::IsWindows() && Platform::IsWindows8OrGreater())
-		|| Platform::IsMac();
 }
 
 void SetupSpellchecker(
@@ -452,24 +456,6 @@ void SetupPerformance(
 		not_null<Window::SessionController*> controller,
 		not_null<Ui::VerticalLayout*> container) {
 	SetupAnimations(container);
-
-	const auto session = &controller->session();
-	AddButton(
-		container,
-		tr::lng_settings_autoplay_gifs(),
-		st::settingsButton
-	)->toggleOn(
-		rpl::single(session->settings().autoplayGifs())
-	)->toggledValue(
-	) | rpl::filter([=](bool enabled) {
-		return (enabled != session->settings().autoplayGifs());
-	}) | rpl::start_with_next([=](bool enabled) {
-		session->settings().setAutoplayGifs(enabled);
-		if (!enabled) {
-			session->data().stopAutoplayAnimations();
-		}
-		session->saveSettingsDelayed();
-	}, container->lifetime());
 }
 
 void SetupSystemIntegration(
diff --git a/Telegram/SourceFiles/settings/settings_chat.cpp b/Telegram/SourceFiles/settings/settings_chat.cpp
index d72ceb81b..3477ca29f 100644
--- a/Telegram/SourceFiles/settings/settings_chat.cpp
+++ b/Telegram/SourceFiles/settings/settings_chat.cpp
@@ -40,6 +40,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "core/application.h"
 #include "data/data_session.h"
 #include "data/data_cloud_themes.h"
+#include "data/data_file_origin.h"
 #include "chat_helpers/emoji_sets_manager.h"
 #include "base/platform/base_platform_info.h"
 #include "base/call_delayed.h"
diff --git a/Telegram/SourceFiles/settings/settings_privacy_controllers.cpp b/Telegram/SourceFiles/settings/settings_privacy_controllers.cpp
index 8d1923322..8915df45c 100644
--- a/Telegram/SourceFiles/settings/settings_privacy_controllers.cpp
+++ b/Telegram/SourceFiles/settings/settings_privacy_controllers.cpp
@@ -180,7 +180,8 @@ AdminLog::OwnedItem GenerateForwardedItem(
 
 BlockedBoxController::BlockedBoxController(
 	not_null<Window::SessionController*> window)
-: _window(window) {
+: _window(window)
+, _api(_window->session().api().instance()) {
 }
 
 Main::Session &BlockedBoxController::session() const {
@@ -220,7 +221,7 @@ void BlockedBoxController::loadMoreRows() {
 		return;
 	}
 
-	_loadRequestId = request(MTPcontacts_GetBlocked(
+	_loadRequestId = _api.request(MTPcontacts_GetBlocked(
 		MTP_int(_offset),
 		MTP_int(kBlockedPerPage)
 	)).done([=](const MTPcontacts_Blocked &result) {
@@ -336,7 +337,7 @@ std::unique_ptr<PeerListRow> BlockedBoxController::createRow(
 		return tr::lng_blocked_list_unknown_phone(tr::now);
 	}();
 	row->setCustomStatus(status);
-	return std::move(row);
+	return row;
 }
 
 ApiWrap::Privacy::Key PhoneNumberPrivacyController::key() {
@@ -446,7 +447,7 @@ object_ptr<Ui::RpWidget> PhoneNumberPrivacyController::setupMiddleWidget(
 			QVector<MTPInputPrivacyRule>(1, value));
 	};
 
-	return std::move(widget);
+	return widget;
 }
 
 void PhoneNumberPrivacyController::saveAdditional() {
diff --git a/Telegram/SourceFiles/settings/settings_privacy_controllers.h b/Telegram/SourceFiles/settings/settings_privacy_controllers.h
index 0b0f9eec6..2a9bf11b6 100644
--- a/Telegram/SourceFiles/settings/settings_privacy_controllers.h
+++ b/Telegram/SourceFiles/settings/settings_privacy_controllers.h
@@ -16,8 +16,7 @@ namespace Settings {
 
 class BlockedBoxController
 	: public PeerListController
-	, private base::Subscriber
-	, private MTP::Sender {
+	, private base::Subscriber {
 public:
 	explicit BlockedBoxController(
 		not_null<Window::SessionController*> window);
@@ -39,6 +38,7 @@ private:
 	std::unique_ptr<PeerListRow> createRow(not_null<UserData*> user) const;
 
 	const not_null<Window::SessionController*> _window;
+	MTP::Sender _api;
 
 	int _offset = 0;
 	mtpRequestId _loadRequestId = 0;
diff --git a/Telegram/SourceFiles/settings/settings_privacy_security.cpp b/Telegram/SourceFiles/settings/settings_privacy_security.cpp
index 896360626..dafccb221 100644
--- a/Telegram/SourceFiles/settings/settings_privacy_security.cpp
+++ b/Telegram/SourceFiles/settings/settings_privacy_security.cpp
@@ -7,6 +7,8 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 */
 #include "settings/settings_privacy_security.h"
 
+#include "api/api_self_destruct.h"
+#include "api/api_sensitive_content.h"
 #include "settings/settings_common.h"
 #include "settings/settings_privacy_controllers.h"
 #include "boxes/peer_list_box.h"
@@ -428,20 +430,56 @@ void SetupCloudPassword(
 	session->api().reloadPasswordState();
 
 	AddSkip(container);
+	AddDivider(container);
+}
+
+void SetupSensitiveContent(
+		not_null<Window::SessionController*> controller,
+		not_null<Ui::VerticalLayout*> container) {
+	using namespace rpl::mappers;
+
+	const auto wrap = container->add(
+		object_ptr<Ui::SlideWrap<Ui::VerticalLayout>>(
+			container,
+			object_ptr<Ui::VerticalLayout>(container)));
+	const auto inner = wrap->entity();
+
+	AddSkip(inner);
+	AddSubsectionTitle(inner, tr::lng_settings_sensitive_title());
+
+	const auto session = &controller->session();
+
+	session->api().sensitiveContent().reload();
+	AddButton(
+		inner,
+		tr::lng_settings_sensitive_disable_filtering(),
+		st::settingsButton
+	)->toggleOn(
+		session->api().sensitiveContent().enabled()
+	)->toggledChanges(
+	) | rpl::filter([=](bool toggled) {
+		return toggled != session->api().sensitiveContent().enabledCurrent();
+	}) | rpl::start_with_next([=](bool toggled) {
+		session->api().sensitiveContent().update(toggled);
+	}, container->lifetime());
+
+	AddSkip(inner);
+	AddDividerText(inner, tr::lng_settings_sensitive_about());
+
+	wrap->toggleOn(session->api().sensitiveContent().canChange());
 }
 
 void SetupSelfDestruction(
 		not_null<Window::SessionController*> controller,
 		not_null<Ui::VerticalLayout*> container) {
-	AddDivider(container);
 	AddSkip(container);
 	AddSubsectionTitle(container, tr::lng_settings_destroy_title());
 
 	const auto session = &controller->session();
 
-	session->api().reloadSelfDestruct();
+	session->api().selfDestruct().reload();
 	const auto label = [&] {
-		return session->api().selfDestructValue(
+		return session->api().selfDestruct().days(
 		) | rpl::map(
 			SelfDestructionBox::DaysLabel
 		);
@@ -455,7 +493,7 @@ void SetupSelfDestruction(
 	)->addClickHandler([=] {
 		Ui::show(Box<SelfDestructionBox>(
 			session,
-			session->api().selfDestructValue()));
+			session->api().selfDestruct().days()));
 	});
 
 	AddSkip(container);
@@ -525,7 +563,7 @@ object_ptr<Ui::BoxContent> EditCloudPasswordBox(not_null<Main::Session*> session
 		session->api().clearUnconfirmedPassword();
 	}, box->lifetime());
 
-	return std::move(result);
+	return result;
 }
 
 void RemoveCloudPassword(not_null<::Main::Session*> session) {
@@ -565,7 +603,7 @@ object_ptr<Ui::BoxContent> CloudPasswordAppOutdatedBox() {
 		tr::lng_menu_update(tr::now),
 		callback);
 	*box = result.data();
-	return std::move(result);
+	return result;
 }
 
 void AddPrivacyButton(
@@ -609,6 +647,11 @@ void PrivacySecurity::setupContent(
 	SetupSessionsList(controller, content);
 	SetupLocalPasscode(controller, content);
 	SetupCloudPassword(controller, content);
+#if !defined OS_MAC_STORE && !defined OS_WIN_STORE
+	SetupSensitiveContent(controller, content);
+#else // !OS_MAC_STORE && !OS_WIN_STORE
+	AddDivider(content);
+#endif // !OS_MAC_STORE && !OS_WIN_STORE
 	SetupSelfDestruction(controller, content);
 
 	Ui::ResizeFitChild(this, content);
diff --git a/Telegram/SourceFiles/stdafx.h b/Telegram/SourceFiles/stdafx.h
index 2f93879cf..ccba4b9bc 100644
--- a/Telegram/SourceFiles/stdafx.h
+++ b/Telegram/SourceFiles/stdafx.h
@@ -8,10 +8,6 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 
 #define __HUGE
 
-#ifdef OS_MAC_STORE
-#define MAC_USE_BREAKPAD
-#endif // OS_MAC_STORE
-
 #ifdef __cplusplus
 
 #include <cmath>
@@ -120,7 +116,8 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "core/utils.h"
 #include "config.h"
 
-#include "mtproto/facade.h"
+#include "scheme.h"
+#include "mtproto/type_utils.h"
 
 #include "ui/style/style_core.h"
 #include "styles/palette.h"
diff --git a/Telegram/SourceFiles/storage/download_manager_mtproto.cpp b/Telegram/SourceFiles/storage/download_manager_mtproto.cpp
new file mode 100644
index 000000000..9d6f25be4
--- /dev/null
+++ b/Telegram/SourceFiles/storage/download_manager_mtproto.cpp
@@ -0,0 +1,970 @@
+/*
+This file is part of Telegram Desktop,
+the official desktop application for the Telegram messaging service.
+
+For license and copyright information please follow this link:
+https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+*/
+#include "storage/download_manager_mtproto.h"
+
+#include "mtproto/facade.h"
+#include "mtproto/mtproto_auth_key.h"
+#include "mtproto/mtproto_rpc_sender.h"
+#include "main/main_session.h"
+#include "apiwrap.h"
+#include "base/openssl_help.h"
+
+namespace Storage {
+namespace {
+
+constexpr auto kKillSessionTimeout = 15 * crl::time(1000);
+constexpr auto kStartWaitedInSession = 4 * kDownloadPartSize;
+constexpr auto kMaxWaitedInSession = 16 * kDownloadPartSize;
+constexpr auto kStartSessionsCount = 1;
+constexpr auto kMaxSessionsCount = 8;
+constexpr auto kMaxTrackedSessionRemoves = 64;
+constexpr auto kRetryAddSessionTimeout = 8 * crl::time(1000);
+constexpr auto kRetryAddSessionSuccesses = 3;
+constexpr auto kMaxTrackedSuccesses = kRetryAddSessionSuccesses
+	* kMaxTrackedSessionRemoves;
+constexpr auto kRemoveSessionAfterTimeouts = 4;
+constexpr auto kResetDownloadPrioritiesTimeout = crl::time(200);
+constexpr auto kBadRequestDurationThreshold = 8 * crl::time(1000);
+
+// Each (session remove by timeouts) we wait for time:
+// kRetryAddSessionTimeout * max(removesCount, kMaxTrackedSessionRemoves)
+// and for successes in all remaining sessions:
+// kRetryAddSessionSuccesses * max(removesCount, kMaxTrackedSessionRemoves)
+
+} // namespace
+
+void DownloadManagerMtproto::Queue::enqueue(
+		not_null<Task*> task,
+		int priority) {
+	const auto position = ranges::find_if(_tasks, [&](const Enqueued &task) {
+		return task.priority <= priority;
+	}) - begin(_tasks);
+	const auto now = ranges::find(_tasks, task, &Enqueued::task);
+	const auto i = [&] {
+		if (now != end(_tasks)) {
+			(now->priority = priority);
+			return now;
+		}
+		_tasks.push_back({ task, priority });
+		return end(_tasks) - 1;
+	}();
+	const auto j = begin(_tasks) + position;
+	if (j < i) {
+		std::rotate(j, i, i + 1);
+	} else if (j > i + 1) {
+		std::rotate(i, i + 1, j);
+	}
+}
+
+void DownloadManagerMtproto::Queue::remove(not_null<Task*> task) {
+	_tasks.erase(ranges::remove(_tasks, task, &Enqueued::task), end(_tasks));
+}
+
+void DownloadManagerMtproto::Queue::resetGeneration() {
+	const auto from = ranges::find(_tasks, 0, &Enqueued::priority);
+	for (auto &task : ranges::make_subrange(from, end(_tasks))) {
+		if (task.priority) {
+			Assert(task.priority == -1);
+			break;
+		}
+		task.priority = -1;
+	}
+}
+
+bool DownloadManagerMtproto::Queue::empty() const {
+	return _tasks.empty();
+}
+
+auto DownloadManagerMtproto::Queue::nextTask(bool onlyHighestPriority) const
+-> Task* {
+	if (_tasks.empty()) {
+		return nullptr;
+	}
+	const auto highestPriority = _tasks.front().priority;
+	const auto notHighestPriority = [&](const Enqueued &enqueued) {
+		return (enqueued.priority != highestPriority);
+	};
+	const auto till = (onlyHighestPriority && highestPriority > 0)
+		? ranges::find_if(_tasks, notHighestPriority)
+		: end(_tasks);
+	const auto readyToRequest = [&](const Enqueued &enqueued) {
+		return enqueued.task->readyToRequest();
+	};
+	const auto first = ranges::find_if(
+		ranges::make_subrange(begin(_tasks), till),
+		readyToRequest);
+	return (first != till) ? first->task.get() : nullptr;
+}
+
+void DownloadManagerMtproto::Queue::removeSession(int index) {
+	for (const auto &enqueued : _tasks) {
+		enqueued.task->removeSession(index);
+	}
+}
+
+DownloadManagerMtproto::DcSessionBalanceData::DcSessionBalanceData()
+: maxWaitedAmount(kStartWaitedInSession) {
+}
+
+DownloadManagerMtproto::DcBalanceData::DcBalanceData()
+: sessions(kStartSessionsCount) {
+}
+
+DownloadManagerMtproto::DownloadManagerMtproto(not_null<ApiWrap*> api)
+: _api(api)
+, _resetGenerationTimer([=] { resetGeneration(); })
+, _killSessionsTimer([=] { killSessions(); }) {
+	_api->instance()->restartsByTimeout(
+	) | rpl::filter([](MTP::ShiftedDcId shiftedDcId) {
+		return MTP::isDownloadDcId(shiftedDcId);
+	}) | rpl::start_with_next([=](MTP::ShiftedDcId shiftedDcId) {
+		sessionTimedOut(
+			MTP::BareDcId(shiftedDcId),
+			MTP::GetDcIdShift(shiftedDcId));
+	}, _lifetime);
+}
+
+DownloadManagerMtproto::~DownloadManagerMtproto() {
+	killSessions();
+}
+
+void DownloadManagerMtproto::enqueue(not_null<Task*> task, int priority) {
+	const auto dcId = task->dcId();
+	auto &queue = _queues[dcId];
+	queue.enqueue(task, priority);
+	if (!_resetGenerationTimer.isActive()) {
+		_resetGenerationTimer.callOnce(kResetDownloadPrioritiesTimeout);
+	}
+	checkSendNext(dcId, queue);
+}
+
+void DownloadManagerMtproto::remove(not_null<Task*> task) {
+	const auto dcId = task->dcId();
+	auto &queue = _queues[dcId];
+	queue.remove(task);
+	checkSendNext(dcId, queue);
+}
+
+void DownloadManagerMtproto::resetGeneration() {
+	_resetGenerationTimer.cancel();
+	for (auto &[dcId, queue] : _queues) {
+		queue.resetGeneration();
+	}
+}
+
+void DownloadManagerMtproto::checkSendNext() {
+	for (auto &[dcId, queue] : _queues) {
+		if (queue.empty()) {
+			continue;
+		}
+		checkSendNext(dcId, queue);
+	}
+}
+
+void DownloadManagerMtproto::checkSendNext(MTP::DcId dcId, Queue &queue) {
+	while (trySendNextPart(dcId, queue)) {
+	}
+}
+
+bool DownloadManagerMtproto::trySendNextPart(MTP::DcId dcId, Queue &queue) {
+	auto &balanceData = _balanceData[dcId];
+	const auto &sessions = balanceData.sessions;
+	const auto bestIndex = [&] {
+		const auto proj = [](const DcSessionBalanceData &data) {
+			return (data.requested < data.maxWaitedAmount)
+				? data.requested
+				: kMaxWaitedInSession;
+		};
+		const auto j = ranges::min_element(sessions, ranges::less(), proj);
+		return (j->requested + kDownloadPartSize <= j->maxWaitedAmount)
+			? (j - begin(sessions))
+			: -1;
+	}();
+	if (bestIndex < 0) {
+		return false;
+	}
+	const auto onlyHighestPriority = (balanceData.totalRequested > 0);
+	if (const auto task = queue.nextTask(onlyHighestPriority)) {
+		task->loadPart(bestIndex);
+		return true;
+	}
+	return false;
+}
+
+int DownloadManagerMtproto::changeRequestedAmount(
+		MTP::DcId dcId,
+		int index,
+		int delta) {
+	const auto i = _balanceData.find(dcId);
+	Assert(i != _balanceData.end());
+	Assert(index < i->second.sessions.size());
+	const auto result = (i->second.sessions[index].requested += delta);
+	i->second.totalRequested += delta;
+	const auto findNonEmptySession = [](const DcBalanceData &data) {
+		using namespace rpl::mappers;
+		return ranges::find_if(
+			data.sessions,
+			_1 > 0,
+			&DcSessionBalanceData::requested);
+	};
+	if (delta > 0) {
+		killSessionsCancel(dcId);
+	} else if (findNonEmptySession(i->second) == end(i->second.sessions)) {
+		killSessionsSchedule(dcId);
+	}
+	return result;
+}
+
+void DownloadManagerMtproto::requestSucceeded(
+		MTP::DcId dcId,
+		int index,
+		int amountAtRequestStart,
+		crl::time timeAtRequestStart) {
+	using namespace rpl::mappers;
+
+	const auto guard = gsl::finally([&] {
+		checkSendNext(dcId, _queues[dcId]);
+	});
+
+	const auto i = _balanceData.find(dcId);
+	Assert(i != end(_balanceData));
+	auto &dc = i->second;
+	Assert(index < dc.sessions.size());
+	auto &data = dc.sessions[index];
+	const auto overloaded = (timeAtRequestStart <= dc.lastSessionRemove)
+		|| (amountAtRequestStart > data.maxWaitedAmount);
+	const auto parts = amountAtRequestStart / kDownloadPartSize;
+	const auto duration = (crl::now() - timeAtRequestStart);
+	DEBUG_LOG(("Download (%1,%2) request done, duration: %3, parts: %4%5"
+		).arg(dcId
+		).arg(index
+		).arg(duration
+		).arg(parts
+		).arg(overloaded ? " (overloaded)" : ""));
+	if (overloaded) {
+		return;
+	}
+
+	if (duration >= kBadRequestDurationThreshold) {
+		DEBUG_LOG(("Duration too large, signaling time out."));
+		sessionTimedOut(dcId, index);
+		return;
+	}
+	if (amountAtRequestStart == data.maxWaitedAmount
+		&& data.maxWaitedAmount < kMaxWaitedInSession) {
+		data.maxWaitedAmount = std::min(
+			data.maxWaitedAmount + kDownloadPartSize,
+			kMaxWaitedInSession);
+		DEBUG_LOG(("Download (%1,%2) increased max waited amount %3."
+			).arg(dcId
+			).arg(index
+			).arg(data.maxWaitedAmount));
+	}
+	data.successes = std::min(data.successes + 1, kMaxTrackedSuccesses);
+	const auto notEnough = ranges::find_if(
+		dc.sessions,
+		_1 < (dc.sessionRemoveTimes + 1) * kRetryAddSessionSuccesses,
+		&DcSessionBalanceData::successes);
+	if (notEnough != end(dc.sessions)) {
+		return;
+	}
+	for (auto &session : dc.sessions) {
+		session.successes = 0;
+	}
+	if (dc.timeouts > 0) {
+		--dc.timeouts;
+		return;
+	} else if (dc.sessions.size() == kMaxSessionsCount) {
+		return;
+	}
+	const auto now = crl::now();
+	const auto delay = (dc.sessionRemoveTimes + 1) * kRetryAddSessionTimeout;
+	if (dc.lastSessionRemove && now < dc.lastSessionRemove + delay) {
+		return;
+	}
+	dc.sessions.emplace_back();
+	DEBUG_LOG(("Download (%1,%2) adding, now sessions: %3"
+		).arg(dcId
+		).arg(dc.sessions.size() - 1
+		).arg(dc.sessions.size()));
+}
+
+int DownloadManagerMtproto::chooseSessionIndex(MTP::DcId dcId) const {
+	const auto i = _balanceData.find(dcId);
+	Assert(i != end(_balanceData));
+	const auto &sessions = i->second.sessions;
+	const auto j = ranges::min_element(
+		sessions,
+		ranges::less(),
+		&DcSessionBalanceData::requested);
+	return (j - begin(sessions));
+}
+
+void DownloadManagerMtproto::sessionTimedOut(MTP::DcId dcId, int index) {
+	const auto i = _balanceData.find(dcId);
+	if (i == end(_balanceData)) {
+		return;
+	}
+	auto &dc = i->second;
+	if (index >= dc.sessions.size()) {
+		return;
+	}
+	DEBUG_LOG(("Download (%1,%2) session timed-out.").arg(dcId).arg(index));
+	for (auto &session : dc.sessions) {
+		session.successes = 0;
+	}
+	if (dc.sessions.size() == kStartSessionsCount
+		|| ++dc.timeouts < kRemoveSessionAfterTimeouts) {
+		return;
+	}
+	dc.timeouts = 0;
+	removeSession(dcId);
+}
+
+void DownloadManagerMtproto::removeSession(MTP::DcId dcId) {
+	auto &dc = _balanceData[dcId];
+	Assert(dc.sessions.size() > kStartSessionsCount);
+	const auto index = int(dc.sessions.size() - 1);
+	DEBUG_LOG(("Download (%1,%2) removing, now sessions: %3"
+		).arg(dcId
+		).arg(index
+		).arg(index));
+	auto &queue = _queues[dcId];
+	if (dc.sessionRemoveIndex == index) {
+		dc.sessionRemoveTimes = std::min(
+			dc.sessionRemoveTimes + 1,
+			kMaxTrackedSessionRemoves);
+	} else {
+		dc.sessionRemoveIndex = index;
+		dc.sessionRemoveTimes = 1;
+	}
+	auto &session = dc.sessions.back();
+
+	// Make sure we don't send anything to that session while redirecting.
+	session.requested += kMaxWaitedInSession * kMaxSessionsCount;
+	_queues[dcId].removeSession(index);
+	Assert(session.requested == kMaxWaitedInSession * kMaxSessionsCount);
+
+	dc.sessions.pop_back();
+	MTP::killSession(MTP::downloadDcId(dcId, index));
+
+	dc.lastSessionRemove = crl::now();
+}
+
+void DownloadManagerMtproto::killSessionsSchedule(MTP::DcId dcId) {
+	if (!_killSessionsWhen.contains(dcId)) {
+		_killSessionsWhen.emplace(dcId, crl::now() + kKillSessionTimeout);
+	}
+	if (!_killSessionsTimer.isActive()) {
+		_killSessionsTimer.callOnce(kKillSessionTimeout + 5);
+	}
+}
+
+void DownloadManagerMtproto::killSessionsCancel(MTP::DcId dcId) {
+	_killSessionsWhen.erase(dcId);
+	if (_killSessionsWhen.empty()) {
+		_killSessionsTimer.cancel();
+	}
+}
+
+void DownloadManagerMtproto::killSessions() {
+	const auto now = crl::now();
+	auto left = kKillSessionTimeout;
+	for (auto i = begin(_killSessionsWhen); i != end(_killSessionsWhen); ) {
+		if (i->second <= now) {
+			killSessions(i->first);
+			i = _killSessionsWhen.erase(i);
+		} else {
+			if (i->second - now < left) {
+				left = i->second - now;
+			}
+			++i;
+		}
+	}
+	if (!_killSessionsWhen.empty()) {
+		_killSessionsTimer.callOnce(left);
+	}
+}
+
+void DownloadManagerMtproto::killSessions(MTP::DcId dcId) {
+	const auto i = _balanceData.find(dcId);
+	if (i != end(_balanceData)) {
+		auto &dc = i->second;
+		Assert(dc.totalRequested == 0);
+		auto sessions = base::take(dc.sessions);
+		dc = DcBalanceData();
+		for (auto j = 0; j != int(sessions.size()); ++j) {
+			Assert(sessions[j].requested == 0);
+			sessions[j] = DcSessionBalanceData();
+			MTP::stopSession(MTP::downloadDcId(dcId, j));
+		}
+		dc.sessions = base::take(sessions);
+	}
+}
+
+DownloadMtprotoTask::DownloadMtprotoTask(
+	not_null<DownloadManagerMtproto*> owner,
+	const StorageFileLocation &location,
+	Data::FileOrigin origin)
+: _owner(owner)
+, _dcId(location.dcId())
+, _location({ location })
+, _origin(origin) {
+}
+
+DownloadMtprotoTask::DownloadMtprotoTask(
+	not_null<DownloadManagerMtproto*> owner,
+	MTP::DcId dcId,
+	const Location &location)
+: _owner(owner)
+, _dcId(dcId)
+, _location(location) {
+}
+
+DownloadMtprotoTask::~DownloadMtprotoTask() {
+	cancelAllRequests();
+	_owner->remove(this);
+}
+
+MTP::DcId DownloadMtprotoTask::dcId() const {
+	return _dcId;
+}
+
+Data::FileOrigin DownloadMtprotoTask::fileOrigin() const {
+	return _origin;
+}
+
+uint64 DownloadMtprotoTask::objectId() const {
+	if (const auto v = base::get_if<StorageFileLocation>(&_location.data)) {
+		return v->objectId();
+	}
+	return 0;
+}
+
+const DownloadMtprotoTask::Location &DownloadMtprotoTask::location() const {
+	return _location;
+}
+
+void DownloadMtprotoTask::refreshFileReferenceFrom(
+		const Data::UpdatedFileReferences &updates,
+		int requestId,
+		const QByteArray &current) {
+	if (const auto v = base::get_if<StorageFileLocation>(&_location.data)) {
+		v->refreshFileReference(updates);
+		if (v->fileReference() == current) {
+			cancelOnFail();
+			return;
+		}
+	} else {
+		cancelOnFail();
+		return;
+	}
+	if (_sentRequests.contains(requestId)) {
+		makeRequest(finishSentRequest(
+			requestId,
+			FinishRequestReason::Redirect));
+	}
+}
+
+void DownloadMtprotoTask::loadPart(int sessionIndex) {
+	makeRequest({ takeNextRequestOffset(), sessionIndex });
+}
+
+void DownloadMtprotoTask::removeSession(int sessionIndex) {
+	struct Redirect {
+		mtpRequestId requestId = 0;
+		int offset = 0;
+	};
+	auto redirect = std::vector<Redirect>();
+	for (const auto &[requestId, requestData] : _sentRequests) {
+		if (requestData.sessionIndex == sessionIndex) {
+			redirect.reserve(_sentRequests.size());
+			redirect.push_back({ requestId, requestData.offset });
+		}
+	}
+	for (const auto &[requestId, offset] : redirect) {
+		cancelRequest(requestId);
+		const auto newIndex = _owner->chooseSessionIndex(dcId());
+		Assert(newIndex < sessionIndex);
+		makeRequest({ offset, newIndex });
+	}
+}
+
+mtpRequestId DownloadMtprotoTask::sendRequest(
+		const RequestData &requestData) {
+	const auto offset = requestData.offset;
+	const auto limit = Storage::kDownloadPartSize;
+	const auto shiftedDcId = MTP::downloadDcId(
+		_cdnDcId ? _cdnDcId : dcId(),
+		requestData.sessionIndex);
+	if (_cdnDcId) {
+		return api().request(MTPupload_GetCdnFile(
+			MTP_bytes(_cdnToken),
+			MTP_int(offset),
+			MTP_int(limit)
+		)).done([=](const MTPupload_CdnFile &result, mtpRequestId id) {
+			cdnPartLoaded(result, id);
+		}).fail([=](const RPCError &error, mtpRequestId id) {
+			cdnPartFailed(error, id);
+		}).toDC(shiftedDcId).send();
+	}
+	return _location.data.match([&](const WebFileLocation &location) {
+		return api().request(MTPupload_GetWebFile(
+			MTP_inputWebFileLocation(
+				MTP_bytes(location.url()),
+				MTP_long(location.accessHash())),
+			MTP_int(offset),
+			MTP_int(limit)
+		)).done([=](const MTPupload_WebFile &result, mtpRequestId id) {
+			webPartLoaded(result, id);
+		}).fail([=](const RPCError &error, mtpRequestId id) {
+			partFailed(error, id);
+		}).toDC(shiftedDcId).send();
+	}, [&](const GeoPointLocation &location) {
+		return api().request(MTPupload_GetWebFile(
+			MTP_inputWebFileGeoPointLocation(
+				MTP_inputGeoPoint(
+					MTP_double(location.lat),
+					MTP_double(location.lon)),
+				MTP_long(location.access),
+				MTP_int(location.width),
+				MTP_int(location.height),
+				MTP_int(location.zoom),
+				MTP_int(location.scale)),
+			MTP_int(offset),
+			MTP_int(limit)
+		)).done([=](const MTPupload_WebFile &result, mtpRequestId id) {
+			webPartLoaded(result, id);
+		}).fail([=](const RPCError &error, mtpRequestId id) {
+			partFailed(error, id);
+		}).toDC(shiftedDcId).send();
+	}, [&](const StorageFileLocation &location) {
+		const auto reference = location.fileReference();
+		return api().request(MTPupload_GetFile(
+			MTP_flags(0),
+			location.tl(api().session().userId()),
+			MTP_int(offset),
+			MTP_int(limit)
+		)).done([=](const MTPupload_File &result, mtpRequestId id) {
+			normalPartLoaded(result, id);
+		}).fail([=](const RPCError &error, mtpRequestId id) {
+			normalPartFailed(reference, error, id);
+		}).toDC(shiftedDcId).send();
+	});
+}
+
+bool DownloadMtprotoTask::setWebFileSizeHook(int size) {
+	return true;
+}
+
+void DownloadMtprotoTask::makeRequest(const RequestData &requestData) {
+	placeSentRequest(sendRequest(requestData), requestData);
+}
+
+void DownloadMtprotoTask::requestMoreCdnFileHashes() {
+	if (_cdnHashesRequestId || _cdnUncheckedParts.empty()) {
+		return;
+	}
+
+	const auto requestData = _cdnUncheckedParts.cbegin()->first;
+	const auto shiftedDcId = MTP::downloadDcId(
+		dcId(),
+		requestData.sessionIndex);
+	_cdnHashesRequestId = api().request(MTPupload_GetCdnFileHashes(
+		MTP_bytes(_cdnToken),
+		MTP_int(requestData.offset)
+	)).done([=](const MTPVector<MTPFileHash> &result, mtpRequestId id) {
+		getCdnFileHashesDone(result, id);
+	}).fail([=](const RPCError &error, mtpRequestId id) {
+		cdnPartFailed(error, id);
+	}).toDC(shiftedDcId).send();
+	placeSentRequest(_cdnHashesRequestId, requestData);
+}
+
+void DownloadMtprotoTask::normalPartLoaded(
+		const MTPupload_File &result,
+		mtpRequestId requestId) {
+	const auto requestData = finishSentRequest(
+		requestId,
+		FinishRequestReason::Success);
+	result.match([&](const MTPDupload_fileCdnRedirect &data) {
+		switchToCDN(requestData, data);
+	}, [&](const MTPDupload_file &data) {
+		partLoaded(requestData.offset, data.vbytes().v);
+	});
+}
+
+void DownloadMtprotoTask::webPartLoaded(
+		const MTPupload_WebFile &result,
+		mtpRequestId requestId) {
+	result.match([&](const MTPDupload_webFile &data) {
+		const auto requestData = finishSentRequest(
+			requestId,
+			FinishRequestReason::Success);
+		if (setWebFileSizeHook(data.vsize().v)) {
+			partLoaded(requestData.offset, data.vbytes().v);
+		}
+	});
+}
+
+void DownloadMtprotoTask::cdnPartLoaded(const MTPupload_CdnFile &result, mtpRequestId requestId) {
+	result.match([&](const MTPDupload_cdnFileReuploadNeeded &data) {
+		const auto requestData = finishSentRequest(
+			requestId,
+			FinishRequestReason::Redirect);
+		const auto shiftedDcId = MTP::downloadDcId(
+			dcId(),
+			requestData.sessionIndex);
+		const auto requestId = api().request(MTPupload_ReuploadCdnFile(
+			MTP_bytes(_cdnToken),
+			data.vrequest_token()
+		)).done([=](const MTPVector<MTPFileHash> &result, mtpRequestId id) {
+			reuploadDone(result, id);
+		}).fail([=](const RPCError &error, mtpRequestId id) {
+			cdnPartFailed(error, id);
+		}).toDC(shiftedDcId).send();
+		placeSentRequest(requestId, requestData);
+	}, [&](const MTPDupload_cdnFile &data) {
+		const auto requestData = finishSentRequest(
+			requestId,
+			FinishRequestReason::Success);
+		auto key = bytes::make_span(_cdnEncryptionKey);
+		auto iv = bytes::make_span(_cdnEncryptionIV);
+		Expects(key.size() == MTP::CTRState::KeySize);
+		Expects(iv.size() == MTP::CTRState::IvecSize);
+
+		auto state = MTP::CTRState();
+		auto ivec = bytes::make_span(state.ivec);
+		std::copy(iv.begin(), iv.end(), ivec.begin());
+
+		auto counterOffset = static_cast<uint32>(requestData.offset) >> 4;
+		state.ivec[15] = static_cast<uchar>(counterOffset & 0xFF);
+		state.ivec[14] = static_cast<uchar>((counterOffset >> 8) & 0xFF);
+		state.ivec[13] = static_cast<uchar>((counterOffset >> 16) & 0xFF);
+		state.ivec[12] = static_cast<uchar>((counterOffset >> 24) & 0xFF);
+
+		auto decryptInPlace = data.vbytes().v;
+		auto buffer = bytes::make_detached_span(decryptInPlace);
+		MTP::aesCtrEncrypt(buffer, key.data(), &state);
+
+		switch (checkCdnFileHash(requestData.offset, buffer)) {
+		case CheckCdnHashResult::NoHash: {
+			_cdnUncheckedParts.emplace(requestData, decryptInPlace);
+			requestMoreCdnFileHashes();
+		} return;
+
+		case CheckCdnHashResult::Invalid: {
+			LOG(("API Error: Wrong cdnFileHash for offset %1."
+				).arg(requestData.offset));
+			cancelOnFail();
+		} return;
+
+		case CheckCdnHashResult::Good: {
+			partLoaded(requestData.offset, decryptInPlace);
+		} return;
+		}
+		Unexpected("Result of checkCdnFileHash()");
+	});
+}
+
+DownloadMtprotoTask::CheckCdnHashResult DownloadMtprotoTask::checkCdnFileHash(
+		int offset,
+		bytes::const_span buffer) {
+	const auto cdnFileHashIt = _cdnFileHashes.find(offset);
+	if (cdnFileHashIt == _cdnFileHashes.cend()) {
+		return CheckCdnHashResult::NoHash;
+	}
+	const auto realHash = openssl::Sha256(buffer);
+	const auto receivedHash = bytes::make_span(cdnFileHashIt->second.hash);
+	if (bytes::compare(realHash, receivedHash)) {
+		return CheckCdnHashResult::Invalid;
+	}
+	return CheckCdnHashResult::Good;
+}
+
+void DownloadMtprotoTask::reuploadDone(
+		const MTPVector<MTPFileHash> &result,
+		mtpRequestId requestId) {
+	const auto requestData = finishSentRequest(
+		requestId,
+		FinishRequestReason::Redirect);
+	addCdnHashes(result.v);
+	makeRequest(requestData);
+}
+
+void DownloadMtprotoTask::getCdnFileHashesDone(
+		const MTPVector<MTPFileHash> &result,
+		mtpRequestId requestId) {
+	Expects(_cdnHashesRequestId == requestId);
+
+	const auto requestData = finishSentRequest(
+		requestId,
+		FinishRequestReason::Redirect);
+	addCdnHashes(result.v);
+	auto someMoreChecked = false;
+	for (auto i = _cdnUncheckedParts.begin(); i != _cdnUncheckedParts.cend();) {
+		const auto uncheckedData = i->first;
+		const auto uncheckedBytes = bytes::make_span(i->second);
+
+		switch (checkCdnFileHash(uncheckedData.offset, uncheckedBytes)) {
+		case CheckCdnHashResult::NoHash: {
+			++i;
+		} break;
+
+		case CheckCdnHashResult::Invalid: {
+			LOG(("API Error: Wrong cdnFileHash for offset %1."
+				).arg(uncheckedData.offset));
+			cancelOnFail();
+			return;
+		} break;
+
+		case CheckCdnHashResult::Good: {
+			someMoreChecked = true;
+			const auto goodOffset = uncheckedData.offset;
+			const auto goodBytes = std::move(i->second);
+			const auto weak = base::make_weak(this);
+			i = _cdnUncheckedParts.erase(i);
+			if (!feedPart(goodOffset, goodBytes) || !weak) {
+				return;
+			}
+		} break;
+
+		default: Unexpected("Result of checkCdnFileHash()");
+		}
+	}
+	if (!someMoreChecked) {
+		LOG(("API Error: "
+			"Could not find cdnFileHash for offset %1 "
+			"after getCdnFileHashes request."
+			).arg(requestData.offset));
+		cancelOnFail();
+		return;
+	}
+	requestMoreCdnFileHashes();
+}
+
+void DownloadMtprotoTask::placeSentRequest(
+		mtpRequestId requestId,
+		const RequestData &requestData) {
+	const auto amount = _owner->changeRequestedAmount(
+		dcId(),
+		requestData.sessionIndex,
+		Storage::kDownloadPartSize);
+	const auto [i, ok1] = _sentRequests.emplace(requestId, requestData);
+	const auto [j, ok2] = _requestByOffset.emplace(
+		requestData.offset,
+		requestId);
+
+	i->second.requestedInSession = amount;
+	i->second.sent = crl::now();
+
+	Ensures(ok1 && ok2);
+}
+
+auto DownloadMtprotoTask::finishSentRequest(
+	mtpRequestId requestId,
+	FinishRequestReason reason)
+-> RequestData {
+	auto it = _sentRequests.find(requestId);
+	Assert(it != _sentRequests.cend());
+
+	if (_cdnHashesRequestId == requestId) {
+		_cdnHashesRequestId = 0;
+	}
+	const auto result = it->second;
+	_owner->changeRequestedAmount(
+		dcId(),
+		result.sessionIndex,
+		-Storage::kDownloadPartSize);
+	_sentRequests.erase(it);
+	const auto ok = _requestByOffset.remove(result.offset);
+
+	if (reason == FinishRequestReason::Success) {
+		_owner->requestSucceeded(
+			dcId(),
+			result.sessionIndex,
+			result.requestedInSession,
+			result.sent);
+	}
+
+	Ensures(ok);
+	return result;
+}
+
+bool DownloadMtprotoTask::haveSentRequests() const {
+	return !_sentRequests.empty() || !_cdnUncheckedParts.empty();
+}
+
+bool DownloadMtprotoTask::haveSentRequestForOffset(int offset) const {
+	return _requestByOffset.contains(offset)
+		|| _cdnUncheckedParts.contains({ offset, 0 });
+}
+
+void DownloadMtprotoTask::cancelAllRequests() {
+	while (!_sentRequests.empty()) {
+		cancelRequest(_sentRequests.begin()->first);
+	}
+	_cdnUncheckedParts.clear();
+}
+
+void DownloadMtprotoTask::cancelRequestForOffset(int offset) {
+	const auto i = _requestByOffset.find(offset);
+	if (i != end(_requestByOffset)) {
+		cancelRequest(i->second);
+	}
+	_cdnUncheckedParts.remove({ offset, 0 });
+}
+
+void DownloadMtprotoTask::cancelRequest(mtpRequestId requestId) {
+	const auto hashes = (_cdnHashesRequestId == requestId);
+	api().request(requestId).cancel();
+	[[maybe_unused]] const auto data = finishSentRequest(
+		requestId,
+		FinishRequestReason::Cancel);
+	if (hashes && !_cdnUncheckedParts.empty()) {
+		crl::on_main(this, [=] {
+			requestMoreCdnFileHashes();
+		});
+	}
+}
+
+void DownloadMtprotoTask::addToQueue(int priority) {
+	_owner->enqueue(this, priority);
+}
+
+void DownloadMtprotoTask::removeFromQueue() {
+	_owner->remove(this);
+}
+
+void DownloadMtprotoTask::partLoaded(
+		int offset,
+		const QByteArray &bytes) {
+	feedPart(offset, bytes);
+}
+
+bool DownloadMtprotoTask::normalPartFailed(
+		QByteArray fileReference,
+		const RPCError &error,
+		mtpRequestId requestId) {
+	if (MTP::isDefaultHandledError(error)) {
+		return false;
+	}
+	if (error.code() == 400
+		&& error.type().startsWith(qstr("FILE_REFERENCE_"))) {
+		api().refreshFileReference(
+			_origin,
+			this,
+			requestId,
+			fileReference);
+		return true;
+	}
+	return partFailed(error, requestId);
+}
+
+bool DownloadMtprotoTask::partFailed(
+		const RPCError &error,
+		mtpRequestId requestId) {
+	if (MTP::isDefaultHandledError(error)) {
+		return false;
+	}
+	cancelOnFail();
+	return true;
+}
+
+bool DownloadMtprotoTask::cdnPartFailed(
+		const RPCError &error,
+		mtpRequestId requestId) {
+	if (MTP::isDefaultHandledError(error)) {
+		return false;
+	}
+
+	if (error.type() == qstr("FILE_TOKEN_INVALID")
+		|| error.type() == qstr("REQUEST_TOKEN_INVALID")) {
+		const auto requestData = finishSentRequest(
+			requestId,
+			FinishRequestReason::Redirect);
+		changeCDNParams(
+			requestData,
+			0,
+			QByteArray(),
+			QByteArray(),
+			QByteArray(),
+			QVector<MTPFileHash>());
+		return true;
+	}
+	return partFailed(error, requestId);
+}
+
+void DownloadMtprotoTask::switchToCDN(
+		const RequestData &requestData,
+		const MTPDupload_fileCdnRedirect &redirect) {
+	changeCDNParams(
+		requestData,
+		redirect.vdc_id().v,
+		redirect.vfile_token().v,
+		redirect.vencryption_key().v,
+		redirect.vencryption_iv().v,
+		redirect.vfile_hashes().v);
+}
+
+void DownloadMtprotoTask::addCdnHashes(
+		const QVector<MTPFileHash> &hashes) {
+	for (const auto &hash : hashes) {
+		hash.match([&](const MTPDfileHash &data) {
+			_cdnFileHashes.emplace(
+				data.voffset().v,
+				CdnFileHash{ data.vlimit().v, data.vhash().v });
+		});
+	}
+}
+
+void DownloadMtprotoTask::changeCDNParams(
+		const RequestData &requestData,
+		MTP::DcId dcId,
+		const QByteArray &token,
+		const QByteArray &encryptionKey,
+		const QByteArray &encryptionIV,
+		const QVector<MTPFileHash> &hashes) {
+	if (dcId != 0
+		&& (encryptionKey.size() != MTP::CTRState::KeySize
+			|| encryptionIV.size() != MTP::CTRState::IvecSize)) {
+		LOG(("Message Error: Wrong key (%1) / iv (%2) size in CDN params"
+			).arg(encryptionKey.size()
+			).arg(encryptionIV.size()));
+		cancelOnFail();
+		return;
+	}
+
+	auto resendAllRequests = (_cdnDcId != dcId
+		|| _cdnToken != token
+		|| _cdnEncryptionKey != encryptionKey
+		|| _cdnEncryptionIV != encryptionIV);
+	_cdnDcId = dcId;
+	_cdnToken = token;
+	_cdnEncryptionKey = encryptionKey;
+	_cdnEncryptionIV = encryptionIV;
+	addCdnHashes(hashes);
+
+	if (resendAllRequests && !_sentRequests.empty()) {
+		auto resendRequests = std::vector<RequestData>();
+		resendRequests.reserve(_sentRequests.size());
+		while (!_sentRequests.empty()) {
+			const auto requestId = _sentRequests.begin()->first;
+			api().request(requestId).cancel();
+			resendRequests.push_back(finishSentRequest(
+				requestId,
+				FinishRequestReason::Redirect));
+		}
+		for (const auto &requestData : resendRequests) {
+			makeRequest(requestData);
+		}
+	}
+	makeRequest(requestData);
+}
+
+} // namespace Storage
diff --git a/Telegram/SourceFiles/storage/download_manager_mtproto.h b/Telegram/SourceFiles/storage/download_manager_mtproto.h
new file mode 100644
index 000000000..de342fd68
--- /dev/null
+++ b/Telegram/SourceFiles/storage/download_manager_mtproto.h
@@ -0,0 +1,268 @@
+/*
+This file is part of Telegram Desktop,
+the official desktop application for the Telegram messaging service.
+
+For license and copyright information please follow this link:
+https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+*/
+#pragma once
+
+#include "data/data_file_origin.h"
+#include "base/timer.h"
+#include "base/weak_ptr.h"
+
+class ApiWrap;
+class RPCError;
+
+namespace Storage {
+
+// Different part sizes are not supported for now :(
+// Because we start downloading with some part size
+// and then we get a CDN-redirect where we support only
+// fixed part size download for hash checking.
+constexpr auto kDownloadPartSize = 128 * 1024;
+
+class DownloadMtprotoTask;
+
+class DownloadManagerMtproto final : public base::has_weak_ptr {
+public:
+	using Task = DownloadMtprotoTask;
+
+	explicit DownloadManagerMtproto(not_null<ApiWrap*> api);
+	~DownloadManagerMtproto();
+
+	[[nodiscard]] ApiWrap &api() const {
+		return *_api;
+	}
+
+	void enqueue(not_null<Task*> task, int priority);
+	void remove(not_null<Task*> task);
+
+	[[nodiscard]] base::Observable<void> &taskFinished() {
+		return _taskFinishedObservable;
+	}
+
+	int changeRequestedAmount(MTP::DcId dcId, int index, int delta);
+	void requestSucceeded(
+		MTP::DcId dcId,
+		int index,
+		int amountAtRequestStart,
+		crl::time timeAtRequestStart);
+	[[nodiscard]] int chooseSessionIndex(MTP::DcId dcId) const;
+
+private:
+	class Queue final {
+	public:
+		void enqueue(not_null<Task*> task, int priority);
+		void remove(not_null<Task*> task);
+		void resetGeneration();
+		[[nodiscard]] bool empty() const;
+		[[nodiscard]] Task *nextTask(bool onlyHighestPriority) const;
+		void removeSession(int index);
+
+	private:
+		struct Enqueued {
+			not_null<Task*> task;
+			int priority = 0;
+		};
+		std::vector<Enqueued> _tasks;
+
+	};
+	struct DcSessionBalanceData {
+		DcSessionBalanceData();
+
+		int requested = 0;
+		int successes = 0; // Since last timeout in this dc in any session.
+		int maxWaitedAmount = 0;
+	};
+	struct DcBalanceData {
+		DcBalanceData();
+
+		std::vector<DcSessionBalanceData> sessions;
+		crl::time lastSessionRemove = 0;
+		int sessionRemoveIndex = 0;
+		int sessionRemoveTimes = 0;
+		int timeouts = 0; // Since all sessions had successes >= required.
+		int totalRequested = 0;
+	};
+
+	void checkSendNext();
+	void checkSendNext(MTP::DcId dcId, Queue &queue);
+	bool trySendNextPart(MTP::DcId dcId, Queue &queue);
+
+	void killSessionsSchedule(MTP::DcId dcId);
+	void killSessionsCancel(MTP::DcId dcId);
+	void killSessions();
+	void killSessions(MTP::DcId dcId);
+
+	void resetGeneration();
+	void sessionTimedOut(MTP::DcId dcId, int index);
+	void removeSession(MTP::DcId dcId);
+
+	const not_null<ApiWrap*> _api;
+
+	base::Observable<void> _taskFinishedObservable;
+
+	base::flat_map<MTP::DcId, DcBalanceData> _balanceData;
+	base::Timer _resetGenerationTimer;
+
+	base::flat_map<MTP::DcId, crl::time> _killSessionsWhen;
+	base::Timer _killSessionsTimer;
+
+	base::flat_map<MTP::DcId, Queue> _queues;
+	rpl::lifetime _lifetime;
+
+};
+
+class DownloadMtprotoTask : public base::has_weak_ptr {
+public:
+	struct Location {
+		base::variant<
+			StorageFileLocation,
+			WebFileLocation,
+			GeoPointLocation> data;
+	};
+
+	DownloadMtprotoTask(
+		not_null<DownloadManagerMtproto*> owner,
+		const StorageFileLocation &location,
+		Data::FileOrigin origin);
+	DownloadMtprotoTask(
+		not_null<DownloadManagerMtproto*> owner,
+		MTP::DcId dcId,
+		const Location &location);
+	virtual ~DownloadMtprotoTask();
+
+	[[nodiscard]] MTP::DcId dcId() const;
+	[[nodiscard]] Data::FileOrigin fileOrigin() const;
+	[[nodiscard]] uint64 objectId() const;
+	[[nodiscard]] const Location &location() const;
+
+	[[nodiscard]] virtual bool readyToRequest() const = 0;
+	void loadPart(int sessionIndex);
+	void removeSession(int sessionIndex);
+
+	void refreshFileReferenceFrom(
+		const Data::UpdatedFileReferences &updates,
+		int requestId,
+		const QByteArray &current);
+
+protected:
+	[[nodiscard]] bool haveSentRequests() const;
+	[[nodiscard]] bool haveSentRequestForOffset(int offset) const;
+	void cancelAllRequests();
+	void cancelRequestForOffset(int offset);
+
+	void addToQueue(int priority = 0);
+	void removeFromQueue();
+
+	[[nodiscard]] ApiWrap &api() const {
+		return _owner->api();
+	}
+
+private:
+	struct RequestData {
+		int offset = 0;
+		int sessionIndex = 0;
+		int requestedInSession = 0;
+		crl::time sent = 0;
+
+		inline bool operator<(const RequestData &other) const {
+			return offset < other.offset;
+		}
+	};
+	struct CdnFileHash {
+		CdnFileHash(int limit, QByteArray hash) : limit(limit), hash(hash) {
+		}
+		int limit = 0;
+		QByteArray hash;
+	};
+	enum class CheckCdnHashResult {
+		NoHash,
+		Invalid,
+		Good,
+	};
+	enum class FinishRequestReason {
+		Success,
+		Redirect,
+		Cancel,
+	};
+
+	// Called only if readyToRequest() == true.
+	[[nodiscard]] virtual int takeNextRequestOffset() = 0;
+	virtual bool feedPart(int offset, const QByteArray &bytes) = 0;
+	virtual bool setWebFileSizeHook(int size);
+	virtual void cancelOnFail() = 0;
+
+	void cancelRequest(mtpRequestId requestId);
+	void makeRequest(const RequestData &requestData);
+	void normalPartLoaded(
+		const MTPupload_File &result,
+		mtpRequestId requestId);
+	void webPartLoaded(
+		const MTPupload_WebFile &result,
+		mtpRequestId requestId);
+	void cdnPartLoaded(
+		const MTPupload_CdnFile &result,
+		mtpRequestId requestId);
+	void reuploadDone(
+		const MTPVector<MTPFileHash> &result,
+		mtpRequestId requestId);
+	void requestMoreCdnFileHashes();
+	void getCdnFileHashesDone(
+		const MTPVector<MTPFileHash> &result,
+		mtpRequestId requestId);
+
+	void partLoaded(int offset, const QByteArray &bytes);
+
+	bool partFailed(const RPCError &error, mtpRequestId requestId);
+	bool normalPartFailed(
+		QByteArray fileReference,
+		const RPCError &error,
+		mtpRequestId requestId);
+	bool cdnPartFailed(const RPCError &error, mtpRequestId requestId);
+
+	[[nodiscard]] mtpRequestId sendRequest(const RequestData &requestData);
+	void placeSentRequest(
+		mtpRequestId requestId,
+		const RequestData &requestData);
+	[[nodiscard]] RequestData finishSentRequest(
+		mtpRequestId requestId,
+		FinishRequestReason reason);
+	void switchToCDN(
+		const RequestData &requestData,
+		const MTPDupload_fileCdnRedirect &redirect);
+	void addCdnHashes(const QVector<MTPFileHash> &hashes);
+	void changeCDNParams(
+		const RequestData &requestData,
+		MTP::DcId dcId,
+		const QByteArray &token,
+		const QByteArray &encryptionKey,
+		const QByteArray &encryptionIV,
+		const QVector<MTPFileHash> &hashes);
+
+	[[nodiscard]] CheckCdnHashResult checkCdnFileHash(
+		int offset,
+		bytes::const_span buffer);
+
+	const not_null<DownloadManagerMtproto*> _owner;
+	const MTP::DcId _dcId = 0;
+
+	// _location can be changed with an updated file_reference.
+	Location _location;
+	const Data::FileOrigin _origin;
+
+	base::flat_map<mtpRequestId, RequestData> _sentRequests;
+	base::flat_map<int, mtpRequestId> _requestByOffset;
+
+	MTP::DcId _cdnDcId = 0;
+	QByteArray _cdnToken;
+	QByteArray _cdnEncryptionKey;
+	QByteArray _cdnEncryptionIV;
+	base::flat_map<int, CdnFileHash> _cdnFileHashes;
+	base::flat_map<RequestData, QByteArray> _cdnUncheckedParts;
+	mtpRequestId _cdnHashesRequestId = 0;
+
+};
+
+} // namespace Storage
diff --git a/Telegram/SourceFiles/storage/file_download.cpp b/Telegram/SourceFiles/storage/file_download.cpp
index d76c4b180..72ddd262d 100644
--- a/Telegram/SourceFiles/storage/file_download.cpp
+++ b/Telegram/SourceFiles/storage/file_download.cpp
@@ -15,7 +15,6 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "core/application.h"
 #include "storage/localstorage.h"
 #include "platform/platform_file_utilities.h"
-#include "mtproto/connection.h" // for MTP::kAckSendWaiting
 #include "main/main_session.h"
 #include "apiwrap.h"
 #include "core/crash_reports.h"
@@ -24,135 +23,6 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "facades.h"
 #include "app.h"
 
-namespace Storage {
-namespace {
-
-// How much time without download causes additional session kill.
-constexpr auto kKillSessionTimeout = crl::time(5000);
-
-// Max 16 file parts downloaded at the same time, 128 KB each.
-constexpr auto kMaxFileQueries = 16;
-
-// Max 8 http[s] files downloaded at the same time.
-constexpr auto kMaxWebFileQueries = 8;
-
-// Different part sizes are not supported for now :(
-// Because we start downloading with some part size
-// and then we get a cdn-redirect where we support only
-// fixed part size download for hash checking.
-constexpr auto kPartSize = 128 * 1024;
-
-} // namespace
-
-Downloader::Downloader(not_null<ApiWrap*> api)
-: _api(api)
-, _killDownloadSessionsTimer([=] { killDownloadSessions(); })
-, _queueForWeb(kMaxWebFileQueries) {
-}
-
-void Downloader::clearPriorities() {
-	++_priority;
-}
-
-void Downloader::requestedAmountIncrement(MTP::DcId dcId, int index, int amount) {
-	Expects(index >= 0 && index < cNetDownloadSessionsCount());
-
-	using namespace rpl::mappers;
-
-	auto it = _requestedBytesAmount.find(dcId);
-	if (it == _requestedBytesAmount.cend()) {
-		it = _requestedBytesAmount.emplace(dcId, RequestedInDc { { 0 } }).first;
-	}
-	it->second[index] += amount;
-	if (amount > 0) {
-		killDownloadSessionsStop(dcId);
-	} else if (ranges::find_if(it->second, _1 > 0) == end(it->second)) {
-		killDownloadSessionsStart(dcId);
-	}
-}
-
-void Downloader::killDownloadSessionsStart(MTP::DcId dcId) {
-	if (!_killDownloadSessionTimes.contains(dcId)) {
-		_killDownloadSessionTimes.emplace(
-			dcId,
-			crl::now() + MTP::kAckSendWaiting + kKillSessionTimeout);
-	}
-	if (!_killDownloadSessionsTimer.isActive()) {
-		_killDownloadSessionsTimer.callOnce(
-			MTP::kAckSendWaiting + kKillSessionTimeout + 5);
-	}
-}
-
-void Downloader::killDownloadSessionsStop(MTP::DcId dcId) {
-	_killDownloadSessionTimes.erase(dcId);
-	if (_killDownloadSessionTimes.empty()
-		&& _killDownloadSessionsTimer.isActive()) {
-		_killDownloadSessionsTimer.cancel();
-	}
-}
-
-void Downloader::killDownloadSessions() {
-	auto ms = crl::now(), left = MTP::kAckSendWaiting + kKillSessionTimeout;
-	for (auto i = _killDownloadSessionTimes.begin(); i != _killDownloadSessionTimes.end(); ) {
-		if (i->second <= ms) {
-			for (int j = 0; j < cNetDownloadSessionsCount(); ++j) {
-				MTP::stopSession(MTP::downloadDcId(i->first, j));
-			}
-			i = _killDownloadSessionTimes.erase(i);
-		} else {
-			if (i->second - ms < left) {
-				left = i->second - ms;
-			}
-			++i;
-		}
-	}
-	if (!_killDownloadSessionTimes.empty()) {
-		_killDownloadSessionsTimer.callOnce(left);
-	}
-}
-
-int Downloader::chooseDcIndexForRequest(MTP::DcId dcId) const {
-	auto result = 0;
-	auto it = _requestedBytesAmount.find(dcId);
-	if (it != _requestedBytesAmount.cend()) {
-		for (auto i = 1; i != cNetDownloadSessionsCount(); ++i) {
-			if (it->second[i] < it->second[result]) {
-				result = i;
-			}
-		}
-	}
-	return result;
-}
-
-not_null<Downloader::Queue*> Downloader::queueForDc(MTP::DcId dcId) {
-	const auto i = _queuesForDc.find(dcId);
-	const auto result = (i != end(_queuesForDc))
-		? i
-		: _queuesForDc.emplace(dcId, Queue(cNetMaxFileQueries())).first;
-	return &result->second;
-}
-
-not_null<Downloader::Queue*> Downloader::queueForWeb() {
-	return &_queueForWeb;
-}
-
-Downloader::~Downloader() {
-	killDownloadSessions();
-}
-
-} // namespace Storage
-
-namespace {
-
-QThread *_webLoadThread = nullptr;
-WebLoadManager *_webLoadManager = nullptr;
-WebLoadManager *webLoadManager() {
-	return (_webLoadManager && _webLoadManager != FinishedWebLoadManager) ? _webLoadManager : nullptr;
-}
-WebLoadMainManager *_webLoadMainManager = nullptr;
-
-} // namespace
-
 FileLoader::FileLoader(
 	const QString &toFile,
 	int32 size,
@@ -161,7 +31,7 @@ FileLoader::FileLoader(
 	LoadFromCloudSetting fromCloud,
 	bool autoLoading,
 	uint8 cacheTag)
-: _downloader(&Auth().downloader())
+: _session(&Auth())
 , _autoLoading(autoLoading)
 , _cacheTag(cacheTag)
 , _filename(toFile)
@@ -173,8 +43,10 @@ FileLoader::FileLoader(
 	Expects(!_filename.isEmpty() || (_size <= Storage::kMaxFileInMemory));
 }
 
+FileLoader::~FileLoader() = default;
+
 Main::Session &FileLoader::session() const {
-	return _downloader->api().session();
+	return *_session;
 }
 
 void FileLoader::finishWithBytes(const QByteArray &data) {
@@ -200,7 +72,7 @@ void FileLoader::finishWithBytes(const QByteArray &data) {
 		Platform::File::PostprocessDownloaded(
 			QFileInfo(_file).absoluteFilePath());
 	}
-	_downloader->taskFinished().notify();
+	Auth().downloaderTaskFinished().notify();
 }
 
 QByteArray FileLoader::imageFormat(const QSize &shrinkBox) const {
@@ -258,46 +130,7 @@ void FileLoader::permitLoadFromCloud() {
 }
 
 void FileLoader::notifyAboutProgress() {
-	const auto queue = _queue;
 	emit progress(this);
-	LoadNextFromQueue(queue);
-}
-
-void FileLoader::LoadNextFromQueue(not_null<Queue*> queue) {
-	if (queue->queriesCount >= queue->queriesLimit) {
-		return;
-	}
-	for (auto i = queue->start; i;) {
-		if (i->loadPart()) {
-			if (queue->queriesCount >= queue->queriesLimit) {
-				return;
-			}
-		} else {
-			i = i->_next;
-		}
-	}
-}
-
-void FileLoader::removeFromQueue() {
-	if (!_inQueue) return;
-	if (_next) {
-		_next->_prev = _prev;
-	}
-	if (_prev) {
-		_prev->_next = _next;
-	}
-	if (_queue->end == this) {
-		_queue->end = _prev;
-	}
-	if (_queue->start == this) {
-		_queue->start = _next;
-	}
-	_next = _prev = nullptr;
-	_inQueue = false;
-}
-
-FileLoader::~FileLoader() {
-	removeFromQueue();
 }
 
 void FileLoader::localLoaded(
@@ -332,71 +165,7 @@ void FileLoader::start() {
 			return cancel(true);
 		}
 	}
-
-	auto currentPriority = _downloader->currentPriority();
-	FileLoader *before = nullptr, *after = nullptr;
-	if (_inQueue && _priority == currentPriority) {
-		if (!_next || _next->_priority < currentPriority) return startLoading();
-		after = _next;
-		while (after->_next && after->_next->_priority == currentPriority) {
-			after = after->_next;
-		}
-	} else {
-		_priority = currentPriority;
-		if (_inQueue) {
-			if (_next && _next->_priority == currentPriority) {
-				after = _next;
-			} else if (_prev && _prev->_priority < currentPriority) {
-				before = _prev;
-				while (before->_prev && before->_prev->_priority < currentPriority) {
-					before = before->_prev;
-				}
-			} else {
-				return startLoading();
-			}
-		} else {
-			if (_queue->start && _queue->start->_priority == currentPriority) {
-				after = _queue->start;
-			} else {
-				before = _queue->start;
-			}
-		}
-		if (after) {
-			while (after->_next && after->_next->_priority == currentPriority) {
-				after = after->_next;
-			}
-		}
-	}
-
-	removeFromQueue();
-
-	_inQueue = true;
-	if (!_queue->start) {
-		_queue->start = _queue->end = this;
-	} else if (before) {
-		if (before != _next) {
-			_prev = before->_prev;
-			_next = before;
-			_next->_prev = this;
-			if (_prev) {
-				_prev->_next = this;
-			}
-			if (_queue->start->_prev) _queue->start = _queue->start->_prev;
-		}
-	} else if (after) {
-		if (after != _prev) {
-			_next = after->_next;
-			_prev = after;
-			after->_next = this;
-			if (_next) {
-				_next->_prev = this;
-			}
-			if (_queue->end->_next) _queue->end = _queue->end->_next;
-		}
-	} else {
-		LOG(("Queue Error: _start && !before && !after"));
-	}
-	return startLoading();
+	startLoading();
 }
 
 void FileLoader::loadLocal(const Storage::Cache::Key &key) {
@@ -472,7 +241,9 @@ void FileLoader::cancel() {
 
 void FileLoader::cancel(bool fail) {
 	const auto started = (currentOffset() > 0);
-	cancelRequests();
+
+	cancelHook();
+
 	_cancelled = true;
 	_finished = true;
 	if (_fileIsOpen) {
@@ -481,10 +252,7 @@ void FileLoader::cancel(bool fail) {
 		_file.remove();
 	}
 	_data = QByteArray();
-	removeFromQueue();
 
-	const auto queue = _queue;
-	const auto sessionGuard = &session();
 	const auto weak = QPointer<FileLoader>(this);
 	if (fail) {
 		emit failed(this, started);
@@ -495,16 +263,6 @@ void FileLoader::cancel(bool fail) {
 		_filename = QString();
 		_file.setFileName(_filename);
 	}
-
-	// Current cancel() call could be made from ~Main::Session().
-	crl::on_main(sessionGuard, [=] { LoadNextFromQueue(queue); });
-}
-
-void FileLoader::startLoading() {
-	if ((_queue->queriesCount >= _queue->queriesLimit) || _finished) {
-		return;
-	}
-	loadPart();
 }
 
 int FileLoader::currentOffset() const {
@@ -595,8 +353,6 @@ bool FileLoader::finalizeResult() {
 		Platform::File::PostprocessDownloaded(
 			QFileInfo(_file).absoluteFilePath());
 	}
-	removeFromQueue();
-
 	if (_localStatus == LocalStatus::NotFound) {
 		if (const auto key = fileLocationKey()) {
 			if (!_filename.isEmpty()) {
@@ -612,1019 +368,6 @@ bool FileLoader::finalizeResult() {
 					_cacheTag));
 		}
 	}
-	_downloader->taskFinished().notify();
+	Auth().downloaderTaskFinished().notify();
 	return true;
 }
-
-mtpFileLoader::mtpFileLoader(
-	const StorageFileLocation &location,
-	Data::FileOrigin origin,
-	LocationType type,
-	const QString &to,
-	int32 size,
-	LoadToCacheSetting toCache,
-	LoadFromCloudSetting fromCloud,
-	bool autoLoading,
-	uint8 cacheTag)
-: FileLoader(
-	to,
-	size,
-	type,
-	toCache,
-	fromCloud,
-	autoLoading,
-	cacheTag)
-, _location(location)
-, _origin(origin) {
-	_queue = _downloader->queueForDc(dcId());
-}
-
-mtpFileLoader::mtpFileLoader(
-	const WebFileLocation &location,
-	int32 size,
-	LoadFromCloudSetting fromCloud,
-	bool autoLoading,
-	uint8 cacheTag)
-: FileLoader(
-	QString(),
-	size,
-	UnknownFileLocation,
-	LoadToCacheAsWell,
-	fromCloud,
-	autoLoading,
-	cacheTag)
-, _location(location) {
-	_queue = _downloader->queueForDc(dcId());
-}
-
-mtpFileLoader::mtpFileLoader(
-	const GeoPointLocation &location,
-	int32 size,
-	LoadFromCloudSetting fromCloud,
-	bool autoLoading,
-	uint8 cacheTag)
-: FileLoader(
-	QString(),
-	size,
-	UnknownFileLocation,
-	LoadToCacheAsWell,
-	fromCloud,
-	autoLoading,
-	cacheTag)
-, _location(location) {
-	_queue = _downloader->queueForDc(dcId());
-}
-
-Data::FileOrigin mtpFileLoader::fileOrigin() const {
-	return _origin;
-}
-
-uint64 mtpFileLoader::objId() const {
-	if (const auto storage = base::get_if<StorageFileLocation>(&_location)) {
-		return storage->objectId();
-	}
-	return 0;
-}
-
-void mtpFileLoader::refreshFileReferenceFrom(
-		const Data::UpdatedFileReferences &updates,
-		int requestId,
-		const QByteArray &current) {
-	if (const auto storage = base::get_if<StorageFileLocation>(&_location)) {
-		storage->refreshFileReference(updates);
-		if (storage->fileReference() == current) {
-			cancel(true);
-			return;
-		}
-	} else {
-		cancel(true);
-		return;
-	}
-	const auto offset = finishSentRequestGetOffset(requestId);
-	makeRequest(offset);
-}
-
-bool mtpFileLoader::loadPart() {
-	if (_finished || _lastComplete || (!_sentRequests.empty() && !_size)) {
-		return false;
-	} else if (_size && _nextRequestOffset >= _size) {
-		return false;
-	}
-
-	makeRequest(_nextRequestOffset);
-	_nextRequestOffset += Storage::kPartSize;
-	return true;
-}
-
-MTP::DcId mtpFileLoader::dcId() const {
-	if (const auto storage = base::get_if<StorageFileLocation>(&_location)) {
-		return storage->dcId();
-	}
-	return Global::WebFileDcId();
-}
-
-mtpFileLoader::RequestData mtpFileLoader::prepareRequest(int offset) const {
-	auto result = RequestData();
-	result.dcId = _cdnDcId ? _cdnDcId : dcId();
-	result.dcIndex = _size
-		? _downloader->chooseDcIndexForRequest(result.dcId)
-		: 0;
-	result.offset = offset;
-	return result;
-}
-
-mtpRequestId mtpFileLoader::sendRequest(const RequestData &requestData) {
-	const auto offset = requestData.offset;
-	const auto limit = Storage::kPartSize;
-	const auto shiftedDcId = MTP::downloadDcId(
-		requestData.dcId,
-		requestData.dcIndex);
-	if (_cdnDcId) {
-		Assert(requestData.dcId == _cdnDcId);
-		return MTP::send(
-			MTPupload_GetCdnFile(
-				MTP_bytes(_cdnToken),
-				MTP_int(offset),
-				MTP_int(limit)),
-			rpcDone(&mtpFileLoader::cdnPartLoaded),
-			rpcFail(&mtpFileLoader::cdnPartFailed),
-			shiftedDcId,
-			50);
-	}
-	return _location.match([&](const WebFileLocation &location) {
-		return MTP::send(
-			MTPupload_GetWebFile(
-				MTP_inputWebFileLocation(
-					MTP_bytes(location.url()),
-					MTP_long(location.accessHash())),
-				MTP_int(offset),
-				MTP_int(limit)),
-			rpcDone(&mtpFileLoader::webPartLoaded),
-			rpcFail(&mtpFileLoader::partFailed),
-			shiftedDcId,
-			50);
-	}, [&](const GeoPointLocation &location) {
-		return MTP::send(
-			MTPupload_GetWebFile(
-				MTP_inputWebFileGeoPointLocation(
-					MTP_inputGeoPoint(
-						MTP_double(location.lat),
-						MTP_double(location.lon)),
-					MTP_long(location.access),
-					MTP_int(location.width),
-					MTP_int(location.height),
-					MTP_int(location.zoom),
-					MTP_int(location.scale)),
-				MTP_int(offset),
-				MTP_int(limit)),
-			rpcDone(&mtpFileLoader::webPartLoaded),
-			rpcFail(&mtpFileLoader::partFailed),
-			shiftedDcId,
-			50);
-	}, [&](const StorageFileLocation &location) {
-		return MTP::send(
-			MTPupload_GetFile(
-				MTP_flags(0),
-				location.tl(session().userId()),
-				MTP_int(offset),
-				MTP_int(limit)),
-			rpcDone(&mtpFileLoader::normalPartLoaded),
-			rpcFail(
-				&mtpFileLoader::normalPartFailed,
-				location.fileReference()),
-			shiftedDcId,
-			50);
-	});
-}
-
-void mtpFileLoader::makeRequest(int offset) {
-	Expects(!_finished);
-
-	auto requestData = prepareRequest(offset);
-	placeSentRequest(sendRequest(requestData), requestData);
-}
-
-void mtpFileLoader::requestMoreCdnFileHashes() {
-	Expects(!_finished);
-
-	if (_cdnHashesRequestId || _cdnUncheckedParts.empty()) {
-		return;
-	}
-
-	auto offset = _cdnUncheckedParts.cbegin()->first;
-	auto requestData = RequestData();
-	requestData.dcId = dcId();
-	requestData.dcIndex = 0;
-	requestData.offset = offset;
-	auto shiftedDcId = MTP::downloadDcId(
-		requestData.dcId,
-		requestData.dcIndex);
-	auto requestId = _cdnHashesRequestId = MTP::send(
-		MTPupload_GetCdnFileHashes(
-			MTP_bytes(_cdnToken),
-			MTP_int(offset)),
-		rpcDone(&mtpFileLoader::getCdnFileHashesDone),
-		rpcFail(&mtpFileLoader::cdnPartFailed),
-		shiftedDcId);
-	placeSentRequest(requestId, requestData);
-}
-
-void mtpFileLoader::normalPartLoaded(
-		const MTPupload_File &result,
-		mtpRequestId requestId) {
-	Expects(!_finished);
-	Expects(result.type() == mtpc_upload_fileCdnRedirect || result.type() == mtpc_upload_file);
-
-	auto offset = finishSentRequestGetOffset(requestId);
-	if (result.type() == mtpc_upload_fileCdnRedirect) {
-		return switchToCDN(offset, result.c_upload_fileCdnRedirect());
-	}
-	auto buffer = bytes::make_span(result.c_upload_file().vbytes().v);
-	return partLoaded(offset, buffer);
-}
-
-void mtpFileLoader::webPartLoaded(
-		const MTPupload_WebFile &result,
-		mtpRequestId requestId) {
-	result.match([&](const MTPDupload_webFile &data) {
-		const auto offset = finishSentRequestGetOffset(requestId);
-		if (!_size) {
-			_size = data.vsize().v;
-		} else if (data.vsize().v != _size) {
-			LOG(("MTP Error: "
-				"Bad size provided by bot for webDocument: %1, real: %2"
-				).arg(_size
-				).arg(data.vsize().v));
-			cancel(true);
-			return;
-		}
-		partLoaded(offset, bytes::make_span(data.vbytes().v));
-	});
-}
-
-void mtpFileLoader::cdnPartLoaded(const MTPupload_CdnFile &result, mtpRequestId requestId) {
-	Expects(!_finished);
-
-	const auto offset = finishSentRequestGetOffset(requestId);
-	result.match([&](const MTPDupload_cdnFileReuploadNeeded &data) {
-		auto requestData = RequestData();
-		requestData.dcId = dcId();
-		requestData.dcIndex = 0;
-		requestData.offset = offset;
-		const auto shiftedDcId = MTP::downloadDcId(
-			requestData.dcId,
-			requestData.dcIndex);
-		const auto requestId = MTP::send(
-			MTPupload_ReuploadCdnFile(
-				MTP_bytes(_cdnToken),
-				data.vrequest_token()),
-			rpcDone(&mtpFileLoader::reuploadDone),
-			rpcFail(&mtpFileLoader::cdnPartFailed),
-			shiftedDcId);
-		placeSentRequest(requestId, requestData);
-	}, [&](const MTPDupload_cdnFile &data) {
-		auto key = bytes::make_span(_cdnEncryptionKey);
-		auto iv = bytes::make_span(_cdnEncryptionIV);
-		Expects(key.size() == MTP::CTRState::KeySize);
-		Expects(iv.size() == MTP::CTRState::IvecSize);
-
-		auto state = MTP::CTRState();
-		auto ivec = bytes::make_span(state.ivec);
-		std::copy(iv.begin(), iv.end(), ivec.begin());
-
-		auto counterOffset = static_cast<uint32>(offset) >> 4;
-		state.ivec[15] = static_cast<uchar>(counterOffset & 0xFF);
-		state.ivec[14] = static_cast<uchar>((counterOffset >> 8) & 0xFF);
-		state.ivec[13] = static_cast<uchar>((counterOffset >> 16) & 0xFF);
-		state.ivec[12] = static_cast<uchar>((counterOffset >> 24) & 0xFF);
-
-		auto decryptInPlace = data.vbytes().v;
-		auto buffer = bytes::make_detached_span(decryptInPlace);
-		MTP::aesCtrEncrypt(buffer, key.data(), &state);
-
-		switch (checkCdnFileHash(offset, buffer)) {
-		case CheckCdnHashResult::NoHash: {
-			_cdnUncheckedParts.emplace(offset, decryptInPlace);
-			requestMoreCdnFileHashes();
-		} return;
-
-		case CheckCdnHashResult::Invalid: {
-			LOG(("API Error: Wrong cdnFileHash for offset %1.").arg(offset));
-			cancel(true);
-		} return;
-
-		case CheckCdnHashResult::Good: {
-			partLoaded(offset, buffer);
-		} return;
-		}
-		Unexpected("Result of checkCdnFileHash()");
-	});
-}
-
-mtpFileLoader::CheckCdnHashResult mtpFileLoader::checkCdnFileHash(
-		int offset,
-		bytes::const_span buffer) {
-	const auto cdnFileHashIt = _cdnFileHashes.find(offset);
-	if (cdnFileHashIt == _cdnFileHashes.cend()) {
-		return CheckCdnHashResult::NoHash;
-	}
-	const auto realHash = openssl::Sha256(buffer);
-	const auto receivedHash = bytes::make_span(cdnFileHashIt->second.hash);
-	if (bytes::compare(realHash, receivedHash)) {
-		return CheckCdnHashResult::Invalid;
-	}
-	return CheckCdnHashResult::Good;
-}
-
-void mtpFileLoader::reuploadDone(
-		const MTPVector<MTPFileHash> &result,
-		mtpRequestId requestId) {
-	auto offset = finishSentRequestGetOffset(requestId);
-	addCdnHashes(result.v);
-	makeRequest(offset);
-}
-
-void mtpFileLoader::getCdnFileHashesDone(
-		const MTPVector<MTPFileHash> &result,
-		mtpRequestId requestId) {
-	Expects(!_finished);
-	Expects(_cdnHashesRequestId == requestId);
-
-	_cdnHashesRequestId = 0;
-
-	const auto offset = finishSentRequestGetOffset(requestId);
-	addCdnHashes(result.v);
-	auto someMoreChecked = false;
-	for (auto i = _cdnUncheckedParts.begin(); i != _cdnUncheckedParts.cend();) {
-		const auto uncheckedOffset = i->first;
-		const auto uncheckedBytes = bytes::make_span(i->second);
-
-		switch (checkCdnFileHash(uncheckedOffset, uncheckedBytes)) {
-		case CheckCdnHashResult::NoHash: {
-			++i;
-		} break;
-
-		case CheckCdnHashResult::Invalid: {
-			LOG(("API Error: Wrong cdnFileHash for offset %1.").arg(offset));
-			cancel(true);
-			return;
-		} break;
-
-		case CheckCdnHashResult::Good: {
-			someMoreChecked = true;
-			const auto goodOffset = uncheckedOffset;
-			const auto goodBytes = std::move(i->second);
-			const auto weak = QPointer<mtpFileLoader>(this);
-			i = _cdnUncheckedParts.erase(i);
-			if (!feedPart(goodOffset, bytes::make_span(goodBytes))
-				|| !weak) {
-				return;
-			} else if (_finished) {
-				notifyAboutProgress();
-				return;
-			}
-		} break;
-
-		default: Unexpected("Result of checkCdnFileHash()");
-		}
-	}
-	if (someMoreChecked) {
-		const auto weak = QPointer<mtpFileLoader>(this);
-		notifyAboutProgress();
-		if (weak) {
-			requestMoreCdnFileHashes();
-		}
-		return;
-	}
-	LOG(("API Error: "
-		"Could not find cdnFileHash for offset %1 "
-		"after getCdnFileHashes request."
-		).arg(offset));
-	cancel(true);
-}
-
-void mtpFileLoader::placeSentRequest(
-		mtpRequestId requestId,
-		const RequestData &requestData) {
-	Expects(!_finished);
-
-	_downloader->requestedAmountIncrement(
-		requestData.dcId,
-		requestData.dcIndex,
-		Storage::kPartSize);
-	++_queue->queriesCount;
-	_sentRequests.emplace(requestId, requestData);
-}
-
-int mtpFileLoader::finishSentRequestGetOffset(mtpRequestId requestId) {
-	auto it = _sentRequests.find(requestId);
-	Assert(it != _sentRequests.cend());
-
-	auto requestData = it->second;
-	_downloader->requestedAmountIncrement(
-		requestData.dcId,
-		requestData.dcIndex,
-		-Storage::kPartSize);
-
-	--_queue->queriesCount;
-	_sentRequests.erase(it);
-
-	return requestData.offset;
-}
-
-bool mtpFileLoader::feedPart(int offset, bytes::const_span buffer) {
-	if (!writeResultPart(offset, buffer)) {
-		return false;
-	}
-	if (buffer.empty() || (buffer.size() % 1024)) { // bad next offset
-		_lastComplete = true;
-	}
-	const auto finished = _sentRequests.empty()
-		&& _cdnUncheckedParts.empty()
-		&& (_lastComplete || (_size && _nextRequestOffset >= _size));
-	if (finished && !finalizeResult()) {
-		return false;
-	}
-	return true;
-}
-
-void mtpFileLoader::partLoaded(int offset, bytes::const_span buffer) {
-	if (feedPart(offset, buffer)) {
-		notifyAboutProgress();
-	}
-}
-
-bool mtpFileLoader::normalPartFailed(
-		QByteArray fileReference,
-		const RPCError &error,
-		mtpRequestId requestId) {
-	if (MTP::isDefaultHandledError(error)) {
-		return false;
-	}
-	if (error.code() == 400
-		&& error.type().startsWith(qstr("FILE_REFERENCE_"))) {
-		session().api().refreshFileReference(
-			_origin,
-			this,
-			requestId,
-			fileReference);
-		return true;
-	}
-	return partFailed(error, requestId);
-}
-
-
-bool mtpFileLoader::partFailed(
-		const RPCError &error,
-		mtpRequestId requestId) {
-	if (MTP::isDefaultHandledError(error)) {
-		return false;
-	}
-	cancel(true);
-	return true;
-}
-
-bool mtpFileLoader::cdnPartFailed(
-		const RPCError &error,
-		mtpRequestId requestId) {
-	if (MTP::isDefaultHandledError(error)) {
-		return false;
-	}
-
-	if (requestId == _cdnHashesRequestId) {
-		_cdnHashesRequestId = 0;
-	}
-	if (error.type() == qstr("FILE_TOKEN_INVALID")
-		|| error.type() == qstr("REQUEST_TOKEN_INVALID")) {
-		auto offset = finishSentRequestGetOffset(requestId);
-		changeCDNParams(
-			offset,
-			0,
-			QByteArray(),
-			QByteArray(),
-			QByteArray(),
-			QVector<MTPFileHash>());
-		return true;
-	}
-	return partFailed(error, requestId);
-}
-
-void mtpFileLoader::cancelRequests() {
-	while (!_sentRequests.empty()) {
-		auto requestId = _sentRequests.begin()->first;
-		MTP::cancel(requestId);
-		finishSentRequestGetOffset(requestId);
-	}
-}
-
-void mtpFileLoader::switchToCDN(
-		int offset,
-		const MTPDupload_fileCdnRedirect &redirect) {
-	changeCDNParams(
-		offset,
-		redirect.vdc_id().v,
-		redirect.vfile_token().v,
-		redirect.vencryption_key().v,
-		redirect.vencryption_iv().v,
-		redirect.vfile_hashes().v);
-}
-
-void mtpFileLoader::addCdnHashes(const QVector<MTPFileHash> &hashes) {
-	for (const auto &hash : hashes) {
-		hash.match([&](const MTPDfileHash &data) {
-			_cdnFileHashes.emplace(
-				data.voffset().v,
-				CdnFileHash{ data.vlimit().v, data.vhash().v });
-		});
-	}
-}
-
-void mtpFileLoader::changeCDNParams(
-		int offset,
-		MTP::DcId dcId,
-		const QByteArray &token,
-		const QByteArray &encryptionKey,
-		const QByteArray &encryptionIV,
-		const QVector<MTPFileHash> &hashes) {
-	if (dcId != 0
-		&& (encryptionKey.size() != MTP::CTRState::KeySize
-			|| encryptionIV.size() != MTP::CTRState::IvecSize)) {
-		LOG(("Message Error: Wrong key (%1) / iv (%2) size in CDN params").arg(encryptionKey.size()).arg(encryptionIV.size()));
-		cancel(true);
-		return;
-	}
-
-	auto resendAllRequests = (_cdnDcId != dcId
-		|| _cdnToken != token
-		|| _cdnEncryptionKey != encryptionKey
-		|| _cdnEncryptionIV != encryptionIV);
-	_cdnDcId = dcId;
-	_cdnToken = token;
-	_cdnEncryptionKey = encryptionKey;
-	_cdnEncryptionIV = encryptionIV;
-	addCdnHashes(hashes);
-
-	if (resendAllRequests && !_sentRequests.empty()) {
-		auto resendOffsets = std::vector<int>();
-		resendOffsets.reserve(_sentRequests.size());
-		while (!_sentRequests.empty()) {
-			auto requestId = _sentRequests.begin()->first;
-			MTP::cancel(requestId);
-			auto resendOffset = finishSentRequestGetOffset(requestId);
-			resendOffsets.push_back(resendOffset);
-		}
-		for (auto resendOffset : resendOffsets) {
-			makeRequest(resendOffset);
-		}
-	}
-	makeRequest(offset);
-}
-
-Storage::Cache::Key mtpFileLoader::cacheKey() const {
-	return _location.match([&](const WebFileLocation &location) {
-		return Data::WebDocumentCacheKey(location);
-	}, [&](const GeoPointLocation &location) {
-		return Data::GeoPointCacheKey(location);
-	}, [&](const StorageFileLocation &location) {
-		return location.cacheKey();
-	});
-}
-
-std::optional<MediaKey> mtpFileLoader::fileLocationKey() const {
-	if (_locationType != UnknownFileLocation) {
-		return mediaKey(_locationType, dcId(), objId());
-	}
-	return std::nullopt;
-}
-
-mtpFileLoader::~mtpFileLoader() {
-	cancelRequests();
-}
-
-webFileLoader::webFileLoader(
-	const QString &url,
-	const QString &to,
-	LoadFromCloudSetting fromCloud,
-	bool autoLoading,
-	uint8 cacheTag)
-: FileLoader(
-	QString(),
-	0,
-	UnknownFileLocation,
-	LoadToCacheAsWell,
-	fromCloud,
-	autoLoading,
-	cacheTag)
-, _url(url) {
-	_queue = _downloader->queueForWeb();
-}
-
-bool webFileLoader::loadPart() {
-	if (_finished
-		|| _requestSent
-		|| _webLoadManager == FinishedWebLoadManager) {
-		return false;
-	}
-	if (!_webLoadManager) {
-		_webLoadMainManager = new WebLoadMainManager();
-
-		_webLoadThread = new QThread();
-		_webLoadManager = new WebLoadManager(_webLoadThread);
-
-		_webLoadThread->start();
-	}
-
-	_requestSent = true;
-	_webLoadManager->append(this, _url);
-	return false;
-}
-
-int webFileLoader::currentOffset() const {
-	return _already;
-}
-
-void webFileLoader::loadProgress(qint64 already, qint64 size) {
-	_size = size;
-	_already = already;
-	notifyAboutProgress();
-}
-
-void webFileLoader::loadFinished(const QByteArray &data) {
-	if (writeResultPart(0, bytes::make_span(data))) {
-		if (finalizeResult()) {
-			notifyAboutProgress();
-		}
-	}
-}
-
-void webFileLoader::loadError() {
-	cancel(true);
-}
-
-Storage::Cache::Key webFileLoader::cacheKey() const {
-	return Data::UrlCacheKey(_url);
-}
-
-std::optional<MediaKey> webFileLoader::fileLocationKey() const {
-	return std::nullopt;
-}
-
-void webFileLoader::cancelRequests() {
-	if (!webLoadManager()) return;
-	webLoadManager()->stop(this);
-}
-
-webFileLoader::~webFileLoader() {
-}
-
-class webFileLoaderPrivate {
-public:
-	webFileLoaderPrivate(webFileLoader *loader, const QString &url)
-		: _interface(loader)
-		, _url(url)
-		, _redirectsLeft(kMaxHttpRedirects) {
-	}
-
-	QNetworkReply *reply() {
-		return _reply;
-	}
-
-	QNetworkReply *request(QNetworkAccessManager &manager, const QString &redirect) {
-		if (!redirect.isEmpty()) _url = redirect;
-
-		QNetworkRequest req(_url);
-		QByteArray rangeHeaderValue = "bytes=" + QByteArray::number(_already) + "-";
-		req.setRawHeader("Range", rangeHeaderValue);
-		_reply = manager.get(req);
-		return _reply;
-	}
-
-	bool oneMoreRedirect() {
-		if (_redirectsLeft) {
-			--_redirectsLeft;
-			return true;
-		}
-		return false;
-	}
-
-	void setData(const QByteArray &data) {
-		_data = data;
-	}
-	void addData(const QByteArray &data) {
-		_data.append(data);
-	}
-	const QByteArray &data() {
-		return _data;
-	}
-	void setProgress(qint64 already, qint64 size) {
-		_already = already;
-		_size = qMax(size, 0LL);
-	}
-
-	qint64 size() const {
-		return _size;
-	}
-	qint64 already() const {
-		return _already;
-	}
-
-private:
-	static constexpr auto kMaxHttpRedirects = 5;
-
-	webFileLoader *_interface = nullptr;
-	QUrl _url;
-	qint64 _already = 0;
-	qint64 _size = 0;
-	QNetworkReply *_reply = nullptr;
-	int32 _redirectsLeft = kMaxHttpRedirects;
-	QByteArray _data;
-
-	friend class WebLoadManager;
-};
-
-void stopWebLoadManager() {
-	if (webLoadManager()) {
-		_webLoadThread->quit();
-		DEBUG_LOG(("Waiting for webloadThread to finish"));
-		_webLoadThread->wait();
-		delete _webLoadManager;
-		delete _webLoadMainManager;
-		delete _webLoadThread;
-		_webLoadThread = nullptr;
-		_webLoadMainManager = nullptr;
-		_webLoadManager = FinishedWebLoadManager;
-	}
-}
-
-WebLoadManager::WebLoadManager(QThread *thread) {
-	moveToThread(thread);
-	_manager.moveToThread(thread);
-	connect(thread, SIGNAL(started()), this, SLOT(process()));
-	connect(thread, SIGNAL(finished()), this, SLOT(finish()));
-	connect(this, SIGNAL(processDelayed()), this, SLOT(process()), Qt::QueuedConnection);
-
-	connect(this, SIGNAL(progress(webFileLoader*,qint64,qint64)), _webLoadMainManager, SLOT(progress(webFileLoader*,qint64,qint64)));
-	connect(this, SIGNAL(finished(webFileLoader*,QByteArray)), _webLoadMainManager, SLOT(finished(webFileLoader*,QByteArray)));
-	connect(this, SIGNAL(error(webFileLoader*)), _webLoadMainManager, SLOT(error(webFileLoader*)));
-
-	connect(&_manager, SIGNAL(authenticationRequired(QNetworkReply*,QAuthenticator*)), this, SLOT(onFailed(QNetworkReply*)));
-#ifndef OS_MAC_OLD
-	connect(&_manager, SIGNAL(sslErrors(QNetworkReply*,const QList<QSslError>&)), this, SLOT(onFailed(QNetworkReply*)));
-#endif // OS_MAC_OLD
-}
-
-void WebLoadManager::append(webFileLoader *loader, const QString &url) {
-	loader->_private = new webFileLoaderPrivate(loader, url);
-
-	QMutexLocker lock(&_loaderPointersMutex);
-	_loaderPointers.insert(loader, loader->_private);
-	emit processDelayed();
-}
-
-void WebLoadManager::stop(webFileLoader *loader) {
-	QMutexLocker lock(&_loaderPointersMutex);
-	_loaderPointers.remove(loader);
-	emit processDelayed();
-}
-
-bool WebLoadManager::carries(webFileLoader *loader) const {
-	QMutexLocker lock(&_loaderPointersMutex);
-	return _loaderPointers.contains(loader);
-}
-
-bool WebLoadManager::handleReplyResult(webFileLoaderPrivate *loader, WebReplyProcessResult result) {
-	QMutexLocker lock(&_loaderPointersMutex);
-	LoaderPointers::iterator it = _loaderPointers.find(loader->_interface);
-	if (it != _loaderPointers.cend() && it.key()->_private != loader) {
-		it = _loaderPointers.end(); // it is a new loader which was realloced in the same address
-	}
-	if (it == _loaderPointers.cend()) {
-		return false;
-	}
-
-	if (result == WebReplyProcessProgress) {
-		if (loader->size() > Storage::kMaxFileInMemory) {
-			LOG(("API Error: too large file is loaded to cache: %1").arg(loader->size()));
-			result = WebReplyProcessError;
-		}
-	}
-	if (result == WebReplyProcessError) {
-		if (it != _loaderPointers.cend()) {
-			emit error(it.key());
-		}
-		return false;
-	}
-	if (loader->already() < loader->size() || !loader->size()) {
-		emit progress(it.key(), loader->already(), loader->size());
-		return true;
-	}
-	emit finished(it.key(), loader->data());
-	return false;
-}
-
-void WebLoadManager::onFailed(QNetworkReply::NetworkError error) {
-	onFailed(qobject_cast<QNetworkReply*>(QObject::sender()));
-}
-
-void WebLoadManager::onFailed(QNetworkReply *reply) {
-	if (!reply) return;
-	reply->deleteLater();
-
-	Replies::iterator j = _replies.find(reply);
-	if (j == _replies.cend()) { // handled already
-		return;
-	}
-	webFileLoaderPrivate *loader = j.value();
-	_replies.erase(j);
-
-	LOG(("Network Error: Failed to request '%1', error %2 (%3)").arg(QString::fromLatin1(loader->_url.toEncoded())).arg(int(reply->error())).arg(reply->errorString()));
-
-	if (!handleReplyResult(loader, WebReplyProcessError)) {
-		_loaders.remove(loader);
-		delete loader;
-	}
-}
-
-void WebLoadManager::onProgress(qint64 already, qint64 size) {
-	const auto reply = qobject_cast<QNetworkReply*>(QObject::sender());
-	if (!reply) return;
-
-	const auto j = _replies.find(reply);
-	if (j == _replies.cend()) { // handled already
-		return;
-	}
-	const auto loader = j.value();
-
-	auto result = WebReplyProcessProgress;
-	const auto statusCode = reply->attribute(QNetworkRequest::HttpStatusCodeAttribute);
-	const auto status = statusCode.isValid() ? statusCode.toInt() : 200;
-	if (status != 200 && status != 206 && status != 416) {
-		if (status == 301 || status == 302) {
-			QString loc = reply->header(QNetworkRequest::LocationHeader).toString();
-			if (!loc.isEmpty()) {
-				if (loader->oneMoreRedirect()) {
-					sendRequest(loader, loc);
-					return;
-				} else {
-					LOG(("Network Error: Too many HTTP redirects in onFinished() for web file loader: %1").arg(loc));
-					result = WebReplyProcessError;
-				}
-			}
-		} else {
-			LOG(("Network Error: Bad HTTP status received in WebLoadManager::onProgress(): %1").arg(statusCode.toInt()));
-			result = WebReplyProcessError;
-		}
-	} else {
-		loader->setProgress(already, size);
-		QByteArray r = reply->readAll();
-		if (!r.isEmpty()) {
-			loader->addData(r);
-		}
-		if (size == 0) {
-			LOG(("Network Error: Zero size received for HTTP download progress in WebLoadManager::onProgress(): %1 / %2").arg(already).arg(size));
-			result = WebReplyProcessError;
-		}
-	}
-	if (!handleReplyResult(loader, result)) {
-		_replies.erase(j);
-		_loaders.remove(loader);
-		delete loader;
-
-		reply->abort();
-		reply->deleteLater();
-	}
-}
-
-void WebLoadManager::onMeta() {
-	const auto reply = qobject_cast<QNetworkReply*>(QObject::sender());
-	if (!reply) return;
-
-	const auto j = _replies.find(reply);
-	if (j == _replies.cend()) { // handled already
-		return;
-	}
-	const auto loader = j.value();
-
-	const auto pairs = reply->rawHeaderPairs();
-	for (const auto &pair : pairs) {
-		if (QString::fromUtf8(pair.first).toLower() == "content-range") {
-			const auto m = QRegularExpression(qsl("/(\\d+)([^\\d]|$)")).match(QString::fromUtf8(pair.second));
-			if (m.hasMatch()) {
-				loader->setProgress(qMax(qint64(loader->data().size()), loader->already()), m.captured(1).toLongLong());
-				if (!handleReplyResult(loader, WebReplyProcessProgress)) {
-					_replies.erase(j);
-					_loaders.remove(loader);
-					delete loader;
-
-					reply->abort();
-					reply->deleteLater();
-				}
-			}
-		}
-	}
-}
-
-void WebLoadManager::process() {
-	Loaders newLoaders;
-	{
-		QMutexLocker lock(&_loaderPointersMutex);
-		for (LoaderPointers::iterator i = _loaderPointers.begin(), e = _loaderPointers.end(); i != e; ++i) {
-			Loaders::iterator it = _loaders.find(i.value());
-			if (i.value()) {
-				if (it == _loaders.cend()) {
-					_loaders.insert(i.value());
-					newLoaders.insert(i.value());
-				}
-				i.value() = 0;
-			}
-		}
-		for (auto i = _loaders.begin(), e = _loaders.end(); i != e;) {
-			LoaderPointers::iterator it = _loaderPointers.find((*i)->_interface);
-			if (it != _loaderPointers.cend() && it.key()->_private != (*i)) {
-				it = _loaderPointers.end();
-			}
-			if (it == _loaderPointers.cend()) {
-				if (QNetworkReply *reply = (*i)->reply()) {
-					_replies.remove(reply);
-					reply->abort();
-					reply->deleteLater();
-				}
-				delete (*i);
-				i = _loaders.erase(i);
-			} else {
-				++i;
-			}
-		}
-	}
-	for_const (webFileLoaderPrivate *loader, newLoaders) {
-		if (_loaders.contains(loader)) {
-			sendRequest(loader);
-		}
-	}
-}
-
-void WebLoadManager::sendRequest(webFileLoaderPrivate *loader, const QString &redirect) {
-	Replies::iterator j = _replies.find(loader->reply());
-	if (j != _replies.cend()) {
-		QNetworkReply *r = j.key();
-		_replies.erase(j);
-
-		r->abort();
-		r->deleteLater();
-	}
-
-	QNetworkReply *r = loader->request(_manager, redirect);
-
-	// Those use QObject::sender, so don't just remove the receiver pointer!
-	connect(r, SIGNAL(downloadProgress(qint64, qint64)), this, SLOT(onProgress(qint64, qint64)));
-	connect(r, SIGNAL(error(QNetworkReply::NetworkError)), this, SLOT(onFailed(QNetworkReply::NetworkError)));
-	connect(r, SIGNAL(metaDataChanged()), this, SLOT(onMeta()));
-
-	_replies.insert(r, loader);
-}
-
-void WebLoadManager::finish() {
-	clear();
-}
-
-void WebLoadManager::clear() {
-	QMutexLocker lock(&_loaderPointersMutex);
-	for (auto i = _loaderPointers.begin(), e = _loaderPointers.end(); i != e; ++i) {
-		if (i.value()) {
-			i.key()->_private = nullptr;
-		}
-	}
-	_loaderPointers.clear();
-
-	for (const auto loader : _loaders) {
-		delete loader;
-	}
-	_loaders.clear();
-
-	for (auto i = _replies.begin(), e = _replies.end(); i != e; ++i) {
-		delete i.key();
-	}
-	_replies.clear();
-}
-
-WebLoadManager::~WebLoadManager() {
-	clear();
-}
-
-void WebLoadMainManager::progress(webFileLoader *loader, qint64 already, qint64 size) {
-	if (webLoadManager() && webLoadManager()->carries(loader)) {
-		loader->loadProgress(already, size);
-	}
-}
-
-void WebLoadMainManager::finished(webFileLoader *loader, QByteArray data) {
-	if (webLoadManager() && webLoadManager()->carries(loader)) {
-		loader->loadFinished(data);
-	}
-}
-
-void WebLoadMainManager::error(webFileLoader *loader) {
-	if (webLoadManager() && webLoadManager()->carries(loader)) {
-		loader->loadError();
-	}
-}
diff --git a/Telegram/SourceFiles/storage/file_download.h b/Telegram/SourceFiles/storage/file_download.h
index ce492fc51..d68b81352 100644
--- a/Telegram/SourceFiles/storage/file_download.h
+++ b/Telegram/SourceFiles/storage/file_download.h
@@ -10,11 +10,12 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "base/observer.h"
 #include "base/timer.h"
 #include "base/binary_guard.h"
-#include "data/data_file_origin.h"
 
 #include <QtNetwork/QNetworkReply>
 
-class ApiWrap;
+namespace Data {
+struct FileOrigin;
+} // namespace Data
 
 namespace Main {
 class Session;
@@ -25,68 +26,22 @@ namespace Cache {
 struct Key;
 } // namespace Cache
 
+// 10 MB max file could be hold in memory
 // This value is used in local cache database settings!
-constexpr auto kMaxFileInMemory = 10 * 1024 * 1024; // 10 MB max file could be hold in memory
+constexpr auto kMaxFileInMemory = 10 * 1024 * 1024;
 
-constexpr auto kMaxVoiceInMemory = 2 * 1024 * 1024; // 2 MB audio is hold in memory and auto loaded
-constexpr auto kMaxStickerInMemory = 2 * 1024 * 1024; // 2 MB stickers hold in memory, auto loaded and displayed inline
-constexpr auto kMaxWallPaperInMemory = kMaxFileInMemory;
-constexpr auto kMaxAnimationInMemory = kMaxFileInMemory; // 10 MB gif and mp4 animations held in memory while playing
-constexpr auto kMaxWallPaperDimension = 4096; // 4096x4096 is max area.
-
-class Downloader final {
-public:
-	struct Queue {
-		Queue(int queriesLimit) : queriesLimit(queriesLimit) {
-		}
-		int queriesCount = 0;
-		int queriesLimit = 0;
-		FileLoader *start = nullptr;
-		FileLoader *end = nullptr;
-	};
-
-	explicit Downloader(not_null<ApiWrap*> api);
-	~Downloader();
-
-	ApiWrap &api() const {
-		return *_api;
-	}
-
-	int currentPriority() const {
-		return _priority;
-	}
-	void clearPriorities();
-
-	base::Observable<void> &taskFinished() {
-		return _taskFinishedObservable;
-	}
-
-	void requestedAmountIncrement(MTP::DcId dcId, int index, int amount);
-	int chooseDcIndexForRequest(MTP::DcId dcId) const;
-
-	not_null<Queue*> queueForDc(MTP::DcId dcId);
-	not_null<Queue*> queueForWeb();
+// 2 MB audio is hold in memory and auto loaded
+constexpr auto kMaxVoiceInMemory = 2 * 1024 * 1024;
 
-private:
-	void killDownloadSessionsStart(MTP::DcId dcId);
-	void killDownloadSessionsStop(MTP::DcId dcId);
-	void killDownloadSessions();
+// 2 MB stickers hold in memory, auto loaded and displayed inline
+constexpr auto kMaxStickerInMemory = 2 * 1024 * 1024;
 
-	not_null<ApiWrap*> _api;
-
-	base::Observable<void> _taskFinishedObservable;
-	int _priority = 1;
-
-	using RequestedInDc = std::array<int64, MTP::kDownloadSessionsCountMax>;
-	std::map<MTP::DcId, RequestedInDc> _requestedBytesAmount;
-
-	base::flat_map<MTP::DcId, crl::time> _killDownloadSessionTimes;
-	base::Timer _killDownloadSessionsTimer;
-
-	std::map<MTP::DcId, Queue> _queuesForDc;
-	Queue _queueForWeb;
+// 10 MB GIF and mp4 animations held in memory while playing
+constexpr auto kMaxWallPaperInMemory = kMaxFileInMemory;
+constexpr auto kMaxAnimationInMemory = kMaxFileInMemory;
 
-};
+// 4096x4096 is max area.
+constexpr auto kMaxWallPaperDimension = 4096;
 
 } // namespace Storage
 
@@ -99,9 +54,6 @@ struct StorageImageSaved {
 
 };
 
-class mtpFileLoader;
-class webFileLoader;
-
 class FileLoader : public QObject {
 	Q_OBJECT
 
@@ -114,8 +66,9 @@ public:
 		LoadFromCloudSetting fromCloud,
 		bool autoLoading,
 		uint8 cacheTag);
+	virtual ~FileLoader();
 
-	Main::Session &session() const;
+	[[nodiscard]] Main::Session &session() const;
 
 	bool finished() const {
 		return _finished;
@@ -135,7 +88,8 @@ public:
 	QString fileName() const {
 		return _filename;
 	}
-	virtual Data::FileOrigin fileOrigin() const;
+	// Used in MainWidget::documentLoadFailed.
+	[[nodiscard]] virtual Data::FileOrigin fileOrigin() const;
 	float64 currentProgress() const;
 	virtual int currentOffset() const;
 	int fullSize() const;
@@ -146,12 +100,6 @@ public:
 	void start();
 	void cancel();
 
-	bool loading() const {
-		return _inQueue;
-	}
-	bool started() const {
-		return _inQueue;
-	}
 	bool loadingLocal() const {
 		return (_localStatus == LocalStatus::Loading);
 	}
@@ -159,10 +107,6 @@ public:
 		return _autoLoading;
 	}
 
-	virtual void stop() {
-	}
-	virtual ~FileLoader();
-
 	void localLoaded(
 		const StorageImageSaved &result,
 		const QByteArray &imageFormat,
@@ -173,8 +117,6 @@ signals:
 	void failed(FileLoader *loader, bool started);
 
 protected:
-	using Queue = Storage::Downloader::Queue;
-
 	enum class LocalStatus {
 		NotTried,
 		NotFound,
@@ -188,29 +130,21 @@ protected:
 	void loadLocal(const Storage::Cache::Key &key);
 	virtual Storage::Cache::Key cacheKey() const = 0;
 	virtual std::optional<MediaKey> fileLocationKey() const = 0;
-	virtual void cancelRequests() = 0;
+	virtual void cancelHook() = 0;
+	virtual void startLoading() = 0;
 
-	void startLoading();
-	void removeFromQueue();
 	void cancel(bool failed);
 
 	void notifyAboutProgress();
-	static void LoadNextFromQueue(not_null<Queue*> queue);
-	virtual bool loadPart() = 0;
 
 	bool writeResultPart(int offset, bytes::const_span buffer);
 	bool finalizeResult();
 	[[nodiscard]] QByteArray readLoadedPartBack(int offset, int size);
 
-	not_null<Storage::Downloader*> _downloader;
-	FileLoader *_prev = nullptr;
-	FileLoader *_next = nullptr;
-	int _priority = 0;
-	Queue *_queue = nullptr;
+	const not_null<Main::Session*> _session;
 
 	bool _autoLoading = false;
 	uint8 _cacheTag = 0;
-	bool _inQueue = false;
 	bool _finished = false;
 	bool _cancelled = false;
 	mutable LocalStatus _localStatus = LocalStatus::NotTried;
@@ -233,220 +167,3 @@ protected:
 	mutable QImage _imageData;
 
 };
-
-class StorageImageLocation;
-class WebFileLocation;
-class mtpFileLoader : public FileLoader, public RPCSender {
-public:
-	mtpFileLoader(
-		const StorageFileLocation &location,
-		Data::FileOrigin origin,
-		LocationType type,
-		const QString &toFile,
-		int32 size,
-		LoadToCacheSetting toCache,
-		LoadFromCloudSetting fromCloud,
-		bool autoLoading,
-		uint8 cacheTag);
-	mtpFileLoader(
-		const WebFileLocation &location,
-		int32 size,
-		LoadFromCloudSetting fromCloud,
-		bool autoLoading,
-		uint8 cacheTag);
-	mtpFileLoader(
-		const GeoPointLocation &location,
-		int32 size,
-		LoadFromCloudSetting fromCloud,
-		bool autoLoading,
-		uint8 cacheTag);
-
-	Data::FileOrigin fileOrigin() const override;
-
-	uint64 objId() const override;
-
-	void stop() override {
-		rpcInvalidate();
-	}
-	void refreshFileReferenceFrom(
-		const Data::UpdatedFileReferences &updates,
-		int requestId,
-		const QByteArray &current);
-
-	~mtpFileLoader();
-
-private:
-	struct RequestData {
-		MTP::DcId dcId = 0;
-		int dcIndex = 0;
-		int offset = 0;
-	};
-	struct CdnFileHash {
-		CdnFileHash(int limit, QByteArray hash) : limit(limit), hash(hash) {
-		}
-		int limit = 0;
-		QByteArray hash;
-	};
-	Storage::Cache::Key cacheKey() const override;
-	std::optional<MediaKey> fileLocationKey() const override;
-	void cancelRequests() override;
-
-	MTP::DcId dcId() const;
-	RequestData prepareRequest(int offset) const;
-	void makeRequest(int offset);
-
-	bool loadPart() override;
-	void normalPartLoaded(const MTPupload_File &result, mtpRequestId requestId);
-	void webPartLoaded(const MTPupload_WebFile &result, mtpRequestId requestId);
-	void cdnPartLoaded(const MTPupload_CdnFile &result, mtpRequestId requestId);
-	void reuploadDone(const MTPVector<MTPFileHash> &result, mtpRequestId requestId);
-	void requestMoreCdnFileHashes();
-	void getCdnFileHashesDone(const MTPVector<MTPFileHash> &result, mtpRequestId requestId);
-
-	void partLoaded(int offset, bytes::const_span buffer);
-	bool feedPart(int offset, bytes::const_span buffer);
-
-	bool partFailed(const RPCError &error, mtpRequestId requestId);
-	bool normalPartFailed(QByteArray fileReference, const RPCError &error, mtpRequestId requestId);
-	bool cdnPartFailed(const RPCError &error, mtpRequestId requestId);
-
-	mtpRequestId sendRequest(const RequestData &requestData);
-	void placeSentRequest(mtpRequestId requestId, const RequestData &requestData);
-	int finishSentRequestGetOffset(mtpRequestId requestId);
-	void switchToCDN(int offset, const MTPDupload_fileCdnRedirect &redirect);
-	void addCdnHashes(const QVector<MTPFileHash> &hashes);
-	void changeCDNParams(int offset, MTP::DcId dcId, const QByteArray &token, const QByteArray &encryptionKey, const QByteArray &encryptionIV, const QVector<MTPFileHash> &hashes);
-
-	enum class CheckCdnHashResult {
-		NoHash,
-		Invalid,
-		Good,
-	};
-	CheckCdnHashResult checkCdnFileHash(int offset, bytes::const_span buffer);
-
-	std::map<mtpRequestId, RequestData> _sentRequests;
-
-	bool _lastComplete = false;
-	int32 _nextRequestOffset = 0;
-
-	base::variant<
-		StorageFileLocation,
-		WebFileLocation,
-		GeoPointLocation> _location;
-
-	Data::FileOrigin _origin;
-
-	MTP::DcId _cdnDcId = 0;
-	QByteArray _cdnToken;
-	QByteArray _cdnEncryptionKey;
-	QByteArray _cdnEncryptionIV;
-	std::map<int, CdnFileHash> _cdnFileHashes;
-	std::map<int, QByteArray> _cdnUncheckedParts;
-	mtpRequestId _cdnHashesRequestId = 0;
-
-};
-
-class webFileLoaderPrivate;
-
-class webFileLoader : public FileLoader {
-public:
-	webFileLoader(
-		const QString &url,
-		const QString &to,
-		LoadFromCloudSetting fromCloud,
-		bool autoLoading,
-		uint8 cacheTag);
-
-	int currentOffset() const override;
-
-	void loadProgress(qint64 already, qint64 size);
-	void loadFinished(const QByteArray &data);
-	void loadError();
-
-	void stop() override {
-		cancelRequests();
-	}
-
-	~webFileLoader();
-
-protected:
-	void cancelRequests() override;
-	Storage::Cache::Key cacheKey() const override;
-	std::optional<MediaKey> fileLocationKey() const override;
-	bool loadPart() override;
-
-	QString _url;
-
-	bool _requestSent = false;
-	int32 _already = 0;
-
-	friend class WebLoadManager;
-	webFileLoaderPrivate *_private = nullptr;
-
-};
-
-enum WebReplyProcessResult {
-	WebReplyProcessError,
-	WebReplyProcessProgress,
-	WebReplyProcessFinished,
-};
-
-class WebLoadManager : public QObject {
-	Q_OBJECT
-
-public:
-	WebLoadManager(QThread *thread);
-
-	void append(webFileLoader *loader, const QString &url);
-	void stop(webFileLoader *reader);
-	bool carries(webFileLoader *reader) const;
-
-	~WebLoadManager();
-
-signals:
-	void processDelayed();
-
-	void progress(webFileLoader *loader, qint64 already, qint64 size);
-	void finished(webFileLoader *loader, QByteArray data);
-	void error(webFileLoader *loader);
-
-public slots:
-	void onFailed(QNetworkReply *reply);
-	void onFailed(QNetworkReply::NetworkError error);
-	void onProgress(qint64 already, qint64 size);
-	void onMeta();
-
-	void process();
-	void finish();
-
-private:
-	void clear();
-	void sendRequest(webFileLoaderPrivate *loader, const QString &redirect = QString());
-	bool handleReplyResult(webFileLoaderPrivate *loader, WebReplyProcessResult result);
-
-	QNetworkAccessManager _manager;
-	typedef QMap<webFileLoader*, webFileLoaderPrivate*> LoaderPointers;
-	LoaderPointers _loaderPointers;
-	mutable QMutex _loaderPointersMutex;
-
-	typedef OrderedSet<webFileLoaderPrivate*> Loaders;
-	Loaders _loaders;
-
-	typedef QMap<QNetworkReply*, webFileLoaderPrivate*> Replies;
-	Replies _replies;
-
-};
-
-class WebLoadMainManager : public QObject {
-	Q_OBJECT
-
-public slots:
-	void progress(webFileLoader *loader, qint64 already, qint64 size);
-	void finished(webFileLoader *loader, QByteArray data);
-	void error(webFileLoader *loader);
-
-};
-
-static WebLoadManager * const FinishedWebLoadManager = SharedMemoryLocation<WebLoadManager, 0>();
-
-void stopWebLoadManager();
diff --git a/Telegram/SourceFiles/storage/file_download_mtproto.cpp b/Telegram/SourceFiles/storage/file_download_mtproto.cpp
new file mode 100644
index 000000000..bf14e8bfe
--- /dev/null
+++ b/Telegram/SourceFiles/storage/file_download_mtproto.cpp
@@ -0,0 +1,167 @@
+/*
+This file is part of Telegram Desktop,
+the official desktop application for the Telegram messaging service.
+
+For license and copyright information please follow this link:
+https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+*/
+#include "storage/file_download_mtproto.h"
+
+#include "data/data_document.h"
+#include "data/data_file_origin.h"
+#include "storage/cache/storage_cache_types.h"
+#include "main/main_session.h"
+#include "apiwrap.h"
+#include "mtproto/mtp_instance.h"
+#include "mtproto/mtproto_auth_key.h"
+#include "base/openssl_help.h"
+#include "facades.h"
+
+mtpFileLoader::mtpFileLoader(
+	const StorageFileLocation &location,
+	Data::FileOrigin origin,
+	LocationType type,
+	const QString &to,
+	int32 size,
+	LoadToCacheSetting toCache,
+	LoadFromCloudSetting fromCloud,
+	bool autoLoading,
+	uint8 cacheTag)
+: FileLoader(
+	to,
+	size,
+	type,
+	toCache,
+	fromCloud,
+	autoLoading,
+	cacheTag)
+, DownloadMtprotoTask(&session().downloader(), location, origin) {
+}
+
+mtpFileLoader::mtpFileLoader(
+	const WebFileLocation &location,
+	int32 size,
+	LoadFromCloudSetting fromCloud,
+	bool autoLoading,
+	uint8 cacheTag)
+: FileLoader(
+	QString(),
+	size,
+	UnknownFileLocation,
+	LoadToCacheAsWell,
+	fromCloud,
+	autoLoading,
+	cacheTag)
+, DownloadMtprotoTask(
+	&session().downloader(),
+	Global::WebFileDcId(),
+	{ location }) {
+}
+
+mtpFileLoader::mtpFileLoader(
+	const GeoPointLocation &location,
+	int32 size,
+	LoadFromCloudSetting fromCloud,
+	bool autoLoading,
+	uint8 cacheTag)
+: FileLoader(
+	QString(),
+	size,
+	UnknownFileLocation,
+	LoadToCacheAsWell,
+	fromCloud,
+	autoLoading,
+	cacheTag)
+, DownloadMtprotoTask(
+	&session().downloader(),
+	Global::WebFileDcId(),
+	{ location }) {
+}
+
+Data::FileOrigin mtpFileLoader::fileOrigin() const {
+	return DownloadMtprotoTask::fileOrigin();
+}
+
+uint64 mtpFileLoader::objId() const {
+	return DownloadMtprotoTask::objectId();
+}
+
+bool mtpFileLoader::readyToRequest() const {
+	return !_finished
+		&& !_lastComplete
+		&& (_size != 0 || !haveSentRequests())
+		&& (!_size || _nextRequestOffset < _size);
+}
+
+int mtpFileLoader::takeNextRequestOffset() {
+	Expects(readyToRequest());
+
+	const auto result = _nextRequestOffset;
+	_nextRequestOffset += Storage::kDownloadPartSize;
+	return result;
+}
+
+bool mtpFileLoader::feedPart(int offset, const QByteArray &bytes) {
+	const auto buffer = bytes::make_span(bytes);
+	if (!writeResultPart(offset, buffer)) {
+		return false;
+	}
+	if (buffer.empty() || (buffer.size() % 1024)) { // bad next offset
+		_lastComplete = true;
+	}
+	const auto weak = QPointer<mtpFileLoader>(this);
+	const auto finished = !haveSentRequests()
+		&& (_lastComplete || (_size && _nextRequestOffset >= _size));
+	if (finished) {
+		removeFromQueue();
+		if (!finalizeResult()) {
+			return false;
+		}
+	}
+	if (weak) {
+		notifyAboutProgress();
+	}
+	return true;
+}
+
+void mtpFileLoader::cancelOnFail() {
+	cancel(true);
+}
+
+bool mtpFileLoader::setWebFileSizeHook(int size) {
+	if (!_size || _size == size) {
+		_size = size;
+		return true;
+	}
+	LOG(("MTP Error: "
+		"Bad size provided by bot for webDocument: %1, real: %2"
+		).arg(_size
+		).arg(size));
+	cancel(true);
+	return false;
+}
+
+void mtpFileLoader::startLoading() {
+	addToQueue();
+}
+
+void mtpFileLoader::cancelHook() {
+	cancelAllRequests();
+}
+
+Storage::Cache::Key mtpFileLoader::cacheKey() const {
+	return location().data.match([&](const WebFileLocation &location) {
+		return Data::WebDocumentCacheKey(location);
+	}, [&](const GeoPointLocation &location) {
+		return Data::GeoPointCacheKey(location);
+	}, [&](const StorageFileLocation &location) {
+		return location.cacheKey();
+	});
+}
+
+std::optional<MediaKey> mtpFileLoader::fileLocationKey() const {
+	if (_locationType != UnknownFileLocation) {
+		return mediaKey(_locationType, dcId(), objId());
+	}
+	return std::nullopt;
+}
diff --git a/Telegram/SourceFiles/storage/file_download_mtproto.h b/Telegram/SourceFiles/storage/file_download_mtproto.h
new file mode 100644
index 000000000..0906d47d0
--- /dev/null
+++ b/Telegram/SourceFiles/storage/file_download_mtproto.h
@@ -0,0 +1,58 @@
+/*
+This file is part of Telegram Desktop,
+the official desktop application for the Telegram messaging service.
+
+For license and copyright information please follow this link:
+https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+*/
+#pragma once
+
+#include "storage/file_download.h"
+#include "storage/download_manager_mtproto.h"
+
+class mtpFileLoader final
+	: public FileLoader
+	, private Storage::DownloadMtprotoTask {
+public:
+	mtpFileLoader(
+		const StorageFileLocation &location,
+		Data::FileOrigin origin,
+		LocationType type,
+		const QString &toFile,
+		int32 size,
+		LoadToCacheSetting toCache,
+		LoadFromCloudSetting fromCloud,
+		bool autoLoading,
+		uint8 cacheTag);
+	mtpFileLoader(
+		const WebFileLocation &location,
+		int32 size,
+		LoadFromCloudSetting fromCloud,
+		bool autoLoading,
+		uint8 cacheTag);
+	mtpFileLoader(
+		const GeoPointLocation &location,
+		int32 size,
+		LoadFromCloudSetting fromCloud,
+		bool autoLoading,
+		uint8 cacheTag);
+
+	Data::FileOrigin fileOrigin() const override;
+	uint64 objId() const override;
+
+private:
+	Storage::Cache::Key cacheKey() const override;
+	std::optional<MediaKey> fileLocationKey() const override;
+	void startLoading() override;
+	void cancelHook() override;
+
+	bool readyToRequest() const override;
+	int takeNextRequestOffset() override;
+	bool feedPart(int offset, const QByteArray &bytes) override;
+	void cancelOnFail() override;
+	bool setWebFileSizeHook(int size) override;
+
+	bool _lastComplete = false;
+	int32 _nextRequestOffset = 0;
+
+};
diff --git a/Telegram/SourceFiles/storage/file_download_web.cpp b/Telegram/SourceFiles/storage/file_download_web.cpp
new file mode 100644
index 000000000..5d1878382
--- /dev/null
+++ b/Telegram/SourceFiles/storage/file_download_web.cpp
@@ -0,0 +1,525 @@
+/*
+This file is part of Telegram Desktop,
+the official desktop application for the Telegram messaging service.
+
+For license and copyright information please follow this link:
+https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+*/
+#include "storage/file_download_web.h"
+
+#include "storage/cache/storage_cache_types.h"
+
+#include <QtNetwork/QAuthenticator>
+
+namespace {
+
+constexpr auto kMaxWebFileQueries = 8;
+constexpr auto kMaxHttpRedirects = 5;
+constexpr auto kResetDownloadPrioritiesTimeout = crl::time(200);
+
+std::weak_ptr<WebLoadManager> GlobalLoadManager;
+
+using ErrorSignal = void(QNetworkReply::*)(QNetworkReply::NetworkError);
+const auto QNetworkReply_error = ErrorSignal(&QNetworkReply::error);
+
+[[nodiscard]] std::shared_ptr<WebLoadManager> GetManager() {
+	auto result = GlobalLoadManager.lock();
+	if (!result) {
+		GlobalLoadManager = result = std::make_shared<WebLoadManager>();
+	}
+	return result;
+}
+
+enum class ProcessResult {
+	Error,
+	Progress,
+	Finished,
+};
+
+enum class Error {
+};
+
+struct Progress {
+	qint64 ready = 0;
+	qint64 total = 0;
+};
+
+using Update = base::variant<Progress, QByteArray, Error>;
+
+struct UpdateForLoader {
+	not_null<webFileLoader*> loader;
+	Update data;
+};
+
+} // namespace
+
+class WebLoadManager final : public QObject {
+public:
+	WebLoadManager();
+	~WebLoadManager();
+
+	void enqueue(not_null<webFileLoader*> loader);
+	void remove(not_null<webFileLoader*> loader);
+
+	[[nodiscard]] rpl::producer<Update> updates(
+		not_null<webFileLoader*> loader) const;
+
+private:
+	struct Enqueued {
+		int id = 0;
+		QString url;
+	};
+	struct Sent {
+		QString url;
+		not_null<QNetworkReply*> reply;
+		QByteArray data;
+		int64 ready = 0;
+		int64 total = 0;
+		int redirectsLeft = kMaxHttpRedirects;
+	};
+
+	// Constructor.
+	void handleNetworkErrors();
+
+	// Worker thread.
+	void enqueue(int id, const QString &url);
+	void remove(int id);
+	void resetGeneration();
+	void checkSendNext();
+	void send(const Enqueued &entry);
+	[[nodiscard]] not_null<QNetworkReply*> send(int id, const QString &url);
+	[[nodiscard]] Sent *findSent(int id, not_null<QNetworkReply*> reply);
+	void removeSent(int id);
+	void progress(
+		int id,
+		not_null<QNetworkReply*> reply,
+		int64 ready,
+		int64 total);
+	void failed(
+		int id,
+		not_null<QNetworkReply*> reply,
+		QNetworkReply::NetworkError error);
+	void redirect(int id, not_null<QNetworkReply*> reply);
+	void notify(
+		int id,
+		not_null<QNetworkReply*> reply,
+		int64 ready,
+		int64 total);
+	void failed(int id, not_null<QNetworkReply*> reply);
+	void finished(int id, not_null<QNetworkReply*> reply);
+	void deleteDeferred(not_null<QNetworkReply*> reply);
+	void queueProgressUpdate(int id, int64 ready, int64 total);
+	void queueFailedUpdate(int id);
+	void queueFinishedUpdate(int id, const QByteArray &data);
+	void clear();
+
+	// Main thread.
+	void sendUpdate(int id, Update &&data);
+
+	QThread _thread;
+	QNetworkAccessManager _network;
+	base::Timer _resetGenerationTimer;
+
+	// Main thread.
+	rpl::event_stream<UpdateForLoader> _updates;
+	int _autoincrement = 0;
+	base::flat_map<not_null<webFileLoader*>, int> _ids;
+
+	// Worker thread.
+	std::deque<Enqueued> _queue;
+	std::deque<Enqueued> _previousGeneration;
+	base::flat_map<int, Sent> _sent;
+	std::vector<QPointer<QNetworkReply>> _repliesBeingDeleted;
+
+};
+
+WebLoadManager::WebLoadManager()
+: _resetGenerationTimer(&_thread, [=] { resetGeneration(); }) {
+	handleNetworkErrors();
+
+	const auto original = QThread::currentThread();
+	moveToThread(&_thread);
+	_network.moveToThread(&_thread);
+	connect(&_thread, &QThread::finished, [=] {
+		clear();
+		moveToThread(original);
+		_network.moveToThread(original);
+	});
+	_thread.start();
+}
+
+void WebLoadManager::handleNetworkErrors() {
+	const auto fail = [=](QNetworkReply *reply) {
+		for (const auto &[id, sent] : _sent) {
+			if (sent.reply == reply) {
+				failed(id, reply);
+				return;
+			}
+		}
+	};
+	connect(&_network, &QNetworkAccessManager::authenticationRequired, fail);
+	connect(&_network, &QNetworkAccessManager::sslErrors, fail);
+}
+
+WebLoadManager::~WebLoadManager() {
+	_thread.quit();
+	_thread.wait();
+}
+
+[[nodiscard]] rpl::producer<Update> WebLoadManager::updates(
+		not_null<webFileLoader*> loader) const {
+	return _updates.events(
+	) | rpl::filter([=](const UpdateForLoader &update) {
+		return (update.loader == loader);
+	}) | rpl::map([=](UpdateForLoader &&update) {
+		return std::move(update.data);
+	});
+}
+
+void WebLoadManager::enqueue(not_null<webFileLoader*> loader) {
+	const auto id = [&] {
+		const auto i = _ids.find(loader);
+		return (i != end(_ids))
+			? i->second
+			: _ids.emplace(loader, ++_autoincrement).first->second;
+	}();
+	const auto url = loader->url();
+	InvokeQueued(this, [=] {
+		enqueue(id, url);
+	});
+}
+
+void WebLoadManager::remove(not_null<webFileLoader*> loader) {
+	const auto i = _ids.find(loader);
+	if (i == end(_ids)) {
+		return;
+	}
+	const auto id = i->second;
+	_ids.erase(i);
+	InvokeQueued(this, [=] {
+		remove(id);
+	});
+}
+
+void WebLoadManager::enqueue(int id, const QString &url) {
+	const auto i = ranges::find(_queue, id, &Enqueued::id);
+	if (i != end(_queue)) {
+		return;
+	}
+	_previousGeneration.erase(
+		ranges::remove(_previousGeneration, id, &Enqueued::id),
+		end(_previousGeneration));
+	_queue.push_back(Enqueued{ id, url });
+	if (!_resetGenerationTimer.isActive()) {
+		_resetGenerationTimer.callOnce(kResetDownloadPrioritiesTimeout);
+	}
+	checkSendNext();
+}
+
+void WebLoadManager::remove(int id) {
+	_queue.erase(ranges::remove(_queue, id, &Enqueued::id), end(_queue));
+	_previousGeneration.erase(
+		ranges::remove(_previousGeneration, id, &Enqueued::id),
+		end(_previousGeneration));
+	removeSent(id);
+}
+
+void WebLoadManager::resetGeneration() {
+	if (!_previousGeneration.empty()) {
+		std::copy(
+			begin(_previousGeneration),
+			end(_previousGeneration),
+			std::back_inserter(_queue));
+		_previousGeneration.clear();
+	}
+	std::swap(_queue, _previousGeneration);
+}
+
+void WebLoadManager::checkSendNext() {
+	if (_sent.size() >= kMaxWebFileQueries
+		|| (_queue.empty() && _previousGeneration.empty())) {
+		return;
+	}
+	const auto entry = _queue.empty()
+		? _previousGeneration.front()
+		: _queue.front();
+	(_queue.empty() ? _previousGeneration : _queue).pop_front();
+	send(entry);
+}
+
+void WebLoadManager::send(const Enqueued &entry) {
+	const auto id = entry.id;
+	const auto url = entry.url;
+	_sent.emplace(id, Sent{ url, send(id, url) });
+}
+
+void WebLoadManager::removeSent(int id) {
+	if (const auto i = _sent.find(id); i != end(_sent)) {
+		deleteDeferred(i->second.reply);
+		_sent.erase(i);
+		checkSendNext();
+	}
+}
+
+not_null<QNetworkReply*> WebLoadManager::send(int id, const QString &url) {
+	const auto result = _network.get(QNetworkRequest(url));
+	const auto handleProgress = [=](qint64 ready, qint64 total) {
+		progress(id, result, ready, total);
+	};
+	const auto handleError = [=](QNetworkReply::NetworkError error) {
+		failed(id, result, error);
+	};
+	connect(result, &QNetworkReply::downloadProgress, handleProgress);
+	connect(result, QNetworkReply_error, handleError);
+	return result;
+}
+
+WebLoadManager::Sent *WebLoadManager::findSent(
+		int id,
+		not_null<QNetworkReply*> reply) {
+	const auto i = _sent.find(id);
+	return (i != end(_sent) && i->second.reply == reply)
+		? &i->second
+		: nullptr;
+}
+
+void WebLoadManager::progress(
+		int id,
+		not_null<QNetworkReply*> reply,
+		int64 ready,
+		int64 total) {
+	const auto statusCode = reply->attribute(
+		QNetworkRequest::HttpStatusCodeAttribute);
+	const auto status = statusCode.isValid() ? statusCode.toInt() : 200;
+	if (status == 301 || status == 302) {
+		redirect(id, reply);
+	} else if (status != 200 && status != 206 && status != 416) {
+		LOG(("Network Error: "
+			"Bad HTTP status received in WebLoadManager::onProgress() %1"
+			).arg(status));
+		failed(id, reply);
+	} else {
+		notify(id, reply, ready, total);
+	}
+}
+
+void WebLoadManager::redirect(int id, not_null<QNetworkReply*> reply) {
+	const auto header = reply->header(QNetworkRequest::LocationHeader);
+	const auto url = header.toString();
+	if (url.isEmpty()) {
+		return;
+	}
+
+	if (const auto sent = findSent(id, reply)) {
+		if (!sent->redirectsLeft--) {
+			LOG(("Network Error: "
+				"Too many HTTP redirects in onFinished() "
+				"for web file loader: %1").arg(url));
+			failed(id, reply);
+			return;
+		}
+		deleteDeferred(reply);
+		sent->url = url;
+		sent->reply = send(id, url);
+	}
+}
+
+void WebLoadManager::notify(
+		int id,
+		not_null<QNetworkReply*> reply,
+		int64 ready,
+		int64 total) {
+	if (const auto sent = findSent(id, reply)) {
+		sent->ready = ready;
+		sent->total = std::max(total, int64(0));
+		sent->data.append(reply->readAll());
+		if (total == 0
+			|| total > Storage::kMaxFileInMemory
+			|| sent->data.size() > Storage::kMaxFileInMemory) {
+			LOG(("Network Error: "
+				"Bad size received for HTTP download progress "
+				"in WebLoadManager::onProgress(): %1 / %2 (bytes %3)"
+				).arg(ready
+				).arg(total
+				).arg(sent->data.size()));
+			failed(id, reply);
+		} else if (total > 0 && ready >= total) {
+			finished(id, reply);
+		} else {
+			queueProgressUpdate(id, sent->ready, sent->total);
+		}
+	}
+}
+
+void WebLoadManager::failed(
+		int id,
+		not_null<QNetworkReply*> reply,
+		QNetworkReply::NetworkError error) {
+	if (const auto sent = findSent(id, reply)) {
+		LOG(("Network Error: "
+			"Failed to request '%1', error %2 (%3)"
+			).arg(sent->url
+			).arg(int(error)
+			).arg(reply->errorString()));
+		failed(id, reply);
+	}
+}
+
+void WebLoadManager::failed(int id, not_null<QNetworkReply*> reply) {
+	if (const auto sent = findSent(id, reply)) {
+		removeSent(id);
+		queueFailedUpdate(id);
+	}
+}
+
+void WebLoadManager::deleteDeferred(not_null<QNetworkReply*> reply) {
+	reply->deleteLater();
+	_repliesBeingDeleted.erase(
+		ranges::remove(_repliesBeingDeleted, nullptr),
+		end(_repliesBeingDeleted));
+	_repliesBeingDeleted.emplace_back(reply.get());
+}
+
+void WebLoadManager::finished(int id, not_null<QNetworkReply*> reply) {
+	if (const auto sent = findSent(id, reply)) {
+		const auto data = base::take(sent->data);
+		removeSent(id);
+		queueFinishedUpdate(id, data);
+	}
+}
+
+void WebLoadManager::clear() {
+	for (const auto &[id, sent] : base::take(_sent)) {
+		sent.reply->abort();
+		delete sent.reply;
+	}
+	for (const auto reply : base::take(_repliesBeingDeleted)) {
+		if (reply) {
+			delete reply;
+		}
+	}
+}
+
+void WebLoadManager::queueProgressUpdate(int id, int64 ready, int64 total) {
+	crl::on_main(this, [=] {
+		sendUpdate(id, Progress{ ready, total });
+	});
+}
+
+void WebLoadManager::queueFailedUpdate(int id) {
+	crl::on_main(this, [=] {
+		sendUpdate(id, Error{});
+	});
+}
+
+void WebLoadManager::queueFinishedUpdate(int id, const QByteArray &data) {
+	crl::on_main(this, [=] {
+		LOG(("FINISHED UPDATE FOR: %1").arg(id));
+		for (const auto &[loader, loaderId] : _ids) {
+			if (loaderId == id) {
+				LOG(("LOADER ID: %2").arg(quintptr(loader.get())));
+				break;
+			}
+		}
+		LOG(("SENT"));
+		sendUpdate(id, QByteArray(data));
+	});
+}
+
+void WebLoadManager::sendUpdate(int id, Update &&data) {
+	for (const auto &[loader, loaderId] : _ids) {
+		if (loaderId == id) {
+			_updates.fire(UpdateForLoader{ loader, std::move(data) });
+			return;
+		}
+	}
+}
+
+webFileLoader::webFileLoader(
+	const QString &url,
+	const QString &to,
+	LoadFromCloudSetting fromCloud,
+	bool autoLoading,
+	uint8 cacheTag)
+: FileLoader(
+	QString(),
+	0,
+	UnknownFileLocation,
+	LoadToCacheAsWell,
+	fromCloud,
+	autoLoading,
+	cacheTag)
+, _url(url) {
+}
+
+webFileLoader::~webFileLoader() {
+	cancelRequest();
+}
+
+QString webFileLoader::url() const {
+	return _url;
+}
+
+void webFileLoader::startLoading() {
+	if (_finished) {
+		return;
+	} else if (!_manager) {
+		_manager = GetManager();
+		_manager->updates(
+			this
+		) | rpl::start_with_next([=](const Update &data) {
+			if (const auto progress = base::get_if<Progress>(&data)) {
+				loadProgress(progress->ready, progress->total);
+			} else if (const auto bytes = base::get_if<QByteArray>(&data)) {
+				loadFinished(*bytes);
+			} else {
+				loadFailed();
+			}
+		}, _managerLifetime);
+	}
+	_manager->enqueue(this);
+}
+
+int webFileLoader::currentOffset() const {
+	return _ready;
+}
+
+void webFileLoader::loadProgress(qint64 ready, qint64 total) {
+	_size = total;
+	_ready = ready;
+	notifyAboutProgress();
+}
+
+void webFileLoader::loadFinished(const QByteArray &data) {
+	cancelRequest();
+	if (writeResultPart(0, bytes::make_span(data))) {
+		if (finalizeResult()) {
+			notifyAboutProgress();
+		}
+	}
+}
+
+void webFileLoader::loadFailed() {
+	cancel(true);
+}
+
+Storage::Cache::Key webFileLoader::cacheKey() const {
+	return Data::UrlCacheKey(_url);
+}
+
+std::optional<MediaKey> webFileLoader::fileLocationKey() const {
+	return std::nullopt;
+}
+
+void webFileLoader::cancelHook() {
+	cancelRequest();
+}
+
+void webFileLoader::cancelRequest() {
+	if (!_manager) {
+		return;
+	}
+	_managerLifetime.destroy();
+	_manager->remove(this);
+	_manager = nullptr;
+}
diff --git a/Telegram/SourceFiles/storage/file_download_web.h b/Telegram/SourceFiles/storage/file_download_web.h
new file mode 100644
index 000000000..9c832ae00
--- /dev/null
+++ b/Telegram/SourceFiles/storage/file_download_web.h
@@ -0,0 +1,45 @@
+/*
+This file is part of Telegram Desktop,
+the official desktop application for the Telegram messaging service.
+
+For license and copyright information please follow this link:
+https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+*/
+#pragma once
+
+#include "storage/file_download.h"
+
+class WebLoadManager;
+
+class webFileLoader final : public FileLoader {
+public:
+	webFileLoader(
+		const QString &url,
+		const QString &to,
+		LoadFromCloudSetting fromCloud,
+		bool autoLoading,
+		uint8 cacheTag);
+	~webFileLoader();
+
+	[[nodiscard]] QString url() const;
+
+	int currentOffset() const override;
+
+private:
+	void cancelRequest();
+	void cancelHook() override;
+	void startLoading() override;
+	Storage::Cache::Key cacheKey() const override;
+	std::optional<MediaKey> fileLocationKey() const override;
+
+	void loadProgress(qint64 ready, qint64 size);
+	void loadFinished(const QByteArray &data);
+	void loadFailed();
+
+	const QString _url;
+	int _ready = 0;
+
+	std::shared_ptr<WebLoadManager> _manager;
+	rpl::lifetime _managerLifetime;
+
+};
diff --git a/Telegram/SourceFiles/storage/file_upload.cpp b/Telegram/SourceFiles/storage/file_upload.cpp
index 066edd39c..4e3396e6e 100644
--- a/Telegram/SourceFiles/storage/file_upload.cpp
+++ b/Telegram/SourceFiles/storage/file_upload.cpp
@@ -9,7 +9,6 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 
 #include "storage/localimageloader.h"
 #include "storage/file_download.h"
-#include "mtproto/connection.h" // for MTP::kAckSendWaiting
 #include "data/data_document.h"
 #include "data/data_photo.h"
 #include "data/data_session.h"
@@ -42,7 +41,7 @@ constexpr auto kDocumentUploadPartSize4 = 512 * 1024;
 constexpr auto kUploadRequestInterval = crl::time(500);
 
 // How much time without upload causes additional session kill.
-constexpr auto kKillSessionTimeout = crl::time(5000);
+constexpr auto kKillSessionTimeout = 15 * crl::time(000);
 
 } // namespace
 
@@ -256,8 +255,7 @@ void Uploader::sendNext() {
 	bool stopping = stopSessionsTimer.isActive();
 	if (queue.empty()) {
 		if (!stopping) {
-			stopSessionsTimer.start(
-				MTP::kAckSendWaiting + kKillSessionTimeout);
+			stopSessionsTimer.start(kKillSessionTimeout);
 		}
 		return;
 	}
diff --git a/Telegram/SourceFiles/storage/file_upload.h b/Telegram/SourceFiles/storage/file_upload.h
index 7e1f63d5c..ae48072aa 100644
--- a/Telegram/SourceFiles/storage/file_upload.h
+++ b/Telegram/SourceFiles/storage/file_upload.h
@@ -8,6 +8,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #pragma once
 
 #include "api/api_common.h"
+#include "mtproto/facade.h"
 
 #include <QtCore/QTimer>
 
diff --git a/Telegram/SourceFiles/storage/localstorage.cpp b/Telegram/SourceFiles/storage/localstorage.cpp
index 07a01bf03..89c280cc7 100644
--- a/Telegram/SourceFiles/storage/localstorage.cpp
+++ b/Telegram/SourceFiles/storage/localstorage.cpp
@@ -1117,8 +1117,8 @@ bool _readSetting(quint32 blockId, QDataStream &stream, int version, ReadSetting
 		};
 		set(Type::Photo, photo);
 		set(Type::VoiceMessage, audio);
-		set(Type::GIF, gif);
-		set(Type::VideoMessage, gif);
+		set(Type::AutoPlayGIF, gif);
+		set(Type::AutoPlayVideoMessage, gif);
 	} break;
 
 	case dbiAutoPlayOld: {
@@ -1126,7 +1126,25 @@ bool _readSetting(quint32 blockId, QDataStream &stream, int version, ReadSetting
 		stream >> gif;
 		if (!_checkStreamStatus(stream)) return false;
 
-		GetStoredSessionSettings().setAutoplayGifs(gif == 1);
+		if (!gif) {
+			using namespace Data::AutoDownload;
+			auto &settings = GetStoredSessionSettings().autoDownload();
+			const auto types = {
+				Type::AutoPlayGIF,
+				Type::AutoPlayVideo,
+				Type::AutoPlayVideoMessage,
+			};
+			const auto sources = {
+				Source::User,
+				Source::Group,
+				Source::Channel
+			};
+			for (const auto source : sources) {
+				for (const auto type : types) {
+					settings.setBytesLimit(source, type, 0);
+				}
+			}
+		}
 	} break;
 
 	case dbiDialogsMode: {
@@ -1264,7 +1282,7 @@ bool _readSetting(quint32 blockId, QDataStream &stream, int version, ReadSetting
 		stream >> v;
 		if (!_checkStreamStatus(stream)) return false;
 
-		ProxyData proxy;
+		MTP::ProxyData proxy;
 		switch (v) {
 		case dbictHttpProxy:
 		case dbictTcpProxy: {
@@ -1274,14 +1292,14 @@ bool _readSetting(quint32 blockId, QDataStream &stream, int version, ReadSetting
 
 			proxy.port = uint32(port);
 			proxy.type = (v == dbictTcpProxy)
-				? ProxyData::Type::Socks5
-				: ProxyData::Type::Http;
+				? MTP::ProxyData::Type::Socks5
+				: MTP::ProxyData::Type::Http;
 		} break;
 		};
-		Global::SetSelectedProxy(proxy ? proxy : ProxyData());
+		Global::SetSelectedProxy(proxy ? proxy : MTP::ProxyData());
 		Global::SetProxySettings(proxy
-			? ProxyData::Settings::Enabled
-			: ProxyData::Settings::System);
+			? MTP::ProxyData::Settings::Enabled
+			: MTP::ProxyData::Settings::System);
 		if (proxy) {
 			Global::SetProxiesList({ 1, proxy });
 		} else {
@@ -1299,20 +1317,20 @@ bool _readSetting(quint32 blockId, QDataStream &stream, int version, ReadSetting
 
 		const auto readProxy = [&] {
 			qint32 proxyType, port;
-			ProxyData proxy;
+			MTP::ProxyData proxy;
 			stream >> proxyType >> proxy.host >> port >> proxy.user >> proxy.password;
 			proxy.port = port;
 			proxy.type = (proxyType == dbictTcpProxy)
-				? ProxyData::Type::Socks5
+				? MTP::ProxyData::Type::Socks5
 				: (proxyType == dbictHttpProxy)
-				? ProxyData::Type::Http
-				: (proxyType == kProxyTypeShift + int(ProxyData::Type::Socks5))
-				? ProxyData::Type::Socks5
-				: (proxyType == kProxyTypeShift + int(ProxyData::Type::Http))
-				? ProxyData::Type::Http
-				: (proxyType == kProxyTypeShift + int(ProxyData::Type::Mtproto))
-				? ProxyData::Type::Mtproto
-				: ProxyData::Type::None;
+				? MTP::ProxyData::Type::Http
+				: (proxyType == kProxyTypeShift + int(MTP::ProxyData::Type::Socks5))
+				? MTP::ProxyData::Type::Socks5
+				: (proxyType == kProxyTypeShift + int(MTP::ProxyData::Type::Http))
+				? MTP::ProxyData::Type::Http
+				: (proxyType == kProxyTypeShift + int(MTP::ProxyData::Type::Mtproto))
+				? MTP::ProxyData::Type::Mtproto
+				: MTP::ProxyData::Type::None;
 			return proxy;
 		};
 		if (connectionType == dbictProxiesListOld
@@ -1327,7 +1345,7 @@ bool _readSetting(quint32 blockId, QDataStream &stream, int version, ReadSetting
 				index -= (index > 0 ? count : -count);
 			}
 
-			auto list = std::vector<ProxyData>();
+			auto list = std::vector<MTP::ProxyData>();
 			for (auto i = 0; i < count; ++i) {
 				const auto proxy = readProxy();
 				if (proxy) {
@@ -1345,29 +1363,29 @@ bool _readSetting(quint32 blockId, QDataStream &stream, int version, ReadSetting
 			if (connectionType == dbictProxiesListOld) {
 				settings = static_cast<qint32>(
 					(index > 0 && index <= list.size()
-						? ProxyData::Settings::Enabled
-						: ProxyData::Settings::System));
+						? MTP::ProxyData::Settings::Enabled
+						: MTP::ProxyData::Settings::System));
 				index = std::abs(index);
 			}
 			if (index > 0 && index <= list.size()) {
 				Global::SetSelectedProxy(list[index - 1]);
 			} else {
-				Global::SetSelectedProxy(ProxyData());
+				Global::SetSelectedProxy(MTP::ProxyData());
 			}
 
-			const auto unchecked = static_cast<ProxyData::Settings>(settings);
+			const auto unchecked = static_cast<MTP::ProxyData::Settings>(settings);
 			switch (unchecked) {
-			case ProxyData::Settings::Enabled:
+			case MTP::ProxyData::Settings::Enabled:
 				Global::SetProxySettings(Global::SelectedProxy()
-					? ProxyData::Settings::Enabled
-					: ProxyData::Settings::System);
+					? MTP::ProxyData::Settings::Enabled
+					: MTP::ProxyData::Settings::System);
 				break;
-			case ProxyData::Settings::Disabled:
-			case ProxyData::Settings::System:
+			case MTP::ProxyData::Settings::Disabled:
+			case MTP::ProxyData::Settings::System:
 				Global::SetProxySettings(unchecked);
 				break;
 			default:
-				Global::SetProxySettings(ProxyData::Settings::System);
+				Global::SetProxySettings(MTP::ProxyData::Settings::System);
 				break;
 			}
 			Global::SetUseProxyForCalls(calls == 1);
@@ -1381,14 +1399,14 @@ bool _readSetting(quint32 blockId, QDataStream &stream, int version, ReadSetting
 				Global::SetSelectedProxy(proxy);
 				if (connectionType == dbictTcpProxy
 					|| connectionType == dbictHttpProxy) {
-					Global::SetProxySettings(ProxyData::Settings::Enabled);
+					Global::SetProxySettings(MTP::ProxyData::Settings::Enabled);
 				} else {
-					Global::SetProxySettings(ProxyData::Settings::System);
+					Global::SetProxySettings(MTP::ProxyData::Settings::System);
 				}
 			} else {
 				Global::SetProxiesList({});
-				Global::SetSelectedProxy(ProxyData());
-				Global::SetProxySettings(ProxyData::Settings::System);
+				Global::SetSelectedProxy(MTP::ProxyData());
+				Global::SetProxySettings(MTP::ProxyData::Settings::System);
 			}
 		}
 		Core::App().refreshGlobalProxy();
@@ -2646,7 +2664,7 @@ void writeSettings() {
 	auto &proxies = Global::RefProxiesList();
 	const auto &proxy = Global::SelectedProxy();
 	auto proxyIt = ranges::find(proxies, proxy);
-	if (proxy.type != ProxyData::Type::None
+	if (proxy.type != MTP::ProxyData::Type::None
 		&& proxyIt == end(proxies)) {
 		proxies.push_back(proxy);
 		proxyIt = end(proxies) - 1;
diff --git a/Telegram/SourceFiles/storage/serialize_common.h b/Telegram/SourceFiles/storage/serialize_common.h
index 679c0fece..a1acb9b6b 100644
--- a/Telegram/SourceFiles/storage/serialize_common.h
+++ b/Telegram/SourceFiles/storage/serialize_common.h
@@ -7,7 +7,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 */
 #pragma once
 
-#include "mtproto/auth_key.h"
+#include "mtproto/mtproto_auth_key.h"
 
 namespace Serialize {
 
diff --git a/Telegram/SourceFiles/storage/streamed_file_downloader.cpp b/Telegram/SourceFiles/storage/streamed_file_downloader.cpp
index 12c929fee..db3558efa 100644
--- a/Telegram/SourceFiles/storage/streamed_file_downloader.cpp
+++ b/Telegram/SourceFiles/storage/streamed_file_downloader.cpp
@@ -16,6 +16,7 @@ namespace {
 using namespace Media::Streaming;
 
 constexpr auto kPartSize = Loader::kPartSize;
+constexpr auto kRequestPartsCount = 8;
 
 } // namespace
 
@@ -59,12 +60,10 @@ StreamedFileDownloader::StreamedFileDownloader(
 			savePart(std::move(part));
 		}
 	}, _lifetime);
-
-	_queue = _downloader->queueForDc(dcId);
 }
 
 StreamedFileDownloader::~StreamedFileDownloader() {
-	stop();
+	cancelHook();
 }
 
 uint64 StreamedFileDownloader::objId() const {
@@ -75,8 +74,29 @@ Data::FileOrigin StreamedFileDownloader::fileOrigin() const {
 	return _origin;
 }
 
-void StreamedFileDownloader::stop() {
-	cancelRequests();
+void StreamedFileDownloader::requestParts() {
+	while (!_finished
+		&& _nextPartIndex < _partsCount
+		&& _partsRequested < kRequestPartsCount) {
+		requestPart();
+	}
+}
+
+void StreamedFileDownloader::requestPart() {
+	Expects(!_finished);
+
+	const auto index = std::find(
+		begin(_partIsSaved) + _nextPartIndex,
+		end(_partIsSaved),
+		false
+	) - begin(_partIsSaved);
+	if (index == _partsCount) {
+		_nextPartIndex = _partsCount;
+		return;
+	}
+	_nextPartIndex = index + 1;
+	_reader->loadForDownloader(this, index * kPartSize);
+	++_partsRequested;
 }
 
 QByteArray StreamedFileDownloader::readLoadedPart(int offset) {
@@ -97,38 +117,15 @@ std::optional<MediaKey> StreamedFileDownloader::fileLocationKey() const {
 	return _fileLocationKey;
 }
 
-void StreamedFileDownloader::cancelRequests() {
-	//_partsRequested == std::count(
-	//	begin(_partIsSaved),
-	//	begin(_partIsSaved) + _nextPartIndex,
-	//	false);
-	_queue->queriesCount -= _partsRequested;
+void StreamedFileDownloader::cancelHook() {
 	_partsRequested = 0;
 	_nextPartIndex = 0;
 
 	_reader->cancelForDownloader(this);
 }
 
-bool StreamedFileDownloader::loadPart() {
-	if (_finished || _nextPartIndex >= _partsCount) {
-		return false;
-	}
-	const auto index = std::find(
-		begin(_partIsSaved) + _nextPartIndex,
-		end(_partIsSaved),
-		false
-	) - begin(_partIsSaved);
-	if (index == _partsCount) {
-		_nextPartIndex = _partsCount;
-		return false;
-	}
-	_nextPartIndex = index + 1;
-	_reader->loadForDownloader(this, index * kPartSize);
-
-	++_partsRequested;
-	++_queue->queriesCount;
-
-	return true;
+void StreamedFileDownloader::startLoading() {
+	requestParts();
 }
 
 void StreamedFileDownloader::savePart(const LoadedPart &part) {
@@ -150,7 +147,6 @@ void StreamedFileDownloader::savePart(const LoadedPart &part) {
 
 	if (index < _nextPartIndex) {
 		--_partsRequested;
-		--_queue->queriesCount;
 	}
 	if (!writeResultPart(offset, bytes::make_span(part.bytes))) {
 		return;
@@ -161,6 +157,7 @@ void StreamedFileDownloader::savePart(const LoadedPart &part) {
 		}
 	}
 	_reader->doneForDownloader(offset);
+	requestParts();
 	notifyAboutProgress();
 }
 
diff --git a/Telegram/SourceFiles/storage/streamed_file_downloader.h b/Telegram/SourceFiles/storage/streamed_file_downloader.h
index a223b7f5f..1fbef7a33 100644
--- a/Telegram/SourceFiles/storage/streamed_file_downloader.h
+++ b/Telegram/SourceFiles/storage/streamed_file_downloader.h
@@ -9,6 +9,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 
 #include "storage/file_download.h"
 #include "storage/cache/storage_cache_types.h"
+#include "data/data_file_origin.h"
 
 namespace Media {
 namespace Streaming {
@@ -41,15 +42,16 @@ public:
 
 	uint64 objId() const override;
 	Data::FileOrigin fileOrigin() const override;
-	void stop() override;
 
 	QByteArray readLoadedPart(int offset);
 
 private:
+	void startLoading() override;
 	Cache::Key cacheKey() const override;
 	std::optional<MediaKey> fileLocationKey() const override;
-	void cancelRequests() override;
-	bool loadPart() override;
+	void cancelHook() override;
+	void requestParts();
+	void requestPart();
 
 	void savePart(const Media::Streaming::LoadedPart &part);
 
@@ -60,7 +62,7 @@ private:
 	std::shared_ptr<Media::Streaming::Reader> _reader;
 
 	std::vector<bool> _partIsSaved; // vector<bool> :D
-	int _nextPartIndex = 0;
+	mutable int _nextPartIndex = 0;
 	int _partsCount = 0;
 	int _partsRequested = 0;
 	int _partsSaved = 0;
diff --git a/Telegram/SourceFiles/support/support_helper.cpp b/Telegram/SourceFiles/support/support_helper.cpp
index 56e2d717d..00d3cf6dc 100644
--- a/Telegram/SourceFiles/support/support_helper.cpp
+++ b/Telegram/SourceFiles/support/support_helper.cpp
@@ -288,10 +288,11 @@ TimeId OccupiedBySomeoneTill(History *history) {
 
 Helper::Helper(not_null<Main::Session*> session)
 : _session(session)
+, _api(_session->api().instance())
 , _templates(_session)
 , _reoccupyTimer([=] { reoccupy(); })
 , _checkOccupiedTimer([=] { checkOccupiedChats(); }) {
-	request(MTPhelp_GetSupportName(
+	_api.request(MTPhelp_GetSupportName(
 	)).done([=](const MTPhelp_SupportName &result) {
 		result.match([&](const MTPDhelp_supportName &data) {
 			setSupportName(qs(data.vname()));
@@ -422,7 +423,7 @@ bool Helper::isOccupiedBySomeone(History *history) const {
 }
 
 void Helper::refreshInfo(not_null<UserData*> user) {
-	request(MTPhelp_GetUserInfo(
+	_api.request(MTPhelp_GetUserInfo(
 		user->inputUser
 	)).done([=](const MTPhelp_UserInfo &result) {
 		applyInfo(user, result);
@@ -531,7 +532,7 @@ void Helper::saveInfo(
 			return;
 		} else {
 			i->second.data = text;
-			request(base::take(i->second.requestId)).cancel();
+			_api.request(base::take(i->second.requestId)).cancel();
 		}
 	} else {
 		_userInfoSaving.emplace(user, SavingInfo{ text });
@@ -545,7 +546,7 @@ void Helper::saveInfo(
 	const auto entities = Api::EntitiesToMTP(
 		text.entities,
 		Api::ConvertOption::SkipLocal);
-	_userInfoSaving[user].requestId = request(MTPhelp_EditUserInfo(
+	_userInfoSaving[user].requestId = _api.request(MTPhelp_EditUserInfo(
 		user->inputUser,
 		MTP_string(text.text),
 		entities
diff --git a/Telegram/SourceFiles/support/support_helper.h b/Telegram/SourceFiles/support/support_helper.h
index e3cde4971..46cf1b468 100644
--- a/Telegram/SourceFiles/support/support_helper.h
+++ b/Telegram/SourceFiles/support/support_helper.h
@@ -39,7 +39,7 @@ inline bool operator!=(const UserInfo &a, const UserInfo &b) {
 	return !(a == b);
 }
 
-class Helper : private MTP::Sender {
+class Helper final {
 public:
 	explicit Helper(not_null<Main::Session*> session);
 
@@ -87,6 +87,7 @@ private:
 		Fn<void(bool success)> done);
 
 	not_null<Main::Session*> _session;
+	MTP::Sender _api;
 	Templates _templates;
 	QString _supportName;
 	QString _supportNameNormalized;
diff --git a/Telegram/SourceFiles/ui/image/image.cpp b/Telegram/SourceFiles/ui/image/image.cpp
index 559e0e9b5..157f8e016 100644
--- a/Telegram/SourceFiles/ui/image/image.cpp
+++ b/Telegram/SourceFiles/ui/image/image.cpp
@@ -848,7 +848,7 @@ QPixmap Image::pixNoCache(
 		outerh *= cIntRetinaFactor();
 
 		QImage result(outerw, outerh, QImage::Format_ARGB32_Premultiplied);
-		result.setDevicePixelRatio(cRetinaFactor());
+		result.setDevicePixelRatio(style::DevicePixelRatio());
 
 		{
 			QPainter p(&result);
diff --git a/Telegram/SourceFiles/ui/image/image_location.cpp b/Telegram/SourceFiles/ui/image/image_location.cpp
index 573e4678f..ccd7ac2bb 100644
--- a/Telegram/SourceFiles/ui/image/image_location.cpp
+++ b/Telegram/SourceFiles/ui/image/image_location.cpp
@@ -116,6 +116,12 @@ StorageFileLocation::StorageFileLocation(
 		_sizeLetter = data.vthumb_size().v.isEmpty()
 			? char(0)
 			: data.vthumb_size().v[0];
+	}, [&](const MTPDinputPhotoLegacyFileLocation &data) {
+		_type = Type::Legacy;
+		_volumeId = data.vvolume_id().v;
+		_localId = data.vlocal_id().v;
+		_accessHash = data.vsecret().v;
+		_fileReference = data.vfile_reference().v;
 	}, [&](const MTPDinputPeerPhotoFileLocation &data) {
 		_type = Type::PeerPhoto;
 		const auto fillPeer = base::overload([&](
diff --git a/Telegram/SourceFiles/ui/image/image_source.cpp b/Telegram/SourceFiles/ui/image/image_source.cpp
index f8246ec05..c55c962a1 100644
--- a/Telegram/SourceFiles/ui/image/image_source.cpp
+++ b/Telegram/SourceFiles/ui/image/image_source.cpp
@@ -7,10 +7,11 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 */
 #include "ui/image/image_source.h"
 
-#include "storage/file_download.h"
+#include "storage/cache/storage_cache_database.h"
+#include "storage/file_download_mtproto.h"
+#include "storage/file_download_web.h"
 #include "data/data_session.h"
 #include "data/data_file_origin.h"
-#include "storage/cache/storage_cache_database.h"
 #include "history/history_item.h"
 #include "history/history.h"
 #include "main/main_session.h"
@@ -305,7 +306,6 @@ void RemoteSource::destroyLoader() {
 	if (cancelled()) {
 		loader->cancel();
 	}
-	loader->stop();
 }
 
 void RemoteSource::loadLocal() {
diff --git a/Telegram/SourceFiles/ui/special_buttons.cpp b/Telegram/SourceFiles/ui/special_buttons.cpp
index 7a7737433..1b6e84b17 100644
--- a/Telegram/SourceFiles/ui/special_buttons.cpp
+++ b/Telegram/SourceFiles/ui/special_buttons.cpp
@@ -1118,7 +1118,7 @@ QPoint SilentToggle::tooltipPos() const {
 }
 
 bool SilentToggle::tooltipWindowActive() const {
-	return InFocusChain(window());
+	return Ui::AppInFocus() && InFocusChain(window());
 }
 
 } // namespace Ui
diff --git a/Telegram/SourceFiles/ui/special_buttons.h b/Telegram/SourceFiles/ui/special_buttons.h
index 47ac205fc..f69476787 100644
--- a/Telegram/SourceFiles/ui/special_buttons.h
+++ b/Telegram/SourceFiles/ui/special_buttons.h
@@ -266,7 +266,9 @@ private:
 //
 //};
 
-class SilentToggle : public Ui::IconButton, public Ui::AbstractTooltipShower {
+class SilentToggle
+	: public Ui::IconButton
+	, public Ui::AbstractTooltipShower {
 public:
 	SilentToggle(QWidget *parent, not_null<ChannelData*> channel);
 
diff --git a/Telegram/SourceFiles/ui/widgets/discrete_sliders.cpp b/Telegram/SourceFiles/ui/widgets/discrete_sliders.cpp
index f8c4f3bb5..e4cb7cdb9 100644
--- a/Telegram/SourceFiles/ui/widgets/discrete_sliders.cpp
+++ b/Telegram/SourceFiles/ui/widgets/discrete_sliders.cpp
@@ -54,7 +54,7 @@ void DiscreteSlider::setSelectOnPress(bool selectOnPress) {
 }
 
 void DiscreteSlider::addSection(const QString &label) {
-	_sections.push_back(Section(label, getLabelFont()));
+	_sections.push_back(Section(label, getLabelStyle()));
 	resizeToWidth(width());
 }
 
@@ -63,7 +63,7 @@ void DiscreteSlider::setSections(const QStringList &labels) {
 
 	_sections.clear();
 	for (const auto &label : labels) {
-		_sections.push_back(Section(label, getLabelFont()));
+		_sections.push_back(Section(label, getLabelStyle()));
 	}
 	stopAnimation();
 	if (_activeIndex >= _sections.size()) {
@@ -152,12 +152,16 @@ int DiscreteSlider::getIndexFromPosition(QPoint pos) {
 	return count - 1;
 }
 
-DiscreteSlider::Section::Section(const QString &label, const style::font &font)
-: label(label)
-, labelWidth(font->width(label)) {
+DiscreteSlider::Section::Section(
+	const QString &label,
+	const style::TextStyle &st)
+: label(st, label) {
 }
 
-SettingsSlider::SettingsSlider(QWidget *parent, const style::SettingsSlider &st) : DiscreteSlider(parent)
+SettingsSlider::SettingsSlider(
+	QWidget *parent,
+		const style::SettingsSlider &st)
+: DiscreteSlider(parent)
 , _st(st) {
 	setSelectOnPress(_st.ripple.showDuration == 0);
 }
@@ -166,8 +170,8 @@ void SettingsSlider::setRippleTopRoundRadius(int radius) {
 	_rippleTopRoundRadius = radius;
 }
 
-const style::font &SettingsSlider::getLabelFont() const {
-	return _st.labelFont;
+const style::TextStyle &SettingsSlider::getLabelStyle() const {
+	return _st.labelStyle;
 }
 
 int SettingsSlider::getAnimationDuration() const {
@@ -206,8 +210,8 @@ std::vector<float64> SettingsSlider::countSectionsWidths(
 	auto labelsWidth = 0;
 	auto commonWidth = true;
 	enumerateSections([&](const Section &section) {
-		labelsWidth += section.labelWidth;
-		if (section.labelWidth >= sectionWidth) {
+		labelsWidth += section.label.maxWidth();
+		if (section.label.maxWidth() >= sectionWidth) {
 			commonWidth = false;
 		}
 		return true;
@@ -219,7 +223,7 @@ std::vector<float64> SettingsSlider::countSectionsWidths(
 		enumerateSections([&](const Section &section) {
 			Expects(currentWidth != result.end());
 
-			*currentWidth = padding + section.labelWidth + padding;
+			*currentWidth = padding + section.label.maxWidth() + padding;
 			++currentWidth;
 			return true;
 		});
@@ -275,7 +279,6 @@ void SettingsSlider::paintEvent(QPaintEvent *e) {
 	auto clip = e->rect();
 	auto activeLeft = getCurrentActiveLeft();
 
-	p.setFont(_st.labelFont);
 	enumerateSections([&](Section &section) {
 		auto active = 1. - snap(qAbs(activeLeft - section.left) / float64(section.width), 0., 1.);
 		if (section.ripple) {
@@ -302,9 +305,14 @@ void SettingsSlider::paintEvent(QPaintEvent *e) {
 		if (tofill) {
 			p.fillRect(myrtlrect(from, _st.barTop, tofill, _st.barStroke), _st.barFg);
 		}
-		if (myrtlrect(section.left, _st.labelTop, section.width, _st.labelFont->height).intersects(clip)) {
+		if (myrtlrect(section.left, _st.labelTop, section.width, _st.labelStyle.font->height).intersects(clip)) {
 			p.setPen(anim::pen(_st.labelFg, _st.labelFgActive, active));
-			p.drawTextLeft(section.left + (section.width - section.labelWidth) / 2, _st.labelTop, width(), section.label, section.labelWidth);
+			section.label.drawLeft(
+				p,
+				section.left + (section.width - section.label.maxWidth()) / 2,
+				_st.labelTop,
+				section.label.maxWidth(),
+				width());
 		}
 		return true;
 	});
diff --git a/Telegram/SourceFiles/ui/widgets/discrete_sliders.h b/Telegram/SourceFiles/ui/widgets/discrete_sliders.h
index a09c550b0..3947cab84 100644
--- a/Telegram/SourceFiles/ui/widgets/discrete_sliders.h
+++ b/Telegram/SourceFiles/ui/widgets/discrete_sliders.h
@@ -41,11 +41,11 @@ protected:
 	int resizeGetHeight(int newWidth) override = 0;
 
 	struct Section {
-		Section(const QString &label, const style::font &font);
+		Section(const QString &label, const style::TextStyle &st);
 
-		int left, width;
-		QString label;
-		int labelWidth;
+		int left = 0;
+		int width = 0;
+		Ui::Text::String label;
 		std::unique_ptr<RippleAnimation> ripple;
 	};
 
@@ -72,7 +72,7 @@ protected:
 
 private:
 	void activateCallback();
-	virtual const style::font &getLabelFont() const = 0;
+	virtual const style::TextStyle &getLabelStyle() const = 0;
 	virtual int getAnimationDuration() const = 0;
 
 	int getIndexFromPosition(QPoint pos);
@@ -107,7 +107,7 @@ protected:
 	void startRipple(int sectionIndex) override;
 
 private:
-	const style::font &getLabelFont() const override;
+	const style::TextStyle &getLabelStyle() const override;
 	int getAnimationDuration() const override;
 	QImage prepareRippleMask(int sectionIndex, const Section &section);
 
diff --git a/Telegram/SourceFiles/window/notifications_manager_default.cpp b/Telegram/SourceFiles/window/notifications_manager_default.cpp
index 6f53846e7..0d19e5ac7 100644
--- a/Telegram/SourceFiles/window/notifications_manager_default.cpp
+++ b/Telegram/SourceFiles/window/notifications_manager_default.cpp
@@ -65,7 +65,7 @@ std::unique_ptr<Manager> Create(System *system) {
 Manager::Manager(System *system)
 : Notifications::Manager(system)
 , _inputCheckTimer([=] { checkLastInput(); }) {
-	subscribe(system->session().downloader().taskFinished(), [this] {
+	subscribe(system->session().downloaderTaskFinished(), [this] {
 		for (const auto &notification : _notifications) {
 			notification->updatePeerPhoto();
 		}
diff --git a/Telegram/SourceFiles/window/themes/window_theme.cpp b/Telegram/SourceFiles/window/themes/window_theme.cpp
index 11409f74e..584bf8a9f 100644
--- a/Telegram/SourceFiles/window/themes/window_theme.cpp
+++ b/Telegram/SourceFiles/window/themes/window_theme.cpp
@@ -593,6 +593,9 @@ void ChatBackground::checkUploadWallPaper() {
 				_session->data().documentConvert(
 					_session->data().document(documentId),
 					data.vdocument());
+			}, [&](const MTPDwallPaperNoFile &data) {
+				LOG(("API Error: "
+					"Got wallPaperNoFile after account.UploadWallPaper."));
 			});
 			if (const auto paper = Data::WallPaper::Create(result)) {
 				setPaper(*paper);
diff --git a/Telegram/SourceFiles/window/themes/window_theme_editor_box.cpp b/Telegram/SourceFiles/window/themes/window_theme_editor_box.cpp
index 948e58796..1a550b8f8 100644
--- a/Telegram/SourceFiles/window/themes/window_theme_editor_box.cpp
+++ b/Telegram/SourceFiles/window/themes/window_theme_editor_box.cpp
@@ -534,9 +534,11 @@ Fn<void()> SavePreparedTheme(
 	const auto createTheme = [=](const MTPDocument &data) {
 		const auto document = session->data().processDocument(data);
 		state->requestId = api->request(MTPaccount_CreateTheme(
+			MTP_flags(MTPaccount_CreateTheme::Flag::f_document),
 			MTP_string(fields.slug),
 			MTP_string(fields.title),
-			document->mtpInput()
+			document->mtpInput(),
+			MTPInputThemeSettings()
 		)).done([=](const MTPTheme &result) {
 			finish(result);
 		}).fail([=](const RPCError &error) {
@@ -558,7 +560,8 @@ Fn<void()> SavePreparedTheme(
 			MTP_inputTheme(MTP_long(fields.id), MTP_long(fields.accessHash)),
 			MTP_string(fields.slug),
 			MTP_string(fields.title),
-			document->mtpInput()
+			document->mtpInput(),
+			MTPInputThemeSettings()
 		)).done([=](const MTPTheme &result) {
 			finish(result);
 		}).fail([=](const RPCError &error) {
@@ -618,9 +621,11 @@ Fn<void()> SavePreparedTheme(
 
 	const auto checkFields = [=] {
 		state->requestId = api->request(MTPaccount_CreateTheme(
+			MTP_flags(MTPaccount_CreateTheme::Flag::f_document),
 			MTP_string(fields.slug),
 			MTP_string(fields.title),
-			MTP_inputDocumentEmpty()
+			MTP_inputDocumentEmpty(),
+			MTPInputThemeSettings()
 		)).done([=](const MTPTheme &result) {
 			save();
 		}).fail([=](const RPCError &error) {
diff --git a/Telegram/SourceFiles/window/themes/window_themes_cloud_list.cpp b/Telegram/SourceFiles/window/themes/window_themes_cloud_list.cpp
index fb33bb12b..c63be6ba5 100644
--- a/Telegram/SourceFiles/window/themes/window_themes_cloud_list.cpp
+++ b/Telegram/SourceFiles/window/themes/window_themes_cloud_list.cpp
@@ -211,6 +211,7 @@ void CloudListCheck::validateBackgroundCache(int width) {
 			imageWidth,
 			_backgroundFull.height());
 	Images::prepareRound(_backgroundCache, ImageRoundRadius::Large);
+	_backgroundCache.setDevicePixelRatio(cRetinaFactor());
 }
 
 void CloudListCheck::paint(Painter &p, int left, int top, int outerWidth) {
diff --git a/Telegram/SourceFiles/window/window.style b/Telegram/SourceFiles/window/window.style
index a880acb20..a76108bab 100644
--- a/Telegram/SourceFiles/window/window.style
+++ b/Telegram/SourceFiles/window/window.style
@@ -10,14 +10,14 @@ using "ui/widgets/widgets.style";
 using "history/history.style";
 using "boxes/boxes.style"; // UserpicButton
 
-windowMinWidth: 380px;
+windowMinWidth: 360px;
 windowMinHeight: 480px;
 windowDefaultWidth: 800px;
 windowDefaultHeight: 600px;
 
 columnMinimalWidthLeft: 260px;
 columnMaximalWidthLeft: 540px;
-columnMinimalWidthMain: 380px;
+columnMinimalWidthMain: 360px;
 columnDesiredWidthMain: 512px;
 columnMinimalWidthThird: 292px;
 columnMaximalWidthThird: 392px;
diff --git a/Telegram/SourceFiles/window/window_connecting_widget.cpp b/Telegram/SourceFiles/window/window_connecting_widget.cpp
index 718b17ba5..622c5e6b2 100644
--- a/Telegram/SourceFiles/window/window_connecting_widget.cpp
+++ b/Telegram/SourceFiles/window/window_connecting_widget.cpp
@@ -10,6 +10,7 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include "ui/widgets/buttons.h"
 #include "ui/effects/radial_animation.h"
 #include "ui/ui_utility.h"
+#include "mtproto/facade.h"
 #include "window/themes/window_theme.h"
 #include "boxes/connection_box.h"
 #include "boxes/abstract_box.h"
@@ -270,7 +271,7 @@ void ConnectionState::refreshState() {
 		const auto under = _widget && _widget->isOver();
 		const auto mtp = MTP::dcstate();
 		const auto throughProxy
-			= (Global::ProxySettings() == ProxyData::Settings::Enabled);
+			= (Global::ProxySettings() == MTP::ProxyData::Settings::Enabled);
 		if (mtp == MTP::ConnectingState
 			|| mtp == MTP::DisconnectedState
 			|| (mtp < 0 && mtp > -600)) {
diff --git a/Telegram/SourceFiles/window/window_outdated_bar.cpp b/Telegram/SourceFiles/window/window_outdated_bar.cpp
index 2d6bea832..5d9c7e617 100644
--- a/Telegram/SourceFiles/window/window_outdated_bar.cpp
+++ b/Telegram/SourceFiles/window/window_outdated_bar.cpp
@@ -162,7 +162,7 @@ object_ptr<Ui::RpWidget> CreateOutdatedBar(not_null<QWidget*> parent) {
 		Closed();
 	}, wrap->lifetime());
 
-	return std::move(result);
+	return result;
 }
 
 } // namespace Window
Submodule Telegram/ThirdParty/QR 000000000...67c62461d (new submodule)
diff --git a/Telegram/ThirdParty/QR/Readme.markdown b/Telegram/ThirdParty/QR/Readme.markdown
new file mode 100644
index 0000000..c220958
--- /dev/null
+++ b/Telegram/ThirdParty/QR/Readme.markdown
@@ -0,0 +1,197 @@
+QR Code generator library
+=========================
+
+
+Introduction
+------------
+
+This project aims to be the best, clearest QR Code generator library in multiple languages. The primary goals are flexible options and absolute correctness. Secondary goals are compact implementation size and good documentation comments.
+
+Home page with live JavaScript demo, extensive descriptions, and competitor comparisons: [https://www.nayuki.io/page/qr-code-generator-library](https://www.nayuki.io/page/qr-code-generator-library)
+
+
+Features
+--------
+
+Core features:
+
+* Available in 6 programming languages, all with nearly equal functionality: Java, TypeScript/JavaScript, Python, Rust, C++, C
+* Significantly shorter code but more documentation comments compared to competing libraries
+* Supports encoding all 40 versions (sizes) and all 4 error correction levels, as per the QR Code Model 2 standard
+* Output formats: Raw modules/pixels of the QR symbol (all languages), SVG XML string (all languages except C), `BufferedImage` raster bitmap (Java only), HTML5 canvas (TypeScript/JavaScript only)
+* Detects finder-like penalty patterns more accurately than other implementations
+* Encodes numeric and special-alphanumeric text in less space than general text
+* Open source code under the permissive MIT License
+
+Manual parameters:
+
+* User can specify minimum and maximum version numbers allowed, then library will automatically choose smallest version in the range that fits the data
+* User can specify mask pattern manually, otherwise library will automatically evaluate all 8 masks and select the optimal one
+* User can specify absolute error correction level, or allow the library to boost it if it doesn't increase the version number
+* User can create a list of data segments manually and add ECI segments
+
+Optional advanced features (Java only):
+
+* Encodes Japanese Unicode text in kanji mode to save a lot of space compared to UTF-8 bytes
+* Computes optimal segment mode switching for text with mixed numeric/alphanumeric/general/kanji parts
+
+More information about QR Code technology and this library's design can be found on the project home page.
+
+
+Examples
+--------
+
+Java language:
+
+    import java.awt.image.BufferedImage;
+    import java.io.File;
+    import java.util.List;
+    import javax.imageio.ImageIO;
+    import io.nayuki.qrcodegen.*;
+    
+    // Simple operation
+    QrCode qr0 = QrCode.encodeText("Hello, world!", QrCode.Ecc.MEDIUM);
+    BufferedImage img = qr0.toImage(4, 10);
+    ImageIO.write(img, "png", new File("qr-code.png"));
+    
+    // Manual operation
+    List<QrSegment> segs = QrSegment.makeSegments("3141592653589793238462643383");
+    QrCode qr1 = QrCode.encodeSegments(segs, QrCode.Ecc.HIGH, 5, 5, 2, false);
+    for (int y = 0; y < qr1.size; y++) {
+        for (int x = 0; x < qr1.size; x++) {
+            (... paint qr1.getModule(x, y) ...)
+        }
+    }
+
+TypeScript/JavaScript languages:
+
+    // Name abbreviated for the sake of these examples here
+    var QRC = qrcodegen.QrCode;
+    
+    // Simple operation
+    var qr0 = QRC.encodeText("Hello, world!", QRC.Ecc.MEDIUM);
+    var svg = qr0.toSvgString(4);
+    
+    // Manual operation
+    var segs = qrcodegen.QrSegment.makeSegments("3141592653589793238462643383");
+    var qr1 = QRC.encodeSegments(segs, QRC.Ecc.HIGH, 5, 5, 2, false);
+    for (var y = 0; y < qr1.size; y++) {
+        for (var x = 0; x < qr1.size; x++) {
+            (... paint qr1.getModule(x, y) ...)
+        }
+    }
+
+Python language:
+
+    from qrcodegen import *
+    
+    # Simple operation
+    qr0 = QrCode.encode_text("Hello, world!", QrCode.Ecc.MEDIUM)
+    svg = qr0.to_svg_str(4)
+    
+    # Manual operation
+    segs = QrSegment.make_segments("3141592653589793238462643383")
+    qr1 = QrCode.encode_segments(segs, QrCode.Ecc.HIGH, 5, 5, 2, False)
+    for y in range(qr1.get_size()):
+        for x in range(qr1.get_size()):
+            (... paint qr1.get_module(x, y) ...)
+
+C++ language:
+
+    #include <string>
+    #include <vector>
+    #include "QrCode.hpp"
+    using namespace qrcodegen;
+    
+    // Simple operation
+    QrCode qr0 = QrCode::encodeText("Hello, world!", QrCode::Ecc::MEDIUM);
+    std::string svg = qr0.toSvgString(4);
+    
+    // Manual operation
+    std::vector<QrSegment> segs =
+        QrSegment::makeSegments("3141592653589793238462643383");
+    QrCode qr1 = QrCode::encodeSegments(
+        segs, QrCode::Ecc::HIGH, 5, 5, 2, false);
+    for (int y = 0; y < qr1.getSize(); y++) {
+        for (int x = 0; x < qr1.getSize(); x++) {
+            (... paint qr1.getModule(x, y) ...)
+        }
+    }
+
+C language:
+
+    #include <stdbool.h>
+    #include <stdint.h>
+    #include "qrcodegen.h"
+    
+    // Text data
+    uint8_t qr0[qrcodegen_BUFFER_LEN_MAX];
+    uint8_t tempBuffer[qrcodegen_BUFFER_LEN_MAX];
+    bool ok = qrcodegen_encodeText("Hello, world!",
+        tempBuffer, qr0, qrcodegen_Ecc_MEDIUM,
+        qrcodegen_VERSION_MIN, qrcodegen_VERSION_MAX,
+        qrcodegen_Mask_AUTO, true);
+    if (!ok)
+        return;
+    
+    int size = qrcodegen_getSize(qr0);
+    for (int y = 0; y < size; y++) {
+        for (int x = 0; x < size; x++) {
+            (... paint qrcodegen_getModule(qr0, x, y) ...)
+        }
+    }
+    
+    // Binary data
+    uint8_t dataAndTemp[qrcodegen_BUFFER_LEN_FOR_VERSION(7)]
+        = {0xE3, 0x81, 0x82};
+    uint8_t qr1[qrcodegen_BUFFER_LEN_FOR_VERSION(7)];
+    ok = qrcodegen_encodeBinary(dataAndTemp, 3, qr1,
+        qrcodegen_Ecc_HIGH, 2, 7, qrcodegen_Mask_4, false);
+
+Rust language:
+
+    extern crate qrcodegen;
+    use qrcodegen::QrCode;
+    use qrcodegen::QrCodeEcc;
+    use qrcodegen::QrSegment;
+    
+    // Simple operation
+    let qr = QrCode::encode_text("Hello, world!",
+        QrCodeEcc::Medium).unwrap();
+    let svg = qr.to_svg_string(4);
+    
+    // Manual operation
+    let chrs: Vec<char> = "3141592653589793238462643383".chars().collect();
+    let segs = QrSegment::make_segments(&chrs);
+    let qr = QrCode::encode_segments_advanced(
+        &segs, QrCodeEcc::High, 5, 5, Some(Mask::new(2)), false).unwrap();
+    for y in 0 .. qr.size() {
+        for x in 0 .. qr.size() {
+            (... paint qr.get_module(x, y) ...)
+        }
+    }
+
+
+License
+-------
+
+Copyright © 2019 Project Nayuki. (MIT License)  
+[https://www.nayuki.io/page/qr-code-generator-library](https://www.nayuki.io/page/qr-code-generator-library)
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of
+this software and associated documentation files (the "Software"), to deal in
+the Software without restriction, including without limitation the rights to
+use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+the Software, and to permit persons to whom the Software is furnished to do so,
+subject to the following conditions:
+
+* The above copyright notice and this permission notice shall be included in
+  all copies or substantial portions of the Software.
+
+* The Software is provided "as is", without warranty of any kind, express or
+  implied, including but not limited to the warranties of merchantability,
+  fitness for a particular purpose and noninfringement. In no event shall the
+  authors or copyright holders be liable for any claim, damages or other
+  liability, whether in an action of contract, tort or otherwise, arising from,
+  out of or in connection with the Software or the use or other dealings in the
+  Software.
diff --git a/Telegram/ThirdParty/QR/c/Makefile b/Telegram/ThirdParty/QR/c/Makefile
new file mode 100644
index 0000000..fd0c367
--- /dev/null
+++ b/Telegram/ThirdParty/QR/c/Makefile
@@ -0,0 +1,88 @@
+# 
+# Makefile for QR Code generator (C)
+# 
+# Copyright (c) Project Nayuki. (MIT License)
+# https://www.nayuki.io/page/qr-code-generator-library
+# 
+# Permission is hereby granted, free of charge, to any person obtaining a copy of
+# this software and associated documentation files (the "Software"), to deal in
+# the Software without restriction, including without limitation the rights to
+# use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+# the Software, and to permit persons to whom the Software is furnished to do so,
+# subject to the following conditions:
+# - The above copyright notice and this permission notice shall be included in
+#   all copies or substantial portions of the Software.
+# - The Software is provided "as is", without warranty of any kind, express or
+#   implied, including but not limited to the warranties of merchantability,
+#   fitness for a particular purpose and noninfringement. In no event shall the
+#   authors or copyright holders be liable for any claim, damages or other
+#   liability, whether in an action of contract, tort or otherwise, arising from,
+#   out of or in connection with the Software or the use or other dealings in the
+#   Software.
+# 
+
+
+# ---- Configuration options ----
+
+# External/implicit variables:
+# - CC: The C compiler, such as gcc or clang.
+# - CFLAGS: Any extra user-specified compiler flags (can be blank).
+
+# Recommended compiler flags:
+CFLAGS += -std=c99 -O
+
+# Extra flags for diagnostics:
+# CFLAGS += -g -Wall -Wextra -Wpedantic -Wconversion -Wsign-conversion -fsanitize=undefined,address
+
+
+# ---- Controlling make ----
+
+# Clear default suffix rules
+.SUFFIXES:
+
+# Don't delete object files
+.SECONDARY:
+
+# Stuff concerning goals
+.DEFAULT_GOAL = all
+.PHONY: all clean
+
+
+# ---- Targets to build ----
+
+LIB = qrcodegen
+LIBFILE = lib$(LIB).a
+LIBOBJ = qrcodegen.o
+MAINS = qrcodegen-demo qrcodegen-test qrcodegen-worker
+
+# Build all binaries
+all: $(LIBFILE) $(MAINS)
+
+# Delete build output
+clean:
+	rm -f -- $(LIBOBJ) $(LIBFILE) $(MAINS:=.o) $(MAINS)
+	rm -rf .deps
+
+# Executable files
+%: %.o $(LIBFILE)
+	$(CC) $(CFLAGS) -o $@ $< -L . -l $(LIB)
+
+# Special executable
+qrcodegen-test: qrcodegen-test.c $(LIBOBJ:%.o=%.c)
+	$(CC) $(CFLAGS) -DQRCODEGEN_TEST -o $@ $^
+
+# The library
+$(LIBFILE): $(LIBOBJ)
+	$(AR) -crs $@ -- $^
+
+# Object files
+%.o: %.c .deps/timestamp
+	$(CC) $(CFLAGS) -c -o $@ -MMD -MF .deps/$*.d $<
+
+# Have a place to store header dependencies automatically generated by compiler
+.deps/timestamp:
+	mkdir -p .deps
+	touch .deps/timestamp
+
+# Make use of said dependencies if available
+-include .deps/*.d
diff --git a/Telegram/ThirdParty/QR/c/qrcodegen-demo.c b/Telegram/ThirdParty/QR/c/qrcodegen-demo.c
new file mode 100644
index 0000000..872f48b
--- /dev/null
+++ b/Telegram/ThirdParty/QR/c/qrcodegen-demo.c
@@ -0,0 +1,311 @@
+/* 
+ * QR Code generator demo (C)
+ * 
+ * Run this command-line program with no arguments. The program
+ * computes a demonstration QR Codes and print it to the console.
+ * 
+ * Copyright (c) Project Nayuki. (MIT License)
+ * https://www.nayuki.io/page/qr-code-generator-library
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ * - The above copyright notice and this permission notice shall be included in
+ *   all copies or substantial portions of the Software.
+ * - The Software is provided "as is", without warranty of any kind, express or
+ *   implied, including but not limited to the warranties of merchantability,
+ *   fitness for a particular purpose and noninfringement. In no event shall the
+ *   authors or copyright holders be liable for any claim, damages or other
+ *   liability, whether in an action of contract, tort or otherwise, arising from,
+ *   out of or in connection with the Software or the use or other dealings in the
+ *   Software.
+ */
+
+#include <stdbool.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "qrcodegen.h"
+
+
+// Function prototypes
+static void doBasicDemo(void);
+static void doVarietyDemo(void);
+static void doSegmentDemo(void);
+static void doMaskDemo(void);
+static void printQr(const uint8_t qrcode[]);
+
+
+// The main application program.
+int main(void) {
+	doBasicDemo();
+	doVarietyDemo();
+	doSegmentDemo();
+	doMaskDemo();
+	return EXIT_SUCCESS;
+}
+
+
+
+/*---- Demo suite ----*/
+
+// Creates a single QR Code, then prints it to the console.
+static void doBasicDemo(void) {
+	const char *text = "Hello, world!";                // User-supplied text
+	enum qrcodegen_Ecc errCorLvl = qrcodegen_Ecc_LOW;  // Error correction level
+	
+	// Make and print the QR Code symbol
+	uint8_t qrcode[qrcodegen_BUFFER_LEN_MAX];
+	uint8_t tempBuffer[qrcodegen_BUFFER_LEN_MAX];
+	bool ok = qrcodegen_encodeText(text, tempBuffer, qrcode, errCorLvl,
+		qrcodegen_VERSION_MIN, qrcodegen_VERSION_MAX, qrcodegen_Mask_AUTO, true);
+	if (ok)
+		printQr(qrcode);
+}
+
+
+// Creates a variety of QR Codes that exercise different features of the library, and prints each one to the console.
+static void doVarietyDemo(void) {
+	{  // Numeric mode encoding (3.33 bits per digit)
+		uint8_t qrcode[qrcodegen_BUFFER_LEN_MAX];
+		uint8_t tempBuffer[qrcodegen_BUFFER_LEN_MAX];
+		bool ok = qrcodegen_encodeText("314159265358979323846264338327950288419716939937510", tempBuffer, qrcode,
+			qrcodegen_Ecc_MEDIUM, qrcodegen_VERSION_MIN, qrcodegen_VERSION_MAX, qrcodegen_Mask_AUTO, true);
+		if (ok)
+			printQr(qrcode);
+	}
+	
+	{  // Alphanumeric mode encoding (5.5 bits per character)
+		uint8_t qrcode[qrcodegen_BUFFER_LEN_MAX];
+		uint8_t tempBuffer[qrcodegen_BUFFER_LEN_MAX];
+		bool ok = qrcodegen_encodeText("DOLLAR-AMOUNT:$39.87 PERCENTAGE:100.00% OPERATIONS:+-*/", tempBuffer, qrcode,
+			qrcodegen_Ecc_HIGH, qrcodegen_VERSION_MIN, qrcodegen_VERSION_MAX, qrcodegen_Mask_AUTO, true);
+		if (ok)
+			printQr(qrcode);
+	}
+	
+	{  // Unicode text as UTF-8
+		const char *text = "\xE3\x81\x93\xE3\x82\x93\xE3\x81\xAB\xE3\x81\xA1wa\xE3\x80\x81"
+			"\xE4\xB8\x96\xE7\x95\x8C\xEF\xBC\x81\x20\xCE\xB1\xCE\xB2\xCE\xB3\xCE\xB4";
+		uint8_t qrcode[qrcodegen_BUFFER_LEN_MAX];
+		uint8_t tempBuffer[qrcodegen_BUFFER_LEN_MAX];
+		bool ok = qrcodegen_encodeText(text, tempBuffer, qrcode,
+			qrcodegen_Ecc_QUARTILE, qrcodegen_VERSION_MIN, qrcodegen_VERSION_MAX, qrcodegen_Mask_AUTO, true);
+		if (ok)
+			printQr(qrcode);
+	}
+	
+	{  // Moderately large QR Code using longer text (from Lewis Carroll's Alice in Wonderland)
+		const char *text =
+			"Alice was beginning to get very tired of sitting by her sister on the bank, "
+			"and of having nothing to do: once or twice she had peeped into the book her sister was reading, "
+			"but it had no pictures or conversations in it, 'and what is the use of a book,' thought Alice "
+			"'without pictures or conversations?' So she was considering in her own mind (as well as she could, "
+			"for the hot day made her feel very sleepy and stupid), whether the pleasure of making a "
+			"daisy-chain would be worth the trouble of getting up and picking the daisies, when suddenly "
+			"a White Rabbit with pink eyes ran close by her.";
+		uint8_t qrcode[qrcodegen_BUFFER_LEN_MAX];
+		uint8_t tempBuffer[qrcodegen_BUFFER_LEN_MAX];
+		bool ok = qrcodegen_encodeText(text, tempBuffer, qrcode,
+			qrcodegen_Ecc_HIGH, qrcodegen_VERSION_MIN, qrcodegen_VERSION_MAX, qrcodegen_Mask_AUTO, true);
+		if (ok)
+			printQr(qrcode);
+	}
+}
+
+
+// Creates QR Codes with manually specified segments for better compactness.
+static void doSegmentDemo(void) {
+	{  // Illustration "silver"
+		const char *silver0 = "THE SQUARE ROOT OF 2 IS 1.";
+		const char *silver1 = "41421356237309504880168872420969807856967187537694807317667973799";
+		uint8_t qrcode[qrcodegen_BUFFER_LEN_MAX];
+		uint8_t tempBuffer[qrcodegen_BUFFER_LEN_MAX];
+		bool ok;
+		{
+			char *concat = calloc(strlen(silver0) + strlen(silver1) + 1, sizeof(char));
+			strcat(concat, silver0);
+			strcat(concat, silver1);
+			ok = qrcodegen_encodeText(concat, tempBuffer, qrcode, qrcodegen_Ecc_LOW,
+				qrcodegen_VERSION_MIN, qrcodegen_VERSION_MAX, qrcodegen_Mask_AUTO, true);
+			if (ok)
+				printQr(qrcode);
+			free(concat);
+		}
+		{
+			uint8_t *segBuf0 = malloc(qrcodegen_calcSegmentBufferSize(qrcodegen_Mode_ALPHANUMERIC, strlen(silver0)) * sizeof(uint8_t));
+			uint8_t *segBuf1 = malloc(qrcodegen_calcSegmentBufferSize(qrcodegen_Mode_NUMERIC, strlen(silver1)) * sizeof(uint8_t));
+			struct qrcodegen_Segment segs[] = {
+				qrcodegen_makeAlphanumeric(silver0, segBuf0),
+				qrcodegen_makeNumeric(silver1, segBuf1),
+			};
+			ok = qrcodegen_encodeSegments(segs, sizeof(segs) / sizeof(segs[0]), qrcodegen_Ecc_LOW, tempBuffer, qrcode);
+			free(segBuf0);
+			free(segBuf1);
+			if (ok)
+				printQr(qrcode);
+		}
+	}
+	
+	{  // Illustration "golden"
+		const char *golden0 = "Golden ratio \xCF\x86 = 1.";
+		const char *golden1 = "6180339887498948482045868343656381177203091798057628621354486227052604628189024497072072041893911374";
+		const char *golden2 = "......";
+		uint8_t qrcode[qrcodegen_BUFFER_LEN_MAX];
+		uint8_t tempBuffer[qrcodegen_BUFFER_LEN_MAX];
+		bool ok;
+		{
+			char *concat = calloc(strlen(golden0) + strlen(golden1) + strlen(golden2) + 1, sizeof(char));
+			strcat(concat, golden0);
+			strcat(concat, golden1);
+			strcat(concat, golden2);
+			ok = qrcodegen_encodeText(concat, tempBuffer, qrcode, qrcodegen_Ecc_LOW,
+				qrcodegen_VERSION_MIN, qrcodegen_VERSION_MAX, qrcodegen_Mask_AUTO, true);
+			if (ok)
+				printQr(qrcode);
+			free(concat);
+		}
+		{
+			uint8_t *bytes = malloc(strlen(golden0) * sizeof(uint8_t));
+			for (size_t i = 0, len = strlen(golden0); i < len; i++)
+				bytes[i] = (uint8_t)golden0[i];
+			uint8_t *segBuf0 = malloc(qrcodegen_calcSegmentBufferSize(qrcodegen_Mode_BYTE, strlen(golden0)) * sizeof(uint8_t));
+			uint8_t *segBuf1 = malloc(qrcodegen_calcSegmentBufferSize(qrcodegen_Mode_NUMERIC, strlen(golden1)) * sizeof(uint8_t));
+			uint8_t *segBuf2 = malloc(qrcodegen_calcSegmentBufferSize(qrcodegen_Mode_ALPHANUMERIC, strlen(golden2)) * sizeof(uint8_t));
+			struct qrcodegen_Segment segs[] = {
+				qrcodegen_makeBytes(bytes, strlen(golden0), segBuf0),
+				qrcodegen_makeNumeric(golden1, segBuf1),
+				qrcodegen_makeAlphanumeric(golden2, segBuf2),
+			};
+			free(bytes);
+			ok = qrcodegen_encodeSegments(segs, sizeof(segs) / sizeof(segs[0]), qrcodegen_Ecc_LOW, tempBuffer, qrcode);
+			free(segBuf0);
+			free(segBuf1);
+			free(segBuf2);
+			if (ok)
+				printQr(qrcode);
+		}
+	}
+	
+	{  // Illustration "Madoka": kanji, kana, Cyrillic, full-width Latin, Greek characters
+		uint8_t qrcode[qrcodegen_BUFFER_LEN_MAX];
+		uint8_t tempBuffer[qrcodegen_BUFFER_LEN_MAX];
+		bool ok;
+		{
+			const char *madoka =  // Encoded in UTF-8
+				"\xE3\x80\x8C\xE9\xAD\x94\xE6\xB3\x95\xE5"
+				"\xB0\x91\xE5\xA5\xB3\xE3\x81\xBE\xE3\x81"
+				"\xA9\xE3\x81\x8B\xE2\x98\x86\xE3\x83\x9E"
+				"\xE3\x82\xAE\xE3\x82\xAB\xE3\x80\x8D\xE3"
+				"\x81\xA3\xE3\x81\xA6\xE3\x80\x81\xE3\x80"
+				"\x80\xD0\x98\xD0\x90\xD0\x98\xE3\x80\x80"
+				"\xEF\xBD\x84\xEF\xBD\x85\xEF\xBD\x93\xEF"
+				"\xBD\x95\xE3\x80\x80\xCE\xBA\xCE\xB1\xEF"
+				"\xBC\x9F";
+			ok = qrcodegen_encodeText(madoka, tempBuffer, qrcode, qrcodegen_Ecc_LOW,
+				qrcodegen_VERSION_MIN, qrcodegen_VERSION_MAX, qrcodegen_Mask_AUTO, true);
+			if (ok)
+				printQr(qrcode);
+		}
+		{
+			const int kanjiChars[] = {  // Kanji mode encoding (13 bits per character)
+				0x0035, 0x1002, 0x0FC0, 0x0AED, 0x0AD7,
+				0x015C, 0x0147, 0x0129, 0x0059, 0x01BD,
+				0x018D, 0x018A, 0x0036, 0x0141, 0x0144,
+				0x0001, 0x0000, 0x0249, 0x0240, 0x0249,
+				0x0000, 0x0104, 0x0105, 0x0113, 0x0115,
+				0x0000, 0x0208, 0x01FF, 0x0008,
+			};
+			size_t len = sizeof(kanjiChars) / sizeof(kanjiChars[0]);
+			uint8_t *segBuf = calloc(qrcodegen_calcSegmentBufferSize(qrcodegen_Mode_KANJI, len), sizeof(uint8_t));
+			struct qrcodegen_Segment seg;
+			seg.mode = qrcodegen_Mode_KANJI;
+			seg.numChars = (int)len;
+			seg.bitLength = 0;
+			for (size_t i = 0; i < len; i++) {
+				for (int j = 12; j >= 0; j--, seg.bitLength++)
+					segBuf[seg.bitLength >> 3] |= ((kanjiChars[i] >> j) & 1) << (7 - (seg.bitLength & 7));
+			}
+			seg.data = segBuf;
+			ok = qrcodegen_encodeSegments(&seg, 1, qrcodegen_Ecc_LOW, tempBuffer, qrcode);
+			free(segBuf);
+			if (ok)
+				printQr(qrcode);
+		}
+	}
+}
+
+
+// Creates QR Codes with the same size and contents but different mask patterns.
+static void doMaskDemo(void) {
+	{  // Project Nayuki URL
+		uint8_t qrcode[qrcodegen_BUFFER_LEN_MAX];
+		uint8_t tempBuffer[qrcodegen_BUFFER_LEN_MAX];
+		bool ok;
+		
+		ok = qrcodegen_encodeText("https://www.nayuki.io/", tempBuffer, qrcode,
+			qrcodegen_Ecc_HIGH, qrcodegen_VERSION_MIN, qrcodegen_VERSION_MAX, qrcodegen_Mask_AUTO, true);
+		if (ok)
+			printQr(qrcode);
+		
+		ok = qrcodegen_encodeText("https://www.nayuki.io/", tempBuffer, qrcode,
+			qrcodegen_Ecc_HIGH, qrcodegen_VERSION_MIN, qrcodegen_VERSION_MAX, qrcodegen_Mask_3, true);
+		if (ok)
+			printQr(qrcode);
+	}
+	
+	{  // Chinese text as UTF-8
+		const char *text =
+			"\xE7\xB6\xAD\xE5\x9F\xBA\xE7\x99\xBE\xE7\xA7\x91\xEF\xBC\x88\x57\x69\x6B\x69\x70"
+			"\x65\x64\x69\x61\xEF\xBC\x8C\xE8\x81\x86\xE8\x81\xBD\x69\x2F\xCB\x8C\x77\xC9\xAA"
+			"\x6B\xE1\xB5\xBB\xCB\x88\x70\x69\xCB\x90\x64\x69\x2E\xC9\x99\x2F\xEF\xBC\x89\xE6"
+			"\x98\xAF\xE4\xB8\x80\xE5\x80\x8B\xE8\x87\xAA\xE7\x94\xB1\xE5\x85\xA7\xE5\xAE\xB9"
+			"\xE3\x80\x81\xE5\x85\xAC\xE9\x96\x8B\xE7\xB7\xA8\xE8\xBC\xAF\xE4\xB8\x94\xE5\xA4"
+			"\x9A\xE8\xAA\x9E\xE8\xA8\x80\xE7\x9A\x84\xE7\xB6\xB2\xE8\xB7\xAF\xE7\x99\xBE\xE7"
+			"\xA7\x91\xE5\x85\xA8\xE6\x9B\xB8\xE5\x8D\x94\xE4\xBD\x9C\xE8\xA8\x88\xE7\x95\xAB";
+		uint8_t qrcode[qrcodegen_BUFFER_LEN_MAX];
+		uint8_t tempBuffer[qrcodegen_BUFFER_LEN_MAX];
+		bool ok;
+		
+		ok = qrcodegen_encodeText(text, tempBuffer, qrcode,
+			qrcodegen_Ecc_MEDIUM, qrcodegen_VERSION_MIN, qrcodegen_VERSION_MAX, qrcodegen_Mask_0, true);
+		if (ok)
+			printQr(qrcode);
+		
+		ok = qrcodegen_encodeText(text, tempBuffer, qrcode,
+			qrcodegen_Ecc_MEDIUM, qrcodegen_VERSION_MIN, qrcodegen_VERSION_MAX, qrcodegen_Mask_1, true);
+		if (ok)
+			printQr(qrcode);
+		
+		ok = qrcodegen_encodeText(text, tempBuffer, qrcode,
+			qrcodegen_Ecc_MEDIUM, qrcodegen_VERSION_MIN, qrcodegen_VERSION_MAX, qrcodegen_Mask_5, true);
+		if (ok)
+			printQr(qrcode);
+		
+		ok = qrcodegen_encodeText(text, tempBuffer, qrcode,
+			qrcodegen_Ecc_MEDIUM, qrcodegen_VERSION_MIN, qrcodegen_VERSION_MAX, qrcodegen_Mask_7, true);
+		if (ok)
+			printQr(qrcode);
+	}
+}
+
+
+
+/*---- Utilities ----*/
+
+// Prints the given QR Code to the console.
+static void printQr(const uint8_t qrcode[]) {
+	int size = qrcodegen_getSize(qrcode);
+	int border = 4;
+	for (int y = -border; y < size + border; y++) {
+		for (int x = -border; x < size + border; x++) {
+			fputs((qrcodegen_getModule(qrcode, x, y) ? "##" : "  "), stdout);
+		}
+		fputs("\n", stdout);
+	}
+	fputs("\n", stdout);
+}
diff --git a/Telegram/ThirdParty/QR/c/qrcodegen-test.c b/Telegram/ThirdParty/QR/c/qrcodegen-test.c
new file mode 100644
index 0000000..37612d7
--- /dev/null
+++ b/Telegram/ThirdParty/QR/c/qrcodegen-test.c
@@ -0,0 +1,1075 @@
+/* 
+ * QR Code generator test suite (C)
+ * 
+ * When compiling this program, the library qrcodegen.c needs QRCODEGEN_TEST
+ * to be defined. Run this command line program with no arguments.
+ * 
+ * Copyright (c) Project Nayuki. (MIT License)
+ * https://www.nayuki.io/page/qr-code-generator-library
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ * - The above copyright notice and this permission notice shall be included in
+ *   all copies or substantial portions of the Software.
+ * - The Software is provided "as is", without warranty of any kind, express or
+ *   implied, including but not limited to the warranties of merchantability,
+ *   fitness for a particular purpose and noninfringement. In no event shall the
+ *   authors or copyright holders be liable for any claim, damages or other
+ *   liability, whether in an action of contract, tort or otherwise, arising from,
+ *   out of or in connection with the Software or the use or other dealings in the
+ *   Software.
+ */
+
+#include <assert.h>
+#include <limits.h>
+#include <stdbool.h>
+#include <stddef.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+#include "qrcodegen.h"
+
+#define ARRAY_LENGTH(name)  (sizeof(name) / sizeof(name[0]))
+
+
+// Global variables
+static int numTestCases = 0;
+
+
+// Prototypes of private functions under test
+extern const int8_t ECC_CODEWORDS_PER_BLOCK[4][41];
+extern const int8_t NUM_ERROR_CORRECTION_BLOCKS[4][41];
+void appendBitsToBuffer(unsigned int val, int numBits, uint8_t buffer[], int *bitLen);
+void addEccAndInterleave(uint8_t data[], int version, enum qrcodegen_Ecc ecl, uint8_t result[]);
+int getNumDataCodewords(int version, enum qrcodegen_Ecc ecl);
+int getNumRawDataModules(int version);
+void reedSolomonComputeDivisor(int degree, uint8_t result[]);
+void reedSolomonComputeRemainder(const uint8_t data[], int dataLen, const uint8_t generator[], int degree, uint8_t result[]);
+uint8_t reedSolomonMultiply(uint8_t x, uint8_t y);
+void initializeFunctionModules(int version, uint8_t qrcode[]);
+int getAlignmentPatternPositions(int version, uint8_t result[7]);
+bool getModule(const uint8_t qrcode[], int x, int y);
+void setModule(uint8_t qrcode[], int x, int y, bool isBlack);
+void setModuleBounded(uint8_t qrcode[], int x, int y, bool isBlack);
+int calcSegmentBitLength(enum qrcodegen_Mode mode, size_t numChars);
+int getTotalBits(const struct qrcodegen_Segment segs[], size_t len, int version);
+
+
+/*---- Test cases ----*/
+
+static void testAppendBitsToBuffer(void) {
+	{
+		uint8_t buf[1] = {0};
+		int bitLen = 0;
+		appendBitsToBuffer(0, 0, buf, &bitLen);
+		assert(bitLen == 0);
+		assert(buf[0] == 0);
+		appendBitsToBuffer(1, 1, buf, &bitLen);
+		assert(bitLen == 1);
+		assert(buf[0] == 0x80);
+		appendBitsToBuffer(0, 1, buf, &bitLen);
+		assert(bitLen == 2);
+		assert(buf[0] == 0x80);
+		appendBitsToBuffer(5, 3, buf, &bitLen);
+		assert(bitLen == 5);
+		assert(buf[0] == 0xA8);
+		appendBitsToBuffer(6, 3, buf, &bitLen);
+		assert(bitLen == 8);
+		assert(buf[0] == 0xAE);
+		numTestCases++;
+	}
+	{
+		uint8_t buf[6] = {0};
+		int bitLen = 0;
+		appendBitsToBuffer(16942, 16, buf, &bitLen);
+		assert(bitLen == 16);
+		assert(buf[0] == 0x42 && buf[1] == 0x2E && buf[2] == 0x00 && buf[3] == 0x00 && buf[4] == 0x00 && buf[5] == 0x00);
+		appendBitsToBuffer(10, 7, buf, &bitLen);
+		assert(bitLen == 23);
+		assert(buf[0] == 0x42 && buf[1] == 0x2E && buf[2] == 0x14 && buf[3] == 0x00 && buf[4] == 0x00 && buf[5] == 0x00);
+		appendBitsToBuffer(15, 4, buf, &bitLen);
+		assert(bitLen == 27);
+		assert(buf[0] == 0x42 && buf[1] == 0x2E && buf[2] == 0x15 && buf[3] == 0xE0 && buf[4] == 0x00 && buf[5] == 0x00);
+		appendBitsToBuffer(26664, 15, buf, &bitLen);
+		assert(bitLen == 42);
+		assert(buf[0] == 0x42 && buf[1] == 0x2E && buf[2] == 0x15 && buf[3] == 0xFA && buf[4] == 0x0A && buf[5] == 0x00);
+		numTestCases++;
+	}
+}
+
+
+// Ported from the Java version of the code.
+static uint8_t *addEccAndInterleaveReference(const uint8_t *data, int version, enum qrcodegen_Ecc ecl) {
+	// Calculate parameter numbers
+	size_t numBlocks = (size_t)NUM_ERROR_CORRECTION_BLOCKS[(int)ecl][version];
+	size_t blockEccLen = (size_t)ECC_CODEWORDS_PER_BLOCK[(int)ecl][version];
+	size_t rawCodewords = (size_t)getNumRawDataModules(version) / 8;
+	size_t numShortBlocks = numBlocks - rawCodewords % numBlocks;
+	size_t shortBlockLen = rawCodewords / numBlocks;
+	
+	// Split data into blocks and append ECC to each block
+	uint8_t **blocks = malloc(numBlocks * sizeof(uint8_t*));
+	uint8_t *generator = malloc(blockEccLen * sizeof(uint8_t));
+	reedSolomonComputeDivisor((int)blockEccLen, generator);
+	for (size_t i = 0, k = 0; i < numBlocks; i++) {
+		uint8_t *block = malloc((shortBlockLen + 1) * sizeof(uint8_t));
+		size_t datLen = shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1);
+		memcpy(block, &data[k], datLen * sizeof(uint8_t));
+		reedSolomonComputeRemainder(&data[k], (int)datLen, generator, (int)blockEccLen, &block[shortBlockLen + 1 - blockEccLen]);
+		k += datLen;
+		blocks[i] = block;
+	}
+	free(generator);
+	
+	// Interleave (not concatenate) the bytes from every block into a single sequence
+	uint8_t *result = malloc(rawCodewords * sizeof(uint8_t));
+	for (size_t i = 0, k = 0; i < shortBlockLen + 1; i++) {
+		for (size_t j = 0; j < numBlocks; j++) {
+			// Skip the padding byte in short blocks
+			if (i != shortBlockLen - blockEccLen || j >= numShortBlocks) {
+				result[k] = blocks[j][i];
+				k++;
+			}
+		}
+	}
+	for (size_t i = 0; i < numBlocks; i++)
+		free(blocks[i]);
+	free(blocks);
+	return result;
+}
+
+
+static void testAddEccAndInterleave(void) {
+	for (int version = 1; version <= 40; version++) {
+		for (int ecl = 0; ecl < 4; ecl++) {
+			size_t dataLen = (size_t)getNumDataCodewords(version, (enum qrcodegen_Ecc)ecl);
+			uint8_t *pureData = malloc(dataLen * sizeof(uint8_t));
+			for (size_t i = 0; i < dataLen; i++)
+				pureData[i] = (uint8_t)(rand() % 256);
+			uint8_t *expectOutput = addEccAndInterleaveReference(pureData, version, (enum qrcodegen_Ecc)ecl);
+			
+			size_t dataAndEccLen = (size_t)getNumRawDataModules(version) / 8;
+			uint8_t *paddedData = malloc(dataAndEccLen * sizeof(uint8_t));
+			memcpy(paddedData, pureData, dataLen * sizeof(uint8_t));
+			uint8_t *actualOutput = malloc(dataAndEccLen * sizeof(uint8_t));
+			addEccAndInterleave(paddedData, version, (enum qrcodegen_Ecc)ecl, actualOutput);
+			
+			assert(memcmp(actualOutput, expectOutput, dataAndEccLen * sizeof(uint8_t)) == 0);
+			free(pureData);
+			free(expectOutput);
+			free(paddedData);
+			free(actualOutput);
+			numTestCases++;
+		}
+	}
+}
+
+
+static void testGetNumDataCodewords(void) {
+	const int cases[][3] = {
+		{ 3, 1,   44},
+		{ 3, 2,   34},
+		{ 3, 3,   26},
+		{ 6, 0,  136},
+		{ 7, 0,  156},
+		{ 9, 0,  232},
+		{ 9, 1,  182},
+		{12, 3,  158},
+		{15, 0,  523},
+		{16, 2,  325},
+		{19, 3,  341},
+		{21, 0,  932},
+		{22, 0, 1006},
+		{22, 1,  782},
+		{22, 3,  442},
+		{24, 0, 1174},
+		{24, 3,  514},
+		{28, 0, 1531},
+		{30, 3,  745},
+		{32, 3,  845},
+		{33, 0, 2071},
+		{33, 3,  901},
+		{35, 0, 2306},
+		{35, 1, 1812},
+		{35, 2, 1286},
+		{36, 3, 1054},
+		{37, 3, 1096},
+		{39, 1, 2216},
+		{40, 1, 2334},
+	};
+	for (size_t i = 0; i < ARRAY_LENGTH(cases); i++) {
+		const int *tc = cases[i];
+		assert(getNumDataCodewords(tc[0], (enum qrcodegen_Ecc)tc[1]) == tc[2]);
+		numTestCases++;
+	}
+}
+
+
+static void testGetNumRawDataModules(void) {
+	const int cases[][2] = {
+		{ 1,   208},
+		{ 2,   359},
+		{ 3,   567},
+		{ 6,  1383},
+		{ 7,  1568},
+		{12,  3728},
+		{15,  5243},
+		{18,  7211},
+		{22, 10068},
+		{26, 13652},
+		{32, 19723},
+		{37, 25568},
+		{40, 29648},
+	};
+	for (size_t i = 0; i < ARRAY_LENGTH(cases); i++) {
+		const int *tc = cases[i];
+		assert(getNumRawDataModules(tc[0]) == tc[1]);
+		numTestCases++;
+	}
+}
+
+
+static void testReedSolomonComputeDivisor(void) {
+	uint8_t generator[30];
+	
+	reedSolomonComputeDivisor(1, generator);
+	assert(generator[0] == 0x01);
+	numTestCases++;
+	
+	reedSolomonComputeDivisor(2, generator);
+	assert(generator[0] == 0x03);
+	assert(generator[1] == 0x02);
+	numTestCases++;
+	
+	reedSolomonComputeDivisor(5, generator);
+	assert(generator[0] == 0x1F);
+	assert(generator[1] == 0xC6);
+	assert(generator[2] == 0x3F);
+	assert(generator[3] == 0x93);
+	assert(generator[4] == 0x74);
+	numTestCases++;
+	
+	reedSolomonComputeDivisor(30, generator);
+	assert(generator[ 0] == 0xD4);
+	assert(generator[ 1] == 0xF6);
+	assert(generator[ 5] == 0xC0);
+	assert(generator[12] == 0x16);
+	assert(generator[13] == 0xD9);
+	assert(generator[20] == 0x12);
+	assert(generator[27] == 0x6A);
+	assert(generator[29] == 0x96);
+	numTestCases++;
+}
+
+
+static void testReedSolomonComputeRemainder(void) {
+	{
+		uint8_t data[1];
+		uint8_t generator[3];
+		uint8_t remainder[ARRAY_LENGTH(generator)];
+		reedSolomonComputeDivisor(ARRAY_LENGTH(generator), generator);
+		reedSolomonComputeRemainder(data, 0, generator, ARRAY_LENGTH(generator), remainder);
+		assert(remainder[0] == 0);
+		assert(remainder[1] == 0);
+		assert(remainder[2] == 0);
+		numTestCases++;
+	}
+	{
+		uint8_t data[2] = {0, 1};
+		uint8_t generator[4];
+		uint8_t remainder[ARRAY_LENGTH(generator)];
+		reedSolomonComputeDivisor(ARRAY_LENGTH(generator), generator);
+		reedSolomonComputeRemainder(data, ARRAY_LENGTH(data), generator, ARRAY_LENGTH(generator), remainder);
+		assert(remainder[0] == generator[0]);
+		assert(remainder[1] == generator[1]);
+		assert(remainder[2] == generator[2]);
+		assert(remainder[3] == generator[3]);
+		numTestCases++;
+	}
+	{
+		uint8_t data[5] = {0x03, 0x3A, 0x60, 0x12, 0xC7};
+		uint8_t generator[5];
+		uint8_t remainder[ARRAY_LENGTH(generator)];
+		reedSolomonComputeDivisor(ARRAY_LENGTH(generator), generator);
+		reedSolomonComputeRemainder(data, ARRAY_LENGTH(data), generator, ARRAY_LENGTH(generator), remainder);
+		assert(remainder[0] == 0xCB);
+		assert(remainder[1] == 0x36);
+		assert(remainder[2] == 0x16);
+		assert(remainder[3] == 0xFA);
+		assert(remainder[4] == 0x9D);
+		numTestCases++;
+	}
+	{
+		uint8_t data[43] = {
+			0x38, 0x71, 0xDB, 0xF9, 0xD7, 0x28, 0xF6, 0x8E, 0xFE, 0x5E,
+			0xE6, 0x7D, 0x7D, 0xB2, 0xA5, 0x58, 0xBC, 0x28, 0x23, 0x53,
+			0x14, 0xD5, 0x61, 0xC0, 0x20, 0x6C, 0xDE, 0xDE, 0xFC, 0x79,
+			0xB0, 0x8B, 0x78, 0x6B, 0x49, 0xD0, 0x1A, 0xAD, 0xF3, 0xEF,
+			0x52, 0x7D, 0x9A,
+		};
+		uint8_t generator[30];
+		uint8_t remainder[ARRAY_LENGTH(generator)];
+		reedSolomonComputeDivisor(ARRAY_LENGTH(generator), generator);
+		reedSolomonComputeRemainder(data, ARRAY_LENGTH(data), generator, ARRAY_LENGTH(generator), remainder);
+		assert(remainder[ 0] == 0xCE);
+		assert(remainder[ 1] == 0xF0);
+		assert(remainder[ 2] == 0x31);
+		assert(remainder[ 3] == 0xDE);
+		assert(remainder[ 8] == 0xE1);
+		assert(remainder[12] == 0xCA);
+		assert(remainder[17] == 0xE3);
+		assert(remainder[19] == 0x85);
+		assert(remainder[20] == 0x50);
+		assert(remainder[24] == 0xBE);
+		assert(remainder[29] == 0xB3);
+		numTestCases++;
+	}
+}
+
+
+static void testReedSolomonMultiply(void) {
+	const uint8_t cases[][3] = {
+		{0x00, 0x00, 0x00},
+		{0x01, 0x01, 0x01},
+		{0x02, 0x02, 0x04},
+		{0x00, 0x6E, 0x00},
+		{0xB2, 0xDD, 0xE6},
+		{0x41, 0x11, 0x25},
+		{0xB0, 0x1F, 0x11},
+		{0x05, 0x75, 0xBC},
+		{0x52, 0xB5, 0xAE},
+		{0xA8, 0x20, 0xA4},
+		{0x0E, 0x44, 0x9F},
+		{0xD4, 0x13, 0xA0},
+		{0x31, 0x10, 0x37},
+		{0x6C, 0x58, 0xCB},
+		{0xB6, 0x75, 0x3E},
+		{0xFF, 0xFF, 0xE2},
+	};
+	for (size_t i = 0; i < ARRAY_LENGTH(cases); i++) {
+		const uint8_t *tc = cases[i];
+		assert(reedSolomonMultiply(tc[0], tc[1]) == tc[2]);
+		numTestCases++;
+	}
+}
+
+
+static void testInitializeFunctionModulesEtc(void) {
+	for (int ver = 1; ver <= 40; ver++) {
+		uint8_t *qrcode = malloc((size_t)qrcodegen_BUFFER_LEN_FOR_VERSION(ver) * sizeof(uint8_t));
+		assert(qrcode != NULL);
+		initializeFunctionModules(ver, qrcode);
+		
+		int size = qrcodegen_getSize(qrcode);
+		if (ver == 1)
+			assert(size == 21);
+		else if (ver == 40)
+			assert(size == 177);
+		else
+			assert(size == ver * 4 + 17);
+		
+		bool hasWhite = false;
+		bool hasBlack = false;
+		for (int y = 0; y < size; y++) {
+			for (int x = 0; x < size; x++) {
+				bool color = qrcodegen_getModule(qrcode, x, y);
+				if (color)
+					hasBlack = true;
+				else
+					hasWhite = true;
+			}
+		}
+		assert(hasWhite && hasBlack);
+		free(qrcode);
+		numTestCases++;
+	}
+}
+
+
+static void testGetAlignmentPatternPositions(void) {
+	const int cases[][9] = {
+		{ 1, 0,  -1,  -1,  -1,  -1,  -1,  -1,  -1},
+		{ 2, 2,   6,  18,  -1,  -1,  -1,  -1,  -1},
+		{ 3, 2,   6,  22,  -1,  -1,  -1,  -1,  -1},
+		{ 6, 2,   6,  34,  -1,  -1,  -1,  -1,  -1},
+		{ 7, 3,   6,  22,  38,  -1,  -1,  -1,  -1},
+		{ 8, 3,   6,  24,  42,  -1,  -1,  -1,  -1},
+		{16, 4,   6,  26,  50,  74,  -1,  -1,  -1},
+		{25, 5,   6,  32,  58,  84, 110,  -1,  -1},
+		{32, 6,   6,  34,  60,  86, 112, 138,  -1},
+		{33, 6,   6,  30,  58,  86, 114, 142,  -1},
+		{39, 7,   6,  26,  54,  82, 110, 138, 166},
+		{40, 7,   6,  30,  58,  86, 114, 142, 170},
+	};
+	for (size_t i = 0; i < ARRAY_LENGTH(cases); i++) {
+		const int *tc = cases[i];
+		uint8_t pos[7];
+		int num = getAlignmentPatternPositions(tc[0], pos);
+		assert(num == tc[1]);
+		for (int j = 0; j < num; j++)
+			assert(pos[j] == tc[2 + j]);
+		numTestCases++;
+	}
+}
+
+
+static void testGetSetModule(void) {
+	uint8_t qrcode[qrcodegen_BUFFER_LEN_FOR_VERSION(23)];
+	initializeFunctionModules(23, qrcode);
+	int size = qrcodegen_getSize(qrcode);
+	
+	for (int y = 0; y < size; y++) {  // Clear all to white
+		for (int x = 0; x < size; x++)
+			setModule(qrcode, x, y, false);
+	}
+	for (int y = 0; y < size; y++) {  // Check all white
+		for (int x = 0; x < size; x++)
+			assert(qrcodegen_getModule(qrcode, x, y) == false);
+	}
+	for (int y = 0; y < size; y++) {  // Set all to black
+		for (int x = 0; x < size; x++)
+			setModule(qrcode, x, y, true);
+	}
+	for (int y = 0; y < size; y++) {  // Check all black
+		for (int x = 0; x < size; x++)
+			assert(qrcodegen_getModule(qrcode, x, y) == true);
+	}
+	
+	// Set some out of bounds modules to white
+	setModuleBounded(qrcode, -1, -1, false);
+	setModuleBounded(qrcode, -1, 0, false);
+	setModuleBounded(qrcode, 0, -1, false);
+	setModuleBounded(qrcode, size, 5, false);
+	setModuleBounded(qrcode, 72, size, false);
+	setModuleBounded(qrcode, size, size, false);
+	for (int y = 0; y < size; y++) {  // Check all black
+		for (int x = 0; x < size; x++)
+			assert(qrcodegen_getModule(qrcode, x, y) == true);
+	}
+	
+	// Set some modules to white
+	setModule(qrcode, 3, 8, false);
+	setModule(qrcode, 61, 49, false);
+	for (int y = 0; y < size; y++) {  // Check most black
+		for (int x = 0; x < size; x++) {
+			bool white = (x == 3 && y == 8) || (x == 61 && y == 49);
+			assert(qrcodegen_getModule(qrcode, x, y) != white);
+		}
+	}
+	numTestCases++;
+}
+
+
+static void testGetSetModuleRandomly(void) {
+	uint8_t qrcode[qrcodegen_BUFFER_LEN_FOR_VERSION(1)];
+	initializeFunctionModules(1, qrcode);
+	int size = qrcodegen_getSize(qrcode);
+	
+	bool modules[21][21];
+	for (int y = 0; y < size; y++) {
+		for (int x = 0; x < size; x++)
+			modules[y][x] = qrcodegen_getModule(qrcode, x, y);
+	}
+	
+	long trials = 100000;
+	for (long i = 0; i < trials; i++) {
+		int x = rand() % (size * 2) - size / 2;
+		int y = rand() % (size * 2) - size / 2;
+		bool isInBounds = 0 <= x && x < size && 0 <= y && y < size;
+		bool oldColor = isInBounds && modules[y][x];
+		if (isInBounds)
+			assert(getModule(qrcode, x, y) == oldColor);
+		assert(qrcodegen_getModule(qrcode, x, y) == oldColor);
+		
+		bool newColor = rand() % 2 == 0;
+		if (isInBounds)
+			modules[y][x] = newColor;
+		if (isInBounds && rand() % 2 == 0)
+			setModule(qrcode, x, y, newColor);
+		else
+			setModuleBounded(qrcode, x, y, newColor);
+	}
+	numTestCases++;
+}
+
+
+static void testIsAlphanumeric(void) {
+	struct TestCase {
+		bool answer;
+		const char *text;
+	};
+	const struct TestCase cases[] = {
+		{true, ""},
+		{true, "0"},
+		{true, "A"},
+		{false, "a"},
+		{true, " "},
+		{true, "."},
+		{true, "*"},
+		{false, ","},
+		{false, "|"},
+		{false, "@"},
+		{true, "XYZ"},
+		{false, "XYZ!"},
+		{true, "79068"},
+		{true, "+123 ABC$"},
+		{false, "\x01"},
+		{false, "\x7F"},
+		{false, "\x80"},
+		{false, "\xC0"},
+		{false, "\xFF"},
+	};
+	for (size_t i = 0; i < ARRAY_LENGTH(cases); i++) {
+		assert(qrcodegen_isAlphanumeric(cases[i].text) == cases[i].answer);
+		numTestCases++;
+	}
+}
+
+
+static void testIsNumeric(void) {
+	struct TestCase {
+		bool answer;
+		const char *text;
+	};
+	const struct TestCase cases[] = {
+		{true, ""},
+		{true, "0"},
+		{false, "A"},
+		{false, "a"},
+		{false, " "},
+		{false, "."},
+		{false, "*"},
+		{false, ","},
+		{false, "|"},
+		{false, "@"},
+		{false, "XYZ"},
+		{false, "XYZ!"},
+		{true, "79068"},
+		{false, "+123 ABC$"},
+		{false, "\x01"},
+		{false, "\x7F"},
+		{false, "\x80"},
+		{false, "\xC0"},
+		{false, "\xFF"},
+	};
+	for (size_t i = 0; i < ARRAY_LENGTH(cases); i++) {
+		assert(qrcodegen_isNumeric(cases[i].text) == cases[i].answer);
+		numTestCases++;
+	}
+}
+
+
+static void testCalcSegmentBufferSize(void) {
+	{
+		const size_t cases[][2] = {
+			{0, 0},
+			{1, 1},
+			{2, 1},
+			{3, 2},
+			{4, 2},
+			{5, 3},
+			{6, 3},
+			{1472, 614},
+			{2097, 874},
+			{5326, 2220},
+			{9828, 4095},
+			{9829, 4096},
+			{9830, 4096},
+			{9831, SIZE_MAX},
+			{9832, SIZE_MAX},
+			{12000, SIZE_MAX},
+			{28453, SIZE_MAX},
+			{55555, SIZE_MAX},
+			{SIZE_MAX / 6, SIZE_MAX},
+			{SIZE_MAX / 4, SIZE_MAX},
+			{SIZE_MAX / 2, SIZE_MAX},
+			{SIZE_MAX / 1, SIZE_MAX},
+		};
+		for (size_t i = 0; i < ARRAY_LENGTH(cases); i++) {
+			assert(qrcodegen_calcSegmentBufferSize(qrcodegen_Mode_NUMERIC, cases[i][0]) == cases[i][1]);
+			numTestCases++;
+		}
+	}
+	{
+		const size_t cases[][2] = {
+			{0, 0},
+			{1, 1},
+			{2, 2},
+			{3, 3},
+			{4, 3},
+			{5, 4},
+			{6, 5},
+			{1472, 1012},
+			{2097, 1442},
+			{5326, 3662},
+			{5955, 4095},
+			{5956, 4095},
+			{5957, 4096},
+			{5958, SIZE_MAX},
+			{5959, SIZE_MAX},
+			{12000, SIZE_MAX},
+			{28453, SIZE_MAX},
+			{55555, SIZE_MAX},
+			{SIZE_MAX / 10, SIZE_MAX},
+			{SIZE_MAX / 8, SIZE_MAX},
+			{SIZE_MAX / 5, SIZE_MAX},
+			{SIZE_MAX / 2, SIZE_MAX},
+			{SIZE_MAX / 1, SIZE_MAX},
+		};
+		for (size_t i = 0; i < ARRAY_LENGTH(cases); i++) {
+			assert(qrcodegen_calcSegmentBufferSize(qrcodegen_Mode_ALPHANUMERIC, cases[i][0]) == cases[i][1]);
+			numTestCases++;
+		}
+	}
+	{
+		const size_t cases[][2] = {
+			{0, 0},
+			{1, 1},
+			{2, 2},
+			{3, 3},
+			{1472, 1472},
+			{2097, 2097},
+			{4094, 4094},
+			{4095, 4095},
+			{4096, SIZE_MAX},
+			{4097, SIZE_MAX},
+			{5957, SIZE_MAX},
+			{12000, SIZE_MAX},
+			{28453, SIZE_MAX},
+			{55555, SIZE_MAX},
+			{SIZE_MAX / 16 + 1, SIZE_MAX},
+			{SIZE_MAX / 14, SIZE_MAX},
+			{SIZE_MAX / 9, SIZE_MAX},
+			{SIZE_MAX / 7, SIZE_MAX},
+			{SIZE_MAX / 4, SIZE_MAX},
+			{SIZE_MAX / 3, SIZE_MAX},
+			{SIZE_MAX / 2, SIZE_MAX},
+			{SIZE_MAX / 1, SIZE_MAX},
+		};
+		for (size_t i = 0; i < ARRAY_LENGTH(cases); i++) {
+			assert(qrcodegen_calcSegmentBufferSize(qrcodegen_Mode_BYTE, cases[i][0]) == cases[i][1]);
+			numTestCases++;
+		}
+	}
+	{
+		const size_t cases[][2] = {
+			{0, 0},
+			{1, 2},
+			{2, 4},
+			{3, 5},
+			{1472, 2392},
+			{2097, 3408},
+			{2519, 4094},
+			{2520, 4095},
+			{2521, SIZE_MAX},
+			{5957, SIZE_MAX},
+			{2522, SIZE_MAX},
+			{12000, SIZE_MAX},
+			{28453, SIZE_MAX},
+			{55555, SIZE_MAX},
+			{SIZE_MAX / 13 + 1, SIZE_MAX},
+			{SIZE_MAX / 12, SIZE_MAX},
+			{SIZE_MAX / 9, SIZE_MAX},
+			{SIZE_MAX / 4, SIZE_MAX},
+			{SIZE_MAX / 3, SIZE_MAX},
+			{SIZE_MAX / 2, SIZE_MAX},
+			{SIZE_MAX / 1, SIZE_MAX},
+		};
+		for (size_t i = 0; i < ARRAY_LENGTH(cases); i++) {
+			assert(qrcodegen_calcSegmentBufferSize(qrcodegen_Mode_KANJI, cases[i][0]) == cases[i][1]);
+			numTestCases++;
+		}
+	}
+	{
+		assert(qrcodegen_calcSegmentBufferSize(qrcodegen_Mode_ECI, 0) == 3);
+		numTestCases++;
+	}
+}
+
+
+static void testCalcSegmentBitLength(void) {
+	struct TestCase {
+		size_t numChars;
+		int result;
+	};
+	{
+		const struct TestCase CASES[] = {
+			{0, 0},
+			{1, 4},
+			{2, 7},
+			{3, 10},
+			{4, 14},
+			{5, 17},
+			{6, 20},
+			{1472, 4907},
+			{2097, 6990},
+			{5326, 17754},
+			{9828, 32760},
+			{9829, 32764},
+			{9830, 32767},
+			{9831, -1},
+			{9832, -1},
+			{12000, -1},
+			{28453, -1},
+			{SIZE_MAX / 6, -1},
+			{SIZE_MAX / 3, -1},
+			{SIZE_MAX / 2, -1},
+			{SIZE_MAX / 1, -1},
+		};
+		for (size_t i = 0; i < ARRAY_LENGTH(CASES); i++) {
+			assert(calcSegmentBitLength(qrcodegen_Mode_NUMERIC, CASES[i].numChars) == CASES[i].result);
+			numTestCases++;
+		}
+	}
+	{
+		const struct TestCase CASES[] = {
+			{0, 0},
+			{1, 6},
+			{2, 11},
+			{3, 17},
+			{4, 22},
+			{5, 28},
+			{6, 33},
+			{1472, 8096},
+			{2097, 11534},
+			{5326, 29293},
+			{5955, 32753},
+			{5956, 32758},
+			{5957, 32764},
+			{5958, -1},
+			{5959, -1},
+			{12000, -1},
+			{28453, -1},
+			{SIZE_MAX / 10, -1},
+			{SIZE_MAX / 5, -1},
+			{SIZE_MAX / 2, -1},
+			{SIZE_MAX / 1, -1},
+		};
+		for (size_t i = 0; i < ARRAY_LENGTH(CASES); i++) {
+			assert(calcSegmentBitLength(qrcodegen_Mode_ALPHANUMERIC, CASES[i].numChars) == CASES[i].result);
+			numTestCases++;
+		}
+	}
+	{
+		const struct TestCase CASES[] = {
+			{0, 0},
+			{1, 8},
+			{2, 16},
+			{3, 24},
+			{1472, 11776},
+			{2097, 16776},
+			{4094, 32752},
+			{4095, 32760},
+			{4096, -1},
+			{4097, -1},
+			{5957, -1},
+			{12000, -1},
+			{28453, -1},
+			{SIZE_MAX / 15, -1},
+			{SIZE_MAX / 12, -1},
+			{SIZE_MAX / 7, -1},
+			{SIZE_MAX / 3, -1},
+			{SIZE_MAX / 1, -1},
+		};
+		for (size_t i = 0; i < ARRAY_LENGTH(CASES); i++) {
+			assert(calcSegmentBitLength(qrcodegen_Mode_BYTE, CASES[i].numChars) == CASES[i].result);
+			numTestCases++;
+		}
+	}
+	{
+		const struct TestCase CASES[] = {
+			{0, 0},
+			{1, 13},
+			{2, 26},
+			{3, 39},
+			{1472, 19136},
+			{2097, 27261},
+			{2519, 32747},
+			{2520, 32760},
+			{2521, -1},
+			{5957, -1},
+			{2522, -1},
+			{12000, -1},
+			{28453, -1},
+			{SIZE_MAX / 25, -1},
+			{SIZE_MAX / 20, -1},
+			{SIZE_MAX / 11, -1},
+			{SIZE_MAX / 4, -1},
+			{SIZE_MAX / 2, -1},
+			{SIZE_MAX / 1, -1},
+		};
+		for (size_t i = 0; i < ARRAY_LENGTH(CASES); i++) {
+			assert(calcSegmentBitLength(qrcodegen_Mode_KANJI, CASES[i].numChars) == CASES[i].result);
+			numTestCases++;
+		}
+	}
+	{
+		assert(calcSegmentBitLength(qrcodegen_Mode_ECI, 0) == 24);
+		numTestCases++;
+	}
+}
+
+
+static void testMakeBytes(void) {
+	{
+		struct qrcodegen_Segment seg = qrcodegen_makeBytes(NULL, 0, NULL);
+		assert(seg.mode == qrcodegen_Mode_BYTE);
+		assert(seg.numChars == 0);
+		assert(seg.bitLength == 0);
+		numTestCases++;
+	}
+	{
+		const uint8_t data[] = {0x00};
+		uint8_t buf[1];
+		struct qrcodegen_Segment seg = qrcodegen_makeBytes(data, 1, buf);
+		assert(seg.numChars == 1);
+		assert(seg.bitLength == 8);
+		assert(seg.data[0] == 0x00);
+		numTestCases++;
+	}
+	{
+		const uint8_t data[] = {0xEF, 0xBB, 0xBF};
+		uint8_t buf[3];
+		struct qrcodegen_Segment seg = qrcodegen_makeBytes(data, 3, buf);
+		assert(seg.numChars == 3);
+		assert(seg.bitLength == 24);
+		assert(seg.data[0] == 0xEF);
+		assert(seg.data[1] == 0xBB);
+		assert(seg.data[2] == 0xBF);
+		numTestCases++;
+	}
+}
+
+
+static void testMakeNumeric(void) {
+	{
+		struct qrcodegen_Segment seg = qrcodegen_makeNumeric("", NULL);
+		assert(seg.mode == qrcodegen_Mode_NUMERIC);
+		assert(seg.numChars == 0);
+		assert(seg.bitLength == 0);
+		numTestCases++;
+	}
+	{
+		uint8_t buf[1];
+		struct qrcodegen_Segment seg = qrcodegen_makeNumeric("9", buf);
+		assert(seg.numChars == 1);
+		assert(seg.bitLength == 4);
+		assert(seg.data[0] == 0x90);
+		numTestCases++;
+	}
+	{
+		uint8_t buf[1];
+		struct qrcodegen_Segment seg = qrcodegen_makeNumeric("81", buf);
+		assert(seg.numChars == 2);
+		assert(seg.bitLength == 7);
+		assert(seg.data[0] == 0xA2);
+		numTestCases++;
+	}
+	{
+		uint8_t buf[2];
+		struct qrcodegen_Segment seg = qrcodegen_makeNumeric("673", buf);
+		assert(seg.numChars == 3);
+		assert(seg.bitLength == 10);
+		assert(seg.data[0] == 0xA8);
+		assert(seg.data[1] == 0x40);
+		numTestCases++;
+	}
+	{
+		uint8_t buf[5];
+		struct qrcodegen_Segment seg = qrcodegen_makeNumeric("3141592653", buf);
+		assert(seg.numChars == 10);
+		assert(seg.bitLength == 34);
+		assert(seg.data[0] == 0x4E);
+		assert(seg.data[1] == 0x89);
+		assert(seg.data[2] == 0xF4);
+		assert(seg.data[3] == 0x24);
+		assert(seg.data[4] == 0xC0);
+		numTestCases++;
+	}
+}
+
+
+static void testMakeAlphanumeric(void) {
+	{
+		struct qrcodegen_Segment seg = qrcodegen_makeAlphanumeric("", NULL);
+		assert(seg.mode == qrcodegen_Mode_ALPHANUMERIC);
+		assert(seg.numChars == 0);
+		assert(seg.bitLength == 0);
+		numTestCases++;
+	}
+	{
+		uint8_t buf[1];
+		struct qrcodegen_Segment seg = qrcodegen_makeAlphanumeric("A", buf);
+		assert(seg.numChars == 1);
+		assert(seg.bitLength == 6);
+		assert(seg.data[0] == 0x28);
+		numTestCases++;
+	}
+	{
+		uint8_t buf[2];
+		struct qrcodegen_Segment seg = qrcodegen_makeAlphanumeric("%:", buf);
+		assert(seg.numChars == 2);
+		assert(seg.bitLength == 11);
+		assert(seg.data[0] == 0xDB);
+		assert(seg.data[1] == 0x40);
+		numTestCases++;
+	}
+	{
+		uint8_t buf[3];
+		struct qrcodegen_Segment seg = qrcodegen_makeAlphanumeric("Q R", buf);
+		assert(seg.numChars == 3);
+		assert(seg.bitLength == 17);
+		assert(seg.data[0] == 0x96);
+		assert(seg.data[1] == 0xCD);
+		assert(seg.data[2] == 0x80);
+		numTestCases++;
+	}
+}
+
+
+static void testMakeEci(void) {
+	{
+		uint8_t buf[1];
+		struct qrcodegen_Segment seg = qrcodegen_makeEci(127, buf);
+		assert(seg.mode == qrcodegen_Mode_ECI);
+		assert(seg.numChars == 0);
+		assert(seg.bitLength == 8);
+		assert(seg.data[0] == 0x7F);
+		numTestCases++;
+	}
+	{
+		uint8_t buf[2];
+		struct qrcodegen_Segment seg = qrcodegen_makeEci(10345, buf);
+		assert(seg.numChars == 0);
+		assert(seg.bitLength == 16);
+		assert(seg.data[0] == 0xA8);
+		assert(seg.data[1] == 0x69);
+		numTestCases++;
+	}
+	{
+		uint8_t buf[3];
+		struct qrcodegen_Segment seg = qrcodegen_makeEci(999999, buf);
+		assert(seg.numChars == 0);
+		assert(seg.bitLength == 24);
+		assert(seg.data[0] == 0xCF);
+		assert(seg.data[1] == 0x42);
+		assert(seg.data[2] == 0x3F);
+		numTestCases++;
+	}
+}
+
+
+static void testGetTotalBits(void) {
+	{
+		assert(getTotalBits(NULL, 0, 1) == 0);
+		numTestCases++;
+		assert(getTotalBits(NULL, 0, 40) == 0);
+		numTestCases++;
+	}
+	{
+		struct qrcodegen_Segment segs[] = {
+			{qrcodegen_Mode_BYTE, 3, NULL, 24},
+		};
+		assert(getTotalBits(segs, ARRAY_LENGTH(segs), 2) == 36);
+		numTestCases++;
+		assert(getTotalBits(segs, ARRAY_LENGTH(segs), 10) == 44);
+		numTestCases++;
+		assert(getTotalBits(segs, ARRAY_LENGTH(segs), 39) == 44);
+		numTestCases++;
+	}
+	{
+		struct qrcodegen_Segment segs[] = {
+			{qrcodegen_Mode_ECI, 0, NULL, 8},
+			{qrcodegen_Mode_NUMERIC, 7, NULL, 24},
+			{qrcodegen_Mode_ALPHANUMERIC, 1, NULL, 6},
+			{qrcodegen_Mode_KANJI, 4, NULL, 52},
+		};
+		assert(getTotalBits(segs, ARRAY_LENGTH(segs), 9) == 133);
+		numTestCases++;
+		assert(getTotalBits(segs, ARRAY_LENGTH(segs), 21) == 139);
+		numTestCases++;
+		assert(getTotalBits(segs, ARRAY_LENGTH(segs), 27) == 145);
+		numTestCases++;
+	}
+	{
+		struct qrcodegen_Segment segs[] = {
+			{qrcodegen_Mode_BYTE, 4093, NULL, 32744},
+		};
+		assert(getTotalBits(segs, ARRAY_LENGTH(segs), 1) == -1);
+		numTestCases++;
+		assert(getTotalBits(segs, ARRAY_LENGTH(segs), 10) == 32764);
+		numTestCases++;
+		assert(getTotalBits(segs, ARRAY_LENGTH(segs), 27) == 32764);
+		numTestCases++;
+	}
+	{
+		struct qrcodegen_Segment segs[] = {
+			{qrcodegen_Mode_NUMERIC, 2047, NULL, 6824},
+			{qrcodegen_Mode_NUMERIC, 2047, NULL, 6824},
+			{qrcodegen_Mode_NUMERIC, 2047, NULL, 6824},
+			{qrcodegen_Mode_NUMERIC, 2047, NULL, 6824},
+			{qrcodegen_Mode_NUMERIC, 1617, NULL, 5390},
+		};
+		assert(getTotalBits(segs, ARRAY_LENGTH(segs), 1) == -1);
+		numTestCases++;
+		assert(getTotalBits(segs, ARRAY_LENGTH(segs), 10) == 32766);
+		numTestCases++;
+		assert(getTotalBits(segs, ARRAY_LENGTH(segs), 27) == -1);
+		numTestCases++;
+	}
+	{
+		struct qrcodegen_Segment segs[] = {
+			{qrcodegen_Mode_KANJI, 255, NULL, 3315},
+			{qrcodegen_Mode_KANJI, 255, NULL, 3315},
+			{qrcodegen_Mode_KANJI, 255, NULL, 3315},
+			{qrcodegen_Mode_KANJI, 255, NULL, 3315},
+			{qrcodegen_Mode_KANJI, 255, NULL, 3315},
+			{qrcodegen_Mode_KANJI, 255, NULL, 3315},
+			{qrcodegen_Mode_KANJI, 255, NULL, 3315},
+			{qrcodegen_Mode_KANJI, 255, NULL, 3315},
+			{qrcodegen_Mode_KANJI, 255, NULL, 3315},
+			{qrcodegen_Mode_ALPHANUMERIC, 511, NULL, 2811},
+		};
+		assert(getTotalBits(segs, ARRAY_LENGTH(segs), 9) == 32767);
+		numTestCases++;
+		assert(getTotalBits(segs, ARRAY_LENGTH(segs), 26) == -1);
+		numTestCases++;
+		assert(getTotalBits(segs, ARRAY_LENGTH(segs), 40) == -1);
+		numTestCases++;
+	}
+}
+
+
+/*---- Main runner ----*/
+
+int main(void) {
+	srand((unsigned int)time(NULL));
+	testAppendBitsToBuffer();
+	testAddEccAndInterleave();
+	testGetNumDataCodewords();
+	testGetNumRawDataModules();
+	testReedSolomonComputeDivisor();
+	testReedSolomonComputeRemainder();
+	testReedSolomonMultiply();
+	testInitializeFunctionModulesEtc();
+	testGetAlignmentPatternPositions();
+	testGetSetModule();
+	testGetSetModuleRandomly();
+	testIsAlphanumeric();
+	testIsNumeric();
+	testCalcSegmentBufferSize();
+	testCalcSegmentBitLength();
+	testMakeBytes();
+	testMakeNumeric();
+	testMakeAlphanumeric();
+	testMakeEci();
+	testGetTotalBits();
+	printf("All %d test cases passed\n", numTestCases);
+	return EXIT_SUCCESS;
+}
diff --git a/Telegram/ThirdParty/QR/c/qrcodegen-worker.c b/Telegram/ThirdParty/QR/c/qrcodegen-worker.c
new file mode 100644
index 0000000..dc16888
--- /dev/null
+++ b/Telegram/ThirdParty/QR/c/qrcodegen-worker.c
@@ -0,0 +1,118 @@
+/* 
+ * QR Code generator test worker (C)
+ * 
+ * This program reads data and encoding parameters from standard input and writes
+ * QR Code bitmaps to standard output. The I/O format is one integer per line.
+ * Run with no command line arguments. The program is intended for automated
+ * batch testing of end-to-end functionality of this QR Code generator library.
+ * 
+ * Copyright (c) Project Nayuki. (MIT License)
+ * https://www.nayuki.io/page/qr-code-generator-library
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ * - The above copyright notice and this permission notice shall be included in
+ *   all copies or substantial portions of the Software.
+ * - The Software is provided "as is", without warranty of any kind, express or
+ *   implied, including but not limited to the warranties of merchantability,
+ *   fitness for a particular purpose and noninfringement. In no event shall the
+ *   authors or copyright holders be liable for any claim, damages or other
+ *   liability, whether in an action of contract, tort or otherwise, arising from,
+ *   out of or in connection with the Software or the use or other dealings in the
+ *   Software.
+ */
+
+#include <stdbool.h>
+#include <stddef.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "qrcodegen.h"
+
+
+int main(void) {
+	while (true) {
+		
+		// Read data length or exit
+		size_t length;
+		{
+			int temp;
+			if (scanf("%d", &temp) != 1)
+				return EXIT_FAILURE;
+			if (temp == -1)
+				break;
+			length = (size_t)temp;
+		}
+		
+		// Read data bytes
+		bool isAscii = true;
+		uint8_t *data = malloc(length * sizeof(uint8_t));
+		if (data == NULL) {
+			perror("malloc");
+			return EXIT_FAILURE;
+		}
+		for (size_t i = 0; i < length; i++) {
+			int b;
+			if (scanf("%d", &b) != 1)
+				return EXIT_FAILURE;
+			data[i] = (uint8_t)b;
+			isAscii &= 0 < b && b < 128;
+		}
+		
+		// Read encoding parameters
+		int errCorLvl, minVersion, maxVersion, mask, boostEcl;
+		if (scanf("%d %d %d %d %d", &errCorLvl, &minVersion, &maxVersion, &mask, &boostEcl) != 5)
+			return EXIT_FAILURE;
+		
+		// Allocate memory for QR Code
+		size_t bufferLen = (size_t)qrcodegen_BUFFER_LEN_FOR_VERSION(maxVersion);
+		uint8_t *qrcode     = malloc(bufferLen * sizeof(uint8_t));
+		uint8_t *tempBuffer = malloc(bufferLen * sizeof(uint8_t));
+		if (qrcode == NULL || tempBuffer == NULL) {
+			perror("malloc");
+			return EXIT_FAILURE;
+		}
+		
+		// Try to make QR Code symbol
+		bool ok;
+		if (isAscii) {
+			char *text = malloc((length + 1) * sizeof(char));
+			if (text == NULL) {
+				perror("malloc");
+				return EXIT_FAILURE;
+			}
+			for (size_t i = 0; i < length; i++)
+				text[i] = (char)data[i];
+			text[length] = '\0';
+			ok = qrcodegen_encodeText(text, tempBuffer, qrcode, (enum qrcodegen_Ecc)errCorLvl,
+				minVersion, maxVersion, (enum qrcodegen_Mask)mask, boostEcl == 1);
+			free(text);
+		} else if (length <= bufferLen) {
+			memcpy(tempBuffer, data, length * sizeof(data[0]));
+			ok = qrcodegen_encodeBinary(tempBuffer, length, qrcode, (enum qrcodegen_Ecc)errCorLvl,
+				minVersion, maxVersion, (enum qrcodegen_Mask)mask, boostEcl == 1);
+		} else
+			ok = false;
+		free(data);
+		free(tempBuffer);
+		
+		if (ok) {
+			// Print grid of modules
+			int size = qrcodegen_getSize(qrcode);
+			printf("%d\n", (size - 17) / 4);
+			for (int y = 0; y < size; y++) {
+				for (int x = 0; x < size; x++)
+					printf("%d\n", qrcodegen_getModule(qrcode, x, y) ? 1 : 0);
+			}
+		} else
+			printf("-1\n");
+		free(qrcode);
+		fflush(stdout);
+	}
+	return EXIT_SUCCESS;
+}
diff --git a/Telegram/ThirdParty/QR/c/qrcodegen.c b/Telegram/ThirdParty/QR/c/qrcodegen.c
new file mode 100644
index 0000000..cf7cd64
--- /dev/null
+++ b/Telegram/ThirdParty/QR/c/qrcodegen.c
@@ -0,0 +1,1022 @@
+/* 
+ * QR Code generator library (C)
+ * 
+ * Copyright (c) Project Nayuki. (MIT License)
+ * https://www.nayuki.io/page/qr-code-generator-library
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ * - The above copyright notice and this permission notice shall be included in
+ *   all copies or substantial portions of the Software.
+ * - The Software is provided "as is", without warranty of any kind, express or
+ *   implied, including but not limited to the warranties of merchantability,
+ *   fitness for a particular purpose and noninfringement. In no event shall the
+ *   authors or copyright holders be liable for any claim, damages or other
+ *   liability, whether in an action of contract, tort or otherwise, arising from,
+ *   out of or in connection with the Software or the use or other dealings in the
+ *   Software.
+ */
+
+#include <assert.h>
+#include <limits.h>
+#include <stdlib.h>
+#include <string.h>
+#include "qrcodegen.h"
+
+#ifndef QRCODEGEN_TEST
+	#define testable static  // Keep functions private
+#else
+	#define testable  // Expose private functions
+#endif
+
+
+/*---- Forward declarations for private functions ----*/
+
+// Regarding all public and private functions defined in this source file:
+// - They require all pointer/array arguments to be not null unless the array length is zero.
+// - They only read input scalar/array arguments, write to output pointer/array
+//   arguments, and return scalar values; they are "pure" functions.
+// - They don't read mutable global variables or write to any global variables.
+// - They don't perform I/O, read the clock, print to console, etc.
+// - They allocate a small and constant amount of stack memory.
+// - They don't allocate or free any memory on the heap.
+// - They don't recurse or mutually recurse. All the code
+//   could be inlined into the top-level public functions.
+// - They run in at most quadratic time with respect to input arguments.
+//   Most functions run in linear time, and some in constant time.
+//   There are no unbounded loops or non-obvious termination conditions.
+// - They are completely thread-safe if the caller does not give the
+//   same writable buffer to concurrent calls to these functions.
+
+testable void appendBitsToBuffer(unsigned int val, int numBits, uint8_t buffer[], int *bitLen);
+
+testable void addEccAndInterleave(uint8_t data[], int version, enum qrcodegen_Ecc ecl, uint8_t result[]);
+testable int getNumDataCodewords(int version, enum qrcodegen_Ecc ecl);
+testable int getNumRawDataModules(int ver);
+
+testable void reedSolomonComputeDivisor(int degree, uint8_t result[]);
+testable void reedSolomonComputeRemainder(const uint8_t data[], int dataLen,
+	const uint8_t generator[], int degree, uint8_t result[]);
+testable uint8_t reedSolomonMultiply(uint8_t x, uint8_t y);
+
+testable void initializeFunctionModules(int version, uint8_t qrcode[]);
+static void drawWhiteFunctionModules(uint8_t qrcode[], int version);
+static void drawFormatBits(enum qrcodegen_Ecc ecl, enum qrcodegen_Mask mask, uint8_t qrcode[]);
+testable int getAlignmentPatternPositions(int version, uint8_t result[7]);
+static void fillRectangle(int left, int top, int width, int height, uint8_t qrcode[]);
+
+static void drawCodewords(const uint8_t data[], int dataLen, uint8_t qrcode[]);
+static void applyMask(const uint8_t functionModules[], uint8_t qrcode[], enum qrcodegen_Mask mask);
+static long getPenaltyScore(const uint8_t qrcode[]);
+static int finderPenaltyCountPatterns(const int runHistory[7], int qrsize);
+static int finderPenaltyTerminateAndCount(bool currentRunColor, int currentRunLength, int runHistory[7], int qrsize);
+static void finderPenaltyAddHistory(int currentRunLength, int runHistory[7]);
+
+testable bool getModule(const uint8_t qrcode[], int x, int y);
+testable void setModule(uint8_t qrcode[], int x, int y, bool isBlack);
+testable void setModuleBounded(uint8_t qrcode[], int x, int y, bool isBlack);
+static bool getBit(int x, int i);
+
+testable int calcSegmentBitLength(enum qrcodegen_Mode mode, size_t numChars);
+testable int getTotalBits(const struct qrcodegen_Segment segs[], size_t len, int version);
+static int numCharCountBits(enum qrcodegen_Mode mode, int version);
+
+
+
+/*---- Private tables of constants ----*/
+
+// The set of all legal characters in alphanumeric mode, where each character
+// value maps to the index in the string. For checking text and encoding segments.
+static const char *ALPHANUMERIC_CHARSET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";
+
+// For generating error correction codes.
+testable const int8_t ECC_CODEWORDS_PER_BLOCK[4][41] = {
+	// Version: (note that index 0 is for padding, and is set to an illegal value)
+	//0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
+	{-1,  7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30},  // Low
+	{-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28},  // Medium
+	{-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30},  // Quartile
+	{-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30},  // High
+};
+
+#define qrcodegen_REED_SOLOMON_DEGREE_MAX 30  // Based on the table above
+
+// For generating error correction codes.
+testable const int8_t NUM_ERROR_CORRECTION_BLOCKS[4][41] = {
+	// Version: (note that index 0 is for padding, and is set to an illegal value)
+	//0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
+	{-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4,  4,  4,  4,  4,  6,  6,  6,  6,  7,  8,  8,  9,  9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25},  // Low
+	{-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5,  5,  8,  9,  9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49},  // Medium
+	{-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8,  8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68},  // Quartile
+	{-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81},  // High
+};
+
+// For automatic mask pattern selection.
+static const int PENALTY_N1 =  3;
+static const int PENALTY_N2 =  3;
+static const int PENALTY_N3 = 40;
+static const int PENALTY_N4 = 10;
+
+
+
+/*---- High-level QR Code encoding functions ----*/
+
+// Public function - see documentation comment in header file.
+bool qrcodegen_encodeText(const char *text, uint8_t tempBuffer[], uint8_t qrcode[],
+		enum qrcodegen_Ecc ecl, int minVersion, int maxVersion, enum qrcodegen_Mask mask, bool boostEcl) {
+	
+	size_t textLen = strlen(text);
+	if (textLen == 0)
+		return qrcodegen_encodeSegmentsAdvanced(NULL, 0, ecl, minVersion, maxVersion, mask, boostEcl, tempBuffer, qrcode);
+	size_t bufLen = (size_t)qrcodegen_BUFFER_LEN_FOR_VERSION(maxVersion);
+	
+	struct qrcodegen_Segment seg;
+	if (qrcodegen_isNumeric(text)) {
+		if (qrcodegen_calcSegmentBufferSize(qrcodegen_Mode_NUMERIC, textLen) > bufLen)
+			goto fail;
+		seg = qrcodegen_makeNumeric(text, tempBuffer);
+	} else if (qrcodegen_isAlphanumeric(text)) {
+		if (qrcodegen_calcSegmentBufferSize(qrcodegen_Mode_ALPHANUMERIC, textLen) > bufLen)
+			goto fail;
+		seg = qrcodegen_makeAlphanumeric(text, tempBuffer);
+	} else {
+		if (textLen > bufLen)
+			goto fail;
+		for (size_t i = 0; i < textLen; i++)
+			tempBuffer[i] = (uint8_t)text[i];
+		seg.mode = qrcodegen_Mode_BYTE;
+		seg.bitLength = calcSegmentBitLength(seg.mode, textLen);
+		if (seg.bitLength == -1)
+			goto fail;
+		seg.numChars = (int)textLen;
+		seg.data = tempBuffer;
+	}
+	return qrcodegen_encodeSegmentsAdvanced(&seg, 1, ecl, minVersion, maxVersion, mask, boostEcl, tempBuffer, qrcode);
+	
+fail:
+	qrcode[0] = 0;  // Set size to invalid value for safety
+	return false;
+}
+
+
+// Public function - see documentation comment in header file.
+bool qrcodegen_encodeBinary(uint8_t dataAndTemp[], size_t dataLen, uint8_t qrcode[],
+		enum qrcodegen_Ecc ecl, int minVersion, int maxVersion, enum qrcodegen_Mask mask, bool boostEcl) {
+	
+	struct qrcodegen_Segment seg;
+	seg.mode = qrcodegen_Mode_BYTE;
+	seg.bitLength = calcSegmentBitLength(seg.mode, dataLen);
+	if (seg.bitLength == -1) {
+		qrcode[0] = 0;  // Set size to invalid value for safety
+		return false;
+	}
+	seg.numChars = (int)dataLen;
+	seg.data = dataAndTemp;
+	return qrcodegen_encodeSegmentsAdvanced(&seg, 1, ecl, minVersion, maxVersion, mask, boostEcl, dataAndTemp, qrcode);
+}
+
+
+// Appends the given number of low-order bits of the given value to the given byte-based
+// bit buffer, increasing the bit length. Requires 0 <= numBits <= 16 and val < 2^numBits.
+testable void appendBitsToBuffer(unsigned int val, int numBits, uint8_t buffer[], int *bitLen) {
+	assert(0 <= numBits && numBits <= 16 && (unsigned long)val >> numBits == 0);
+	for (int i = numBits - 1; i >= 0; i--, (*bitLen)++)
+		buffer[*bitLen >> 3] |= ((val >> i) & 1) << (7 - (*bitLen & 7));
+}
+
+
+
+/*---- Low-level QR Code encoding functions ----*/
+
+// Public function - see documentation comment in header file.
+bool qrcodegen_encodeSegments(const struct qrcodegen_Segment segs[], size_t len,
+		enum qrcodegen_Ecc ecl, uint8_t tempBuffer[], uint8_t qrcode[]) {
+	return qrcodegen_encodeSegmentsAdvanced(segs, len, ecl,
+		qrcodegen_VERSION_MIN, qrcodegen_VERSION_MAX, qrcodegen_Mask_AUTO, true, tempBuffer, qrcode);
+}
+
+
+// Public function - see documentation comment in header file.
+bool qrcodegen_encodeSegmentsAdvanced(const struct qrcodegen_Segment segs[], size_t len, enum qrcodegen_Ecc ecl,
+		int minVersion, int maxVersion, enum qrcodegen_Mask mask, bool boostEcl, uint8_t tempBuffer[], uint8_t qrcode[]) {
+	assert(segs != NULL || len == 0);
+	assert(qrcodegen_VERSION_MIN <= minVersion && minVersion <= maxVersion && maxVersion <= qrcodegen_VERSION_MAX);
+	assert(0 <= (int)ecl && (int)ecl <= 3 && -1 <= (int)mask && (int)mask <= 7);
+	
+	// Find the minimal version number to use
+	int version, dataUsedBits;
+	for (version = minVersion; ; version++) {
+		int dataCapacityBits = getNumDataCodewords(version, ecl) * 8;  // Number of data bits available
+		dataUsedBits = getTotalBits(segs, len, version);
+		if (dataUsedBits != -1 && dataUsedBits <= dataCapacityBits)
+			break;  // This version number is found to be suitable
+		if (version >= maxVersion) {  // All versions in the range could not fit the given data
+			qrcode[0] = 0;  // Set size to invalid value for safety
+			return false;
+		}
+	}
+	assert(dataUsedBits != -1);
+	
+	// Increase the error correction level while the data still fits in the current version number
+	for (int i = (int)qrcodegen_Ecc_MEDIUM; i <= (int)qrcodegen_Ecc_HIGH; i++) {  // From low to high
+		if (boostEcl && dataUsedBits <= getNumDataCodewords(version, (enum qrcodegen_Ecc)i) * 8)
+			ecl = (enum qrcodegen_Ecc)i;
+	}
+	
+	// Concatenate all segments to create the data bit string
+	memset(qrcode, 0, (size_t)qrcodegen_BUFFER_LEN_FOR_VERSION(version) * sizeof(qrcode[0]));
+	int bitLen = 0;
+	for (size_t i = 0; i < len; i++) {
+		const struct qrcodegen_Segment *seg = &segs[i];
+		appendBitsToBuffer((unsigned int)seg->mode, 4, qrcode, &bitLen);
+		appendBitsToBuffer((unsigned int)seg->numChars, numCharCountBits(seg->mode, version), qrcode, &bitLen);
+		for (int j = 0; j < seg->bitLength; j++) {
+			int bit = (seg->data[j >> 3] >> (7 - (j & 7))) & 1;
+			appendBitsToBuffer((unsigned int)bit, 1, qrcode, &bitLen);
+		}
+	}
+	assert(bitLen == dataUsedBits);
+	
+	// Add terminator and pad up to a byte if applicable
+	int dataCapacityBits = getNumDataCodewords(version, ecl) * 8;
+	assert(bitLen <= dataCapacityBits);
+	int terminatorBits = dataCapacityBits - bitLen;
+	if (terminatorBits > 4)
+		terminatorBits = 4;
+	appendBitsToBuffer(0, terminatorBits, qrcode, &bitLen);
+	appendBitsToBuffer(0, (8 - bitLen % 8) % 8, qrcode, &bitLen);
+	assert(bitLen % 8 == 0);
+	
+	// Pad with alternating bytes until data capacity is reached
+	for (uint8_t padByte = 0xEC; bitLen < dataCapacityBits; padByte ^= 0xEC ^ 0x11)
+		appendBitsToBuffer(padByte, 8, qrcode, &bitLen);
+	
+	// Draw function and data codeword modules
+	addEccAndInterleave(qrcode, version, ecl, tempBuffer);
+	initializeFunctionModules(version, qrcode);
+	drawCodewords(tempBuffer, getNumRawDataModules(version) / 8, qrcode);
+	drawWhiteFunctionModules(qrcode, version);
+	initializeFunctionModules(version, tempBuffer);
+	
+	// Handle masking
+	if (mask == qrcodegen_Mask_AUTO) {  // Automatically choose best mask
+		long minPenalty = LONG_MAX;
+		for (int i = 0; i < 8; i++) {
+			enum qrcodegen_Mask msk = (enum qrcodegen_Mask)i;
+			applyMask(tempBuffer, qrcode, msk);
+			drawFormatBits(ecl, msk, qrcode);
+			long penalty = getPenaltyScore(qrcode);
+			if (penalty < minPenalty) {
+				mask = msk;
+				minPenalty = penalty;
+			}
+			applyMask(tempBuffer, qrcode, msk);  // Undoes the mask due to XOR
+		}
+	}
+	assert(0 <= (int)mask && (int)mask <= 7);
+	applyMask(tempBuffer, qrcode, mask);
+	drawFormatBits(ecl, mask, qrcode);
+	return true;
+}
+
+
+
+/*---- Error correction code generation functions ----*/
+
+// Appends error correction bytes to each block of the given data array, then interleaves
+// bytes from the blocks and stores them in the result array. data[0 : dataLen] contains
+// the input data. data[dataLen : rawCodewords] is used as a temporary work area and will
+// be clobbered by this function. The final answer is stored in result[0 : rawCodewords].
+testable void addEccAndInterleave(uint8_t data[], int version, enum qrcodegen_Ecc ecl, uint8_t result[]) {
+	// Calculate parameter numbers
+	assert(0 <= (int)ecl && (int)ecl < 4 && qrcodegen_VERSION_MIN <= version && version <= qrcodegen_VERSION_MAX);
+	int numBlocks = NUM_ERROR_CORRECTION_BLOCKS[(int)ecl][version];
+	int blockEccLen = ECC_CODEWORDS_PER_BLOCK  [(int)ecl][version];
+	int rawCodewords = getNumRawDataModules(version) / 8;
+	int dataLen = getNumDataCodewords(version, ecl);
+	int numShortBlocks = numBlocks - rawCodewords % numBlocks;
+	int shortBlockDataLen = rawCodewords / numBlocks - blockEccLen;
+	
+	// Split data into blocks, calculate ECC, and interleave
+	// (not concatenate) the bytes into a single sequence
+	uint8_t rsdiv[qrcodegen_REED_SOLOMON_DEGREE_MAX];
+	reedSolomonComputeDivisor(blockEccLen, rsdiv);
+	const uint8_t *dat = data;
+	for (int i = 0; i < numBlocks; i++) {
+		int datLen = shortBlockDataLen + (i < numShortBlocks ? 0 : 1);
+		uint8_t *ecc = &data[dataLen];  // Temporary storage
+		reedSolomonComputeRemainder(dat, datLen, rsdiv, blockEccLen, ecc);
+		for (int j = 0, k = i; j < datLen; j++, k += numBlocks) {  // Copy data
+			if (j == shortBlockDataLen)
+				k -= numShortBlocks;
+			result[k] = dat[j];
+		}
+		for (int j = 0, k = dataLen + i; j < blockEccLen; j++, k += numBlocks)  // Copy ECC
+			result[k] = ecc[j];
+		dat += datLen;
+	}
+}
+
+
+// Returns the number of 8-bit codewords that can be used for storing data (not ECC),
+// for the given version number and error correction level. The result is in the range [9, 2956].
+testable int getNumDataCodewords(int version, enum qrcodegen_Ecc ecl) {
+	int v = version, e = (int)ecl;
+	assert(0 <= e && e < 4);
+	return getNumRawDataModules(v) / 8
+		- ECC_CODEWORDS_PER_BLOCK    [e][v]
+		* NUM_ERROR_CORRECTION_BLOCKS[e][v];
+}
+
+
+// Returns the number of data bits that can be stored in a QR Code of the given version number, after
+// all function modules are excluded. This includes remainder bits, so it might not be a multiple of 8.
+// The result is in the range [208, 29648]. This could be implemented as a 40-entry lookup table.
+testable int getNumRawDataModules(int ver) {
+	assert(qrcodegen_VERSION_MIN <= ver && ver <= qrcodegen_VERSION_MAX);
+	int result = (16 * ver + 128) * ver + 64;
+	if (ver >= 2) {
+		int numAlign = ver / 7 + 2;
+		result -= (25 * numAlign - 10) * numAlign - 55;
+		if (ver >= 7)
+			result -= 36;
+	}
+	assert(208 <= result && result <= 29648);
+	return result;
+}
+
+
+
+/*---- Reed-Solomon ECC generator functions ----*/
+
+// Computes a Reed-Solomon ECC generator polynomial for the given degree, storing in result[0 : degree].
+// This could be implemented as a lookup table over all possible parameter values, instead of as an algorithm.
+testable void reedSolomonComputeDivisor(int degree, uint8_t result[]) {
+	assert(1 <= degree && degree <= qrcodegen_REED_SOLOMON_DEGREE_MAX);
+	// Polynomial coefficients are stored from highest to lowest power, excluding the leading term which is always 1.
+	// For example the polynomial x^3 + 255x^2 + 8x + 93 is stored as the uint8 array {255, 8, 93}.
+	memset(result, 0, (size_t)degree * sizeof(result[0]));
+	result[degree - 1] = 1;  // Start off with the monomial x^0
+	
+	// Compute the product polynomial (x - r^0) * (x - r^1) * (x - r^2) * ... * (x - r^{degree-1}),
+	// drop the highest monomial term which is always 1x^degree.
+	// Note that r = 0x02, which is a generator element of this field GF(2^8/0x11D).
+	uint8_t root = 1;
+	for (int i = 0; i < degree; i++) {
+		// Multiply the current product by (x - r^i)
+		for (int j = 0; j < degree; j++) {
+			result[j] = reedSolomonMultiply(result[j], root);
+			if (j + 1 < degree)
+				result[j] ^= result[j + 1];
+		}
+		root = reedSolomonMultiply(root, 0x02);
+	}
+}
+
+
+// Computes the Reed-Solomon error correction codeword for the given data and divisor polynomials.
+// The remainder when data[0 : dataLen] is divided by divisor[0 : degree] is stored in result[0 : degree].
+// All polynomials are in big endian, and the generator has an implicit leading 1 term.
+testable void reedSolomonComputeRemainder(const uint8_t data[], int dataLen,
+		const uint8_t generator[], int degree, uint8_t result[]) {
+	assert(1 <= degree && degree <= qrcodegen_REED_SOLOMON_DEGREE_MAX);
+	memset(result, 0, (size_t)degree * sizeof(result[0]));
+	for (int i = 0; i < dataLen; i++) {  // Polynomial division
+		uint8_t factor = data[i] ^ result[0];
+		memmove(&result[0], &result[1], (size_t)(degree - 1) * sizeof(result[0]));
+		result[degree - 1] = 0;
+		for (int j = 0; j < degree; j++)
+			result[j] ^= reedSolomonMultiply(generator[j], factor);
+	}
+}
+
+#undef qrcodegen_REED_SOLOMON_DEGREE_MAX
+
+
+// Returns the product of the two given field elements modulo GF(2^8/0x11D).
+// All inputs are valid. This could be implemented as a 256*256 lookup table.
+testable uint8_t reedSolomonMultiply(uint8_t x, uint8_t y) {
+	// Russian peasant multiplication
+	uint8_t z = 0;
+	for (int i = 7; i >= 0; i--) {
+		z = (uint8_t)((z << 1) ^ ((z >> 7) * 0x11D));
+		z ^= ((y >> i) & 1) * x;
+	}
+	return z;
+}
+
+
+
+/*---- Drawing function modules ----*/
+
+// Clears the given QR Code grid with white modules for the given
+// version's size, then marks every function module as black.
+testable void initializeFunctionModules(int version, uint8_t qrcode[]) {
+	// Initialize QR Code
+	int qrsize = version * 4 + 17;
+	memset(qrcode, 0, (size_t)((qrsize * qrsize + 7) / 8 + 1) * sizeof(qrcode[0]));
+	qrcode[0] = (uint8_t)qrsize;
+	
+	// Fill horizontal and vertical timing patterns
+	fillRectangle(6, 0, 1, qrsize, qrcode);
+	fillRectangle(0, 6, qrsize, 1, qrcode);
+	
+	// Fill 3 finder patterns (all corners except bottom right) and format bits
+	fillRectangle(0, 0, 9, 9, qrcode);
+	fillRectangle(qrsize - 8, 0, 8, 9, qrcode);
+	fillRectangle(0, qrsize - 8, 9, 8, qrcode);
+	
+	// Fill numerous alignment patterns
+	uint8_t alignPatPos[7];
+	int numAlign = getAlignmentPatternPositions(version, alignPatPos);
+	for (int i = 0; i < numAlign; i++) {
+		for (int j = 0; j < numAlign; j++) {
+			// Don't draw on the three finder corners
+			if (!((i == 0 && j == 0) || (i == 0 && j == numAlign - 1) || (i == numAlign - 1 && j == 0)))
+				fillRectangle(alignPatPos[i] - 2, alignPatPos[j] - 2, 5, 5, qrcode);
+		}
+	}
+	
+	// Fill version blocks
+	if (version >= 7) {
+		fillRectangle(qrsize - 11, 0, 3, 6, qrcode);
+		fillRectangle(0, qrsize - 11, 6, 3, qrcode);
+	}
+}
+
+
+// Draws white function modules and possibly some black modules onto the given QR Code, without changing
+// non-function modules. This does not draw the format bits. This requires all function modules to be previously
+// marked black (namely by initializeFunctionModules()), because this may skip redrawing black function modules.
+static void drawWhiteFunctionModules(uint8_t qrcode[], int version) {
+	// Draw horizontal and vertical timing patterns
+	int qrsize = qrcodegen_getSize(qrcode);
+	for (int i = 7; i < qrsize - 7; i += 2) {
+		setModule(qrcode, 6, i, false);
+		setModule(qrcode, i, 6, false);
+	}
+	
+	// Draw 3 finder patterns (all corners except bottom right; overwrites some timing modules)
+	for (int dy = -4; dy <= 4; dy++) {
+		for (int dx = -4; dx <= 4; dx++) {
+			int dist = abs(dx);
+			if (abs(dy) > dist)
+				dist = abs(dy);
+			if (dist == 2 || dist == 4) {
+				setModuleBounded(qrcode, 3 + dx, 3 + dy, false);
+				setModuleBounded(qrcode, qrsize - 4 + dx, 3 + dy, false);
+				setModuleBounded(qrcode, 3 + dx, qrsize - 4 + dy, false);
+			}
+		}
+	}
+	
+	// Draw numerous alignment patterns
+	uint8_t alignPatPos[7];
+	int numAlign = getAlignmentPatternPositions(version, alignPatPos);
+	for (int i = 0; i < numAlign; i++) {
+		for (int j = 0; j < numAlign; j++) {
+			if ((i == 0 && j == 0) || (i == 0 && j == numAlign - 1) || (i == numAlign - 1 && j == 0))
+				continue;  // Don't draw on the three finder corners
+			for (int dy = -1; dy <= 1; dy++) {
+				for (int dx = -1; dx <= 1; dx++)
+					setModule(qrcode, alignPatPos[i] + dx, alignPatPos[j] + dy, dx == 0 && dy == 0);
+			}
+		}
+	}
+	
+	// Draw version blocks
+	if (version >= 7) {
+		// Calculate error correction code and pack bits
+		int rem = version;  // version is uint6, in the range [7, 40]
+		for (int i = 0; i < 12; i++)
+			rem = (rem << 1) ^ ((rem >> 11) * 0x1F25);
+		long bits = (long)version << 12 | rem;  // uint18
+		assert(bits >> 18 == 0);
+		
+		// Draw two copies
+		for (int i = 0; i < 6; i++) {
+			for (int j = 0; j < 3; j++) {
+				int k = qrsize - 11 + j;
+				setModule(qrcode, k, i, (bits & 1) != 0);
+				setModule(qrcode, i, k, (bits & 1) != 0);
+				bits >>= 1;
+			}
+		}
+	}
+}
+
+
+// Draws two copies of the format bits (with its own error correction code) based
+// on the given mask and error correction level. This always draws all modules of
+// the format bits, unlike drawWhiteFunctionModules() which might skip black modules.
+static void drawFormatBits(enum qrcodegen_Ecc ecl, enum qrcodegen_Mask mask, uint8_t qrcode[]) {
+	// Calculate error correction code and pack bits
+	assert(0 <= (int)mask && (int)mask <= 7);
+	static const int table[] = {1, 0, 3, 2};
+	int data = table[(int)ecl] << 3 | (int)mask;  // errCorrLvl is uint2, mask is uint3
+	int rem = data;
+	for (int i = 0; i < 10; i++)
+		rem = (rem << 1) ^ ((rem >> 9) * 0x537);
+	int bits = (data << 10 | rem) ^ 0x5412;  // uint15
+	assert(bits >> 15 == 0);
+	
+	// Draw first copy
+	for (int i = 0; i <= 5; i++)
+		setModule(qrcode, 8, i, getBit(bits, i));
+	setModule(qrcode, 8, 7, getBit(bits, 6));
+	setModule(qrcode, 8, 8, getBit(bits, 7));
+	setModule(qrcode, 7, 8, getBit(bits, 8));
+	for (int i = 9; i < 15; i++)
+		setModule(qrcode, 14 - i, 8, getBit(bits, i));
+	
+	// Draw second copy
+	int qrsize = qrcodegen_getSize(qrcode);
+	for (int i = 0; i < 8; i++)
+		setModule(qrcode, qrsize - 1 - i, 8, getBit(bits, i));
+	for (int i = 8; i < 15; i++)
+		setModule(qrcode, 8, qrsize - 15 + i, getBit(bits, i));
+	setModule(qrcode, 8, qrsize - 8, true);  // Always black
+}
+
+
+// Calculates and stores an ascending list of positions of alignment patterns
+// for this version number, returning the length of the list (in the range [0,7]).
+// Each position is in the range [0,177), and are used on both the x and y axes.
+// This could be implemented as lookup table of 40 variable-length lists of unsigned bytes.
+testable int getAlignmentPatternPositions(int version, uint8_t result[7]) {
+	if (version == 1)
+		return 0;
+	int numAlign = version / 7 + 2;
+	int step = (version == 32) ? 26 :
+		(version*4 + numAlign*2 + 1) / (numAlign*2 - 2) * 2;
+	for (int i = numAlign - 1, pos = version * 4 + 10; i >= 1; i--, pos -= step)
+		result[i] = (uint8_t)pos;
+	result[0] = 6;
+	return numAlign;
+}
+
+
+// Sets every pixel in the range [left : left + width] * [top : top + height] to black.
+static void fillRectangle(int left, int top, int width, int height, uint8_t qrcode[]) {
+	for (int dy = 0; dy < height; dy++) {
+		for (int dx = 0; dx < width; dx++)
+			setModule(qrcode, left + dx, top + dy, true);
+	}
+}
+
+
+
+/*---- Drawing data modules and masking ----*/
+
+// Draws the raw codewords (including data and ECC) onto the given QR Code. This requires the initial state of
+// the QR Code to be black at function modules and white at codeword modules (including unused remainder bits).
+static void drawCodewords(const uint8_t data[], int dataLen, uint8_t qrcode[]) {
+	int qrsize = qrcodegen_getSize(qrcode);
+	int i = 0;  // Bit index into the data
+	// Do the funny zigzag scan
+	for (int right = qrsize - 1; right >= 1; right -= 2) {  // Index of right column in each column pair
+		if (right == 6)
+			right = 5;
+		for (int vert = 0; vert < qrsize; vert++) {  // Vertical counter
+			for (int j = 0; j < 2; j++) {
+				int x = right - j;  // Actual x coordinate
+				bool upward = ((right + 1) & 2) == 0;
+				int y = upward ? qrsize - 1 - vert : vert;  // Actual y coordinate
+				if (!getModule(qrcode, x, y) && i < dataLen * 8) {
+					bool black = getBit(data[i >> 3], 7 - (i & 7));
+					setModule(qrcode, x, y, black);
+					i++;
+				}
+				// If this QR Code has any remainder bits (0 to 7), they were assigned as
+				// 0/false/white by the constructor and are left unchanged by this method
+			}
+		}
+	}
+	assert(i == dataLen * 8);
+}
+
+
+// XORs the codeword modules in this QR Code with the given mask pattern.
+// The function modules must be marked and the codeword bits must be drawn
+// before masking. Due to the arithmetic of XOR, calling applyMask() with
+// the same mask value a second time will undo the mask. A final well-formed
+// QR Code needs exactly one (not zero, two, etc.) mask applied.
+static void applyMask(const uint8_t functionModules[], uint8_t qrcode[], enum qrcodegen_Mask mask) {
+	assert(0 <= (int)mask && (int)mask <= 7);  // Disallows qrcodegen_Mask_AUTO
+	int qrsize = qrcodegen_getSize(qrcode);
+	for (int y = 0; y < qrsize; y++) {
+		for (int x = 0; x < qrsize; x++) {
+			if (getModule(functionModules, x, y))
+				continue;
+			bool invert;
+			switch ((int)mask) {
+				case 0:  invert = (x + y) % 2 == 0;                    break;
+				case 1:  invert = y % 2 == 0;                          break;
+				case 2:  invert = x % 3 == 0;                          break;
+				case 3:  invert = (x + y) % 3 == 0;                    break;
+				case 4:  invert = (x / 3 + y / 2) % 2 == 0;            break;
+				case 5:  invert = x * y % 2 + x * y % 3 == 0;          break;
+				case 6:  invert = (x * y % 2 + x * y % 3) % 2 == 0;    break;
+				case 7:  invert = ((x + y) % 2 + x * y % 3) % 2 == 0;  break;
+				default:  assert(false);  return;
+			}
+			bool val = getModule(qrcode, x, y);
+			setModule(qrcode, x, y, val ^ invert);
+		}
+	}
+}
+
+
+// Calculates and returns the penalty score based on state of the given QR Code's current modules.
+// This is used by the automatic mask choice algorithm to find the mask pattern that yields the lowest score.
+static long getPenaltyScore(const uint8_t qrcode[]) {
+	int qrsize = qrcodegen_getSize(qrcode);
+	long result = 0;
+	
+	// Adjacent modules in row having same color, and finder-like patterns
+	for (int y = 0; y < qrsize; y++) {
+		bool runColor = false;
+		int runX = 0;
+		int runHistory[7] = {0};
+		int padRun = qrsize;  // Add white border to initial run
+		for (int x = 0; x < qrsize; x++) {
+			if (getModule(qrcode, x, y) == runColor) {
+				runX++;
+				if (runX == 5)
+					result += PENALTY_N1;
+				else if (runX > 5)
+					result++;
+			} else {
+				finderPenaltyAddHistory(runX + padRun, runHistory);
+				padRun = 0;
+				if (!runColor)
+					result += finderPenaltyCountPatterns(runHistory, qrsize) * PENALTY_N3;
+				runColor = getModule(qrcode, x, y);
+				runX = 1;
+			}
+		}
+		result += finderPenaltyTerminateAndCount(runColor, runX + padRun, runHistory, qrsize) * PENALTY_N3;
+	}
+	// Adjacent modules in column having same color, and finder-like patterns
+	for (int x = 0; x < qrsize; x++) {
+		bool runColor = false;
+		int runY = 0;
+		int runHistory[7] = {0};
+		int padRun = qrsize;  // Add white border to initial run
+		for (int y = 0; y < qrsize; y++) {
+			if (getModule(qrcode, x, y) == runColor) {
+				runY++;
+				if (runY == 5)
+					result += PENALTY_N1;
+				else if (runY > 5)
+					result++;
+			} else {
+				finderPenaltyAddHistory(runY + padRun, runHistory);
+				padRun = 0;
+				if (!runColor)
+					result += finderPenaltyCountPatterns(runHistory, qrsize) * PENALTY_N3;
+				runColor = getModule(qrcode, x, y);
+				runY = 1;
+			}
+		}
+		result += finderPenaltyTerminateAndCount(runColor, runY + padRun, runHistory, qrsize) * PENALTY_N3;
+	}
+	
+	// 2*2 blocks of modules having same color
+	for (int y = 0; y < qrsize - 1; y++) {
+		for (int x = 0; x < qrsize - 1; x++) {
+			bool  color = getModule(qrcode, x, y);
+			if (  color == getModule(qrcode, x + 1, y) &&
+			      color == getModule(qrcode, x, y + 1) &&
+			      color == getModule(qrcode, x + 1, y + 1))
+				result += PENALTY_N2;
+		}
+	}
+	
+	// Balance of black and white modules
+	int black = 0;
+	for (int y = 0; y < qrsize; y++) {
+		for (int x = 0; x < qrsize; x++) {
+			if (getModule(qrcode, x, y))
+				black++;
+		}
+	}
+	int total = qrsize * qrsize;  // Note that size is odd, so black/total != 1/2
+	// Compute the smallest integer k >= 0 such that (45-5k)% <= black/total <= (55+5k)%
+	int k = (int)((labs(black * 20L - total * 10L) + total - 1) / total) - 1;
+	result += k * PENALTY_N4;
+	return result;
+}
+
+
+// Can only be called immediately after a white run is added, and
+// returns either 0, 1, or 2. A helper function for getPenaltyScore().
+static int finderPenaltyCountPatterns(const int runHistory[7], int qrsize) {
+	int n = runHistory[1];
+	assert(n <= qrsize * 3);
+	bool core = n > 0 && runHistory[2] == n && runHistory[3] == n * 3 && runHistory[4] == n && runHistory[5] == n;
+	// The maximum QR Code size is 177, hence the black run length n <= 177.
+	// Arithmetic is promoted to int, so n*4 will not overflow.
+	return (core && runHistory[0] >= n * 4 && runHistory[6] >= n ? 1 : 0)
+	     + (core && runHistory[6] >= n * 4 && runHistory[0] >= n ? 1 : 0);
+}
+
+
+// Must be called at the end of a line (row or column) of modules. A helper function for getPenaltyScore().
+static int finderPenaltyTerminateAndCount(bool currentRunColor, int currentRunLength, int runHistory[7], int qrsize) {
+	if (currentRunColor) {  // Terminate black run
+		finderPenaltyAddHistory(currentRunLength, runHistory);
+		currentRunLength = 0;
+	}
+	currentRunLength += qrsize;  // Add white border to final run
+	finderPenaltyAddHistory(currentRunLength, runHistory);
+	return finderPenaltyCountPatterns(runHistory, qrsize);
+}
+
+
+// Pushes the given value to the front and drops the last value. A helper function for getPenaltyScore().
+static void finderPenaltyAddHistory(int currentRunLength, int runHistory[7]) {
+	memmove(&runHistory[1], &runHistory[0], 6 * sizeof(runHistory[0]));
+	runHistory[0] = currentRunLength;
+}
+
+
+
+/*---- Basic QR Code information ----*/
+
+// Public function - see documentation comment in header file.
+int qrcodegen_getSize(const uint8_t qrcode[]) {
+	assert(qrcode != NULL);
+	int result = qrcode[0];
+	assert((qrcodegen_VERSION_MIN * 4 + 17) <= result
+		&& result <= (qrcodegen_VERSION_MAX * 4 + 17));
+	return result;
+}
+
+
+// Public function - see documentation comment in header file.
+bool qrcodegen_getModule(const uint8_t qrcode[], int x, int y) {
+	assert(qrcode != NULL);
+	int qrsize = qrcode[0];
+	return (0 <= x && x < qrsize && 0 <= y && y < qrsize) && getModule(qrcode, x, y);
+}
+
+
+// Gets the module at the given coordinates, which must be in bounds.
+testable bool getModule(const uint8_t qrcode[], int x, int y) {
+	int qrsize = qrcode[0];
+	assert(21 <= qrsize && qrsize <= 177 && 0 <= x && x < qrsize && 0 <= y && y < qrsize);
+	int index = y * qrsize + x;
+	return getBit(qrcode[(index >> 3) + 1], index & 7);
+}
+
+
+// Sets the module at the given coordinates, which must be in bounds.
+testable void setModule(uint8_t qrcode[], int x, int y, bool isBlack) {
+	int qrsize = qrcode[0];
+	assert(21 <= qrsize && qrsize <= 177 && 0 <= x && x < qrsize && 0 <= y && y < qrsize);
+	int index = y * qrsize + x;
+	int bitIndex = index & 7;
+	int byteIndex = (index >> 3) + 1;
+	if (isBlack)
+		qrcode[byteIndex] |= 1 << bitIndex;
+	else
+		qrcode[byteIndex] &= (1 << bitIndex) ^ 0xFF;
+}
+
+
+// Sets the module at the given coordinates, doing nothing if out of bounds.
+testable void setModuleBounded(uint8_t qrcode[], int x, int y, bool isBlack) {
+	int qrsize = qrcode[0];
+	if (0 <= x && x < qrsize && 0 <= y && y < qrsize)
+		setModule(qrcode, x, y, isBlack);
+}
+
+
+// Returns true iff the i'th bit of x is set to 1. Requires x >= 0 and 0 <= i <= 14.
+static bool getBit(int x, int i) {
+	return ((x >> i) & 1) != 0;
+}
+
+
+
+/*---- Segment handling ----*/
+
+// Public function - see documentation comment in header file.
+bool qrcodegen_isAlphanumeric(const char *text) {
+	assert(text != NULL);
+	for (; *text != '\0'; text++) {
+		if (strchr(ALPHANUMERIC_CHARSET, *text) == NULL)
+			return false;
+	}
+	return true;
+}
+
+
+// Public function - see documentation comment in header file.
+bool qrcodegen_isNumeric(const char *text) {
+	assert(text != NULL);
+	for (; *text != '\0'; text++) {
+		if (*text < '0' || *text > '9')
+			return false;
+	}
+	return true;
+}
+
+
+// Public function - see documentation comment in header file.
+size_t qrcodegen_calcSegmentBufferSize(enum qrcodegen_Mode mode, size_t numChars) {
+	int temp = calcSegmentBitLength(mode, numChars);
+	if (temp == -1)
+		return SIZE_MAX;
+	assert(0 <= temp && temp <= INT16_MAX);
+	return ((size_t)temp + 7) / 8;
+}
+
+
+// Returns the number of data bits needed to represent a segment
+// containing the given number of characters using the given mode. Notes:
+// - Returns -1 on failure, i.e. numChars > INT16_MAX or
+//   the number of needed bits exceeds INT16_MAX (i.e. 32767).
+// - Otherwise, all valid results are in the range [0, INT16_MAX].
+// - For byte mode, numChars measures the number of bytes, not Unicode code points.
+// - For ECI mode, numChars must be 0, and the worst-case number of bits is returned.
+//   An actual ECI segment can have shorter data. For non-ECI modes, the result is exact.
+testable int calcSegmentBitLength(enum qrcodegen_Mode mode, size_t numChars) {
+	// All calculations are designed to avoid overflow on all platforms
+	if (numChars > (unsigned int)INT16_MAX)
+		return -1;
+	long result = (long)numChars;
+	if (mode == qrcodegen_Mode_NUMERIC)
+		result = (result * 10 + 2) / 3;  // ceil(10/3 * n)
+	else if (mode == qrcodegen_Mode_ALPHANUMERIC)
+		result = (result * 11 + 1) / 2;  // ceil(11/2 * n)
+	else if (mode == qrcodegen_Mode_BYTE)
+		result *= 8;
+	else if (mode == qrcodegen_Mode_KANJI)
+		result *= 13;
+	else if (mode == qrcodegen_Mode_ECI && numChars == 0)
+		result = 3 * 8;
+	else {  // Invalid argument
+		assert(false);
+		return -1;
+	}
+	assert(result >= 0);
+	if (result > INT16_MAX)
+		return -1;
+	return (int)result;
+}
+
+
+// Public function - see documentation comment in header file.
+struct qrcodegen_Segment qrcodegen_makeBytes(const uint8_t data[], size_t len, uint8_t buf[]) {
+	assert(data != NULL || len == 0);
+	struct qrcodegen_Segment result;
+	result.mode = qrcodegen_Mode_BYTE;
+	result.bitLength = calcSegmentBitLength(result.mode, len);
+	assert(result.bitLength != -1);
+	result.numChars = (int)len;
+	if (len > 0)
+		memcpy(buf, data, len * sizeof(buf[0]));
+	result.data = buf;
+	return result;
+}
+
+
+// Public function - see documentation comment in header file.
+struct qrcodegen_Segment qrcodegen_makeNumeric(const char *digits, uint8_t buf[]) {
+	assert(digits != NULL);
+	struct qrcodegen_Segment result;
+	size_t len = strlen(digits);
+	result.mode = qrcodegen_Mode_NUMERIC;
+	int bitLen = calcSegmentBitLength(result.mode, len);
+	assert(bitLen != -1);
+	result.numChars = (int)len;
+	if (bitLen > 0)
+		memset(buf, 0, ((size_t)bitLen + 7) / 8 * sizeof(buf[0]));
+	result.bitLength = 0;
+	
+	unsigned int accumData = 0;
+	int accumCount = 0;
+	for (; *digits != '\0'; digits++) {
+		char c = *digits;
+		assert('0' <= c && c <= '9');
+		accumData = accumData * 10 + (unsigned int)(c - '0');
+		accumCount++;
+		if (accumCount == 3) {
+			appendBitsToBuffer(accumData, 10, buf, &result.bitLength);
+			accumData = 0;
+			accumCount = 0;
+		}
+	}
+	if (accumCount > 0)  // 1 or 2 digits remaining
+		appendBitsToBuffer(accumData, accumCount * 3 + 1, buf, &result.bitLength);
+	assert(result.bitLength == bitLen);
+	result.data = buf;
+	return result;
+}
+
+
+// Public function - see documentation comment in header file.
+struct qrcodegen_Segment qrcodegen_makeAlphanumeric(const char *text, uint8_t buf[]) {
+	assert(text != NULL);
+	struct qrcodegen_Segment result;
+	size_t len = strlen(text);
+	result.mode = qrcodegen_Mode_ALPHANUMERIC;
+	int bitLen = calcSegmentBitLength(result.mode, len);
+	assert(bitLen != -1);
+	result.numChars = (int)len;
+	if (bitLen > 0)
+		memset(buf, 0, ((size_t)bitLen + 7) / 8 * sizeof(buf[0]));
+	result.bitLength = 0;
+	
+	unsigned int accumData = 0;
+	int accumCount = 0;
+	for (; *text != '\0'; text++) {
+		const char *temp = strchr(ALPHANUMERIC_CHARSET, *text);
+		assert(temp != NULL);
+		accumData = accumData * 45 + (unsigned int)(temp - ALPHANUMERIC_CHARSET);
+		accumCount++;
+		if (accumCount == 2) {
+			appendBitsToBuffer(accumData, 11, buf, &result.bitLength);
+			accumData = 0;
+			accumCount = 0;
+		}
+	}
+	if (accumCount > 0)  // 1 character remaining
+		appendBitsToBuffer(accumData, 6, buf, &result.bitLength);
+	assert(result.bitLength == bitLen);
+	result.data = buf;
+	return result;
+}
+
+
+// Public function - see documentation comment in header file.
+struct qrcodegen_Segment qrcodegen_makeEci(long assignVal, uint8_t buf[]) {
+	struct qrcodegen_Segment result;
+	result.mode = qrcodegen_Mode_ECI;
+	result.numChars = 0;
+	result.bitLength = 0;
+	if (assignVal < 0)
+		assert(false);
+	else if (assignVal < (1 << 7)) {
+		memset(buf, 0, 1 * sizeof(buf[0]));
+		appendBitsToBuffer((unsigned int)assignVal, 8, buf, &result.bitLength);
+	} else if (assignVal < (1 << 14)) {
+		memset(buf, 0, 2 * sizeof(buf[0]));
+		appendBitsToBuffer(2, 2, buf, &result.bitLength);
+		appendBitsToBuffer((unsigned int)assignVal, 14, buf, &result.bitLength);
+	} else if (assignVal < 1000000L) {
+		memset(buf, 0, 3 * sizeof(buf[0]));
+		appendBitsToBuffer(6, 3, buf, &result.bitLength);
+		appendBitsToBuffer((unsigned int)(assignVal >> 10), 11, buf, &result.bitLength);
+		appendBitsToBuffer((unsigned int)(assignVal & 0x3FF), 10, buf, &result.bitLength);
+	} else
+		assert(false);
+	result.data = buf;
+	return result;
+}
+
+
+// Calculates the number of bits needed to encode the given segments at the given version.
+// Returns a non-negative number if successful. Otherwise returns -1 if a segment has too
+// many characters to fit its length field, or the total bits exceeds INT16_MAX.
+testable int getTotalBits(const struct qrcodegen_Segment segs[], size_t len, int version) {
+	assert(segs != NULL || len == 0);
+	long result = 0;
+	for (size_t i = 0; i < len; i++) {
+		int numChars  = segs[i].numChars;
+		int bitLength = segs[i].bitLength;
+		assert(0 <= numChars  && numChars  <= INT16_MAX);
+		assert(0 <= bitLength && bitLength <= INT16_MAX);
+		int ccbits = numCharCountBits(segs[i].mode, version);
+		assert(0 <= ccbits && ccbits <= 16);
+		if (numChars >= (1L << ccbits))
+			return -1;  // The segment's length doesn't fit the field's bit width
+		result += 4L + ccbits + bitLength;
+		if (result > INT16_MAX)
+			return -1;  // The sum might overflow an int type
+	}
+	assert(0 <= result && result <= INT16_MAX);
+	return (int)result;
+}
+
+
+// Returns the bit width of the character count field for a segment in the given mode
+// in a QR Code at the given version number. The result is in the range [0, 16].
+static int numCharCountBits(enum qrcodegen_Mode mode, int version) {
+	assert(qrcodegen_VERSION_MIN <= version && version <= qrcodegen_VERSION_MAX);
+	int i = (version + 7) / 17;
+	switch (mode) {
+		case qrcodegen_Mode_NUMERIC     : { static const int temp[] = {10, 12, 14}; return temp[i]; }
+		case qrcodegen_Mode_ALPHANUMERIC: { static const int temp[] = { 9, 11, 13}; return temp[i]; }
+		case qrcodegen_Mode_BYTE        : { static const int temp[] = { 8, 16, 16}; return temp[i]; }
+		case qrcodegen_Mode_KANJI       : { static const int temp[] = { 8, 10, 12}; return temp[i]; }
+		case qrcodegen_Mode_ECI         : return 0;
+		default:  assert(false);  return -1;  // Dummy value
+	}
+}
diff --git a/Telegram/ThirdParty/QR/c/qrcodegen.h b/Telegram/ThirdParty/QR/c/qrcodegen.h
new file mode 100644
index 0000000..a99b94d
--- /dev/null
+++ b/Telegram/ThirdParty/QR/c/qrcodegen.h
@@ -0,0 +1,311 @@
+/* 
+ * QR Code generator library (C)
+ * 
+ * Copyright (c) Project Nayuki. (MIT License)
+ * https://www.nayuki.io/page/qr-code-generator-library
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ * - The above copyright notice and this permission notice shall be included in
+ *   all copies or substantial portions of the Software.
+ * - The Software is provided "as is", without warranty of any kind, express or
+ *   implied, including but not limited to the warranties of merchantability,
+ *   fitness for a particular purpose and noninfringement. In no event shall the
+ *   authors or copyright holders be liable for any claim, damages or other
+ *   liability, whether in an action of contract, tort or otherwise, arising from,
+ *   out of or in connection with the Software or the use or other dealings in the
+ *   Software.
+ */
+
+#pragma once
+
+#include <stdbool.h>
+#include <stddef.h>
+#include <stdint.h>
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* 
+ * This library creates QR Code symbols, which is a type of two-dimension barcode.
+ * Invented by Denso Wave and described in the ISO/IEC 18004 standard.
+ * A QR Code structure is an immutable square grid of black and white cells.
+ * The library provides functions to create a QR Code from text or binary data.
+ * The library covers the QR Code Model 2 specification, supporting all versions (sizes)
+ * from 1 to 40, all 4 error correction levels, and 4 character encoding modes.
+ * 
+ * Ways to create a QR Code object:
+ * - High level: Take the payload data and call qrcodegen_encodeText() or qrcodegen_encodeBinary().
+ * - Low level: Custom-make the list of segments and call
+ *   qrcodegen_encodeSegments() or qrcodegen_encodeSegmentsAdvanced().
+ * (Note that all ways require supplying the desired error correction level and various byte buffers.)
+ */
+
+
+/*---- Enum and struct types----*/
+
+/* 
+ * The error correction level in a QR Code symbol.
+ */
+enum qrcodegen_Ecc {
+	// Must be declared in ascending order of error protection
+	// so that an internal qrcodegen function works properly
+	qrcodegen_Ecc_LOW = 0 ,  // The QR Code can tolerate about  7% erroneous codewords
+	qrcodegen_Ecc_MEDIUM  ,  // The QR Code can tolerate about 15% erroneous codewords
+	qrcodegen_Ecc_QUARTILE,  // The QR Code can tolerate about 25% erroneous codewords
+	qrcodegen_Ecc_HIGH    ,  // The QR Code can tolerate about 30% erroneous codewords
+};
+
+
+/* 
+ * The mask pattern used in a QR Code symbol.
+ */
+enum qrcodegen_Mask {
+	// A special value to tell the QR Code encoder to
+	// automatically select an appropriate mask pattern
+	qrcodegen_Mask_AUTO = -1,
+	// The eight actual mask patterns
+	qrcodegen_Mask_0 = 0,
+	qrcodegen_Mask_1,
+	qrcodegen_Mask_2,
+	qrcodegen_Mask_3,
+	qrcodegen_Mask_4,
+	qrcodegen_Mask_5,
+	qrcodegen_Mask_6,
+	qrcodegen_Mask_7,
+};
+
+
+/* 
+ * Describes how a segment's data bits are interpreted.
+ */
+enum qrcodegen_Mode {
+	qrcodegen_Mode_NUMERIC      = 0x1,
+	qrcodegen_Mode_ALPHANUMERIC = 0x2,
+	qrcodegen_Mode_BYTE         = 0x4,
+	qrcodegen_Mode_KANJI        = 0x8,
+	qrcodegen_Mode_ECI          = 0x7,
+};
+
+
+/* 
+ * A segment of character/binary/control data in a QR Code symbol.
+ * The mid-level way to create a segment is to take the payload data
+ * and call a factory function such as qrcodegen_makeNumeric().
+ * The low-level way to create a segment is to custom-make the bit buffer
+ * and initialize a qrcodegen_Segment struct with appropriate values.
+ * Even in the most favorable conditions, a QR Code can only hold 7089 characters of data.
+ * Any segment longer than this is meaningless for the purpose of generating QR Codes.
+ * Moreover, the maximum allowed bit length is 32767 because
+ * the largest QR Code (version 40) has 31329 modules.
+ */
+struct qrcodegen_Segment {
+	// The mode indicator of this segment.
+	enum qrcodegen_Mode mode;
+	
+	// The length of this segment's unencoded data. Measured in characters for
+	// numeric/alphanumeric/kanji mode, bytes for byte mode, and 0 for ECI mode.
+	// Always zero or positive. Not the same as the data's bit length.
+	int numChars;
+	
+	// The data bits of this segment, packed in bitwise big endian.
+	// Can be null if the bit length is zero.
+	uint8_t *data;
+	
+	// The number of valid data bits used in the buffer. Requires
+	// 0 <= bitLength <= 32767, and bitLength <= (capacity of data array) * 8.
+	// The character count (numChars) must agree with the mode and the bit buffer length.
+	int bitLength;
+};
+
+
+
+/*---- Macro constants and functions ----*/
+
+#define qrcodegen_VERSION_MIN   1  // The minimum version number supported in the QR Code Model 2 standard
+#define qrcodegen_VERSION_MAX  40  // The maximum version number supported in the QR Code Model 2 standard
+
+// Calculates the number of bytes needed to store any QR Code up to and including the given version number,
+// as a compile-time constant. For example, 'uint8_t buffer[qrcodegen_BUFFER_LEN_FOR_VERSION(25)];'
+// can store any single QR Code from version 1 to 25 (inclusive). The result fits in an int (or int16).
+// Requires qrcodegen_VERSION_MIN <= n <= qrcodegen_VERSION_MAX.
+#define qrcodegen_BUFFER_LEN_FOR_VERSION(n)  ((((n) * 4 + 17) * ((n) * 4 + 17) + 7) / 8 + 1)
+
+// The worst-case number of bytes needed to store one QR Code, up to and including
+// version 40. This value equals 3918, which is just under 4 kilobytes.
+// Use this more convenient value to avoid calculating tighter memory bounds for buffers.
+#define qrcodegen_BUFFER_LEN_MAX  qrcodegen_BUFFER_LEN_FOR_VERSION(qrcodegen_VERSION_MAX)
+
+
+
+/*---- Functions (high level) to generate QR Codes ----*/
+
+/* 
+ * Encodes the given text string to a QR Code, returning true if encoding succeeded.
+ * If the data is too long to fit in any version in the given range
+ * at the given ECC level, then false is returned.
+ * - The input text must be encoded in UTF-8 and contain no NULs.
+ * - The variables ecl and mask must correspond to enum constant values.
+ * - Requires 1 <= minVersion <= maxVersion <= 40.
+ * - The arrays tempBuffer and qrcode must each have a length
+ *   of at least qrcodegen_BUFFER_LEN_FOR_VERSION(maxVersion).
+ * - After the function returns, tempBuffer contains no useful data.
+ * - If successful, the resulting QR Code may use numeric,
+ *   alphanumeric, or byte mode to encode the text.
+ * - In the most optimistic case, a QR Code at version 40 with low ECC
+ *   can hold any UTF-8 string up to 2953 bytes, or any alphanumeric string
+ *   up to 4296 characters, or any digit string up to 7089 characters.
+ *   These numbers represent the hard upper limit of the QR Code standard.
+ * - Please consult the QR Code specification for information on
+ *   data capacities per version, ECC level, and text encoding mode.
+ */
+bool qrcodegen_encodeText(const char *text, uint8_t tempBuffer[], uint8_t qrcode[],
+	enum qrcodegen_Ecc ecl, int minVersion, int maxVersion, enum qrcodegen_Mask mask, bool boostEcl);
+
+
+/* 
+ * Encodes the given binary data to a QR Code, returning true if encoding succeeded.
+ * If the data is too long to fit in any version in the given range
+ * at the given ECC level, then false is returned.
+ * - The input array range dataAndTemp[0 : dataLen] should normally be
+ *   valid UTF-8 text, but is not required by the QR Code standard.
+ * - The variables ecl and mask must correspond to enum constant values.
+ * - Requires 1 <= minVersion <= maxVersion <= 40.
+ * - The arrays dataAndTemp and qrcode must each have a length
+ *   of at least qrcodegen_BUFFER_LEN_FOR_VERSION(maxVersion).
+ * - After the function returns, the contents of dataAndTemp may have changed,
+ *   and does not represent useful data anymore.
+ * - If successful, the resulting QR Code will use byte mode to encode the data.
+ * - In the most optimistic case, a QR Code at version 40 with low ECC can hold any byte
+ *   sequence up to length 2953. This is the hard upper limit of the QR Code standard.
+ * - Please consult the QR Code specification for information on
+ *   data capacities per version, ECC level, and text encoding mode.
+ */
+bool qrcodegen_encodeBinary(uint8_t dataAndTemp[], size_t dataLen, uint8_t qrcode[],
+	enum qrcodegen_Ecc ecl, int minVersion, int maxVersion, enum qrcodegen_Mask mask, bool boostEcl);
+
+
+/*---- Functions (low level) to generate QR Codes ----*/
+
+/* 
+ * Renders a QR Code representing the given segments at the given error correction level.
+ * The smallest possible QR Code version is automatically chosen for the output. Returns true if
+ * QR Code creation succeeded, or false if the data is too long to fit in any version. The ECC level
+ * of the result may be higher than the ecl argument if it can be done without increasing the version.
+ * This function allows the user to create a custom sequence of segments that switches
+ * between modes (such as alphanumeric and byte) to encode text in less space.
+ * This is a low-level API; the high-level API is qrcodegen_encodeText() and qrcodegen_encodeBinary().
+ * To save memory, the segments' data buffers can alias/overlap tempBuffer, and will
+ * result in them being clobbered, but the QR Code output will still be correct.
+ * But the qrcode array must not overlap tempBuffer or any segment's data buffer.
+ */
+bool qrcodegen_encodeSegments(const struct qrcodegen_Segment segs[], size_t len,
+	enum qrcodegen_Ecc ecl, uint8_t tempBuffer[], uint8_t qrcode[]);
+
+
+/* 
+ * Renders a QR Code representing the given segments with the given encoding parameters.
+ * Returns true if QR Code creation succeeded, or false if the data is too long to fit in the range of versions.
+ * The smallest possible QR Code version within the given range is automatically
+ * chosen for the output. Iff boostEcl is true, then the ECC level of the result
+ * may be higher than the ecl argument if it can be done without increasing the
+ * version. The mask is either between qrcodegen_Mask_0 to 7 to force that mask, or
+ * qrcodegen_Mask_AUTO to automatically choose an appropriate mask (which may be slow).
+ * This function allows the user to create a custom sequence of segments that switches
+ * between modes (such as alphanumeric and byte) to encode text in less space.
+ * This is a low-level API; the high-level API is qrcodegen_encodeText() and qrcodegen_encodeBinary().
+ * To save memory, the segments' data buffers can alias/overlap tempBuffer, and will
+ * result in them being clobbered, but the QR Code output will still be correct.
+ * But the qrcode array must not overlap tempBuffer or any segment's data buffer.
+ */
+bool qrcodegen_encodeSegmentsAdvanced(const struct qrcodegen_Segment segs[], size_t len, enum qrcodegen_Ecc ecl,
+	int minVersion, int maxVersion, enum qrcodegen_Mask mask, bool boostEcl, uint8_t tempBuffer[], uint8_t qrcode[]);
+
+
+/* 
+ * Tests whether the given string can be encoded as a segment in alphanumeric mode.
+ * A string is encodable iff each character is in the following set: 0 to 9, A to Z
+ * (uppercase only), space, dollar, percent, asterisk, plus, hyphen, period, slash, colon.
+ */
+bool qrcodegen_isAlphanumeric(const char *text);
+
+
+/* 
+ * Tests whether the given string can be encoded as a segment in numeric mode.
+ * A string is encodable iff each character is in the range 0 to 9.
+ */
+bool qrcodegen_isNumeric(const char *text);
+
+
+/* 
+ * Returns the number of bytes (uint8_t) needed for the data buffer of a segment
+ * containing the given number of characters using the given mode. Notes:
+ * - Returns SIZE_MAX on failure, i.e. numChars > INT16_MAX or
+ *   the number of needed bits exceeds INT16_MAX (i.e. 32767).
+ * - Otherwise, all valid results are in the range [0, ceil(INT16_MAX / 8)], i.e. at most 4096.
+ * - It is okay for the user to allocate more bytes for the buffer than needed.
+ * - For byte mode, numChars measures the number of bytes, not Unicode code points.
+ * - For ECI mode, numChars must be 0, and the worst-case number of bytes is returned.
+ *   An actual ECI segment can have shorter data. For non-ECI modes, the result is exact.
+ */
+size_t qrcodegen_calcSegmentBufferSize(enum qrcodegen_Mode mode, size_t numChars);
+
+
+/* 
+ * Returns a segment representing the given binary data encoded in
+ * byte mode. All input byte arrays are acceptable. Any text string
+ * can be converted to UTF-8 bytes and encoded as a byte mode segment.
+ */
+struct qrcodegen_Segment qrcodegen_makeBytes(const uint8_t data[], size_t len, uint8_t buf[]);
+
+
+/* 
+ * Returns a segment representing the given string of decimal digits encoded in numeric mode.
+ */
+struct qrcodegen_Segment qrcodegen_makeNumeric(const char *digits, uint8_t buf[]);
+
+
+/* 
+ * Returns a segment representing the given text string encoded in alphanumeric mode.
+ * The characters allowed are: 0 to 9, A to Z (uppercase only), space,
+ * dollar, percent, asterisk, plus, hyphen, period, slash, colon.
+ */
+struct qrcodegen_Segment qrcodegen_makeAlphanumeric(const char *text, uint8_t buf[]);
+
+
+/* 
+ * Returns a segment representing an Extended Channel Interpretation
+ * (ECI) designator with the given assignment value.
+ */
+struct qrcodegen_Segment qrcodegen_makeEci(long assignVal, uint8_t buf[]);
+
+
+/*---- Functions to extract raw data from QR Codes ----*/
+
+/* 
+ * Returns the side length of the given QR Code, assuming that encoding succeeded.
+ * The result is in the range [21, 177]. Note that the length of the array buffer
+ * is related to the side length - every 'uint8_t qrcode[]' must have length at least
+ * qrcodegen_BUFFER_LEN_FOR_VERSION(version), which equals ceil(size^2 / 8 + 1).
+ */
+int qrcodegen_getSize(const uint8_t qrcode[]);
+
+
+/* 
+ * Returns the color of the module (pixel) at the given coordinates, which is false
+ * for white or true for black. The top left corner has the coordinates (x=0, y=0).
+ * If the given coordinates are out of bounds, then false (white) is returned.
+ */
+bool qrcodegen_getModule(const uint8_t qrcode[], int x, int y);
+
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/Telegram/ThirdParty/QR/cpp/BitBuffer.cpp b/Telegram/ThirdParty/QR/cpp/BitBuffer.cpp
new file mode 100644
index 0000000..e22e9d3
--- /dev/null
+++ b/Telegram/ThirdParty/QR/cpp/BitBuffer.cpp
@@ -0,0 +1,41 @@
+/* 
+ * QR Code generator library (C++)
+ * 
+ * Copyright (c) Project Nayuki. (MIT License)
+ * https://www.nayuki.io/page/qr-code-generator-library
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ * - The above copyright notice and this permission notice shall be included in
+ *   all copies or substantial portions of the Software.
+ * - The Software is provided "as is", without warranty of any kind, express or
+ *   implied, including but not limited to the warranties of merchantability,
+ *   fitness for a particular purpose and noninfringement. In no event shall the
+ *   authors or copyright holders be liable for any claim, damages or other
+ *   liability, whether in an action of contract, tort or otherwise, arising from,
+ *   out of or in connection with the Software or the use or other dealings in the
+ *   Software.
+ */
+
+#include <stdexcept>
+#include "BitBuffer.hpp"
+
+
+namespace qrcodegen {
+
+BitBuffer::BitBuffer()
+	: std::vector<bool>() {}
+
+
+void BitBuffer::appendBits(std::uint32_t val, int len) {
+	if (len < 0 || len > 31 || val >> len != 0)
+		throw std::domain_error("Value out of range");
+	for (int i = len - 1; i >= 0; i--)  // Append bit by bit
+		this->push_back(((val >> i) & 1) != 0);
+}
+
+}
diff --git a/Telegram/ThirdParty/QR/cpp/BitBuffer.hpp b/Telegram/ThirdParty/QR/cpp/BitBuffer.hpp
new file mode 100644
index 0000000..f30913a
--- /dev/null
+++ b/Telegram/ThirdParty/QR/cpp/BitBuffer.hpp
@@ -0,0 +1,52 @@
+/* 
+ * QR Code generator library (C++)
+ * 
+ * Copyright (c) Project Nayuki. (MIT License)
+ * https://www.nayuki.io/page/qr-code-generator-library
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ * - The above copyright notice and this permission notice shall be included in
+ *   all copies or substantial portions of the Software.
+ * - The Software is provided "as is", without warranty of any kind, express or
+ *   implied, including but not limited to the warranties of merchantability,
+ *   fitness for a particular purpose and noninfringement. In no event shall the
+ *   authors or copyright holders be liable for any claim, damages or other
+ *   liability, whether in an action of contract, tort or otherwise, arising from,
+ *   out of or in connection with the Software or the use or other dealings in the
+ *   Software.
+ */
+
+#pragma once
+
+#include <cstdint>
+#include <vector>
+
+
+namespace qrcodegen {
+
+/* 
+ * An appendable sequence of bits (0s and 1s). Mainly used by QrSegment.
+ */
+class BitBuffer final : public std::vector<bool> {
+	
+	/*---- Constructor ----*/
+	
+	// Creates an empty bit buffer (length 0).
+	public: BitBuffer();
+	
+	
+	
+	/*---- Method ----*/
+	
+	// Appends the given number of low-order bits of the given value
+	// to this buffer. Requires 0 <= len <= 31 and val < 2^len.
+	public: void appendBits(std::uint32_t val, int len);
+	
+};
+
+}
diff --git a/Telegram/ThirdParty/QR/cpp/Makefile b/Telegram/ThirdParty/QR/cpp/Makefile
new file mode 100644
index 0000000..1d32943
--- /dev/null
+++ b/Telegram/ThirdParty/QR/cpp/Makefile
@@ -0,0 +1,84 @@
+# 
+# Makefile for QR Code generator (C++)
+# 
+# Copyright (c) Project Nayuki. (MIT License)
+# https://www.nayuki.io/page/qr-code-generator-library
+# 
+# Permission is hereby granted, free of charge, to any person obtaining a copy of
+# this software and associated documentation files (the "Software"), to deal in
+# the Software without restriction, including without limitation the rights to
+# use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+# the Software, and to permit persons to whom the Software is furnished to do so,
+# subject to the following conditions:
+# - The above copyright notice and this permission notice shall be included in
+#   all copies or substantial portions of the Software.
+# - The Software is provided "as is", without warranty of any kind, express or
+#   implied, including but not limited to the warranties of merchantability,
+#   fitness for a particular purpose and noninfringement. In no event shall the
+#   authors or copyright holders be liable for any claim, damages or other
+#   liability, whether in an action of contract, tort or otherwise, arising from,
+#   out of or in connection with the Software or the use or other dealings in the
+#   Software.
+# 
+
+
+# ---- Configuration options ----
+
+# External/implicit variables:
+# - CXX: The C++ compiler, such as g++ or clang++.
+# - CXXFLAGS: Any extra user-specified compiler flags (can be blank).
+
+# Recommended compiler flags:
+CXXFLAGS += -std=c++11 -O
+
+# Extra flags for diagnostics:
+# CXXFLAGS += -g -Wall -Wextra -Wpedantic -Wconversion -Wsign-conversion -fsanitize=undefined,address
+
+
+# ---- Controlling make ----
+
+# Clear default suffix rules
+.SUFFIXES:
+
+# Don't delete object files
+.SECONDARY:
+
+# Stuff concerning goals
+.DEFAULT_GOAL = all
+.PHONY: all clean
+
+
+# ---- Targets to build ----
+
+LIB = qrcodegen
+LIBFILE = lib$(LIB).a
+LIBOBJ = BitBuffer.o QrCode.o QrSegment.o
+MAINS = QrCodeGeneratorDemo QrCodeGeneratorWorker
+
+# Build all binaries
+all: $(LIBFILE) $(MAINS)
+
+# Delete build output
+clean:
+	rm -f -- $(LIBOBJ) $(LIBFILE) $(MAINS:=.o) $(MAINS)
+	rm -rf .deps
+
+# Executable files
+%: %.o $(LIBFILE)
+	$(CXX) $(CXXFLAGS) -o $@ $< -L . -l $(LIB)
+
+# The library
+$(LIBFILE): $(LIBOBJ)
+	$(AR) -crs $@ -- $^
+
+# Object files
+%.o: %.cpp .deps/timestamp
+	$(CXX) $(CXXFLAGS) -c -o $@ -MMD -MF .deps/$*.d $<
+
+# Have a place to store header dependencies automatically generated by compiler
+.deps/timestamp:
+	mkdir -p .deps
+	touch .deps/timestamp
+
+# Make use of said dependencies if available
+-include .deps/*.d
diff --git a/Telegram/ThirdParty/QR/cpp/QrCode.cpp b/Telegram/ThirdParty/QR/cpp/QrCode.cpp
new file mode 100644
index 0000000..503f39c
--- /dev/null
+++ b/Telegram/ThirdParty/QR/cpp/QrCode.cpp
@@ -0,0 +1,660 @@
+/* 
+ * QR Code generator library (C++)
+ * 
+ * Copyright (c) Project Nayuki. (MIT License)
+ * https://www.nayuki.io/page/qr-code-generator-library
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ * - The above copyright notice and this permission notice shall be included in
+ *   all copies or substantial portions of the Software.
+ * - The Software is provided "as is", without warranty of any kind, express or
+ *   implied, including but not limited to the warranties of merchantability,
+ *   fitness for a particular purpose and noninfringement. In no event shall the
+ *   authors or copyright holders be liable for any claim, damages or other
+ *   liability, whether in an action of contract, tort or otherwise, arising from,
+ *   out of or in connection with the Software or the use or other dealings in the
+ *   Software.
+ */
+
+#include <algorithm>
+#include <climits>
+#include <cstddef>
+#include <cstdlib>
+#include <sstream>
+#include <utility>
+#include "BitBuffer.hpp"
+#include "QrCode.hpp"
+
+using std::int8_t;
+using std::uint8_t;
+using std::size_t;
+using std::vector;
+
+
+namespace qrcodegen {
+
+int QrCode::getFormatBits(Ecc ecl) {
+	switch (ecl) {
+		case Ecc::LOW     :  return 1;
+		case Ecc::MEDIUM  :  return 0;
+		case Ecc::QUARTILE:  return 3;
+		case Ecc::HIGH    :  return 2;
+		default:  throw std::logic_error("Assertion error");
+	}
+}
+
+
+QrCode QrCode::encodeText(const char *text, Ecc ecl) {
+	vector<QrSegment> segs = QrSegment::makeSegments(text);
+	return encodeSegments(segs, ecl);
+}
+
+
+QrCode QrCode::encodeBinary(const vector<uint8_t> &data, Ecc ecl) {
+	vector<QrSegment> segs{QrSegment::makeBytes(data)};
+	return encodeSegments(segs, ecl);
+}
+
+
+QrCode QrCode::encodeSegments(const vector<QrSegment> &segs, Ecc ecl,
+		int minVersion, int maxVersion, int mask, bool boostEcl) {
+	if (!(MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= MAX_VERSION) || mask < -1 || mask > 7)
+		throw std::invalid_argument("Invalid value");
+	
+	// Find the minimal version number to use
+	int version, dataUsedBits;
+	for (version = minVersion; ; version++) {
+		int dataCapacityBits = getNumDataCodewords(version, ecl) * 8;  // Number of data bits available
+		dataUsedBits = QrSegment::getTotalBits(segs, version);
+		if (dataUsedBits != -1 && dataUsedBits <= dataCapacityBits)
+			break;  // This version number is found to be suitable
+		if (version >= maxVersion) {  // All versions in the range could not fit the given data
+			std::ostringstream sb;
+			if (dataUsedBits == -1)
+				sb << "Segment too long";
+			else {
+				sb << "Data length = " << dataUsedBits << " bits, ";
+				sb << "Max capacity = " << dataCapacityBits << " bits";
+			}
+			throw data_too_long(sb.str());
+		}
+	}
+	if (dataUsedBits == -1)
+		throw std::logic_error("Assertion error");
+	
+	// Increase the error correction level while the data still fits in the current version number
+	for (Ecc newEcl : vector<Ecc>{Ecc::MEDIUM, Ecc::QUARTILE, Ecc::HIGH}) {  // From low to high
+		if (boostEcl && dataUsedBits <= getNumDataCodewords(version, newEcl) * 8)
+			ecl = newEcl;
+	}
+	
+	// Concatenate all segments to create the data bit string
+	BitBuffer bb;
+	for (const QrSegment &seg : segs) {
+		bb.appendBits(static_cast<uint32_t>(seg.getMode().getModeBits()), 4);
+		bb.appendBits(static_cast<uint32_t>(seg.getNumChars()), seg.getMode().numCharCountBits(version));
+		bb.insert(bb.end(), seg.getData().begin(), seg.getData().end());
+	}
+	if (bb.size() != static_cast<unsigned int>(dataUsedBits))
+		throw std::logic_error("Assertion error");
+	
+	// Add terminator and pad up to a byte if applicable
+	size_t dataCapacityBits = static_cast<size_t>(getNumDataCodewords(version, ecl)) * 8;
+	if (bb.size() > dataCapacityBits)
+		throw std::logic_error("Assertion error");
+	bb.appendBits(0, std::min(4, static_cast<int>(dataCapacityBits - bb.size())));
+	bb.appendBits(0, (8 - static_cast<int>(bb.size() % 8)) % 8);
+	if (bb.size() % 8 != 0)
+		throw std::logic_error("Assertion error");
+	
+	// Pad with alternating bytes until data capacity is reached
+	for (uint8_t padByte = 0xEC; bb.size() < dataCapacityBits; padByte ^= 0xEC ^ 0x11)
+		bb.appendBits(padByte, 8);
+	
+	// Pack bits into bytes in big endian
+	vector<uint8_t> dataCodewords(bb.size() / 8);
+	for (size_t i = 0; i < bb.size(); i++)
+		dataCodewords[i >> 3] |= (bb.at(i) ? 1 : 0) << (7 - (i & 7));
+	
+	// Create the QR Code object
+	return QrCode(version, ecl, dataCodewords, mask);
+}
+
+
+QrCode::QrCode(int ver, Ecc ecl, const vector<uint8_t> &dataCodewords, int msk) :
+		// Initialize fields and check arguments
+		version(ver),
+		errorCorrectionLevel(ecl) {
+	if (ver < MIN_VERSION || ver > MAX_VERSION)
+		throw std::domain_error("Version value out of range");
+	if (msk < -1 || msk > 7)
+		throw std::domain_error("Mask value out of range");
+	size = ver * 4 + 17;
+	size_t sz = static_cast<size_t>(size);
+	modules    = vector<vector<bool> >(sz, vector<bool>(sz));  // Initially all white
+	isFunction = vector<vector<bool> >(sz, vector<bool>(sz));
+	
+	// Compute ECC, draw modules
+	drawFunctionPatterns();
+	const vector<uint8_t> allCodewords = addEccAndInterleave(dataCodewords);
+	drawCodewords(allCodewords);
+	
+	// Do masking
+	if (msk == -1) {  // Automatically choose best mask
+		long minPenalty = LONG_MAX;
+		for (int i = 0; i < 8; i++) {
+			applyMask(i);
+			drawFormatBits(i);
+			long penalty = getPenaltyScore();
+			if (penalty < minPenalty) {
+				msk = i;
+				minPenalty = penalty;
+			}
+			applyMask(i);  // Undoes the mask due to XOR
+		}
+	}
+	if (msk < 0 || msk > 7)
+		throw std::logic_error("Assertion error");
+	this->mask = msk;
+	applyMask(msk);  // Apply the final choice of mask
+	drawFormatBits(msk);  // Overwrite old format bits
+	
+	isFunction.clear();
+	isFunction.shrink_to_fit();
+}
+
+
+int QrCode::getVersion() const {
+	return version;
+}
+
+
+int QrCode::getSize() const {
+	return size;
+}
+
+
+QrCode::Ecc QrCode::getErrorCorrectionLevel() const {
+	return errorCorrectionLevel;
+}
+
+
+int QrCode::getMask() const {
+	return mask;
+}
+
+
+bool QrCode::getModule(int x, int y) const {
+	return 0 <= x && x < size && 0 <= y && y < size && module(x, y);
+}
+
+
+std::string QrCode::toSvgString(int border) const {
+	if (border < 0)
+		throw std::domain_error("Border must be non-negative");
+	if (border > INT_MAX / 2 || border * 2 > INT_MAX - size)
+		throw std::overflow_error("Border too large");
+	
+	std::ostringstream sb;
+	sb << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
+	sb << "<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n";
+	sb << "<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" viewBox=\"0 0 ";
+	sb << (size + border * 2) << " " << (size + border * 2) << "\" stroke=\"none\">\n";
+	sb << "\t<rect width=\"100%\" height=\"100%\" fill=\"#FFFFFF\"/>\n";
+	sb << "\t<path d=\"";
+	for (int y = 0; y < size; y++) {
+		for (int x = 0; x < size; x++) {
+			if (getModule(x, y)) {
+				if (x != 0 || y != 0)
+					sb << " ";
+				sb << "M" << (x + border) << "," << (y + border) << "h1v1h-1z";
+			}
+		}
+	}
+	sb << "\" fill=\"#000000\"/>\n";
+	sb << "</svg>\n";
+	return sb.str();
+}
+
+
+void QrCode::drawFunctionPatterns() {
+	// Draw horizontal and vertical timing patterns
+	for (int i = 0; i < size; i++) {
+		setFunctionModule(6, i, i % 2 == 0);
+		setFunctionModule(i, 6, i % 2 == 0);
+	}
+	
+	// Draw 3 finder patterns (all corners except bottom right; overwrites some timing modules)
+	drawFinderPattern(3, 3);
+	drawFinderPattern(size - 4, 3);
+	drawFinderPattern(3, size - 4);
+	
+	// Draw numerous alignment patterns
+	const vector<int> alignPatPos = getAlignmentPatternPositions();
+	size_t numAlign = alignPatPos.size();
+	for (size_t i = 0; i < numAlign; i++) {
+		for (size_t j = 0; j < numAlign; j++) {
+			// Don't draw on the three finder corners
+			if (!((i == 0 && j == 0) || (i == 0 && j == numAlign - 1) || (i == numAlign - 1 && j == 0)))
+				drawAlignmentPattern(alignPatPos.at(i), alignPatPos.at(j));
+		}
+	}
+	
+	// Draw configuration data
+	drawFormatBits(0);  // Dummy mask value; overwritten later in the constructor
+	drawVersion();
+}
+
+
+void QrCode::drawFormatBits(int msk) {
+	// Calculate error correction code and pack bits
+	int data = getFormatBits(errorCorrectionLevel) << 3 | msk;  // errCorrLvl is uint2, msk is uint3
+	int rem = data;
+	for (int i = 0; i < 10; i++)
+		rem = (rem << 1) ^ ((rem >> 9) * 0x537);
+	int bits = (data << 10 | rem) ^ 0x5412;  // uint15
+	if (bits >> 15 != 0)
+		throw std::logic_error("Assertion error");
+	
+	// Draw first copy
+	for (int i = 0; i <= 5; i++)
+		setFunctionModule(8, i, getBit(bits, i));
+	setFunctionModule(8, 7, getBit(bits, 6));
+	setFunctionModule(8, 8, getBit(bits, 7));
+	setFunctionModule(7, 8, getBit(bits, 8));
+	for (int i = 9; i < 15; i++)
+		setFunctionModule(14 - i, 8, getBit(bits, i));
+	
+	// Draw second copy
+	for (int i = 0; i < 8; i++)
+		setFunctionModule(size - 1 - i, 8, getBit(bits, i));
+	for (int i = 8; i < 15; i++)
+		setFunctionModule(8, size - 15 + i, getBit(bits, i));
+	setFunctionModule(8, size - 8, true);  // Always black
+}
+
+
+void QrCode::drawVersion() {
+	if (version < 7)
+		return;
+	
+	// Calculate error correction code and pack bits
+	int rem = version;  // version is uint6, in the range [7, 40]
+	for (int i = 0; i < 12; i++)
+		rem = (rem << 1) ^ ((rem >> 11) * 0x1F25);
+	long bits = static_cast<long>(version) << 12 | rem;  // uint18
+	if (bits >> 18 != 0)
+		throw std::logic_error("Assertion error");
+	
+	// Draw two copies
+	for (int i = 0; i < 18; i++) {
+		bool bit = getBit(bits, i);
+		int a = size - 11 + i % 3;
+		int b = i / 3;
+		setFunctionModule(a, b, bit);
+		setFunctionModule(b, a, bit);
+	}
+}
+
+
+void QrCode::drawFinderPattern(int x, int y) {
+	for (int dy = -4; dy <= 4; dy++) {
+		for (int dx = -4; dx <= 4; dx++) {
+			int dist = std::max(std::abs(dx), std::abs(dy));  // Chebyshev/infinity norm
+			int xx = x + dx, yy = y + dy;
+			if (0 <= xx && xx < size && 0 <= yy && yy < size)
+				setFunctionModule(xx, yy, dist != 2 && dist != 4);
+		}
+	}
+}
+
+
+void QrCode::drawAlignmentPattern(int x, int y) {
+	for (int dy = -2; dy <= 2; dy++) {
+		for (int dx = -2; dx <= 2; dx++)
+			setFunctionModule(x + dx, y + dy, std::max(std::abs(dx), std::abs(dy)) != 1);
+	}
+}
+
+
+void QrCode::setFunctionModule(int x, int y, bool isBlack) {
+	size_t ux = static_cast<size_t>(x);
+	size_t uy = static_cast<size_t>(y);
+	modules   .at(uy).at(ux) = isBlack;
+	isFunction.at(uy).at(ux) = true;
+}
+
+
+bool QrCode::module(int x, int y) const {
+	return modules.at(static_cast<size_t>(y)).at(static_cast<size_t>(x));
+}
+
+
+vector<uint8_t> QrCode::addEccAndInterleave(const vector<uint8_t> &data) const {
+	if (data.size() != static_cast<unsigned int>(getNumDataCodewords(version, errorCorrectionLevel)))
+		throw std::invalid_argument("Invalid argument");
+	
+	// Calculate parameter numbers
+	int numBlocks = NUM_ERROR_CORRECTION_BLOCKS[static_cast<int>(errorCorrectionLevel)][version];
+	int blockEccLen = ECC_CODEWORDS_PER_BLOCK  [static_cast<int>(errorCorrectionLevel)][version];
+	int rawCodewords = getNumRawDataModules(version) / 8;
+	int numShortBlocks = numBlocks - rawCodewords % numBlocks;
+	int shortBlockLen = rawCodewords / numBlocks;
+	
+	// Split data into blocks and append ECC to each block
+	vector<vector<uint8_t> > blocks;
+	const vector<uint8_t> rsDiv = reedSolomonComputeDivisor(blockEccLen);
+	for (int i = 0, k = 0; i < numBlocks; i++) {
+		vector<uint8_t> dat(data.cbegin() + k, data.cbegin() + (k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1)));
+		k += static_cast<int>(dat.size());
+		const vector<uint8_t> ecc = reedSolomonComputeRemainder(dat, rsDiv);
+		if (i < numShortBlocks)
+			dat.push_back(0);
+		dat.insert(dat.end(), ecc.cbegin(), ecc.cend());
+		blocks.push_back(std::move(dat));
+	}
+	
+	// Interleave (not concatenate) the bytes from every block into a single sequence
+	vector<uint8_t> result;
+	for (size_t i = 0; i < blocks.at(0).size(); i++) {
+		for (size_t j = 0; j < blocks.size(); j++) {
+			// Skip the padding byte in short blocks
+			if (i != static_cast<unsigned int>(shortBlockLen - blockEccLen) || j >= static_cast<unsigned int>(numShortBlocks))
+				result.push_back(blocks.at(j).at(i));
+		}
+	}
+	if (result.size() != static_cast<unsigned int>(rawCodewords))
+		throw std::logic_error("Assertion error");
+	return result;
+}
+
+
+void QrCode::drawCodewords(const vector<uint8_t> &data) {
+	if (data.size() != static_cast<unsigned int>(getNumRawDataModules(version) / 8))
+		throw std::invalid_argument("Invalid argument");
+	
+	size_t i = 0;  // Bit index into the data
+	// Do the funny zigzag scan
+	for (int right = size - 1; right >= 1; right -= 2) {  // Index of right column in each column pair
+		if (right == 6)
+			right = 5;
+		for (int vert = 0; vert < size; vert++) {  // Vertical counter
+			for (int j = 0; j < 2; j++) {
+				size_t x = static_cast<size_t>(right - j);  // Actual x coordinate
+				bool upward = ((right + 1) & 2) == 0;
+				size_t y = static_cast<size_t>(upward ? size - 1 - vert : vert);  // Actual y coordinate
+				if (!isFunction.at(y).at(x) && i < data.size() * 8) {
+					modules.at(y).at(x) = getBit(data.at(i >> 3), 7 - static_cast<int>(i & 7));
+					i++;
+				}
+				// If this QR Code has any remainder bits (0 to 7), they were assigned as
+				// 0/false/white by the constructor and are left unchanged by this method
+			}
+		}
+	}
+	if (i != data.size() * 8)
+		throw std::logic_error("Assertion error");
+}
+
+
+void QrCode::applyMask(int msk) {
+	if (msk < 0 || msk > 7)
+		throw std::domain_error("Mask value out of range");
+	size_t sz = static_cast<size_t>(size);
+	for (size_t y = 0; y < sz; y++) {
+		for (size_t x = 0; x < sz; x++) {
+			bool invert;
+			switch (msk) {
+				case 0:  invert = (x + y) % 2 == 0;                    break;
+				case 1:  invert = y % 2 == 0;                          break;
+				case 2:  invert = x % 3 == 0;                          break;
+				case 3:  invert = (x + y) % 3 == 0;                    break;
+				case 4:  invert = (x / 3 + y / 2) % 2 == 0;            break;
+				case 5:  invert = x * y % 2 + x * y % 3 == 0;          break;
+				case 6:  invert = (x * y % 2 + x * y % 3) % 2 == 0;    break;
+				case 7:  invert = ((x + y) % 2 + x * y % 3) % 2 == 0;  break;
+				default:  throw std::logic_error("Assertion error");
+			}
+			modules.at(y).at(x) = modules.at(y).at(x) ^ (invert & !isFunction.at(y).at(x));
+		}
+	}
+}
+
+
+long QrCode::getPenaltyScore() const {
+	long result = 0;
+	
+	// Adjacent modules in row having same color, and finder-like patterns
+	for (int y = 0; y < size; y++) {
+		bool runColor = false;
+		int runX = 0;
+		std::array<int,7> runHistory = {};
+		int padRun = size;  // Add white border to initial run
+		for (int x = 0; x < size; x++) {
+			if (module(x, y) == runColor) {
+				runX++;
+				if (runX == 5)
+					result += PENALTY_N1;
+				else if (runX > 5)
+					result++;
+			} else {
+				finderPenaltyAddHistory(runX + padRun, runHistory);
+				padRun = 0;
+				if (!runColor)
+					result += finderPenaltyCountPatterns(runHistory) * PENALTY_N3;
+				runColor = module(x, y);
+				runX = 1;
+			}
+		}
+		result += finderPenaltyTerminateAndCount(runColor, runX + padRun, runHistory) * PENALTY_N3;
+	}
+	// Adjacent modules in column having same color, and finder-like patterns
+	for (int x = 0; x < size; x++) {
+		bool runColor = false;
+		int runY = 0;
+		std::array<int,7> runHistory = {};
+		int padRun = size;  // Add white border to initial run
+		for (int y = 0; y < size; y++) {
+			if (module(x, y) == runColor) {
+				runY++;
+				if (runY == 5)
+					result += PENALTY_N1;
+				else if (runY > 5)
+					result++;
+			} else {
+				finderPenaltyAddHistory(runY + padRun, runHistory);
+				padRun = 0;
+				if (!runColor)
+					result += finderPenaltyCountPatterns(runHistory) * PENALTY_N3;
+				runColor = module(x, y);
+				runY = 1;
+			}
+		}
+		result += finderPenaltyTerminateAndCount(runColor, runY + padRun, runHistory) * PENALTY_N3;
+	}
+	
+	// 2*2 blocks of modules having same color
+	for (int y = 0; y < size - 1; y++) {
+		for (int x = 0; x < size - 1; x++) {
+			bool  color = module(x, y);
+			if (  color == module(x + 1, y) &&
+			      color == module(x, y + 1) &&
+			      color == module(x + 1, y + 1))
+				result += PENALTY_N2;
+		}
+	}
+	
+	// Balance of black and white modules
+	int black = 0;
+	for (const vector<bool> &row : modules) {
+		for (bool color : row) {
+			if (color)
+				black++;
+		}
+	}
+	int total = size * size;  // Note that size is odd, so black/total != 1/2
+	// Compute the smallest integer k >= 0 such that (45-5k)% <= black/total <= (55+5k)%
+	int k = static_cast<int>((std::abs(black * 20L - total * 10L) + total - 1) / total) - 1;
+	result += k * PENALTY_N4;
+	return result;
+}
+
+
+vector<int> QrCode::getAlignmentPatternPositions() const {
+	if (version == 1)
+		return vector<int>();
+	else {
+		int numAlign = version / 7 + 2;
+		int step = (version == 32) ? 26 :
+			(version*4 + numAlign*2 + 1) / (numAlign*2 - 2) * 2;
+		vector<int> result;
+		for (int i = 0, pos = size - 7; i < numAlign - 1; i++, pos -= step)
+			result.insert(result.begin(), pos);
+		result.insert(result.begin(), 6);
+		return result;
+	}
+}
+
+
+int QrCode::getNumRawDataModules(int ver) {
+	if (ver < MIN_VERSION || ver > MAX_VERSION)
+		throw std::domain_error("Version number out of range");
+	int result = (16 * ver + 128) * ver + 64;
+	if (ver >= 2) {
+		int numAlign = ver / 7 + 2;
+		result -= (25 * numAlign - 10) * numAlign - 55;
+		if (ver >= 7)
+			result -= 36;
+	}
+	if (!(208 <= result && result <= 29648))
+		throw std::logic_error("Assertion error");
+	return result;
+}
+
+
+int QrCode::getNumDataCodewords(int ver, Ecc ecl) {
+	return getNumRawDataModules(ver) / 8
+		- ECC_CODEWORDS_PER_BLOCK    [static_cast<int>(ecl)][ver]
+		* NUM_ERROR_CORRECTION_BLOCKS[static_cast<int>(ecl)][ver];
+}
+
+
+vector<uint8_t> QrCode::reedSolomonComputeDivisor(int degree) {
+	if (degree < 1 || degree > 255)
+		throw std::domain_error("Degree out of range");
+	// Polynomial coefficients are stored from highest to lowest power, excluding the leading term which is always 1.
+	// For example the polynomial x^3 + 255x^2 + 8x + 93 is stored as the uint8 array {255, 8, 93}.
+	vector<uint8_t> result(static_cast<size_t>(degree));
+	result.at(result.size() - 1) = 1;  // Start off with the monomial x^0
+	
+	// Compute the product polynomial (x - r^0) * (x - r^1) * (x - r^2) * ... * (x - r^{degree-1}),
+	// and drop the highest monomial term which is always 1x^degree.
+	// Note that r = 0x02, which is a generator element of this field GF(2^8/0x11D).
+	uint8_t root = 1;
+	for (int i = 0; i < degree; i++) {
+		// Multiply the current product by (x - r^i)
+		for (size_t j = 0; j < result.size(); j++) {
+			result.at(j) = reedSolomonMultiply(result.at(j), root);
+			if (j + 1 < result.size())
+				result.at(j) ^= result.at(j + 1);
+		}
+		root = reedSolomonMultiply(root, 0x02);
+	}
+	return result;
+}
+
+
+vector<uint8_t> QrCode::reedSolomonComputeRemainder(const vector<uint8_t> &data, const vector<uint8_t> &divisor) {
+	vector<uint8_t> result(divisor.size());
+	for (uint8_t b : data) {  // Polynomial division
+		uint8_t factor = b ^ result.at(0);
+		result.erase(result.begin());
+		result.push_back(0);
+		for (size_t i = 0; i < result.size(); i++)
+			result.at(i) ^= reedSolomonMultiply(divisor.at(i), factor);
+	}
+	return result;
+}
+
+
+uint8_t QrCode::reedSolomonMultiply(uint8_t x, uint8_t y) {
+	// Russian peasant multiplication
+	int z = 0;
+	for (int i = 7; i >= 0; i--) {
+		z = (z << 1) ^ ((z >> 7) * 0x11D);
+		z ^= ((y >> i) & 1) * x;
+	}
+	if (z >> 8 != 0)
+		throw std::logic_error("Assertion error");
+	return static_cast<uint8_t>(z);
+}
+
+
+int QrCode::finderPenaltyCountPatterns(const std::array<int,7> &runHistory) const {
+	int n = runHistory.at(1);
+	if (n > size * 3)
+		throw std::logic_error("Assertion error");
+	bool core = n > 0 && runHistory.at(2) == n && runHistory.at(3) == n * 3 && runHistory.at(4) == n && runHistory.at(5) == n;
+	return (core && runHistory.at(0) >= n * 4 && runHistory.at(6) >= n ? 1 : 0)
+	     + (core && runHistory.at(6) >= n * 4 && runHistory.at(0) >= n ? 1 : 0);
+}
+
+
+int QrCode::finderPenaltyTerminateAndCount(bool currentRunColor, int currentRunLength, std::array<int,7> &runHistory) const {
+	if (currentRunColor) {  // Terminate black run
+		finderPenaltyAddHistory(currentRunLength, runHistory);
+		currentRunLength = 0;
+	}
+	currentRunLength += size;  // Add white border to final run
+	finderPenaltyAddHistory(currentRunLength, runHistory);
+	return finderPenaltyCountPatterns(runHistory);
+}
+
+
+void QrCode::finderPenaltyAddHistory(int currentRunLength, std::array<int,7> &runHistory) {
+	std::copy_backward(runHistory.cbegin(), runHistory.cend() - 1, runHistory.end());
+	runHistory.at(0) = currentRunLength;
+}
+
+
+bool QrCode::getBit(long x, int i) {
+	return ((x >> i) & 1) != 0;
+}
+
+
+/*---- Tables of constants ----*/
+
+const int QrCode::PENALTY_N1 =  3;
+const int QrCode::PENALTY_N2 =  3;
+const int QrCode::PENALTY_N3 = 40;
+const int QrCode::PENALTY_N4 = 10;
+
+
+const int8_t QrCode::ECC_CODEWORDS_PER_BLOCK[4][41] = {
+	// Version: (note that index 0 is for padding, and is set to an illegal value)
+	//0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
+	{-1,  7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30},  // Low
+	{-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28},  // Medium
+	{-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30},  // Quartile
+	{-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30},  // High
+};
+
+const int8_t QrCode::NUM_ERROR_CORRECTION_BLOCKS[4][41] = {
+	// Version: (note that index 0 is for padding, and is set to an illegal value)
+	//0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
+	{-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4,  4,  4,  4,  4,  6,  6,  6,  6,  7,  8,  8,  9,  9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25},  // Low
+	{-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5,  5,  8,  9,  9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49},  // Medium
+	{-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8,  8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68},  // Quartile
+	{-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81},  // High
+};
+
+
+data_too_long::data_too_long(const std::string &msg) :
+	std::length_error(msg) {}
+
+}
diff --git a/Telegram/ThirdParty/QR/cpp/QrCode.hpp b/Telegram/ThirdParty/QR/cpp/QrCode.hpp
new file mode 100644
index 0000000..6babfdf
--- /dev/null
+++ b/Telegram/ThirdParty/QR/cpp/QrCode.hpp
@@ -0,0 +1,350 @@
+/* 
+ * QR Code generator library (C++)
+ * 
+ * Copyright (c) Project Nayuki. (MIT License)
+ * https://www.nayuki.io/page/qr-code-generator-library
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ * - The above copyright notice and this permission notice shall be included in
+ *   all copies or substantial portions of the Software.
+ * - The Software is provided "as is", without warranty of any kind, express or
+ *   implied, including but not limited to the warranties of merchantability,
+ *   fitness for a particular purpose and noninfringement. In no event shall the
+ *   authors or copyright holders be liable for any claim, damages or other
+ *   liability, whether in an action of contract, tort or otherwise, arising from,
+ *   out of or in connection with the Software or the use or other dealings in the
+ *   Software.
+ */
+
+#pragma once
+
+#include <array>
+#include <cstdint>
+#include <stdexcept>
+#include <string>
+#include <vector>
+#include "QrSegment.hpp"
+
+
+namespace qrcodegen {
+
+/* 
+ * A QR Code symbol, which is a type of two-dimension barcode.
+ * Invented by Denso Wave and described in the ISO/IEC 18004 standard.
+ * Instances of this class represent an immutable square grid of black and white cells.
+ * The class provides static factory functions to create a QR Code from text or binary data.
+ * The class covers the QR Code Model 2 specification, supporting all versions (sizes)
+ * from 1 to 40, all 4 error correction levels, and 4 character encoding modes.
+ * 
+ * Ways to create a QR Code object:
+ * - High level: Take the payload data and call QrCode::encodeText() or QrCode::encodeBinary().
+ * - Mid level: Custom-make the list of segments and call QrCode::encodeSegments().
+ * - Low level: Custom-make the array of data codeword bytes (including
+ *   segment headers and final padding, excluding error correction codewords),
+ *   supply the appropriate version number, and call the QrCode() constructor.
+ * (Note that all ways require supplying the desired error correction level.)
+ */
+class QrCode final {
+	
+	/*---- Public helper enumeration ----*/
+	
+	/* 
+	 * The error correction level in a QR Code symbol.
+	 */
+	public: enum class Ecc {
+		LOW = 0 ,  // The QR Code can tolerate about  7% erroneous codewords
+		MEDIUM  ,  // The QR Code can tolerate about 15% erroneous codewords
+		QUARTILE,  // The QR Code can tolerate about 25% erroneous codewords
+		HIGH    ,  // The QR Code can tolerate about 30% erroneous codewords
+	};
+	
+	
+	// Returns a value in the range 0 to 3 (unsigned 2-bit integer).
+	private: static int getFormatBits(Ecc ecl);
+	
+	
+	
+	/*---- Static factory functions (high level) ----*/
+	
+	/* 
+	 * Returns a QR Code representing the given Unicode text string at the given error correction level.
+	 * As a conservative upper bound, this function is guaranteed to succeed for strings that have 2953 or fewer
+	 * UTF-8 code units (not Unicode code points) if the low error correction level is used. The smallest possible
+	 * QR Code version is automatically chosen for the output. The ECC level of the result may be higher than
+	 * the ecl argument if it can be done without increasing the version.
+	 */
+	public: static QrCode encodeText(const char *text, Ecc ecl);
+	
+	
+	/* 
+	 * Returns a QR Code representing the given binary data at the given error correction level.
+	 * This function always encodes using the binary segment mode, not any text mode. The maximum number of
+	 * bytes allowed is 2953. The smallest possible QR Code version is automatically chosen for the output.
+	 * The ECC level of the result may be higher than the ecl argument if it can be done without increasing the version.
+	 */
+	public: static QrCode encodeBinary(const std::vector<std::uint8_t> &data, Ecc ecl);
+	
+	
+	/*---- Static factory functions (mid level) ----*/
+	
+	/* 
+	 * Returns a QR Code representing the given segments with the given encoding parameters.
+	 * The smallest possible QR Code version within the given range is automatically
+	 * chosen for the output. Iff boostEcl is true, then the ECC level of the result
+	 * may be higher than the ecl argument if it can be done without increasing the
+	 * version. The mask number is either between 0 to 7 (inclusive) to force that
+	 * mask, or -1 to automatically choose an appropriate mask (which may be slow).
+	 * This function allows the user to create a custom sequence of segments that switches
+	 * between modes (such as alphanumeric and byte) to encode text in less space.
+	 * This is a mid-level API; the high-level API is encodeText() and encodeBinary().
+	 */
+	public: static QrCode encodeSegments(const std::vector<QrSegment> &segs, Ecc ecl,
+		int minVersion=1, int maxVersion=40, int mask=-1, bool boostEcl=true);  // All optional parameters
+	
+	
+	
+	/*---- Instance fields ----*/
+	
+	// Immutable scalar parameters:
+	
+	/* The version number of this QR Code, which is between 1 and 40 (inclusive).
+	 * This determines the size of this barcode. */
+	private: int version;
+	
+	/* The width and height of this QR Code, measured in modules, between
+	 * 21 and 177 (inclusive). This is equal to version * 4 + 17. */
+	private: int size;
+	
+	/* The error correction level used in this QR Code. */
+	private: Ecc errorCorrectionLevel;
+	
+	/* The index of the mask pattern used in this QR Code, which is between 0 and 7 (inclusive).
+	 * Even if a QR Code is created with automatic masking requested (mask = -1),
+	 * the resulting object still has a mask value between 0 and 7. */
+	private: int mask;
+	
+	// Private grids of modules/pixels, with dimensions of size*size:
+	
+	// The modules of this QR Code (false = white, true = black).
+	// Immutable after constructor finishes. Accessed through getModule().
+	private: std::vector<std::vector<bool> > modules;
+	
+	// Indicates function modules that are not subjected to masking. Discarded when constructor finishes.
+	private: std::vector<std::vector<bool> > isFunction;
+	
+	
+	
+	/*---- Constructor (low level) ----*/
+	
+	/* 
+	 * Creates a new QR Code with the given version number,
+	 * error correction level, data codeword bytes, and mask number.
+	 * This is a low-level API that most users should not use directly.
+	 * A mid-level API is the encodeSegments() function.
+	 */
+	public: QrCode(int ver, Ecc ecl, const std::vector<std::uint8_t> &dataCodewords, int msk);
+	
+	
+	
+	/*---- Public instance methods ----*/
+	
+	/* 
+	 * Returns this QR Code's version, in the range [1, 40].
+	 */
+	public: int getVersion() const;
+	
+	
+	/* 
+	 * Returns this QR Code's size, in the range [21, 177].
+	 */
+	public: int getSize() const;
+	
+	
+	/* 
+	 * Returns this QR Code's error correction level.
+	 */
+	public: Ecc getErrorCorrectionLevel() const;
+	
+	
+	/* 
+	 * Returns this QR Code's mask, in the range [0, 7].
+	 */
+	public: int getMask() const;
+	
+	
+	/* 
+	 * Returns the color of the module (pixel) at the given coordinates, which is false
+	 * for white or true for black. The top left corner has the coordinates (x=0, y=0).
+	 * If the given coordinates are out of bounds, then false (white) is returned.
+	 */
+	public: bool getModule(int x, int y) const;
+	
+	
+	/* 
+	 * Returns a string of SVG code for an image depicting this QR Code, with the given number
+	 * of border modules. The string always uses Unix newlines (\n), regardless of the platform.
+	 */
+	public: std::string toSvgString(int border) const;
+	
+	
+	
+	/*---- Private helper methods for constructor: Drawing function modules ----*/
+	
+	// Reads this object's version field, and draws and marks all function modules.
+	private: void drawFunctionPatterns();
+	
+	
+	// Draws two copies of the format bits (with its own error correction code)
+	// based on the given mask and this object's error correction level field.
+	private: void drawFormatBits(int msk);
+	
+	
+	// Draws two copies of the version bits (with its own error correction code),
+	// based on this object's version field, iff 7 <= version <= 40.
+	private: void drawVersion();
+	
+	
+	// Draws a 9*9 finder pattern including the border separator,
+	// with the center module at (x, y). Modules can be out of bounds.
+	private: void drawFinderPattern(int x, int y);
+	
+	
+	// Draws a 5*5 alignment pattern, with the center module
+	// at (x, y). All modules must be in bounds.
+	private: void drawAlignmentPattern(int x, int y);
+	
+	
+	// Sets the color of a module and marks it as a function module.
+	// Only used by the constructor. Coordinates must be in bounds.
+	private: void setFunctionModule(int x, int y, bool isBlack);
+	
+	
+	// Returns the color of the module at the given coordinates, which must be in range.
+	private: bool module(int x, int y) const;
+	
+	
+	/*---- Private helper methods for constructor: Codewords and masking ----*/
+	
+	// Returns a new byte string representing the given data with the appropriate error correction
+	// codewords appended to it, based on this object's version and error correction level.
+	private: std::vector<std::uint8_t> addEccAndInterleave(const std::vector<std::uint8_t> &data) const;
+	
+	
+	// Draws the given sequence of 8-bit codewords (data and error correction) onto the entire
+	// data area of this QR Code. Function modules need to be marked off before this is called.
+	private: void drawCodewords(const std::vector<std::uint8_t> &data);
+	
+	
+	// XORs the codeword modules in this QR Code with the given mask pattern.
+	// The function modules must be marked and the codeword bits must be drawn
+	// before masking. Due to the arithmetic of XOR, calling applyMask() with
+	// the same mask value a second time will undo the mask. A final well-formed
+	// QR Code needs exactly one (not zero, two, etc.) mask applied.
+	private: void applyMask(int msk);
+	
+	
+	// Calculates and returns the penalty score based on state of this QR Code's current modules.
+	// This is used by the automatic mask choice algorithm to find the mask pattern that yields the lowest score.
+	private: long getPenaltyScore() const;
+	
+	
+	
+	/*---- Private helper functions ----*/
+	
+	// Returns an ascending list of positions of alignment patterns for this version number.
+	// Each position is in the range [0,177), and are used on both the x and y axes.
+	// This could be implemented as lookup table of 40 variable-length lists of unsigned bytes.
+	private: std::vector<int> getAlignmentPatternPositions() const;
+	
+	
+	// Returns the number of data bits that can be stored in a QR Code of the given version number, after
+	// all function modules are excluded. This includes remainder bits, so it might not be a multiple of 8.
+	// The result is in the range [208, 29648]. This could be implemented as a 40-entry lookup table.
+	private: static int getNumRawDataModules(int ver);
+	
+	
+	// Returns the number of 8-bit data (i.e. not error correction) codewords contained in any
+	// QR Code of the given version number and error correction level, with remainder bits discarded.
+	// This stateless pure function could be implemented as a (40*4)-cell lookup table.
+	private: static int getNumDataCodewords(int ver, Ecc ecl);
+	
+	
+	// Returns a Reed-Solomon ECC generator polynomial for the given degree. This could be
+	// implemented as a lookup table over all possible parameter values, instead of as an algorithm.
+	private: static std::vector<std::uint8_t> reedSolomonComputeDivisor(int degree);
+	
+	
+	// Returns the Reed-Solomon error correction codeword for the given data and divisor polynomials.
+	private: static std::vector<std::uint8_t> reedSolomonComputeRemainder(const std::vector<std::uint8_t> &data, const std::vector<std::uint8_t> &divisor);
+	
+	
+	// Returns the product of the two given field elements modulo GF(2^8/0x11D).
+	// All inputs are valid. This could be implemented as a 256*256 lookup table.
+	private: static std::uint8_t reedSolomonMultiply(std::uint8_t x, std::uint8_t y);
+	
+	
+	// Can only be called immediately after a white run is added, and
+	// returns either 0, 1, or 2. A helper function for getPenaltyScore().
+	private: int finderPenaltyCountPatterns(const std::array<int,7> &runHistory) const;
+	
+	
+	// Must be called at the end of a line (row or column) of modules. A helper function for getPenaltyScore().
+	private: int finderPenaltyTerminateAndCount(bool currentRunColor, int currentRunLength, std::array<int,7> &runHistory) const;
+	
+	
+	// Pushes the given value to the front and drops the last value. A helper function for getPenaltyScore().
+	private: static void finderPenaltyAddHistory(int currentRunLength, std::array<int,7> &runHistory);
+	
+	
+	// Returns true iff the i'th bit of x is set to 1.
+	private: static bool getBit(long x, int i);
+	
+	
+	/*---- Constants and tables ----*/
+	
+	// The minimum version number supported in the QR Code Model 2 standard.
+	public: static constexpr int MIN_VERSION =  1;
+	
+	// The maximum version number supported in the QR Code Model 2 standard.
+	public: static constexpr int MAX_VERSION = 40;
+	
+	
+	// For use in getPenaltyScore(), when evaluating which mask is best.
+	private: static const int PENALTY_N1;
+	private: static const int PENALTY_N2;
+	private: static const int PENALTY_N3;
+	private: static const int PENALTY_N4;
+	
+	
+	private: static const std::int8_t ECC_CODEWORDS_PER_BLOCK[4][41];
+	private: static const std::int8_t NUM_ERROR_CORRECTION_BLOCKS[4][41];
+	
+};
+
+
+
+/*---- Public exception class ----*/
+
+/* 
+ * Thrown when the supplied data does not fit any QR Code version. Ways to handle this exception include:
+ * - Decrease the error correction level if it was greater than Ecc::LOW.
+ * - If the encodeSegments() function was called with a maxVersion argument, then increase
+ *   it if it was less than QrCode::MAX_VERSION. (This advice does not apply to the other
+ *   factory functions because they search all versions up to QrCode::MAX_VERSION.)
+ * - Split the text data into better or optimal segments in order to reduce the number of bits required.
+ * - Change the text or binary data to be shorter.
+ * - Change the text to fit the character set of a particular segment mode (e.g. alphanumeric).
+ * - Propagate the error upward to the caller/user.
+ */
+class data_too_long : public std::length_error {
+	
+	public: explicit data_too_long(const std::string &msg);
+	
+};
+
+}
diff --git a/Telegram/ThirdParty/QR/cpp/QrCodeGeneratorDemo.cpp b/Telegram/ThirdParty/QR/cpp/QrCodeGeneratorDemo.cpp
new file mode 100644
index 0000000..8284cfa
--- /dev/null
+++ b/Telegram/ThirdParty/QR/cpp/QrCodeGeneratorDemo.cpp
@@ -0,0 +1,200 @@
+/* 
+ * QR Code generator demo (C++)
+ * 
+ * Run this command-line program with no arguments. The program computes a bunch of demonstration
+ * QR Codes and prints them to the console. Also, the SVG code for one QR Code is printed as a sample.
+ * 
+ * Copyright (c) Project Nayuki. (MIT License)
+ * https://www.nayuki.io/page/qr-code-generator-library
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ * - The above copyright notice and this permission notice shall be included in
+ *   all copies or substantial portions of the Software.
+ * - The Software is provided "as is", without warranty of any kind, express or
+ *   implied, including but not limited to the warranties of merchantability,
+ *   fitness for a particular purpose and noninfringement. In no event shall the
+ *   authors or copyright holders be liable for any claim, damages or other
+ *   liability, whether in an action of contract, tort or otherwise, arising from,
+ *   out of or in connection with the Software or the use or other dealings in the
+ *   Software.
+ */
+
+#include <cstdint>
+#include <cstdlib>
+#include <cstring>
+#include <iostream>
+#include <string>
+#include <vector>
+#include "BitBuffer.hpp"
+#include "QrCode.hpp"
+
+using std::uint8_t;
+using qrcodegen::QrCode;
+using qrcodegen::QrSegment;
+
+
+// Function prototypes
+static void doBasicDemo();
+static void doVarietyDemo();
+static void doSegmentDemo();
+static void doMaskDemo();
+static void printQr(const QrCode &qr);
+
+
+// The main application program.
+int main() {
+	doBasicDemo();
+	doVarietyDemo();
+	doSegmentDemo();
+	doMaskDemo();
+	return EXIT_SUCCESS;
+}
+
+
+
+/*---- Demo suite ----*/
+
+// Creates a single QR Code, then prints it to the console.
+static void doBasicDemo() {
+	const char *text = "Hello, world!";              // User-supplied text
+	const QrCode::Ecc errCorLvl = QrCode::Ecc::LOW;  // Error correction level
+	
+	// Make and print the QR Code symbol
+	const QrCode qr = QrCode::encodeText(text, errCorLvl);
+	printQr(qr);
+	std::cout << qr.toSvgString(4) << std::endl;
+}
+
+
+// Creates a variety of QR Codes that exercise different features of the library, and prints each one to the console.
+static void doVarietyDemo() {
+	// Numeric mode encoding (3.33 bits per digit)
+	const QrCode qr0 = QrCode::encodeText("314159265358979323846264338327950288419716939937510", QrCode::Ecc::MEDIUM);
+	printQr(qr0);
+	
+	// Alphanumeric mode encoding (5.5 bits per character)
+	const QrCode qr1 = QrCode::encodeText("DOLLAR-AMOUNT:$39.87 PERCENTAGE:100.00% OPERATIONS:+-*/", QrCode::Ecc::HIGH);
+	printQr(qr1);
+	
+	// Unicode text as UTF-8
+	const QrCode qr2 = QrCode::encodeText("\xE3\x81\x93\xE3\x82\x93\xE3\x81\xAB\xE3\x81\xA1wa\xE3\x80\x81"
+		"\xE4\xB8\x96\xE7\x95\x8C\xEF\xBC\x81\x20\xCE\xB1\xCE\xB2\xCE\xB3\xCE\xB4", QrCode::Ecc::QUARTILE);
+	printQr(qr2);
+	
+	// Moderately large QR Code using longer text (from Lewis Carroll's Alice in Wonderland)
+	const QrCode qr3 = QrCode::encodeText(
+		"Alice was beginning to get very tired of sitting by her sister on the bank, "
+		"and of having nothing to do: once or twice she had peeped into the book her sister was reading, "
+		"but it had no pictures or conversations in it, 'and what is the use of a book,' thought Alice "
+		"'without pictures or conversations?' So she was considering in her own mind (as well as she could, "
+		"for the hot day made her feel very sleepy and stupid), whether the pleasure of making a "
+		"daisy-chain would be worth the trouble of getting up and picking the daisies, when suddenly "
+		"a White Rabbit with pink eyes ran close by her.", QrCode::Ecc::HIGH);
+	printQr(qr3);
+}
+
+
+// Creates QR Codes with manually specified segments for better compactness.
+static void doSegmentDemo() {
+	// Illustration "silver"
+	const char *silver0 = "THE SQUARE ROOT OF 2 IS 1.";
+	const char *silver1 = "41421356237309504880168872420969807856967187537694807317667973799";
+	const QrCode qr0 = QrCode::encodeText(
+		(std::string(silver0) + silver1).c_str(),
+		QrCode::Ecc::LOW);
+	printQr(qr0);
+	
+	const QrCode qr1 = QrCode::encodeSegments(
+		{QrSegment::makeAlphanumeric(silver0), QrSegment::makeNumeric(silver1)},
+		QrCode::Ecc::LOW);
+	printQr(qr1);
+	
+	// Illustration "golden"
+	const char *golden0 = "Golden ratio \xCF\x86 = 1.";
+	const char *golden1 = "6180339887498948482045868343656381177203091798057628621354486227052604628189024497072072041893911374";
+	const char *golden2 = "......";
+	const QrCode qr2 = QrCode::encodeText(
+		(std::string(golden0) + golden1 + golden2).c_str(),
+		QrCode::Ecc::LOW);
+	printQr(qr2);
+	
+	std::vector<uint8_t> bytes(golden0, golden0 + std::strlen(golden0));
+	const QrCode qr3 = QrCode::encodeSegments(
+		{QrSegment::makeBytes(bytes), QrSegment::makeNumeric(golden1), QrSegment::makeAlphanumeric(golden2)},
+		QrCode::Ecc::LOW);
+	printQr(qr3);
+	
+	// Illustration "Madoka": kanji, kana, Cyrillic, full-width Latin, Greek characters
+	const char *madoka =  // Encoded in UTF-8
+		"\xE3\x80\x8C\xE9\xAD\x94\xE6\xB3\x95\xE5"
+		"\xB0\x91\xE5\xA5\xB3\xE3\x81\xBE\xE3\x81"
+		"\xA9\xE3\x81\x8B\xE2\x98\x86\xE3\x83\x9E"
+		"\xE3\x82\xAE\xE3\x82\xAB\xE3\x80\x8D\xE3"
+		"\x81\xA3\xE3\x81\xA6\xE3\x80\x81\xE3\x80"
+		"\x80\xD0\x98\xD0\x90\xD0\x98\xE3\x80\x80"
+		"\xEF\xBD\x84\xEF\xBD\x85\xEF\xBD\x93\xEF"
+		"\xBD\x95\xE3\x80\x80\xCE\xBA\xCE\xB1\xEF"
+		"\xBC\x9F";
+	const QrCode qr4 = QrCode::encodeText(madoka, QrCode::Ecc::LOW);
+	printQr(qr4);
+	
+	const std::vector<int> kanjiChars{  // Kanji mode encoding (13 bits per character)
+		0x0035, 0x1002, 0x0FC0, 0x0AED, 0x0AD7,
+		0x015C, 0x0147, 0x0129, 0x0059, 0x01BD,
+		0x018D, 0x018A, 0x0036, 0x0141, 0x0144,
+		0x0001, 0x0000, 0x0249, 0x0240, 0x0249,
+		0x0000, 0x0104, 0x0105, 0x0113, 0x0115,
+		0x0000, 0x0208, 0x01FF, 0x0008,
+	};
+	qrcodegen::BitBuffer bb;
+	for (int c : kanjiChars)
+		bb.appendBits(static_cast<std::uint32_t>(c), 13);
+	const QrCode qr5 = QrCode::encodeSegments(
+		{QrSegment(QrSegment::Mode::KANJI, static_cast<int>(kanjiChars.size()), bb)},
+		QrCode::Ecc::LOW);
+	printQr(qr5);
+}
+
+
+// Creates QR Codes with the same size and contents but different mask patterns.
+static void doMaskDemo() {
+	// Project Nayuki URL
+	std::vector<QrSegment> segs0 = QrSegment::makeSegments("https://www.nayuki.io/");
+	printQr(QrCode::encodeSegments(segs0, QrCode::Ecc::HIGH, QrCode::MIN_VERSION, QrCode::MAX_VERSION, -1, true));  // Automatic mask
+	printQr(QrCode::encodeSegments(segs0, QrCode::Ecc::HIGH, QrCode::MIN_VERSION, QrCode::MAX_VERSION, 3, true));  // Force mask 3
+	
+	// Chinese text as UTF-8
+	std::vector<QrSegment> segs1 = QrSegment::makeSegments(
+		"\xE7\xB6\xAD\xE5\x9F\xBA\xE7\x99\xBE\xE7\xA7\x91\xEF\xBC\x88\x57\x69\x6B\x69\x70"
+		"\x65\x64\x69\x61\xEF\xBC\x8C\xE8\x81\x86\xE8\x81\xBD\x69\x2F\xCB\x8C\x77\xC9\xAA"
+		"\x6B\xE1\xB5\xBB\xCB\x88\x70\x69\xCB\x90\x64\x69\x2E\xC9\x99\x2F\xEF\xBC\x89\xE6"
+		"\x98\xAF\xE4\xB8\x80\xE5\x80\x8B\xE8\x87\xAA\xE7\x94\xB1\xE5\x85\xA7\xE5\xAE\xB9"
+		"\xE3\x80\x81\xE5\x85\xAC\xE9\x96\x8B\xE7\xB7\xA8\xE8\xBC\xAF\xE4\xB8\x94\xE5\xA4"
+		"\x9A\xE8\xAA\x9E\xE8\xA8\x80\xE7\x9A\x84\xE7\xB6\xB2\xE8\xB7\xAF\xE7\x99\xBE\xE7"
+		"\xA7\x91\xE5\x85\xA8\xE6\x9B\xB8\xE5\x8D\x94\xE4\xBD\x9C\xE8\xA8\x88\xE7\x95\xAB");
+	printQr(QrCode::encodeSegments(segs1, QrCode::Ecc::MEDIUM, QrCode::MIN_VERSION, QrCode::MAX_VERSION, 0, true));  // Force mask 0
+	printQr(QrCode::encodeSegments(segs1, QrCode::Ecc::MEDIUM, QrCode::MIN_VERSION, QrCode::MAX_VERSION, 1, true));  // Force mask 1
+	printQr(QrCode::encodeSegments(segs1, QrCode::Ecc::MEDIUM, QrCode::MIN_VERSION, QrCode::MAX_VERSION, 5, true));  // Force mask 5
+	printQr(QrCode::encodeSegments(segs1, QrCode::Ecc::MEDIUM, QrCode::MIN_VERSION, QrCode::MAX_VERSION, 7, true));  // Force mask 7
+}
+
+
+
+/*---- Utilities ----*/
+
+// Prints the given QrCode object to the console.
+static void printQr(const QrCode &qr) {
+	int border = 4;
+	for (int y = -border; y < qr.getSize() + border; y++) {
+		for (int x = -border; x < qr.getSize() + border; x++) {
+			std::cout << (qr.getModule(x, y) ? "##" : "  ");
+		}
+		std::cout << std::endl;
+	}
+	std::cout << std::endl;
+}
diff --git a/Telegram/ThirdParty/QR/cpp/QrCodeGeneratorWorker.cpp b/Telegram/ThirdParty/QR/cpp/QrCodeGeneratorWorker.cpp
new file mode 100644
index 0000000..073107f
--- /dev/null
+++ b/Telegram/ThirdParty/QR/cpp/QrCodeGeneratorWorker.cpp
@@ -0,0 +1,101 @@
+/* 
+ * QR Code generator test worker (C++)
+ * 
+ * This program reads data and encoding parameters from standard input and writes
+ * QR Code bitmaps to standard output. The I/O format is one integer per line.
+ * Run with no command line arguments. The program is intended for automated
+ * batch testing of end-to-end functionality of this QR Code generator library.
+ * 
+ * Copyright (c) Project Nayuki. (MIT License)
+ * https://www.nayuki.io/page/qr-code-generator-library
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ * - The above copyright notice and this permission notice shall be included in
+ *   all copies or substantial portions of the Software.
+ * - The Software is provided "as is", without warranty of any kind, express or
+ *   implied, including but not limited to the warranties of merchantability,
+ *   fitness for a particular purpose and noninfringement. In no event shall the
+ *   authors or copyright holders be liable for any claim, damages or other
+ *   liability, whether in an action of contract, tort or otherwise, arising from,
+ *   out of or in connection with the Software or the use or other dealings in the
+ *   Software.
+ */
+
+#include <cstddef>
+#include <cstdint>
+#include <cstdlib>
+#include <cstring>
+#include <iostream>
+#include <vector>
+#include "QrCode.hpp"
+
+using qrcodegen::QrCode;
+using qrcodegen::QrSegment;
+
+
+static const std::vector<QrCode::Ecc> ECC_LEVELS{
+	QrCode::Ecc::LOW,
+	QrCode::Ecc::MEDIUM,
+	QrCode::Ecc::QUARTILE,
+	QrCode::Ecc::HIGH,
+};
+
+
+int main() {
+	while (true) {
+		
+		// Read data length or exit
+		int length;
+		std::cin >> length;
+		if (length == -1)
+			break;
+		
+		// Read data bytes
+		bool isAscii = true;
+		std::vector<uint8_t> data;
+		for (int i = 0; i < length; i++) {
+			int b;
+			std::cin >> b;
+			data.push_back(static_cast<uint8_t>(b));
+			isAscii &= 0 < b && b < 128;
+		}
+		
+		// Read encoding parameters
+		int errCorLvl, minVersion, maxVersion, mask, boostEcl;
+		std::cin >> errCorLvl;
+		std::cin >> minVersion;
+		std::cin >> maxVersion;
+		std::cin >> mask;
+		std::cin >> boostEcl;
+		
+		// Make list of segments
+		std::vector<QrSegment> segs;
+		if (isAscii) {
+			std::vector<char> text(data.cbegin(), data.cend());
+			text.push_back('\0');
+			segs = QrSegment::makeSegments(text.data());
+		} else
+			segs.push_back(QrSegment::makeBytes(data));
+		
+		try {  // Try to make QR Code symbol
+			const QrCode qr = QrCode::encodeSegments(segs,
+				ECC_LEVELS.at(static_cast<std::size_t>(errCorLvl)), minVersion, maxVersion, mask, boostEcl == 1);
+			// Print grid of modules
+			std::cout << qr.getVersion() << std::endl;
+			for (int y = 0; y < qr.getSize(); y++) {
+				for (int x = 0; x < qr.getSize(); x++)
+					std::cout << (qr.getModule(x, y) ? 1 : 0) << std::endl;
+			}
+			
+		} catch (const qrcodegen::data_too_long &ex) {
+			std::cout << -1 << std::endl;
+		}
+		std::cout << std::flush;
+	}
+	return EXIT_SUCCESS;
+}
diff --git a/Telegram/ThirdParty/QR/cpp/QrSegment.cpp b/Telegram/ThirdParty/QR/cpp/QrSegment.cpp
new file mode 100644
index 0000000..45ea843
--- /dev/null
+++ b/Telegram/ThirdParty/QR/cpp/QrSegment.cpp
@@ -0,0 +1,225 @@
+/* 
+ * QR Code generator library (C++)
+ * 
+ * Copyright (c) Project Nayuki. (MIT License)
+ * https://www.nayuki.io/page/qr-code-generator-library
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ * - The above copyright notice and this permission notice shall be included in
+ *   all copies or substantial portions of the Software.
+ * - The Software is provided "as is", without warranty of any kind, express or
+ *   implied, including but not limited to the warranties of merchantability,
+ *   fitness for a particular purpose and noninfringement. In no event shall the
+ *   authors or copyright holders be liable for any claim, damages or other
+ *   liability, whether in an action of contract, tort or otherwise, arising from,
+ *   out of or in connection with the Software or the use or other dealings in the
+ *   Software.
+ */
+
+#include <climits>
+#include <cstring>
+#include <stdexcept>
+#include <utility>
+#include "QrSegment.hpp"
+
+using std::uint8_t;
+using std::vector;
+
+
+namespace qrcodegen {
+
+QrSegment::Mode::Mode(int mode, int cc0, int cc1, int cc2) :
+		modeBits(mode) {
+	numBitsCharCount[0] = cc0;
+	numBitsCharCount[1] = cc1;
+	numBitsCharCount[2] = cc2;
+}
+
+
+int QrSegment::Mode::getModeBits() const {
+	return modeBits;
+}
+
+
+int QrSegment::Mode::numCharCountBits(int ver) const {
+	return numBitsCharCount[(ver + 7) / 17];
+}
+
+
+const QrSegment::Mode QrSegment::Mode::NUMERIC     (0x1, 10, 12, 14);
+const QrSegment::Mode QrSegment::Mode::ALPHANUMERIC(0x2,  9, 11, 13);
+const QrSegment::Mode QrSegment::Mode::BYTE        (0x4,  8, 16, 16);
+const QrSegment::Mode QrSegment::Mode::KANJI       (0x8,  8, 10, 12);
+const QrSegment::Mode QrSegment::Mode::ECI         (0x7,  0,  0,  0);
+
+
+
+QrSegment QrSegment::makeBytes(const vector<uint8_t> &data) {
+	if (data.size() > static_cast<unsigned int>(INT_MAX))
+		throw std::length_error("Data too long");
+	BitBuffer bb;
+	for (uint8_t b : data)
+		bb.appendBits(b, 8);
+	return QrSegment(Mode::BYTE, static_cast<int>(data.size()), std::move(bb));
+}
+
+
+QrSegment QrSegment::makeNumeric(const char *digits) {
+	BitBuffer bb;
+	int accumData = 0;
+	int accumCount = 0;
+	int charCount = 0;
+	for (; *digits != '\0'; digits++, charCount++) {
+		char c = *digits;
+		if (c < '0' || c > '9')
+			throw std::domain_error("String contains non-numeric characters");
+		accumData = accumData * 10 + (c - '0');
+		accumCount++;
+		if (accumCount == 3) {
+			bb.appendBits(static_cast<uint32_t>(accumData), 10);
+			accumData = 0;
+			accumCount = 0;
+		}
+	}
+	if (accumCount > 0)  // 1 or 2 digits remaining
+		bb.appendBits(static_cast<uint32_t>(accumData), accumCount * 3 + 1);
+	return QrSegment(Mode::NUMERIC, charCount, std::move(bb));
+}
+
+
+QrSegment QrSegment::makeAlphanumeric(const char *text) {
+	BitBuffer bb;
+	int accumData = 0;
+	int accumCount = 0;
+	int charCount = 0;
+	for (; *text != '\0'; text++, charCount++) {
+		const char *temp = std::strchr(ALPHANUMERIC_CHARSET, *text);
+		if (temp == nullptr)
+			throw std::domain_error("String contains unencodable characters in alphanumeric mode");
+		accumData = accumData * 45 + static_cast<int>(temp - ALPHANUMERIC_CHARSET);
+		accumCount++;
+		if (accumCount == 2) {
+			bb.appendBits(static_cast<uint32_t>(accumData), 11);
+			accumData = 0;
+			accumCount = 0;
+		}
+	}
+	if (accumCount > 0)  // 1 character remaining
+		bb.appendBits(static_cast<uint32_t>(accumData), 6);
+	return QrSegment(Mode::ALPHANUMERIC, charCount, std::move(bb));
+}
+
+
+vector<QrSegment> QrSegment::makeSegments(const char *text) {
+	// Select the most efficient segment encoding automatically
+	vector<QrSegment> result;
+	if (*text == '\0');  // Leave result empty
+	else if (isNumeric(text))
+		result.push_back(makeNumeric(text));
+	else if (isAlphanumeric(text))
+		result.push_back(makeAlphanumeric(text));
+	else {
+		vector<uint8_t> bytes;
+		for (; *text != '\0'; text++)
+			bytes.push_back(static_cast<uint8_t>(*text));
+		result.push_back(makeBytes(bytes));
+	}
+	return result;
+}
+
+
+QrSegment QrSegment::makeEci(long assignVal) {
+	BitBuffer bb;
+	if (assignVal < 0)
+		throw std::domain_error("ECI assignment value out of range");
+	else if (assignVal < (1 << 7))
+		bb.appendBits(static_cast<uint32_t>(assignVal), 8);
+	else if (assignVal < (1 << 14)) {
+		bb.appendBits(2, 2);
+		bb.appendBits(static_cast<uint32_t>(assignVal), 14);
+	} else if (assignVal < 1000000L) {
+		bb.appendBits(6, 3);
+		bb.appendBits(static_cast<uint32_t>(assignVal), 21);
+	} else
+		throw std::domain_error("ECI assignment value out of range");
+	return QrSegment(Mode::ECI, 0, std::move(bb));
+}
+
+
+QrSegment::QrSegment(Mode md, int numCh, const std::vector<bool> &dt) :
+		mode(md),
+		numChars(numCh),
+		data(dt) {
+	if (numCh < 0)
+		throw std::domain_error("Invalid value");
+}
+
+
+QrSegment::QrSegment(Mode md, int numCh, std::vector<bool> &&dt) :
+		mode(md),
+		numChars(numCh),
+		data(std::move(dt)) {
+	if (numCh < 0)
+		throw std::domain_error("Invalid value");
+}
+
+
+int QrSegment::getTotalBits(const vector<QrSegment> &segs, int version) {
+	int result = 0;
+	for (const QrSegment &seg : segs) {
+		int ccbits = seg.mode.numCharCountBits(version);
+		if (seg.numChars >= (1L << ccbits))
+			return -1;  // The segment's length doesn't fit the field's bit width
+		if (4 + ccbits > INT_MAX - result)
+			return -1;  // The sum will overflow an int type
+		result += 4 + ccbits;
+		if (seg.data.size() > static_cast<unsigned int>(INT_MAX - result))
+			return -1;  // The sum will overflow an int type
+		result += static_cast<int>(seg.data.size());
+	}
+	return result;
+}
+
+
+bool QrSegment::isAlphanumeric(const char *text) {
+	for (; *text != '\0'; text++) {
+		if (std::strchr(ALPHANUMERIC_CHARSET, *text) == nullptr)
+			return false;
+	}
+	return true;
+}
+
+
+bool QrSegment::isNumeric(const char *text) {
+	for (; *text != '\0'; text++) {
+		char c = *text;
+		if (c < '0' || c > '9')
+			return false;
+	}
+	return true;
+}
+
+
+QrSegment::Mode QrSegment::getMode() const {
+	return mode;
+}
+
+
+int QrSegment::getNumChars() const {
+	return numChars;
+}
+
+
+const std::vector<bool> &QrSegment::getData() const {
+	return data;
+}
+
+
+const char *QrSegment::ALPHANUMERIC_CHARSET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";
+
+}
diff --git a/Telegram/ThirdParty/QR/cpp/QrSegment.hpp b/Telegram/ThirdParty/QR/cpp/QrSegment.hpp
new file mode 100644
index 0000000..663b8bb
--- /dev/null
+++ b/Telegram/ThirdParty/QR/cpp/QrSegment.hpp
@@ -0,0 +1,216 @@
+/* 
+ * QR Code generator library (C++)
+ * 
+ * Copyright (c) Project Nayuki. (MIT License)
+ * https://www.nayuki.io/page/qr-code-generator-library
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ * - The above copyright notice and this permission notice shall be included in
+ *   all copies or substantial portions of the Software.
+ * - The Software is provided "as is", without warranty of any kind, express or
+ *   implied, including but not limited to the warranties of merchantability,
+ *   fitness for a particular purpose and noninfringement. In no event shall the
+ *   authors or copyright holders be liable for any claim, damages or other
+ *   liability, whether in an action of contract, tort or otherwise, arising from,
+ *   out of or in connection with the Software or the use or other dealings in the
+ *   Software.
+ */
+
+#pragma once
+
+#include <cstdint>
+#include <vector>
+#include "BitBuffer.hpp"
+
+
+namespace qrcodegen {
+
+/* 
+ * A segment of character/binary/control data in a QR Code symbol.
+ * Instances of this class are immutable.
+ * The mid-level way to create a segment is to take the payload data
+ * and call a static factory function such as QrSegment::makeNumeric().
+ * The low-level way to create a segment is to custom-make the bit buffer
+ * and call the QrSegment() constructor with appropriate values.
+ * This segment class imposes no length restrictions, but QR Codes have restrictions.
+ * Even in the most favorable conditions, a QR Code can only hold 7089 characters of data.
+ * Any segment longer than this is meaningless for the purpose of generating QR Codes.
+ */
+class QrSegment final {
+	
+	/*---- Public helper enumeration ----*/
+	
+	/* 
+	 * Describes how a segment's data bits are interpreted. Immutable.
+	 */
+	public: class Mode final {
+		
+		/*-- Constants --*/
+		
+		public: static const Mode NUMERIC;
+		public: static const Mode ALPHANUMERIC;
+		public: static const Mode BYTE;
+		public: static const Mode KANJI;
+		public: static const Mode ECI;
+		
+		
+		/*-- Fields --*/
+		
+		// The mode indicator bits, which is a uint4 value (range 0 to 15).
+		private: int modeBits;
+		
+		// Number of character count bits for three different version ranges.
+		private: int numBitsCharCount[3];
+		
+		
+		/*-- Constructor --*/
+		
+		private: Mode(int mode, int cc0, int cc1, int cc2);
+		
+		
+		/*-- Methods --*/
+		
+		/* 
+		 * (Package-private) Returns the mode indicator bits, which is an unsigned 4-bit value (range 0 to 15).
+		 */
+		public: int getModeBits() const;
+		
+		/* 
+		 * (Package-private) Returns the bit width of the character count field for a segment in
+		 * this mode in a QR Code at the given version number. The result is in the range [0, 16].
+		 */
+		public: int numCharCountBits(int ver) const;
+		
+	};
+	
+	
+	
+	/*---- Static factory functions (mid level) ----*/
+	
+	/* 
+	 * Returns a segment representing the given binary data encoded in
+	 * byte mode. All input byte vectors are acceptable. Any text string
+	 * can be converted to UTF-8 bytes and encoded as a byte mode segment.
+	 */
+	public: static QrSegment makeBytes(const std::vector<std::uint8_t> &data);
+	
+	
+	/* 
+	 * Returns a segment representing the given string of decimal digits encoded in numeric mode.
+	 */
+	public: static QrSegment makeNumeric(const char *digits);
+	
+	
+	/* 
+	 * Returns a segment representing the given text string encoded in alphanumeric mode.
+	 * The characters allowed are: 0 to 9, A to Z (uppercase only), space,
+	 * dollar, percent, asterisk, plus, hyphen, period, slash, colon.
+	 */
+	public: static QrSegment makeAlphanumeric(const char *text);
+	
+	
+	/* 
+	 * Returns a list of zero or more segments to represent the given text string. The result
+	 * may use various segment modes and switch modes to optimize the length of the bit stream.
+	 */
+	public: static std::vector<QrSegment> makeSegments(const char *text);
+	
+	
+	/* 
+	 * Returns a segment representing an Extended Channel Interpretation
+	 * (ECI) designator with the given assignment value.
+	 */
+	public: static QrSegment makeEci(long assignVal);
+	
+	
+	/*---- Public static helper functions ----*/
+	
+	/* 
+	 * Tests whether the given string can be encoded as a segment in alphanumeric mode.
+	 * A string is encodable iff each character is in the following set: 0 to 9, A to Z
+	 * (uppercase only), space, dollar, percent, asterisk, plus, hyphen, period, slash, colon.
+	 */
+	public: static bool isAlphanumeric(const char *text);
+	
+	
+	/* 
+	 * Tests whether the given string can be encoded as a segment in numeric mode.
+	 * A string is encodable iff each character is in the range 0 to 9.
+	 */
+	public: static bool isNumeric(const char *text);
+	
+	
+	
+	/*---- Instance fields ----*/
+	
+	/* The mode indicator of this segment. Accessed through getMode(). */
+	private: Mode mode;
+	
+	/* The length of this segment's unencoded data. Measured in characters for
+	 * numeric/alphanumeric/kanji mode, bytes for byte mode, and 0 for ECI mode.
+	 * Always zero or positive. Not the same as the data's bit length.
+	 * Accessed through getNumChars(). */
+	private: int numChars;
+	
+	/* The data bits of this segment. Accessed through getData(). */
+	private: std::vector<bool> data;
+	
+	
+	/*---- Constructors (low level) ----*/
+	
+	/* 
+	 * Creates a new QR Code segment with the given attributes and data.
+	 * The character count (numCh) must agree with the mode and the bit buffer length,
+	 * but the constraint isn't checked. The given bit buffer is copied and stored.
+	 */
+	public: QrSegment(Mode md, int numCh, const std::vector<bool> &dt);
+	
+	
+	/* 
+	 * Creates a new QR Code segment with the given parameters and data.
+	 * The character count (numCh) must agree with the mode and the bit buffer length,
+	 * but the constraint isn't checked. The given bit buffer is moved and stored.
+	 */
+	public: QrSegment(Mode md, int numCh, std::vector<bool> &&dt);
+	
+	
+	/*---- Methods ----*/
+	
+	/* 
+	 * Returns the mode field of this segment.
+	 */
+	public: Mode getMode() const;
+	
+	
+	/* 
+	 * Returns the character count field of this segment.
+	 */
+	public: int getNumChars() const;
+	
+	
+	/* 
+	 * Returns the data bits of this segment.
+	 */
+	public: const std::vector<bool> &getData() const;
+	
+	
+	// (Package-private) Calculates the number of bits needed to encode the given segments at
+	// the given version. Returns a non-negative number if successful. Otherwise returns -1 if a
+	// segment has too many characters to fit its length field, or the total bits exceeds INT_MAX.
+	public: static int getTotalBits(const std::vector<QrSegment> &segs, int version);
+	
+	
+	/*---- Private constant ----*/
+	
+	/* The set of all legal characters in alphanumeric mode, where
+	 * each character value maps to the index in the string. */
+	private: static const char *ALPHANUMERIC_CHARSET;
+	
+};
+
+}
diff --git a/Telegram/ThirdParty/QR/java/pom.xml b/Telegram/ThirdParty/QR/java/pom.xml
new file mode 100644
index 0000000..d36e826
--- /dev/null
+++ b/Telegram/ThirdParty/QR/java/pom.xml
@@ -0,0 +1,94 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+	<modelVersion>4.0.0</modelVersion>
+	
+	<groupId>io.nayuki</groupId>
+	<artifactId>qrcodegen</artifactId>
+	<version>1.5.0</version>
+	<packaging>jar</packaging>
+	<properties>
+		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+		<maven.compiler.source>1.8</maven.compiler.source>
+		<maven.compiler.target>1.8</maven.compiler.target>
+	</properties>
+	
+	<build>
+		<plugins>
+			<plugin>
+				<groupId>org.apache.maven.plugins</groupId>
+				<artifactId>maven-source-plugin</artifactId>
+				<version>2.2.1</version>
+				<executions>
+					<execution>
+						<id>attach-sources</id>
+						<goals>
+							<goal>jar-no-fork</goal>
+						</goals>
+					</execution>
+				</executions>
+			</plugin>
+			<plugin>
+				<groupId>org.apache.maven.plugins</groupId>
+				<artifactId>maven-javadoc-plugin</artifactId>
+				<version>2.9.1</version>
+				<executions>
+					<execution>
+						<id>attach-javadocs</id>
+						<goals>
+							<goal>jar</goal>
+						</goals>
+					</execution>
+				</executions>
+			</plugin>
+			<plugin>
+				<groupId>org.apache.maven.plugins</groupId>
+				<artifactId>maven-gpg-plugin</artifactId>
+				<version>1.5</version>
+				<executions>
+					<execution>
+						<id>sign-artifacts</id>
+						<phase>verify</phase>
+						<goals>
+							<goal>sign</goal>
+						</goals>
+					</execution>
+				</executions>
+			</plugin>
+		</plugins>
+	</build>
+	
+	<name>QR Code generator library</name>
+	<description>High quality QR Code generator library</description>
+	<url>https://www.nayuki.io/page/qr-code-generator-library</url>
+	<inceptionYear>2016</inceptionYear>
+	<licenses>
+		<license>
+			<name>The MIT License</name>
+			<url>https://opensource.org/licenses/MIT</url>
+			<distribution>repo</distribution>
+		</license>
+	</licenses>
+	<developers>
+		<developer>
+			<name>Project Nayuki</name>
+			<email>me@nayuki.io</email>
+			<url>https://www.nayuki.io/</url>
+		</developer>
+	</developers>
+	
+	<scm>
+		<connection>scm:git:git://github.com/nayuki/QR-Code-generator.git</connection>
+		<developerConnection>scm:git:ssh://github.com:nayuki/QR-Code-generator.git</developerConnection>
+		<url>https://github.com/nayuki/QR-Code-generator/tree/master/java</url>
+	</scm>
+	<distributionManagement>
+		<snapshotRepository>
+			<id>ossrh</id>
+			<url>https://oss.sonatype.org/content/repositories/snapshots</url>
+		</snapshotRepository>
+		<repository>
+			<id>ossrh</id>
+			<url>https://oss.sonatype.org/service/local/staging/deploy/maven2/</url>
+		</repository>
+	</distributionManagement>
+</project>
diff --git a/Telegram/ThirdParty/QR/java/src/main/java/io/nayuki/qrcodegen/BitBuffer.java b/Telegram/ThirdParty/QR/java/src/main/java/io/nayuki/qrcodegen/BitBuffer.java
new file mode 100644
index 0000000..624d129
--- /dev/null
+++ b/Telegram/ThirdParty/QR/java/src/main/java/io/nayuki/qrcodegen/BitBuffer.java
@@ -0,0 +1,129 @@
+/* 
+ * QR Code generator library (Java)
+ * 
+ * Copyright (c) Project Nayuki. (MIT License)
+ * https://www.nayuki.io/page/qr-code-generator-library
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ * - The above copyright notice and this permission notice shall be included in
+ *   all copies or substantial portions of the Software.
+ * - The Software is provided "as is", without warranty of any kind, express or
+ *   implied, including but not limited to the warranties of merchantability,
+ *   fitness for a particular purpose and noninfringement. In no event shall the
+ *   authors or copyright holders be liable for any claim, damages or other
+ *   liability, whether in an action of contract, tort or otherwise, arising from,
+ *   out of or in connection with the Software or the use or other dealings in the
+ *   Software.
+ */
+
+package io.nayuki.qrcodegen;
+
+import java.util.BitSet;
+import java.util.Objects;
+
+
+/**
+ * An appendable sequence of bits (0s and 1s). Mainly used by {@link QrSegment}.
+ */
+public final class BitBuffer implements Cloneable {
+	
+	/*---- Fields ----*/
+	
+	private BitSet data;
+	
+	private int bitLength;  // Non-negative
+	
+	
+	
+	/*---- Constructor ----*/
+	
+	/**
+	 * Constructs an empty bit buffer (length 0).
+	 */
+	public BitBuffer() {
+		data = new BitSet();
+		bitLength = 0;
+	}
+	
+	
+	
+	/*---- Methods ----*/
+	
+	/**
+	 * Returns the length of this sequence, which is a non-negative value.
+	 * @return the length of this sequence
+	 */
+	public int bitLength() {
+		assert bitLength >= 0;
+		return bitLength;
+	}
+	
+	
+	/**
+	 * Returns the bit at the specified index, yielding 0 or 1.
+	 * @param index the index to get the bit at
+	 * @return the bit at the specified index
+	 * @throws IndexOutOfBoundsException if index &lt; 0 or index &#x2265; bitLength
+	 */
+	public int getBit(int index) {
+		if (index < 0 || index >= bitLength)
+			throw new IndexOutOfBoundsException();
+		return data.get(index) ? 1 : 0;
+	}
+	
+	
+	/**
+	 * Appends the specified number of low-order bits of the specified value to this
+	 * buffer. Requires 0 &#x2264; len &#x2264; 31 and 0 &#x2264; val &lt; 2<sup>len</sup>.
+	 * @param val the value to append
+	 * @param len the number of low-order bits in the value to take
+	 * @throws IllegalArgumentException if the value or number of bits is out of range
+	 * @throws IllegalStateException if appending the data
+	 * would make bitLength exceed Integer.MAX_VALUE
+	 */
+	public void appendBits(int val, int len) {
+		if (len < 0 || len > 31 || val >>> len != 0)
+			throw new IllegalArgumentException("Value out of range");
+		if (Integer.MAX_VALUE - bitLength < len)
+			throw new IllegalStateException("Maximum length reached");
+		for (int i = len - 1; i >= 0; i--, bitLength++)  // Append bit by bit
+			data.set(bitLength, QrCode.getBit(val, i));
+	}
+	
+	
+	/**
+	 * Appends the content of the specified bit buffer to this buffer.
+	 * @param bb the bit buffer whose data to append (not {@code null})
+	 * @throws NullPointerException if the bit buffer is {@code null}
+	 * @throws IllegalStateException if appending the data
+	 * would make bitLength exceed Integer.MAX_VALUE
+	 */
+	public void appendData(BitBuffer bb) {
+		Objects.requireNonNull(bb);
+		if (Integer.MAX_VALUE - bitLength < bb.bitLength)
+			throw new IllegalStateException("Maximum length reached");
+		for (int i = 0; i < bb.bitLength; i++, bitLength++)  // Append bit by bit
+			data.set(bitLength, bb.data.get(i));
+	}
+	
+	
+	/**
+	 * Returns a new copy of this buffer.
+	 * @return a new copy of this buffer (not {@code null})
+	 */
+	public BitBuffer clone() {
+		try {
+			BitBuffer result = (BitBuffer)super.clone();
+			result.data = (BitSet)result.data.clone();
+			return result;
+		} catch (CloneNotSupportedException e) {
+			throw new AssertionError(e);
+		}
+	}
+	
+}
diff --git a/Telegram/ThirdParty/QR/java/src/main/java/io/nayuki/qrcodegen/DataTooLongException.java b/Telegram/ThirdParty/QR/java/src/main/java/io/nayuki/qrcodegen/DataTooLongException.java
new file mode 100644
index 0000000..0cbefc7
--- /dev/null
+++ b/Telegram/ThirdParty/QR/java/src/main/java/io/nayuki/qrcodegen/DataTooLongException.java
@@ -0,0 +1,57 @@
+/* 
+ * QR Code generator library (Java)
+ * 
+ * Copyright (c) Project Nayuki. (MIT License)
+ * https://www.nayuki.io/page/qr-code-generator-library
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ * - The above copyright notice and this permission notice shall be included in
+ *   all copies or substantial portions of the Software.
+ * - The Software is provided "as is", without warranty of any kind, express or
+ *   implied, including but not limited to the warranties of merchantability,
+ *   fitness for a particular purpose and noninfringement. In no event shall the
+ *   authors or copyright holders be liable for any claim, damages or other
+ *   liability, whether in an action of contract, tort or otherwise, arising from,
+ *   out of or in connection with the Software or the use or other dealings in the
+ *   Software.
+ */
+
+package io.nayuki.qrcodegen;
+
+
+/**
+ * Thrown when the supplied data does not fit any QR Code version. Ways to handle this exception include:
+ * <ul>
+ *   <li><p>Decrease the error correction level if it was greater than {@code Ecc.LOW}.</p></li>
+ *   <li><p>If the advanced {@code encodeSegments()} function with 6 arguments or the
+ *     {@code makeSegmentsOptimally()} function was called, then increase the maxVersion argument
+ *     if it was less than {@link QrCode#MAX_VERSION}. (This advice does not apply to the other
+ *     factory functions because they search all versions up to {@code QrCode.MAX_VERSION}.)</p></li>
+ *   <li><p>Split the text data into better or optimal segments in order to reduce the number of
+ *     bits required. (See {@link QrSegmentAdvanced#makeSegmentsOptimally(String,QrCode.Ecc,int,int)
+ *     QrSegmentAdvanced.makeSegmentsOptimally()}.)</p></li>
+ *   <li><p>Change the text or binary data to be shorter.</p></li>
+ *   <li><p>Change the text to fit the character set of a particular segment mode (e.g. alphanumeric).</p></li>
+ *   <li><p>Propagate the error upward to the caller/user.</p></li>
+ * </ul>
+ * @see QrCode#encodeText(String, QrCode.Ecc)
+ * @see QrCode#encodeBinary(byte[], QrCode.Ecc)
+ * @see QrCode#encodeSegments(java.util.List, QrCode.Ecc)
+ * @see QrCode#encodeSegments(java.util.List, QrCode.Ecc, int, int, int, boolean)
+ * @see QrSegmentAdvanced#makeSegmentsOptimally(String, QrCode.Ecc, int, int)
+ */
+public class DataTooLongException extends IllegalArgumentException {
+	
+	public DataTooLongException() {}
+	
+	
+	public DataTooLongException(String msg) {
+		super(msg);
+	}
+	
+}
diff --git a/Telegram/ThirdParty/QR/java/src/main/java/io/nayuki/qrcodegen/QrCode.java b/Telegram/ThirdParty/QR/java/src/main/java/io/nayuki/qrcodegen/QrCode.java
new file mode 100644
index 0000000..59608e8
--- /dev/null
+++ b/Telegram/ThirdParty/QR/java/src/main/java/io/nayuki/qrcodegen/QrCode.java
@@ -0,0 +1,888 @@
+/* 
+ * QR Code generator library (Java)
+ * 
+ * Copyright (c) Project Nayuki. (MIT License)
+ * https://www.nayuki.io/page/qr-code-generator-library
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ * - The above copyright notice and this permission notice shall be included in
+ *   all copies or substantial portions of the Software.
+ * - The Software is provided "as is", without warranty of any kind, express or
+ *   implied, including but not limited to the warranties of merchantability,
+ *   fitness for a particular purpose and noninfringement. In no event shall the
+ *   authors or copyright holders be liable for any claim, damages or other
+ *   liability, whether in an action of contract, tort or otherwise, arising from,
+ *   out of or in connection with the Software or the use or other dealings in the
+ *   Software.
+ */
+
+package io.nayuki.qrcodegen;
+
+import java.awt.image.BufferedImage;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Objects;
+
+
+/**
+ * A QR Code symbol, which is a type of two-dimension barcode.
+ * Invented by Denso Wave and described in the ISO/IEC 18004 standard.
+ * <p>Instances of this class represent an immutable square grid of black and white cells.
+ * The class provides static factory functions to create a QR Code from text or binary data.
+ * The class covers the QR Code Model 2 specification, supporting all versions (sizes)
+ * from 1 to 40, all 4 error correction levels, and 4 character encoding modes.</p>
+ * <p>Ways to create a QR Code object:</p>
+ * <ul>
+ *   <li><p>High level: Take the payload data and call {@link QrCode#encodeText(String,Ecc)}
+ *     or {@link QrCode#encodeBinary(byte[],Ecc)}.</p></li>
+ *   <li><p>Mid level: Custom-make the list of {@link QrSegment segments}
+ *     and call {@link QrCode#encodeSegments(List,Ecc)} or
+ *     {@link QrCode#encodeSegments(List,Ecc,int,int,int,boolean)}</p></li>
+ *   <li><p>Low level: Custom-make the array of data codeword bytes (including segment headers and
+ *     final padding, excluding error correction codewords), supply the appropriate version number,
+ *     and call the {@link QrCode#QrCode(int,Ecc,byte[],int) constructor}.</p></li>
+ * </ul>
+ * <p>(Note that all ways require supplying the desired error correction level.)</p>
+ * @see QrSegment
+ */
+public final class QrCode {
+	
+	/*---- Static factory functions (high level) ----*/
+	
+	/**
+	 * Returns a QR Code representing the specified Unicode text string at the specified error correction level.
+	 * As a conservative upper bound, this function is guaranteed to succeed for strings that have 738 or fewer
+	 * Unicode code points (not UTF-16 code units) if the low error correction level is used. The smallest possible
+	 * QR Code version is automatically chosen for the output. The ECC level of the result may be higher than the
+	 * ecl argument if it can be done without increasing the version.
+	 * @param text the text to be encoded (not {@code null}), which can be any Unicode string
+	 * @param ecl the error correction level to use (not {@code null}) (boostable)
+	 * @return a QR Code (not {@code null}) representing the text
+	 * @throws NullPointerException if the text or error correction level is {@code null}
+	 * @throws DataTooLongException if the text fails to fit in the
+	 * largest version QR Code at the ECL, which means it is too long
+	 */
+	public static QrCode encodeText(String text, Ecc ecl) {
+		Objects.requireNonNull(text);
+		Objects.requireNonNull(ecl);
+		List<QrSegment> segs = QrSegment.makeSegments(text);
+		return encodeSegments(segs, ecl);
+	}
+	
+	
+	/**
+	 * Returns a QR Code representing the specified binary data at the specified error correction level.
+	 * This function always encodes using the binary segment mode, not any text mode. The maximum number of
+	 * bytes allowed is 2953. The smallest possible QR Code version is automatically chosen for the output.
+	 * The ECC level of the result may be higher than the ecl argument if it can be done without increasing the version.
+	 * @param data the binary data to encode (not {@code null})
+	 * @param ecl the error correction level to use (not {@code null}) (boostable)
+	 * @return a QR Code (not {@code null}) representing the data
+	 * @throws NullPointerException if the data or error correction level is {@code null}
+	 * @throws DataTooLongException if the data fails to fit in the
+	 * largest version QR Code at the ECL, which means it is too long
+	 */
+	public static QrCode encodeBinary(byte[] data, Ecc ecl) {
+		Objects.requireNonNull(data);
+		Objects.requireNonNull(ecl);
+		QrSegment seg = QrSegment.makeBytes(data);
+		return encodeSegments(Arrays.asList(seg), ecl);
+	}
+	
+	
+	/*---- Static factory functions (mid level) ----*/
+	
+	/**
+	 * Returns a QR Code representing the specified segments at the specified error correction
+	 * level. The smallest possible QR Code version is automatically chosen for the output. The ECC level
+	 * of the result may be higher than the ecl argument if it can be done without increasing the version.
+	 * <p>This function allows the user to create a custom sequence of segments that switches
+	 * between modes (such as alphanumeric and byte) to encode text in less space.
+	 * This is a mid-level API; the high-level API is {@link #encodeText(String,Ecc)}
+	 * and {@link #encodeBinary(byte[],Ecc)}.</p>
+	 * @param segs the segments to encode
+	 * @param ecl the error correction level to use (not {@code null}) (boostable)
+	 * @return a QR Code (not {@code null}) representing the segments
+	 * @throws NullPointerException if the list of segments, any segment, or the error correction level is {@code null}
+	 * @throws DataTooLongException if the segments fail to fit in the
+	 * largest version QR Code at the ECL, which means they are too long
+	 */
+	public static QrCode encodeSegments(List<QrSegment> segs, Ecc ecl) {
+		return encodeSegments(segs, ecl, MIN_VERSION, MAX_VERSION, -1, true);
+	}
+	
+	
+	/**
+	 * Returns a QR Code representing the specified segments with the specified encoding parameters.
+	 * The smallest possible QR Code version within the specified range is automatically
+	 * chosen for the output. Iff boostEcl is {@code true}, then the ECC level of the
+	 * result may be higher than the ecl argument if it can be done without increasing
+	 * the version. The mask number is either between 0 to 7 (inclusive) to force that
+	 * mask, or &#x2212;1 to automatically choose an appropriate mask (which may be slow).
+	 * <p>This function allows the user to create a custom sequence of segments that switches
+	 * between modes (such as alphanumeric and byte) to encode text in less space.
+	 * This is a mid-level API; the high-level API is {@link #encodeText(String,Ecc)}
+	 * and {@link #encodeBinary(byte[],Ecc)}.</p>
+	 * @param segs the segments to encode
+	 * @param ecl the error correction level to use (not {@code null}) (boostable)
+	 * @param minVersion the minimum allowed version of the QR Code (at least 1)
+	 * @param maxVersion the maximum allowed version of the QR Code (at most 40)
+	 * @param mask the mask number to use (between 0 and 7 (inclusive)), or &#x2212;1 for automatic mask
+	 * @param boostEcl increases the ECC level as long as it doesn't increase the version number
+	 * @return a QR Code (not {@code null}) representing the segments
+	 * @throws NullPointerException if the list of segments, any segment, or the error correction level is {@code null}
+	 * @throws IllegalArgumentException if 1 &#x2264; minVersion &#x2264; maxVersion &#x2264; 40
+	 * or &#x2212;1 &#x2264; mask &#x2264; 7 is violated
+	 * @throws DataTooLongException if the segments fail to fit in
+	 * the maxVersion QR Code at the ECL, which means they are too long
+	 */
+	public static QrCode encodeSegments(List<QrSegment> segs, Ecc ecl, int minVersion, int maxVersion, int mask, boolean boostEcl) {
+		Objects.requireNonNull(segs);
+		Objects.requireNonNull(ecl);
+		if (!(MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= MAX_VERSION) || mask < -1 || mask > 7)
+			throw new IllegalArgumentException("Invalid value");
+		
+		// Find the minimal version number to use
+		int version, dataUsedBits;
+		for (version = minVersion; ; version++) {
+			int dataCapacityBits = getNumDataCodewords(version, ecl) * 8;  // Number of data bits available
+			dataUsedBits = QrSegment.getTotalBits(segs, version);
+			if (dataUsedBits != -1 && dataUsedBits <= dataCapacityBits)
+				break;  // This version number is found to be suitable
+			if (version >= maxVersion) {  // All versions in the range could not fit the given data
+				String msg = "Segment too long";
+				if (dataUsedBits != -1)
+					msg = String.format("Data length = %d bits, Max capacity = %d bits", dataUsedBits, dataCapacityBits);
+				throw new DataTooLongException(msg);
+			}
+		}
+		assert dataUsedBits != -1;
+		
+		// Increase the error correction level while the data still fits in the current version number
+		for (Ecc newEcl : Ecc.values()) {  // From low to high
+			if (boostEcl && dataUsedBits <= getNumDataCodewords(version, newEcl) * 8)
+				ecl = newEcl;
+		}
+		
+		// Concatenate all segments to create the data bit string
+		BitBuffer bb = new BitBuffer();
+		for (QrSegment seg : segs) {
+			bb.appendBits(seg.mode.modeBits, 4);
+			bb.appendBits(seg.numChars, seg.mode.numCharCountBits(version));
+			bb.appendData(seg.data);
+		}
+		assert bb.bitLength() == dataUsedBits;
+		
+		// Add terminator and pad up to a byte if applicable
+		int dataCapacityBits = getNumDataCodewords(version, ecl) * 8;
+		assert bb.bitLength() <= dataCapacityBits;
+		bb.appendBits(0, Math.min(4, dataCapacityBits - bb.bitLength()));
+		bb.appendBits(0, (8 - bb.bitLength() % 8) % 8);
+		assert bb.bitLength() % 8 == 0;
+		
+		// Pad with alternating bytes until data capacity is reached
+		for (int padByte = 0xEC; bb.bitLength() < dataCapacityBits; padByte ^= 0xEC ^ 0x11)
+			bb.appendBits(padByte, 8);
+		
+		// Pack bits into bytes in big endian
+		byte[] dataCodewords = new byte[bb.bitLength() / 8];
+		for (int i = 0; i < bb.bitLength(); i++)
+			dataCodewords[i >>> 3] |= bb.getBit(i) << (7 - (i & 7));
+		
+		// Create the QR Code object
+		return new QrCode(version, ecl, dataCodewords, mask);
+	}
+	
+	
+	
+	/*---- Instance fields ----*/
+	
+	// Public immutable scalar parameters:
+	
+	/** The version number of this QR Code, which is between 1 and 40 (inclusive).
+	 * This determines the size of this barcode. */
+	public final int version;
+	
+	/** The width and height of this QR Code, measured in modules, between
+	 * 21 and 177 (inclusive). This is equal to version &#xD7; 4 + 17. */
+	public final int size;
+	
+	/** The error correction level used in this QR Code, which is not {@code null}. */
+	public final Ecc errorCorrectionLevel;
+	
+	/** The index of the mask pattern used in this QR Code, which is between 0 and 7 (inclusive).
+	 * <p>Even if a QR Code is created with automatic masking requested (mask =
+	 * &#x2212;1), the resulting object still has a mask value between 0 and 7. */
+	public final int mask;
+	
+	// Private grids of modules/pixels, with dimensions of size*size:
+	
+	// The modules of this QR Code (false = white, true = black).
+	// Immutable after constructor finishes. Accessed through getModule().
+	private boolean[][] modules;
+	
+	// Indicates function modules that are not subjected to masking. Discarded when constructor finishes.
+	private boolean[][] isFunction;
+	
+	
+	
+	/*---- Constructor (low level) ----*/
+	
+	/**
+	 * Constructs a QR Code with the specified version number,
+	 * error correction level, data codeword bytes, and mask number.
+	 * <p>This is a low-level API that most users should not use directly. A mid-level
+	 * API is the {@link #encodeSegments(List,Ecc,int,int,int,boolean)} function.</p>
+	 * @param ver the version number to use, which must be in the range 1 to 40 (inclusive)
+	 * @param ecl the error correction level to use
+	 * @param dataCodewords the bytes representing segments to encode (without ECC)
+	 * @param msk the mask pattern to use, which is either &#x2212;1 for automatic choice or from 0 to 7 for fixed choice
+	 * @throws NullPointerException if the byte array or error correction level is {@code null}
+	 * @throws IllegalArgumentException if the version or mask value is out of range,
+	 * or if the data is the wrong length for the specified version and error correction level
+	 */
+	public QrCode(int ver, Ecc ecl, byte[] dataCodewords, int msk) {
+		// Check arguments and initialize fields
+		if (ver < MIN_VERSION || ver > MAX_VERSION)
+			throw new IllegalArgumentException("Version value out of range");
+		if (msk < -1 || msk > 7)
+			throw new IllegalArgumentException("Mask value out of range");
+		version = ver;
+		size = ver * 4 + 17;
+		errorCorrectionLevel = Objects.requireNonNull(ecl);
+		Objects.requireNonNull(dataCodewords);
+		modules    = new boolean[size][size];  // Initially all white
+		isFunction = new boolean[size][size];
+		
+		// Compute ECC, draw modules, do masking
+		drawFunctionPatterns();
+		byte[] allCodewords = addEccAndInterleave(dataCodewords);
+		drawCodewords(allCodewords);
+		this.mask = handleConstructorMasking(msk);
+		isFunction = null;
+	}
+	
+	
+	
+	/*---- Public instance methods ----*/
+	
+	/**
+	 * Returns the color of the module (pixel) at the specified coordinates, which is {@code false}
+	 * for white or {@code true} for black. The top left corner has the coordinates (x=0, y=0).
+	 * If the specified coordinates are out of bounds, then {@code false} (white) is returned.
+	 * @param x the x coordinate, where 0 is the left edge and size&#x2212;1 is the right edge
+	 * @param y the y coordinate, where 0 is the top edge and size&#x2212;1 is the bottom edge
+	 * @return {@code true} if the coordinates are in bounds and the module
+	 * at that location is black, or {@code false} (white) otherwise
+	 */
+	public boolean getModule(int x, int y) {
+		return 0 <= x && x < size && 0 <= y && y < size && modules[y][x];
+	}
+	
+	
+	/**
+	 * Returns a raster image depicting this QR Code, with the specified module scale and border modules.
+	 * <p>For example, toImage(scale=10, border=4) means to pad the QR Code with 4 white
+	 * border modules on all four sides, and use 10&#xD7;10 pixels to represent each module.
+	 * The resulting image only contains the hex colors 000000 and FFFFFF.
+	 * @param scale the side length (measured in pixels, must be positive) of each module
+	 * @param border the number of border modules to add, which must be non-negative
+	 * @return a new image representing this QR Code, with padding and scaling
+	 * @throws IllegalArgumentException if the scale or border is out of range, or if
+	 * {scale, border, size} cause the image dimensions to exceed Integer.MAX_VALUE
+	 */
+	public BufferedImage toImage(int scale, int border) {
+		if (scale <= 0 || border < 0)
+			throw new IllegalArgumentException("Value out of range");
+		if (border > Integer.MAX_VALUE / 2 || size + border * 2L > Integer.MAX_VALUE / scale)
+			throw new IllegalArgumentException("Scale or border too large");
+		
+		BufferedImage result = new BufferedImage((size + border * 2) * scale, (size + border * 2) * scale, BufferedImage.TYPE_INT_RGB);
+		for (int y = 0; y < result.getHeight(); y++) {
+			for (int x = 0; x < result.getWidth(); x++) {
+				boolean color = getModule(x / scale - border, y / scale - border);
+				result.setRGB(x, y, color ? 0x000000 : 0xFFFFFF);
+			}
+		}
+		return result;
+	}
+	
+	
+	/**
+	 * Returns a string of SVG code for an image depicting this QR Code, with the specified number
+	 * of border modules. The string always uses Unix newlines (\n), regardless of the platform.
+	 * @param border the number of border modules to add, which must be non-negative
+	 * @return a string representing this QR Code as an SVG XML document
+	 * @throws IllegalArgumentException if the border is negative
+	 */
+	public String toSvgString(int border) {
+		if (border < 0)
+			throw new IllegalArgumentException("Border must be non-negative");
+		long brd = border;
+		StringBuilder sb = new StringBuilder()
+			.append("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n")
+			.append("<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n")
+			.append(String.format("<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" viewBox=\"0 0 %1$d %1$d\" stroke=\"none\">\n",
+				size + brd * 2))
+			.append("\t<rect width=\"100%\" height=\"100%\" fill=\"#FFFFFF\"/>\n")
+			.append("\t<path d=\"");
+		for (int y = 0; y < size; y++) {
+			for (int x = 0; x < size; x++) {
+				if (getModule(x, y)) {
+					if (x != 0 || y != 0)
+						sb.append(" ");
+					sb.append(String.format("M%d,%dh1v1h-1z", x + brd, y + brd));
+				}
+			}
+		}
+		return sb
+			.append("\" fill=\"#000000\"/>\n")
+			.append("</svg>\n")
+			.toString();
+	}
+	
+	
+	
+	/*---- Private helper methods for constructor: Drawing function modules ----*/
+	
+	// Reads this object's version field, and draws and marks all function modules.
+	private void drawFunctionPatterns() {
+		// Draw horizontal and vertical timing patterns
+		for (int i = 0; i < size; i++) {
+			setFunctionModule(6, i, i % 2 == 0);
+			setFunctionModule(i, 6, i % 2 == 0);
+		}
+		
+		// Draw 3 finder patterns (all corners except bottom right; overwrites some timing modules)
+		drawFinderPattern(3, 3);
+		drawFinderPattern(size - 4, 3);
+		drawFinderPattern(3, size - 4);
+		
+		// Draw numerous alignment patterns
+		int[] alignPatPos = getAlignmentPatternPositions();
+		int numAlign = alignPatPos.length;
+		for (int i = 0; i < numAlign; i++) {
+			for (int j = 0; j < numAlign; j++) {
+				// Don't draw on the three finder corners
+				if (!(i == 0 && j == 0 || i == 0 && j == numAlign - 1 || i == numAlign - 1 && j == 0))
+					drawAlignmentPattern(alignPatPos[i], alignPatPos[j]);
+			}
+		}
+		
+		// Draw configuration data
+		drawFormatBits(0);  // Dummy mask value; overwritten later in the constructor
+		drawVersion();
+	}
+	
+	
+	// Draws two copies of the format bits (with its own error correction code)
+	// based on the given mask and this object's error correction level field.
+	private void drawFormatBits(int msk) {
+		// Calculate error correction code and pack bits
+		int data = errorCorrectionLevel.formatBits << 3 | msk;  // errCorrLvl is uint2, mask is uint3
+		int rem = data;
+		for (int i = 0; i < 10; i++)
+			rem = (rem << 1) ^ ((rem >>> 9) * 0x537);
+		int bits = (data << 10 | rem) ^ 0x5412;  // uint15
+		assert bits >>> 15 == 0;
+		
+		// Draw first copy
+		for (int i = 0; i <= 5; i++)
+			setFunctionModule(8, i, getBit(bits, i));
+		setFunctionModule(8, 7, getBit(bits, 6));
+		setFunctionModule(8, 8, getBit(bits, 7));
+		setFunctionModule(7, 8, getBit(bits, 8));
+		for (int i = 9; i < 15; i++)
+			setFunctionModule(14 - i, 8, getBit(bits, i));
+		
+		// Draw second copy
+		for (int i = 0; i < 8; i++)
+			setFunctionModule(size - 1 - i, 8, getBit(bits, i));
+		for (int i = 8; i < 15; i++)
+			setFunctionModule(8, size - 15 + i, getBit(bits, i));
+		setFunctionModule(8, size - 8, true);  // Always black
+	}
+	
+	
+	// Draws two copies of the version bits (with its own error correction code),
+	// based on this object's version field, iff 7 <= version <= 40.
+	private void drawVersion() {
+		if (version < 7)
+			return;
+		
+		// Calculate error correction code and pack bits
+		int rem = version;  // version is uint6, in the range [7, 40]
+		for (int i = 0; i < 12; i++)
+			rem = (rem << 1) ^ ((rem >>> 11) * 0x1F25);
+		int bits = version << 12 | rem;  // uint18
+		assert bits >>> 18 == 0;
+		
+		// Draw two copies
+		for (int i = 0; i < 18; i++) {
+			boolean bit = getBit(bits, i);
+			int a = size - 11 + i % 3;
+			int b = i / 3;
+			setFunctionModule(a, b, bit);
+			setFunctionModule(b, a, bit);
+		}
+	}
+	
+	
+	// Draws a 9*9 finder pattern including the border separator,
+	// with the center module at (x, y). Modules can be out of bounds.
+	private void drawFinderPattern(int x, int y) {
+		for (int dy = -4; dy <= 4; dy++) {
+			for (int dx = -4; dx <= 4; dx++) {
+				int dist = Math.max(Math.abs(dx), Math.abs(dy));  // Chebyshev/infinity norm
+				int xx = x + dx, yy = y + dy;
+				if (0 <= xx && xx < size && 0 <= yy && yy < size)
+					setFunctionModule(xx, yy, dist != 2 && dist != 4);
+			}
+		}
+	}
+	
+	
+	// Draws a 5*5 alignment pattern, with the center module
+	// at (x, y). All modules must be in bounds.
+	private void drawAlignmentPattern(int x, int y) {
+		for (int dy = -2; dy <= 2; dy++) {
+			for (int dx = -2; dx <= 2; dx++)
+				setFunctionModule(x + dx, y + dy, Math.max(Math.abs(dx), Math.abs(dy)) != 1);
+		}
+	}
+	
+	
+	// Sets the color of a module and marks it as a function module.
+	// Only used by the constructor. Coordinates must be in bounds.
+	private void setFunctionModule(int x, int y, boolean isBlack) {
+		modules[y][x] = isBlack;
+		isFunction[y][x] = true;
+	}
+	
+	
+	/*---- Private helper methods for constructor: Codewords and masking ----*/
+	
+	// Returns a new byte string representing the given data with the appropriate error correction
+	// codewords appended to it, based on this object's version and error correction level.
+	private byte[] addEccAndInterleave(byte[] data) {
+		Objects.requireNonNull(data);
+		if (data.length != getNumDataCodewords(version, errorCorrectionLevel))
+			throw new IllegalArgumentException();
+		
+		// Calculate parameter numbers
+		int numBlocks = NUM_ERROR_CORRECTION_BLOCKS[errorCorrectionLevel.ordinal()][version];
+		int blockEccLen = ECC_CODEWORDS_PER_BLOCK  [errorCorrectionLevel.ordinal()][version];
+		int rawCodewords = getNumRawDataModules(version) / 8;
+		int numShortBlocks = numBlocks - rawCodewords % numBlocks;
+		int shortBlockLen = rawCodewords / numBlocks;
+		
+		// Split data into blocks and append ECC to each block
+		byte[][] blocks = new byte[numBlocks][];
+		byte[] rsDiv = reedSolomonComputeDivisor(blockEccLen);
+		for (int i = 0, k = 0; i < numBlocks; i++) {
+			byte[] dat = Arrays.copyOfRange(data, k, k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1));
+			k += dat.length;
+			byte[] block = Arrays.copyOf(dat, shortBlockLen + 1);
+			byte[] ecc = reedSolomonComputeRemainder(dat, rsDiv);
+			System.arraycopy(ecc, 0, block, block.length - blockEccLen, ecc.length);
+			blocks[i] = block;
+		}
+		
+		// Interleave (not concatenate) the bytes from every block into a single sequence
+		byte[] result = new byte[rawCodewords];
+		for (int i = 0, k = 0; i < blocks[0].length; i++) {
+			for (int j = 0; j < blocks.length; j++) {
+				// Skip the padding byte in short blocks
+				if (i != shortBlockLen - blockEccLen || j >= numShortBlocks) {
+					result[k] = blocks[j][i];
+					k++;
+				}
+			}
+		}
+		return result;
+	}
+	
+	
+	// Draws the given sequence of 8-bit codewords (data and error correction) onto the entire
+	// data area of this QR Code. Function modules need to be marked off before this is called.
+	private void drawCodewords(byte[] data) {
+		Objects.requireNonNull(data);
+		if (data.length != getNumRawDataModules(version) / 8)
+			throw new IllegalArgumentException();
+		
+		int i = 0;  // Bit index into the data
+		// Do the funny zigzag scan
+		for (int right = size - 1; right >= 1; right -= 2) {  // Index of right column in each column pair
+			if (right == 6)
+				right = 5;
+			for (int vert = 0; vert < size; vert++) {  // Vertical counter
+				for (int j = 0; j < 2; j++) {
+					int x = right - j;  // Actual x coordinate
+					boolean upward = ((right + 1) & 2) == 0;
+					int y = upward ? size - 1 - vert : vert;  // Actual y coordinate
+					if (!isFunction[y][x] && i < data.length * 8) {
+						modules[y][x] = getBit(data[i >>> 3], 7 - (i & 7));
+						i++;
+					}
+					// If this QR Code has any remainder bits (0 to 7), they were assigned as
+					// 0/false/white by the constructor and are left unchanged by this method
+				}
+			}
+		}
+		assert i == data.length * 8;
+	}
+	
+	
+	// XORs the codeword modules in this QR Code with the given mask pattern.
+	// The function modules must be marked and the codeword bits must be drawn
+	// before masking. Due to the arithmetic of XOR, calling applyMask() with
+	// the same mask value a second time will undo the mask. A final well-formed
+	// QR Code needs exactly one (not zero, two, etc.) mask applied.
+	private void applyMask(int msk) {
+		if (msk < 0 || msk > 7)
+			throw new IllegalArgumentException("Mask value out of range");
+		for (int y = 0; y < size; y++) {
+			for (int x = 0; x < size; x++) {
+				boolean invert;
+				switch (msk) {
+					case 0:  invert = (x + y) % 2 == 0;                    break;
+					case 1:  invert = y % 2 == 0;                          break;
+					case 2:  invert = x % 3 == 0;                          break;
+					case 3:  invert = (x + y) % 3 == 0;                    break;
+					case 4:  invert = (x / 3 + y / 2) % 2 == 0;            break;
+					case 5:  invert = x * y % 2 + x * y % 3 == 0;          break;
+					case 6:  invert = (x * y % 2 + x * y % 3) % 2 == 0;    break;
+					case 7:  invert = ((x + y) % 2 + x * y % 3) % 2 == 0;  break;
+					default:  throw new AssertionError();
+				}
+				modules[y][x] ^= invert & !isFunction[y][x];
+			}
+		}
+	}
+	
+	
+	// A messy helper function for the constructor. This QR Code must be in an unmasked state when this
+	// method is called. The given argument is the requested mask, which is -1 for auto or 0 to 7 for fixed.
+	// This method applies and returns the actual mask chosen, from 0 to 7.
+	private int handleConstructorMasking(int msk) {
+		if (msk == -1) {  // Automatically choose best mask
+			int minPenalty = Integer.MAX_VALUE;
+			for (int i = 0; i < 8; i++) {
+				applyMask(i);
+				drawFormatBits(i);
+				int penalty = getPenaltyScore();
+				if (penalty < minPenalty) {
+					msk = i;
+					minPenalty = penalty;
+				}
+				applyMask(i);  // Undoes the mask due to XOR
+			}
+		}
+		assert 0 <= msk && msk <= 7;
+		applyMask(msk);  // Apply the final choice of mask
+		drawFormatBits(msk);  // Overwrite old format bits
+		return msk;  // The caller shall assign this value to the final-declared field
+	}
+	
+	
+	// Calculates and returns the penalty score based on state of this QR Code's current modules.
+	// This is used by the automatic mask choice algorithm to find the mask pattern that yields the lowest score.
+	private int getPenaltyScore() {
+		int result = 0;
+		
+		// Adjacent modules in row having same color, and finder-like patterns
+		int[] runHistory = new int[7];
+		for (int y = 0; y < size; y++) {
+			boolean runColor = false;
+			int runX = 0;
+			Arrays.fill(runHistory, 0);
+			int padRun = size;  // Add white border to initial run
+			for (int x = 0; x < size; x++) {
+				if (modules[y][x] == runColor) {
+					runX++;
+					if (runX == 5)
+						result += PENALTY_N1;
+					else if (runX > 5)
+						result++;
+				} else {
+					finderPenaltyAddHistory(runX + padRun, runHistory);
+					padRun = 0;
+					if (!runColor)
+						result += finderPenaltyCountPatterns(runHistory) * PENALTY_N3;
+					runColor = modules[y][x];
+					runX = 1;
+				}
+			}
+			result += finderPenaltyTerminateAndCount(runColor, runX + padRun, runHistory) * PENALTY_N3;
+		}
+		// Adjacent modules in column having same color, and finder-like patterns
+		for (int x = 0; x < size; x++) {
+			boolean runColor = false;
+			int runY = 0;
+			Arrays.fill(runHistory, 0);
+			int padRun = size;  // Add white border to initial run
+			for (int y = 0; y < size; y++) {
+				if (modules[y][x] == runColor) {
+					runY++;
+					if (runY == 5)
+						result += PENALTY_N1;
+					else if (runY > 5)
+						result++;
+				} else {
+					finderPenaltyAddHistory(runY + padRun, runHistory);
+					padRun = 0;
+					if (!runColor)
+						result += finderPenaltyCountPatterns(runHistory) * PENALTY_N3;
+					runColor = modules[y][x];
+					runY = 1;
+				}
+			}
+			result += finderPenaltyTerminateAndCount(runColor, runY + padRun, runHistory) * PENALTY_N3;
+		}
+		
+		// 2*2 blocks of modules having same color
+		for (int y = 0; y < size - 1; y++) {
+			for (int x = 0; x < size - 1; x++) {
+				boolean color = modules[y][x];
+				if (  color == modules[y][x + 1] &&
+				      color == modules[y + 1][x] &&
+				      color == modules[y + 1][x + 1])
+					result += PENALTY_N2;
+			}
+		}
+		
+		// Balance of black and white modules
+		int black = 0;
+		for (boolean[] row : modules) {
+			for (boolean color : row) {
+				if (color)
+					black++;
+			}
+		}
+		int total = size * size;  // Note that size is odd, so black/total != 1/2
+		// Compute the smallest integer k >= 0 such that (45-5k)% <= black/total <= (55+5k)%
+		int k = (Math.abs(black * 20 - total * 10) + total - 1) / total - 1;
+		result += k * PENALTY_N4;
+		return result;
+	}
+	
+	
+	
+	/*---- Private helper functions ----*/
+	
+	// Returns an ascending list of positions of alignment patterns for this version number.
+	// Each position is in the range [0,177), and are used on both the x and y axes.
+	// This could be implemented as lookup table of 40 variable-length lists of unsigned bytes.
+	private int[] getAlignmentPatternPositions() {
+		if (version == 1)
+			return new int[]{};
+		else {
+			int numAlign = version / 7 + 2;
+			int step;
+			if (version == 32)  // Special snowflake
+				step = 26;
+			else  // step = ceil[(size - 13) / (numAlign*2 - 2)] * 2
+				step = (version*4 + numAlign*2 + 1) / (numAlign*2 - 2) * 2;
+			int[] result = new int[numAlign];
+			result[0] = 6;
+			for (int i = result.length - 1, pos = size - 7; i >= 1; i--, pos -= step)
+				result[i] = pos;
+			return result;
+		}
+	}
+	
+	
+	// Returns the number of data bits that can be stored in a QR Code of the given version number, after
+	// all function modules are excluded. This includes remainder bits, so it might not be a multiple of 8.
+	// The result is in the range [208, 29648]. This could be implemented as a 40-entry lookup table.
+	private static int getNumRawDataModules(int ver) {
+		if (ver < MIN_VERSION || ver > MAX_VERSION)
+			throw new IllegalArgumentException("Version number out of range");
+		
+		int size = ver * 4 + 17;
+		int result = size * size;   // Number of modules in the whole QR Code square
+		result -= 8 * 8 * 3;        // Subtract the three finders with separators
+		result -= 15 * 2 + 1;       // Subtract the format information and black module
+		result -= (size - 16) * 2;  // Subtract the timing patterns (excluding finders)
+		// The five lines above are equivalent to: int result = (16 * ver + 128) * ver + 64;
+		if (ver >= 2) {
+			int numAlign = ver / 7 + 2;
+			result -= (numAlign - 1) * (numAlign - 1) * 25;  // Subtract alignment patterns not overlapping with timing patterns
+			result -= (numAlign - 2) * 2 * 20;  // Subtract alignment patterns that overlap with timing patterns
+			// The two lines above are equivalent to: result -= (25 * numAlign - 10) * numAlign - 55;
+			if (ver >= 7)
+				result -= 6 * 3 * 2;  // Subtract version information
+		}
+		assert 208 <= result && result <= 29648;
+		return result;
+	}
+	
+	
+	// Returns a Reed-Solomon ECC generator polynomial for the given degree. This could be
+	// implemented as a lookup table over all possible parameter values, instead of as an algorithm.
+	private static byte[] reedSolomonComputeDivisor(int degree) {
+		if (degree < 1 || degree > 255)
+			throw new IllegalArgumentException("Degree out of range");
+		// Polynomial coefficients are stored from highest to lowest power, excluding the leading term which is always 1.
+		// For example the polynomial x^3 + 255x^2 + 8x + 93 is stored as the uint8 array {255, 8, 93}.
+		byte[] result = new byte[degree];
+		result[degree - 1] = 1;  // Start off with the monomial x^0
+		
+		// Compute the product polynomial (x - r^0) * (x - r^1) * (x - r^2) * ... * (x - r^{degree-1}),
+		// and drop the highest monomial term which is always 1x^degree.
+		// Note that r = 0x02, which is a generator element of this field GF(2^8/0x11D).
+		int root = 1;
+		for (int i = 0; i < degree; i++) {
+			// Multiply the current product by (x - r^i)
+			for (int j = 0; j < result.length; j++) {
+				result[j] = (byte)reedSolomonMultiply(result[j] & 0xFF, root);
+				if (j + 1 < result.length)
+					result[j] ^= result[j + 1];
+			}
+			root = reedSolomonMultiply(root, 0x02);
+		}
+		return result;
+	}
+	
+	
+	// Returns the Reed-Solomon error correction codeword for the given data and divisor polynomials.
+	private static byte[] reedSolomonComputeRemainder(byte[] data, byte[] divisor) {
+		Objects.requireNonNull(data);
+		Objects.requireNonNull(divisor);
+		byte[] result = new byte[divisor.length];
+		for (byte b : data) {  // Polynomial division
+			int factor = (b ^ result[0]) & 0xFF;
+			System.arraycopy(result, 1, result, 0, result.length - 1);
+			result[result.length - 1] = 0;
+			for (int i = 0; i < result.length; i++)
+				result[i] ^= reedSolomonMultiply(divisor[i] & 0xFF, factor);
+		}
+		return result;
+	}
+	
+	
+	// Returns the product of the two given field elements modulo GF(2^8/0x11D). The arguments and result
+	// are unsigned 8-bit integers. This could be implemented as a lookup table of 256*256 entries of uint8.
+	private static int reedSolomonMultiply(int x, int y) {
+		assert x >> 8 == 0 && y >> 8 == 0;
+		// Russian peasant multiplication
+		int z = 0;
+		for (int i = 7; i >= 0; i--) {
+			z = (z << 1) ^ ((z >>> 7) * 0x11D);
+			z ^= ((y >>> i) & 1) * x;
+		}
+		assert z >>> 8 == 0;
+		return z;
+	}
+	
+	
+	// Returns the number of 8-bit data (i.e. not error correction) codewords contained in any
+	// QR Code of the given version number and error correction level, with remainder bits discarded.
+	// This stateless pure function could be implemented as a (40*4)-cell lookup table.
+	static int getNumDataCodewords(int ver, Ecc ecl) {
+		return getNumRawDataModules(ver) / 8
+			- ECC_CODEWORDS_PER_BLOCK    [ecl.ordinal()][ver]
+			* NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal()][ver];
+	}
+	
+	
+	// Can only be called immediately after a white run is added, and
+	// returns either 0, 1, or 2. A helper function for getPenaltyScore().
+	private int finderPenaltyCountPatterns(int[] runHistory) {
+		int n = runHistory[1];
+		assert n <= size * 3;
+		boolean core = n > 0 && runHistory[2] == n && runHistory[3] == n * 3 && runHistory[4] == n && runHistory[5] == n;
+		return (core && runHistory[0] >= n * 4 && runHistory[6] >= n ? 1 : 0)
+		     + (core && runHistory[6] >= n * 4 && runHistory[0] >= n ? 1 : 0);
+	}
+	
+	
+	// Must be called at the end of a line (row or column) of modules. A helper function for getPenaltyScore().
+	private int finderPenaltyTerminateAndCount(boolean currentRunColor, int currentRunLength, int[] runHistory) {
+		if (currentRunColor) {  // Terminate black run
+			finderPenaltyAddHistory(currentRunLength, runHistory);
+			currentRunLength = 0;
+		}
+		currentRunLength += size;  // Add white border to final run
+		finderPenaltyAddHistory(currentRunLength, runHistory);
+		return finderPenaltyCountPatterns(runHistory);
+	}
+	
+	
+	// Pushes the given value to the front and drops the last value. A helper function for getPenaltyScore().
+	private static void finderPenaltyAddHistory(int currentRunLength, int[] runHistory) {
+		System.arraycopy(runHistory, 0, runHistory, 1, runHistory.length - 1);
+		runHistory[0] = currentRunLength;
+	}
+	
+	
+	// Returns true iff the i'th bit of x is set to 1.
+	static boolean getBit(int x, int i) {
+		return ((x >>> i) & 1) != 0;
+	}
+	
+	
+	/*---- Constants and tables ----*/
+	
+	/** The minimum version number  (1) supported in the QR Code Model 2 standard. */
+	public static final int MIN_VERSION =  1;
+	
+	/** The maximum version number (40) supported in the QR Code Model 2 standard. */
+	public static final int MAX_VERSION = 40;
+	
+	
+	// For use in getPenaltyScore(), when evaluating which mask is best.
+	private static final int PENALTY_N1 =  3;
+	private static final int PENALTY_N2 =  3;
+	private static final int PENALTY_N3 = 40;
+	private static final int PENALTY_N4 = 10;
+	
+	
+	private static final byte[][] ECC_CODEWORDS_PER_BLOCK = {
+		// Version: (note that index 0 is for padding, and is set to an illegal value)
+		//0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
+		{-1,  7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30},  // Low
+		{-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28},  // Medium
+		{-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30},  // Quartile
+		{-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30},  // High
+	};
+	
+	private static final byte[][] NUM_ERROR_CORRECTION_BLOCKS = {
+		// Version: (note that index 0 is for padding, and is set to an illegal value)
+		//0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
+		{-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4,  4,  4,  4,  4,  6,  6,  6,  6,  7,  8,  8,  9,  9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25},  // Low
+		{-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5,  5,  8,  9,  9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49},  // Medium
+		{-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8,  8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68},  // Quartile
+		{-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81},  // High
+	};
+	
+	
+	
+	/*---- Public helper enumeration ----*/
+	
+	/**
+	 * The error correction level in a QR Code symbol.
+	 */
+	public enum Ecc {
+		// Must be declared in ascending order of error protection
+		// so that the implicit ordinal() and values() work properly
+		/** The QR Code can tolerate about  7% erroneous codewords. */ LOW(1),
+		/** The QR Code can tolerate about 15% erroneous codewords. */ MEDIUM(0),
+		/** The QR Code can tolerate about 25% erroneous codewords. */ QUARTILE(3),
+		/** The QR Code can tolerate about 30% erroneous codewords. */ HIGH(2);
+		
+		// In the range 0 to 3 (unsigned 2-bit integer).
+		final int formatBits;
+		
+		// Constructor.
+		private Ecc(int fb) {
+			formatBits = fb;
+		}
+	}
+	
+}
diff --git a/Telegram/ThirdParty/QR/java/src/main/java/io/nayuki/qrcodegen/QrCodeGeneratorDemo.java b/Telegram/ThirdParty/QR/java/src/main/java/io/nayuki/qrcodegen/QrCodeGeneratorDemo.java
new file mode 100644
index 0000000..3c50bda
--- /dev/null
+++ b/Telegram/ThirdParty/QR/java/src/main/java/io/nayuki/qrcodegen/QrCodeGeneratorDemo.java
@@ -0,0 +1,175 @@
+/* 
+ * QR Code generator demo (Java)
+ * 
+ * Run this command-line program with no arguments. The program creates/overwrites a bunch of
+ * PNG and SVG files in the current working directory to demonstrate the creation of QR Codes.
+ * 
+ * Copyright (c) Project Nayuki. (MIT License)
+ * https://www.nayuki.io/page/qr-code-generator-library
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ * - The above copyright notice and this permission notice shall be included in
+ *   all copies or substantial portions of the Software.
+ * - The Software is provided "as is", without warranty of any kind, express or
+ *   implied, including but not limited to the warranties of merchantability,
+ *   fitness for a particular purpose and noninfringement. In no event shall the
+ *   authors or copyright holders be liable for any claim, damages or other
+ *   liability, whether in an action of contract, tort or otherwise, arising from,
+ *   out of or in connection with the Software or the use or other dealings in the
+ *   Software.
+ */
+
+package io.nayuki.qrcodegen;
+
+import java.awt.image.BufferedImage;
+import java.io.File;
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.util.Arrays;
+import java.util.List;
+import javax.imageio.ImageIO;
+
+
+public final class QrCodeGeneratorDemo {
+	
+	// The main application program.
+	public static void main(String[] args) throws IOException {
+		doBasicDemo();
+		doVarietyDemo();
+		doSegmentDemo();
+		doMaskDemo();
+	}
+	
+	
+	
+	/*---- Demo suite ----*/
+	
+	// Creates a single QR Code, then writes it to a PNG file and an SVG file.
+	private static void doBasicDemo() throws IOException {
+		String text = "Hello, world!";          // User-supplied Unicode text
+		QrCode.Ecc errCorLvl = QrCode.Ecc.LOW;  // Error correction level
+		
+		QrCode qr = QrCode.encodeText(text, errCorLvl);  // Make the QR Code symbol
+		
+		BufferedImage img = qr.toImage(10, 4);           // Convert to bitmap image
+		File imgFile = new File("hello-world-QR.png");   // File path for output
+		ImageIO.write(img, "png", imgFile);              // Write image to file
+		
+		String svg = qr.toSvgString(4);                  // Convert to SVG XML code
+		File svgFile = new File("hello-world-QR.svg");   // File path for output
+		Files.write(svgFile.toPath(),                    // Write image to file
+			svg.getBytes(StandardCharsets.UTF_8));
+	}
+	
+	
+	// Creates a variety of QR Codes that exercise different features of the library, and writes each one to file.
+	private static void doVarietyDemo() throws IOException {
+		QrCode qr;
+		
+		// Numeric mode encoding (3.33 bits per digit)
+		qr = QrCode.encodeText("314159265358979323846264338327950288419716939937510", QrCode.Ecc.MEDIUM);
+		writePng(qr.toImage(13, 1), "pi-digits-QR.png");
+		
+		// Alphanumeric mode encoding (5.5 bits per character)
+		qr = QrCode.encodeText("DOLLAR-AMOUNT:$39.87 PERCENTAGE:100.00% OPERATIONS:+-*/", QrCode.Ecc.HIGH);
+		writePng(qr.toImage(10, 2), "alphanumeric-QR.png");
+		
+		// Unicode text as UTF-8
+		qr = QrCode.encodeText("こんにちwa、世界！ αβγδ", QrCode.Ecc.QUARTILE);
+		writePng(qr.toImage(10, 3), "unicode-QR.png");
+		
+		// Moderately large QR Code using longer text (from Lewis Carroll's Alice in Wonderland)
+		qr = QrCode.encodeText(
+			"Alice was beginning to get very tired of sitting by her sister on the bank, "
+			+ "and of having nothing to do: once or twice she had peeped into the book her sister was reading, "
+			+ "but it had no pictures or conversations in it, 'and what is the use of a book,' thought Alice "
+			+ "'without pictures or conversations?' So she was considering in her own mind (as well as she could, "
+			+ "for the hot day made her feel very sleepy and stupid), whether the pleasure of making a "
+			+ "daisy-chain would be worth the trouble of getting up and picking the daisies, when suddenly "
+			+ "a White Rabbit with pink eyes ran close by her.", QrCode.Ecc.HIGH);
+		writePng(qr.toImage(6, 10), "alice-wonderland-QR.png");
+	}
+	
+	
+	// Creates QR Codes with manually specified segments for better compactness.
+	private static void doSegmentDemo() throws IOException {
+		QrCode qr;
+		List<QrSegment> segs;
+		
+		// Illustration "silver"
+		String silver0 = "THE SQUARE ROOT OF 2 IS 1.";
+		String silver1 = "41421356237309504880168872420969807856967187537694807317667973799";
+		qr = QrCode.encodeText(silver0 + silver1, QrCode.Ecc.LOW);
+		writePng(qr.toImage(10, 3), "sqrt2-monolithic-QR.png");
+		
+		segs = Arrays.asList(
+			QrSegment.makeAlphanumeric(silver0),
+			QrSegment.makeNumeric(silver1));
+		qr = QrCode.encodeSegments(segs, QrCode.Ecc.LOW);
+		writePng(qr.toImage(10, 3), "sqrt2-segmented-QR.png");
+		
+		// Illustration "golden"
+		String golden0 = "Golden ratio φ = 1.";
+		String golden1 = "6180339887498948482045868343656381177203091798057628621354486227052604628189024497072072041893911374";
+		String golden2 = "......";
+		qr = QrCode.encodeText(golden0 + golden1 + golden2, QrCode.Ecc.LOW);
+		writePng(qr.toImage(8, 5), "phi-monolithic-QR.png");
+		
+		segs = Arrays.asList(
+			QrSegment.makeBytes(golden0.getBytes(StandardCharsets.UTF_8)),
+			QrSegment.makeNumeric(golden1),
+			QrSegment.makeAlphanumeric(golden2));
+		qr = QrCode.encodeSegments(segs, QrCode.Ecc.LOW);
+		writePng(qr.toImage(8, 5), "phi-segmented-QR.png");
+		
+		// Illustration "Madoka": kanji, kana, Cyrillic, full-width Latin, Greek characters
+		String madoka = "「魔法少女まどか☆マギカ」って、　ИАИ　ｄｅｓｕ　κα？";
+		qr = QrCode.encodeText(madoka, QrCode.Ecc.LOW);
+		writePng(qr.toImage(9, 4), "madoka-utf8-QR.png");
+		
+		segs = Arrays.asList(QrSegmentAdvanced.makeKanji(madoka));
+		qr = QrCode.encodeSegments(segs, QrCode.Ecc.LOW);
+		writePng(qr.toImage(9, 4), "madoka-kanji-QR.png");
+	}
+	
+	
+	// Creates QR Codes with the same size and contents but different mask patterns.
+	private static void doMaskDemo() throws IOException {
+		QrCode qr;
+		List<QrSegment> segs;
+		
+		// Project Nayuki URL
+		segs = QrSegment.makeSegments("https://www.nayuki.io/");
+		qr = QrCode.encodeSegments(segs, QrCode.Ecc.HIGH, QrCode.MIN_VERSION, QrCode.MAX_VERSION, -1, true);  // Automatic mask
+		writePng(qr.toImage(8, 6), "project-nayuki-automask-QR.png");
+		qr = QrCode.encodeSegments(segs, QrCode.Ecc.HIGH, QrCode.MIN_VERSION, QrCode.MAX_VERSION, 3, true);  // Force mask 3
+		writePng(qr.toImage(8, 6), "project-nayuki-mask3-QR.png");
+		
+		// Chinese text as UTF-8
+		segs = QrSegment.makeSegments("維基百科（Wikipedia，聆聽i/ˌwɪkᵻˈpiːdi.ə/）是一個自由內容、公開編輯且多語言的網路百科全書協作計畫");
+		qr = QrCode.encodeSegments(segs, QrCode.Ecc.MEDIUM, QrCode.MIN_VERSION, QrCode.MAX_VERSION, 0, true);  // Force mask 0
+		writePng(qr.toImage(10, 3), "unicode-mask0-QR.png");
+		qr = QrCode.encodeSegments(segs, QrCode.Ecc.MEDIUM, QrCode.MIN_VERSION, QrCode.MAX_VERSION, 1, true);  // Force mask 1
+		writePng(qr.toImage(10, 3), "unicode-mask1-QR.png");
+		qr = QrCode.encodeSegments(segs, QrCode.Ecc.MEDIUM, QrCode.MIN_VERSION, QrCode.MAX_VERSION, 5, true);  // Force mask 5
+		writePng(qr.toImage(10, 3), "unicode-mask5-QR.png");
+		qr = QrCode.encodeSegments(segs, QrCode.Ecc.MEDIUM, QrCode.MIN_VERSION, QrCode.MAX_VERSION, 7, true);  // Force mask 7
+		writePng(qr.toImage(10, 3), "unicode-mask7-QR.png");
+	}
+	
+	
+	
+	/*---- Utilities ----*/
+	
+	// Helper function to reduce code duplication.
+	private static void writePng(BufferedImage img, String filepath) throws IOException {
+		ImageIO.write(img, "png", new File(filepath));
+	}
+	
+}
diff --git a/Telegram/ThirdParty/QR/java/src/main/java/io/nayuki/qrcodegen/QrCodeGeneratorWorker.java b/Telegram/ThirdParty/QR/java/src/main/java/io/nayuki/qrcodegen/QrCodeGeneratorWorker.java
new file mode 100644
index 0000000..4cf9de3
--- /dev/null
+++ b/Telegram/ThirdParty/QR/java/src/main/java/io/nayuki/qrcodegen/QrCodeGeneratorWorker.java
@@ -0,0 +1,100 @@
+/* 
+ * QR Code generator test worker (Java)
+ * 
+ * This program reads data and encoding parameters from standard input and writes
+ * QR Code bitmaps to standard output. The I/O format is one integer per line.
+ * Run with no command line arguments. The program is intended for automated
+ * batch testing of end-to-end functionality of this QR Code generator library.
+ * 
+ * Copyright (c) Project Nayuki. (MIT License)
+ * https://www.nayuki.io/page/qr-code-generator-library
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ * - The above copyright notice and this permission notice shall be included in
+ *   all copies or substantial portions of the Software.
+ * - The Software is provided "as is", without warranty of any kind, express or
+ *   implied, including but not limited to the warranties of merchantability,
+ *   fitness for a particular purpose and noninfringement. In no event shall the
+ *   authors or copyright holders be liable for any claim, damages or other
+ *   liability, whether in an action of contract, tort or otherwise, arising from,
+ *   out of or in connection with the Software or the use or other dealings in the
+ *   Software.
+ */
+
+package io.nayuki.qrcodegen;
+
+import java.nio.charset.StandardCharsets;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Scanner;
+
+
+public final class QrCodeGeneratorWorker {
+	
+	public static void main(String[] args) {
+		// Set up input stream and start loop
+		try (Scanner input = new Scanner(System.in, "US-ASCII")) {
+			input.useDelimiter("\r\n|\n|\r");
+			while (processCase(input));
+		}
+	}
+	
+	
+	private static boolean processCase(Scanner input) {
+		// Read data length or exit
+		int length = input.nextInt();
+		if (length == -1)
+			return false;
+		if (length > Short.MAX_VALUE)
+			throw new RuntimeException();
+		
+		// Read data bytes
+		boolean isAscii = true;
+		byte[] data = new byte[length];
+		for (int i = 0; i < data.length; i++) {
+			int b = input.nextInt();
+			if (b < 0 || b > 255)
+				throw new RuntimeException();
+			data[i] = (byte)b;
+			isAscii &= b < 128;
+		}
+		
+		// Read encoding parameters
+		int errCorLvl  = input.nextInt();
+		int minVersion = input.nextInt();
+		int maxVersion = input.nextInt();
+		int mask       = input.nextInt();
+		int boostEcl   = input.nextInt();
+		if (!(0 <= errCorLvl && errCorLvl <= 3) || !(-1 <= mask && mask <= 7) || (boostEcl >>> 1) != 0
+				|| !(QrCode.MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= QrCode.MAX_VERSION))
+			throw new RuntimeException();
+		
+		// Make segments for encoding
+		List<QrSegment> segs;
+		if (isAscii)
+			segs = QrSegment.makeSegments(new String(data, StandardCharsets.US_ASCII));
+		else
+			segs = Arrays.asList(QrSegment.makeBytes(data));
+		
+		try {  // Try to make QR Code symbol
+			QrCode qr = QrCode.encodeSegments(segs, QrCode.Ecc.values()[errCorLvl], minVersion, maxVersion, mask, boostEcl != 0);
+			// Print grid of modules
+			System.out.println(qr.version);
+			for (int y = 0; y < qr.size; y++) {
+				for (int x = 0; x < qr.size; x++)
+					System.out.println(qr.getModule(x, y) ? 1 : 0);
+			}
+			
+		} catch (DataTooLongException e) {
+			System.out.println(-1);
+		}
+		System.out.flush();
+		return true;
+	}
+	
+}
diff --git a/Telegram/ThirdParty/QR/java/src/main/java/io/nayuki/qrcodegen/QrSegment.java b/Telegram/ThirdParty/QR/java/src/main/java/io/nayuki/qrcodegen/QrSegment.java
new file mode 100644
index 0000000..f416200
--- /dev/null
+++ b/Telegram/ThirdParty/QR/java/src/main/java/io/nayuki/qrcodegen/QrSegment.java
@@ -0,0 +1,297 @@
+/* 
+ * QR Code generator library (Java)
+ * 
+ * Copyright (c) Project Nayuki. (MIT License)
+ * https://www.nayuki.io/page/qr-code-generator-library
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ * - The above copyright notice and this permission notice shall be included in
+ *   all copies or substantial portions of the Software.
+ * - The Software is provided "as is", without warranty of any kind, express or
+ *   implied, including but not limited to the warranties of merchantability,
+ *   fitness for a particular purpose and noninfringement. In no event shall the
+ *   authors or copyright holders be liable for any claim, damages or other
+ *   liability, whether in an action of contract, tort or otherwise, arising from,
+ *   out of or in connection with the Software or the use or other dealings in the
+ *   Software.
+ */
+
+package io.nayuki.qrcodegen;
+
+import java.nio.charset.StandardCharsets;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Objects;
+import java.util.regex.Pattern;
+
+
+/**
+ * A segment of character/binary/control data in a QR Code symbol.
+ * Instances of this class are immutable.
+ * <p>The mid-level way to create a segment is to take the payload data and call a
+ * static factory function such as {@link QrSegment#makeNumeric(String)}. The low-level
+ * way to create a segment is to custom-make the bit buffer and call the {@link
+ * QrSegment#QrSegment(Mode,int,BitBuffer) constructor} with appropriate values.</p>
+ * <p>This segment class imposes no length restrictions, but QR Codes have restrictions.
+ * Even in the most favorable conditions, a QR Code can only hold 7089 characters of data.
+ * Any segment longer than this is meaningless for the purpose of generating QR Codes.
+ * This class can represent kanji mode segments, but provides no help in encoding them
+ * - see {@link QrSegmentAdvanced} for full kanji support.</p>
+ */
+public final class QrSegment {
+	
+	/*---- Static factory functions (mid level) ----*/
+	
+	/**
+	 * Returns a segment representing the specified binary data
+	 * encoded in byte mode. All input byte arrays are acceptable.
+	 * <p>Any text string can be converted to UTF-8 bytes ({@code
+	 * s.getBytes(StandardCharsets.UTF_8)}) and encoded as a byte mode segment.</p>
+	 * @param data the binary data (not {@code null})
+	 * @return a segment (not {@code null}) containing the data
+	 * @throws NullPointerException if the array is {@code null}
+	 */
+	public static QrSegment makeBytes(byte[] data) {
+		Objects.requireNonNull(data);
+		BitBuffer bb = new BitBuffer();
+		for (byte b : data)
+			bb.appendBits(b & 0xFF, 8);
+		return new QrSegment(Mode.BYTE, data.length, bb);
+	}
+	
+	
+	/**
+	 * Returns a segment representing the specified string of decimal digits encoded in numeric mode.
+	 * @param digits the text (not {@code null}), with only digits from 0 to 9 allowed
+	 * @return a segment (not {@code null}) containing the text
+	 * @throws NullPointerException if the string is {@code null}
+	 * @throws IllegalArgumentException if the string contains non-digit characters
+	 */
+	public static QrSegment makeNumeric(String digits) {
+		Objects.requireNonNull(digits);
+		if (!NUMERIC_REGEX.matcher(digits).matches())
+			throw new IllegalArgumentException("String contains non-numeric characters");
+		
+		BitBuffer bb = new BitBuffer();
+		for (int i = 0; i < digits.length(); ) {  // Consume up to 3 digits per iteration
+			int n = Math.min(digits.length() - i, 3);
+			bb.appendBits(Integer.parseInt(digits.substring(i, i + n)), n * 3 + 1);
+			i += n;
+		}
+		return new QrSegment(Mode.NUMERIC, digits.length(), bb);
+	}
+	
+	
+	/**
+	 * Returns a segment representing the specified text string encoded in alphanumeric mode.
+	 * The characters allowed are: 0 to 9, A to Z (uppercase only), space,
+	 * dollar, percent, asterisk, plus, hyphen, period, slash, colon.
+	 * @param text the text (not {@code null}), with only certain characters allowed
+	 * @return a segment (not {@code null}) containing the text
+	 * @throws NullPointerException if the string is {@code null}
+	 * @throws IllegalArgumentException if the string contains non-encodable characters
+	 */
+	public static QrSegment makeAlphanumeric(String text) {
+		Objects.requireNonNull(text);
+		if (!ALPHANUMERIC_REGEX.matcher(text).matches())
+			throw new IllegalArgumentException("String contains unencodable characters in alphanumeric mode");
+		
+		BitBuffer bb = new BitBuffer();
+		int i;
+		for (i = 0; i <= text.length() - 2; i += 2) {  // Process groups of 2
+			int temp = ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)) * 45;
+			temp += ALPHANUMERIC_CHARSET.indexOf(text.charAt(i + 1));
+			bb.appendBits(temp, 11);
+		}
+		if (i < text.length())  // 1 character remaining
+			bb.appendBits(ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)), 6);
+		return new QrSegment(Mode.ALPHANUMERIC, text.length(), bb);
+	}
+	
+	
+	/**
+	 * Returns a list of zero or more segments to represent the specified Unicode text string.
+	 * The result may use various segment modes and switch modes to optimize the length of the bit stream.
+	 * @param text the text to be encoded, which can be any Unicode string
+	 * @return a new mutable list (not {@code null}) of segments (not {@code null}) containing the text
+	 * @throws NullPointerException if the text is {@code null}
+	 */
+	public static List<QrSegment> makeSegments(String text) {
+		Objects.requireNonNull(text);
+		
+		// Select the most efficient segment encoding automatically
+		List<QrSegment> result = new ArrayList<>();
+		if (text.equals(""));  // Leave result empty
+		else if (NUMERIC_REGEX.matcher(text).matches())
+			result.add(makeNumeric(text));
+		else if (ALPHANUMERIC_REGEX.matcher(text).matches())
+			result.add(makeAlphanumeric(text));
+		else
+			result.add(makeBytes(text.getBytes(StandardCharsets.UTF_8)));
+		return result;
+	}
+	
+	
+	/**
+	 * Returns a segment representing an Extended Channel Interpretation
+	 * (ECI) designator with the specified assignment value.
+	 * @param assignVal the ECI assignment number (see the AIM ECI specification)
+	 * @return a segment (not {@code null}) containing the data
+	 * @throws IllegalArgumentException if the value is outside the range [0, 10<sup>6</sup>)
+	 */
+	public static QrSegment makeEci(int assignVal) {
+		BitBuffer bb = new BitBuffer();
+		if (assignVal < 0)
+			throw new IllegalArgumentException("ECI assignment value out of range");
+		else if (assignVal < (1 << 7))
+			bb.appendBits(assignVal, 8);
+		else if (assignVal < (1 << 14)) {
+			bb.appendBits(2, 2);
+			bb.appendBits(assignVal, 14);
+		} else if (assignVal < 1_000_000) {
+			bb.appendBits(6, 3);
+			bb.appendBits(assignVal, 21);
+		} else
+			throw new IllegalArgumentException("ECI assignment value out of range");
+		return new QrSegment(Mode.ECI, 0, bb);
+	}
+	
+	
+	
+	/*---- Instance fields ----*/
+	
+	/** The mode indicator of this segment. Not {@code null}. */
+	public final Mode mode;
+	
+	/** The length of this segment's unencoded data. Measured in characters for
+	 * numeric/alphanumeric/kanji mode, bytes for byte mode, and 0 for ECI mode.
+	 * Always zero or positive. Not the same as the data's bit length. */
+	public final int numChars;
+	
+	// The data bits of this segment. Not null. Accessed through getData().
+	final BitBuffer data;
+	
+	
+	/*---- Constructor (low level) ----*/
+	
+	/**
+	 * Constructs a QR Code segment with the specified attributes and data.
+	 * The character count (numCh) must agree with the mode and the bit buffer length,
+	 * but the constraint isn't checked. The specified bit buffer is cloned and stored.
+	 * @param md the mode (not {@code null})
+	 * @param numCh the data length in characters or bytes, which is non-negative
+	 * @param data the data bits (not {@code null})
+	 * @throws NullPointerException if the mode or data is {@code null}
+	 * @throws IllegalArgumentException if the character count is negative
+	 */
+	public QrSegment(Mode md, int numCh, BitBuffer data) {
+		mode = Objects.requireNonNull(md);
+		Objects.requireNonNull(data);
+		if (numCh < 0)
+			throw new IllegalArgumentException("Invalid value");
+		numChars = numCh;
+		this.data = data.clone();  // Make defensive copy
+	}
+	
+	
+	/*---- Methods ----*/
+	
+	/**
+	 * Returns the data bits of this segment.
+	 * @return a new copy of the data bits (not {@code null})
+	 */
+	public BitBuffer getData() {
+		return data.clone();  // Make defensive copy
+	}
+	
+	
+	// Calculates the number of bits needed to encode the given segments at the given version.
+	// Returns a non-negative number if successful. Otherwise returns -1 if a segment has too
+	// many characters to fit its length field, or the total bits exceeds Integer.MAX_VALUE.
+	static int getTotalBits(List<QrSegment> segs, int version) {
+		Objects.requireNonNull(segs);
+		long result = 0;
+		for (QrSegment seg : segs) {
+			Objects.requireNonNull(seg);
+			int ccbits = seg.mode.numCharCountBits(version);
+			if (seg.numChars >= (1 << ccbits))
+				return -1;  // The segment's length doesn't fit the field's bit width
+			result += 4L + ccbits + seg.data.bitLength();
+			if (result > Integer.MAX_VALUE)
+				return -1;  // The sum will overflow an int type
+		}
+		return (int)result;
+	}
+	
+	
+	/*---- Constants ----*/
+	
+	/** Describes precisely all strings that are encodable in numeric mode. To test whether a
+	 * string {@code s} is encodable: {@code boolean ok = NUMERIC_REGEX.matcher(s).matches();}.
+	 * A string is encodable iff each character is in the range 0 to 9.
+	 * @see #makeNumeric(String) */
+	public static final Pattern NUMERIC_REGEX = Pattern.compile("[0-9]*");
+	
+	/** Describes precisely all strings that are encodable in alphanumeric mode. To test whether a
+	 * string {@code s} is encodable: {@code boolean ok = ALPHANUMERIC_REGEX.matcher(s).matches();}.
+	 * A string is encodable iff each character is in the following set: 0 to 9, A to Z
+	 * (uppercase only), space, dollar, percent, asterisk, plus, hyphen, period, slash, colon.
+	 * @see #makeAlphanumeric(String) */
+	public static final Pattern ALPHANUMERIC_REGEX = Pattern.compile("[A-Z0-9 $%*+./:-]*");
+	
+	// The set of all legal characters in alphanumeric mode, where
+	// each character value maps to the index in the string.
+	static final String ALPHANUMERIC_CHARSET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";
+	
+	
+	
+	/*---- Public helper enumeration ----*/
+	
+	/**
+	 * Describes how a segment's data bits are interpreted.
+	 */
+	public enum Mode {
+		
+		/*-- Constants --*/
+		
+		NUMERIC     (0x1, 10, 12, 14),
+		ALPHANUMERIC(0x2,  9, 11, 13),
+		BYTE        (0x4,  8, 16, 16),
+		KANJI       (0x8,  8, 10, 12),
+		ECI         (0x7,  0,  0,  0);
+		
+		
+		/*-- Fields --*/
+		
+		// The mode indicator bits, which is a uint4 value (range 0 to 15).
+		final int modeBits;
+		
+		// Number of character count bits for three different version ranges.
+		private final int[] numBitsCharCount;
+		
+		
+		/*-- Constructor --*/
+		
+		private Mode(int mode, int... ccbits) {
+			modeBits = mode;
+			numBitsCharCount = ccbits;
+		}
+		
+		
+		/*-- Method --*/
+		
+		// Returns the bit width of the character count field for a segment in this mode
+		// in a QR Code at the given version number. The result is in the range [0, 16].
+		int numCharCountBits(int ver) {
+			assert QrCode.MIN_VERSION <= ver && ver <= QrCode.MAX_VERSION;
+			return numBitsCharCount[(ver + 7) / 17];
+		}
+		
+	}
+	
+}
diff --git a/Telegram/ThirdParty/QR/java/src/main/java/io/nayuki/qrcodegen/QrSegmentAdvanced.java b/Telegram/ThirdParty/QR/java/src/main/java/io/nayuki/qrcodegen/QrSegmentAdvanced.java
new file mode 100644
index 0000000..1efe7b5
--- /dev/null
+++ b/Telegram/ThirdParty/QR/java/src/main/java/io/nayuki/qrcodegen/QrSegmentAdvanced.java
@@ -0,0 +1,424 @@
+/* 
+ * QR Code generator library - Optional advanced logic (Java)
+ * 
+ * Copyright (c) Project Nayuki. (MIT License)
+ * https://www.nayuki.io/page/qr-code-generator-library
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ * - The above copyright notice and this permission notice shall be included in
+ *   all copies or substantial portions of the Software.
+ * - The Software is provided "as is", without warranty of any kind, express or
+ *   implied, including but not limited to the warranties of merchantability,
+ *   fitness for a particular purpose and noninfringement. In no event shall the
+ *   authors or copyright holders be liable for any claim, damages or other
+ *   liability, whether in an action of contract, tort or otherwise, arising from,
+ *   out of or in connection with the Software or the use or other dealings in the
+ *   Software.
+ */
+
+package io.nayuki.qrcodegen;
+
+import java.nio.charset.StandardCharsets;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Base64;
+import java.util.List;
+import java.util.Objects;
+import io.nayuki.qrcodegen.QrSegment.Mode;
+
+
+/**
+ * Splits text into optimal segments and encodes kanji segments.
+ * Provides static functions only; not instantiable.
+ * @see QrSegment
+ * @see QrCode
+ */
+public final class QrSegmentAdvanced {
+	
+	/*---- Optimal list of segments encoder ----*/
+	
+	/**
+	 * Returns a list of zero or more segments to represent the specified Unicode text string.
+	 * The resulting list optimally minimizes the total encoded bit length, subjected to the constraints
+	 * in the specified {error correction level, minimum version number, maximum version number}.
+	 * <p>This function can utilize all four text encoding modes: numeric, alphanumeric, byte (UTF-8),
+	 * and kanji. This can be considered as a sophisticated but slower replacement for {@link
+	 * QrSegment#makeSegments(String)}. This requires more input parameters because it searches a
+	 * range of versions, like {@link QrCode#encodeSegments(List,QrCode.Ecc,int,int,int,boolean)}.</p>
+	 * @param text the text to be encoded (not {@code null}), which can be any Unicode string
+	 * @param ecl the error correction level to use (not {@code null})
+	 * @param minVersion the minimum allowed version of the QR Code (at least 1)
+	 * @param maxVersion the maximum allowed version of the QR Code (at most 40)
+	 * @return a new mutable list (not {@code null}) of segments (not {@code null})
+	 * containing the text, minimizing the bit length with respect to the constraints
+	 * @throws NullPointerException if the text or error correction level is {@code null}
+	 * @throws IllegalArgumentException if 1 &#x2264; minVersion &#x2264; maxVersion &#x2264; 40 is violated
+	 * @throws DataTooLongException if the text fails to fit in the maxVersion QR Code at the ECL
+	 */
+	public static List<QrSegment> makeSegmentsOptimally(String text, QrCode.Ecc ecl, int minVersion, int maxVersion) {
+		// Check arguments
+		Objects.requireNonNull(text);
+		Objects.requireNonNull(ecl);
+		if (!(QrCode.MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= QrCode.MAX_VERSION))
+			throw new IllegalArgumentException("Invalid value");
+		
+		// Iterate through version numbers, and make tentative segments
+		List<QrSegment> segs = null;
+		int[] codePoints = toCodePoints(text);
+		for (int version = minVersion; ; version++) {
+			if (version == minVersion || version == 10 || version == 27)
+				segs = makeSegmentsOptimally(codePoints, version);
+			assert segs != null;
+			
+			// Check if the segments fit
+			int dataCapacityBits = QrCode.getNumDataCodewords(version, ecl) * 8;
+			int dataUsedBits = QrSegment.getTotalBits(segs, version);
+			if (dataUsedBits != -1 && dataUsedBits <= dataCapacityBits)
+				return segs;  // This version number is found to be suitable
+			if (version >= maxVersion) {  // All versions in the range could not fit the given text
+				String msg = "Segment too long";
+				if (dataUsedBits != -1)
+					msg = String.format("Data length = %d bits, Max capacity = %d bits", dataUsedBits, dataCapacityBits);
+				throw new DataTooLongException(msg);
+			}
+		}
+	}
+	
+	
+	// Returns a new list of segments that is optimal for the given text at the given version number.
+	private static List<QrSegment> makeSegmentsOptimally(int[] codePoints, int version) {
+		if (codePoints.length == 0)
+			return new ArrayList<>();
+		Mode[] charModes = computeCharacterModes(codePoints, version);
+		return splitIntoSegments(codePoints, charModes);
+	}
+	
+	
+	// Returns a new array representing the optimal mode per code point based on the given text and version.
+	private static Mode[] computeCharacterModes(int[] codePoints, int version) {
+		if (codePoints.length == 0)
+			throw new IllegalArgumentException();
+		final Mode[] modeTypes = {Mode.BYTE, Mode.ALPHANUMERIC, Mode.NUMERIC, Mode.KANJI};  // Do not modify
+		final int numModes = modeTypes.length;
+		
+		// Segment header sizes, measured in 1/6 bits
+		final int[] headCosts = new int[numModes];
+		for (int i = 0; i < numModes; i++)
+			headCosts[i] = (4 + modeTypes[i].numCharCountBits(version)) * 6;
+		
+		// charModes[i][j] represents the mode to encode the code point at
+		// index i such that the final segment ends in modeTypes[j] and the
+		// total number of bits is minimized over all possible choices
+		Mode[][] charModes = new Mode[codePoints.length][numModes];
+		
+		// At the beginning of each iteration of the loop below,
+		// prevCosts[j] is the exact minimum number of 1/6 bits needed to
+		// encode the entire string prefix of length i, and end in modeTypes[j]
+		int[] prevCosts = headCosts.clone();
+		
+		// Calculate costs using dynamic programming
+		for (int i = 0; i < codePoints.length; i++) {
+			int c = codePoints[i];
+			int[] curCosts = new int[numModes];
+			{  // Always extend a byte mode segment
+				curCosts[0] = prevCosts[0] + countUtf8Bytes(c) * 8 * 6;
+				charModes[i][0] = modeTypes[0];
+			}
+			// Extend a segment if possible
+			if (QrSegment.ALPHANUMERIC_CHARSET.indexOf(c) != -1) {  // Is alphanumeric
+				curCosts[1] = prevCosts[1] + 33;  // 5.5 bits per alphanumeric char
+				charModes[i][1] = modeTypes[1];
+			}
+			if ('0' <= c && c <= '9') {  // Is numeric
+				curCosts[2] = prevCosts[2] + 20;  // 3.33 bits per digit
+				charModes[i][2] = modeTypes[2];
+			}
+			if (isKanji(c)) {
+				curCosts[3] = prevCosts[3] + 78;  // 13 bits per Shift JIS char
+				charModes[i][3] = modeTypes[3];
+			}
+			
+			// Start new segment at the end to switch modes
+			for (int j = 0; j < numModes; j++) {  // To mode
+				for (int k = 0; k < numModes; k++) {  // From mode
+					int newCost = (curCosts[k] + 5) / 6 * 6 + headCosts[j];
+					if (charModes[i][k] != null && (charModes[i][j] == null || newCost < curCosts[j])) {
+						curCosts[j] = newCost;
+						charModes[i][j] = modeTypes[k];
+					}
+				}
+			}
+			
+			prevCosts = curCosts;
+		}
+		
+		// Find optimal ending mode
+		Mode curMode = null;
+		for (int i = 0, minCost = 0; i < numModes; i++) {
+			if (curMode == null || prevCosts[i] < minCost) {
+				minCost = prevCosts[i];
+				curMode = modeTypes[i];
+			}
+		}
+		
+		// Get optimal mode for each code point by tracing backwards
+		Mode[] result = new Mode[charModes.length];
+		for (int i = result.length - 1; i >= 0; i--) {
+			for (int j = 0; j < numModes; j++) {
+				if (modeTypes[j] == curMode) {
+					curMode = charModes[i][j];
+					result[i] = curMode;
+					break;
+				}
+			}
+		}
+		return result;
+	}
+	
+	
+	// Returns a new list of segments based on the given text and modes, such that
+	// consecutive code points in the same mode are put into the same segment.
+	private static List<QrSegment> splitIntoSegments(int[] codePoints, Mode[] charModes) {
+		if (codePoints.length == 0)
+			throw new IllegalArgumentException();
+		List<QrSegment> result = new ArrayList<>();
+		
+		// Accumulate run of modes
+		Mode curMode = charModes[0];
+		int start = 0;
+		for (int i = 1; ; i++) {
+			if (i < codePoints.length && charModes[i] == curMode)
+				continue;
+			String s = new String(codePoints, start, i - start);
+			if (curMode == Mode.BYTE)
+				result.add(QrSegment.makeBytes(s.getBytes(StandardCharsets.UTF_8)));
+			else if (curMode == Mode.NUMERIC)
+				result.add(QrSegment.makeNumeric(s));
+			else if (curMode == Mode.ALPHANUMERIC)
+				result.add(QrSegment.makeAlphanumeric(s));
+			else if (curMode == Mode.KANJI)
+				result.add(makeKanji(s));
+			else
+				throw new AssertionError();
+			if (i >= codePoints.length)
+				return result;
+			curMode = charModes[i];
+			start = i;
+		}
+	}
+	
+	
+	// Returns a new array of Unicode code points (effectively
+	// UTF-32 / UCS-4) representing the given UTF-16 string.
+	private static int[] toCodePoints(String s) {
+		int[] result = s.codePoints().toArray();
+		for (int c : result) {
+			if (Character.isSurrogate((char)c))
+				throw new IllegalArgumentException("Invalid UTF-16 string");
+		}
+		return result;
+	}
+	
+	
+	// Returns the number of UTF-8 bytes needed to encode the given Unicode code point.
+	private static int countUtf8Bytes(int cp) {
+		if      (cp <        0) throw new IllegalArgumentException("Invalid code point");
+		else if (cp <     0x80) return 1;
+		else if (cp <    0x800) return 2;
+		else if (cp <  0x10000) return 3;
+		else if (cp < 0x110000) return 4;
+		else                    throw new IllegalArgumentException("Invalid code point");
+	}
+	
+	
+	
+	/*---- Kanji mode segment encoder ----*/
+	
+	/**
+	 * Returns a segment representing the specified text string encoded in kanji mode.
+	 * Broadly speaking, the set of encodable characters are {kanji used in Japan,
+	 * hiragana, katakana, East Asian punctuation, full-width ASCII, Greek, Cyrillic}.
+	 * Examples of non-encodable characters include {ordinary ASCII, half-width katakana,
+	 * more extensive Chinese hanzi}.
+	 * @param text the text (not {@code null}), with only certain characters allowed
+	 * @return a segment (not {@code null}) containing the text
+	 * @throws NullPointerException if the string is {@code null}
+	 * @throws IllegalArgumentException if the string contains non-encodable characters
+	 * @see #isEncodableAsKanji(String)
+	 */
+	public static QrSegment makeKanji(String text) {
+		Objects.requireNonNull(text);
+		BitBuffer bb = new BitBuffer();
+		text.chars().forEachOrdered(c -> {
+			int val = UNICODE_TO_QR_KANJI[c];
+			if (val == -1)
+				throw new IllegalArgumentException("String contains non-kanji-mode characters");
+			bb.appendBits(val, 13);
+		});
+		return new QrSegment(Mode.KANJI, text.length(), bb);
+	}
+	
+	
+	/**
+	 * Tests whether the specified string can be encoded as a segment in kanji mode.
+	 * Broadly speaking, the set of encodable characters are {kanji used in Japan,
+	 * hiragana, katakana, East Asian punctuation, full-width ASCII, Greek, Cyrillic}.
+	 * Examples of non-encodable characters include {ordinary ASCII, half-width katakana,
+	 * more extensive Chinese hanzi}.
+	 * @param text the string to test for encodability (not {@code null})
+	 * @return {@code true} iff each character is in the kanji mode character set
+	 * @throws NullPointerException if the string is {@code null}
+	 * @see #makeKanji(String)
+	 */
+	public static boolean isEncodableAsKanji(String text) {
+		Objects.requireNonNull(text);
+		return text.chars().allMatch(
+			c -> isKanji((char)c));
+	}
+	
+	
+	private static boolean isKanji(int c) {
+		return c < UNICODE_TO_QR_KANJI.length && UNICODE_TO_QR_KANJI[c] != -1;
+	}
+	
+	
+	// Data derived from ftp://ftp.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/JIS/SHIFTJIS.TXT
+	private static final String PACKED_QR_KANJI_TO_UNICODE =
+		"MAAwATAC/wz/DjD7/xr/G/8f/wEwmzCcALT/QACo/z7/4/8/MP0w/jCdMJ4wA07dMAUwBjAHMPwgFSAQ/w8AXDAcIBb/XCAmICUgGCAZIBwgHf8I/wkwFDAV/zv/Pf9b/10wCDAJMAowCzAMMA0wDjAPMBAwEf8LIhIAsQDX//8A9/8dImD/HP8eImYiZyIeIjQmQiZA" +
+		"ALAgMiAzIQP/5f8EAKIAo/8F/wP/Bv8K/yAApyYGJgUlyyXPJc4lxyXGJaEloCWzJbIlvSW8IDswEiGSIZAhkSGTMBP/////////////////////////////IggiCyKGIocigiKDIioiKf////////////////////8iJyIoAKwh0iHUIgAiA///////////////////" +
+		"//////////8iICKlIxIiAiIHImEiUiJqImsiGiI9Ih0iNSIrIiz//////////////////yErIDAmbyZtJmogICAhALb//////////yXv/////////////////////////////////////////////////xD/Ef8S/xP/FP8V/xb/F/8Y/xn///////////////////8h" +
+		"/yL/I/8k/yX/Jv8n/yj/Kf8q/yv/LP8t/y7/L/8w/zH/Mv8z/zT/Nf82/zf/OP85/zr///////////////////9B/0L/Q/9E/0X/Rv9H/0j/Sf9K/0v/TP9N/07/T/9Q/1H/Uv9T/1T/Vf9W/1f/WP9Z/1r//////////zBBMEIwQzBEMEUwRjBHMEgwSTBKMEswTDBN" +
+		"ME4wTzBQMFEwUjBTMFQwVTBWMFcwWDBZMFowWzBcMF0wXjBfMGAwYTBiMGMwZDBlMGYwZzBoMGkwajBrMGwwbTBuMG8wcDBxMHIwczB0MHUwdjB3MHgweTB6MHswfDB9MH4wfzCAMIEwgjCDMIQwhTCGMIcwiDCJMIowizCMMI0wjjCPMJAwkTCSMJP/////////////" +
+		"////////////////////////MKEwojCjMKQwpTCmMKcwqDCpMKowqzCsMK0wrjCvMLAwsTCyMLMwtDC1MLYwtzC4MLkwujC7MLwwvTC+ML8wwDDBMMIwwzDEMMUwxjDHMMgwyTDKMMswzDDNMM4wzzDQMNEw0jDTMNQw1TDWMNcw2DDZMNow2zDcMN0w3jDf//8w4DDh" +
+		"MOIw4zDkMOUw5jDnMOgw6TDqMOsw7DDtMO4w7zDwMPEw8jDzMPQw9TD2/////////////////////wORA5IDkwOUA5UDlgOXA5gDmQOaA5sDnAOdA54DnwOgA6EDowOkA6UDpgOnA6gDqf////////////////////8DsQOyA7MDtAO1A7YDtwO4A7kDugO7A7wDvQO+" +
+		"A78DwAPBA8MDxAPFA8YDxwPIA8n/////////////////////////////////////////////////////////////////////////////////////////////////////////////BBAEEQQSBBMEFAQVBAEEFgQXBBgEGQQaBBsEHAQdBB4EHwQgBCEEIgQjBCQEJQQm" +
+		"BCcEKAQpBCoEKwQsBC0ELgQv////////////////////////////////////////BDAEMQQyBDMENAQ1BFEENgQ3BDgEOQQ6BDsEPAQ9//8EPgQ/BEAEQQRCBEMERARFBEYERwRIBEkESgRLBEwETQROBE///////////////////////////////////yUAJQIlDCUQ" +
+		"JRglFCUcJSwlJCU0JTwlASUDJQ8lEyUbJRclIyUzJSslOyVLJSAlLyUoJTclPyUdJTAlJSU4JUL/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////" +
+		"////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////" +
+		"////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////" +
+		"////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////" +
+		"////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////" +
+		"////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////" +
+		"////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////" +
+		"////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////" +
+		"////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////" +
+		"////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////" +
+		"/////////////////////////////////////06cVRZaA5Y/VMBhG2MoWfaQIoR1gxx6UGCqY+FuJWXthGaCppv1aJNXJ2WhYnFbm1nQhnuY9H1ifb6bjmIWfJ+It1uJXrVjCWaXaEiVx5eNZ09O5U8KT01PnVBJVvJZN1nUWgFcCWDfYQ9hcGYTaQVwunVPdXB5+32t" +
+		"fe+Aw4QOiGOLApBVkHpTO06VTqVX34CykMF4704AWPFuopA4ejKDKIKLnC9RQVNwVL1U4VbgWftfFZjybeuA5IUt////////lmKWcJagl/tUC1PzW4dwz3+9j8KW6FNvnVx6uk4ReJOB/G4mVhhVBGsdhRqcO1nlU6ltZnTclY9WQk6RkEuW8oNPmQxT4VW2WzBfcWYg" +
+		"ZvNoBGw4bPNtKXRbdsh6Tpg0gvGIW4pgku1tsnWrdsqZxWCmiwGNipWyaY5TrVGG//9XElgwWURbtF72YChjqWP0bL9vFHCOcRRxWXHVcz9+AYJ2gtGFl5BgkludG1hpZbxsWnUlUflZLlllX4Bf3GK8ZfpqKmsna7Rzi3/BiVadLJ0OnsRcoWyWg3tRBFxLYbaBxmh2" +
+		"cmFOWU/6U3hgaW4pek+X804LUxZO7k9VTz1PoU9zUqBT71YJWQ9awVu2W+F50WaHZ5xntmtMbLNwa3PCeY15vno8e4eCsYLbgwSDd4Pvg9OHZoqyVimMqI/mkE6XHoaKT8Rc6GIRcll1O4Hlgr2G/ozAlsWZE5nVTstPGonjVt5YSljKXvtf62AqYJRgYmHQYhJi0GU5" +
+		"////////m0FmZmiwbXdwcHVMdoZ9dYKlh/mVi5aOjJ1R8VK+WRZUs1uzXRZhaGmCba94jYTLiFeKcpOnmrhtbJmohtlXo2f/hs6SDlKDVodUBF7TYuFkuWg8aDhru3NyeLp6a4maidKNa48DkO2Vo5aUl2lbZlyzaX2YTZhOY5t7IGor//9qf2i2nA1vX1JyVZ1gcGLs" +
+		"bTtuB27RhFuJEI9EThScOVP2aRtqOpeEaCpRXHrDhLKR3JOMVludKGgigwWEMXylUgiCxXTmTn5Pg1GgW9JSClLYUudd+1WaWCpZ5luMW5hb215yXnlgo2EfYWNhvmPbZWJn0WhTaPprPmtTbFdvIm+Xb0V0sHUYduN3C3r/e6F8IX3pfzZ/8ICdgmaDnomzisyMq5CE" +
+		"lFGVk5WRlaKWZZfTmSiCGE44VCtcuF3Mc6l2THc8XKl/640LlsGYEZhUmFhPAU8OU3FVnFZoV/pZR1sJW8RckF4MXn5fzGPuZzpl12XiZx9oy2jE////////al9eMGvFbBdsfXV/eUhbY3oAfQBfvYmPihiMtI13jsyPHZjimg6bPE6AUH1RAFmTW5xiL2KAZOxrOnKg" +
+		"dZF5R3+ph/uKvItwY6yDypegVAlUA1WraFRqWIpweCdndZ7NU3RbooEahlCQBk4YTkVOx08RU8pUOFuuXxNgJWVR//9nPWxCbHJs43B4dAN6dnquewh9Gnz+fWZl53JbU7tcRV3oYtJi4GMZbiCGWooxjd2S+G8BeaabWk6oTqtOrE+bT6BQ0VFHevZRcVH2U1RTIVN/" +
+		"U+tVrFiDXOFfN19KYC9gUGBtYx9lWWpLbMFywnLtd++A+IEFggiFTpD3k+GX/5lXmlpO8FHdXC1mgWltXEBm8ml1c4loUHyBUMVS5FdHXf6TJmWkayNrPXQ0eYF5vXtLfcqCuYPMiH+JX4s5j9GR0VQfkoBOXVA2U+VTOnLXc5Z36YLmjq+ZxpnImdJRd2Eahl5VsHp6" +
+		"UHZb05BHloVOMmrbkedcUVxI////////Y5h6n2yTl3SPYXqqcYqWiHyCaBd+cGhRk2xS8lQbhauKE3+kjs2Q4VNmiIh5QU/CUL5SEVFEVVNXLXPqV4tZUV9iX4RgdWF2YWdhqWOyZDplbGZvaEJuE3Vmej18+31MfZl+S39rgw6DSobNigiKY4tmjv2YGp2PgriPzpvo" +
+		"//9Sh2IfZINvwJaZaEFQkWsgbHpvVHp0fVCIQIojZwhO9lA5UCZQZVF8UjhSY1WnVw9YBVrMXvphsmH4YvNjcmkcailyfXKscy54FHhvfXl3DICpiYuLGYzijtKQY5N1lnqYVZoTnnhRQ1OfU7Nee18mbhtukHOEc/59Q4I3igCK+pZQTk5QC1PkVHxW+lnRW2Rd8V6r" +
+		"XydiOGVFZ69uVnLQfMqItIChgOGD8IZOioeN6JI3lseYZ58TTpROkk8NU0hUSVQ+Wi9fjF+hYJ9op2qOdFp4gYqeiqSLd5GQTl6byU6kT3xPr1AZUBZRSVFsUp9SuVL+U5pT41QR////////VA5ViVdRV6JZfVtUW11bj13lXedd9154XoNeml63XxhgUmFMYpdi2GOn" +
+		"ZTtmAmZDZvRnbWghaJdpy2xfbSptaW4vbp11MnaHeGx6P3zgfQV9GH1efbGAFYADgK+AsYFUgY+CKoNSiEyIYYsbjKKM/JDKkXWScXg/kvyVpJZN//+YBZmZmtidO1JbUqtT91QIWNVi92/gjGqPX565UUtSO1RKVv16QJF3nWCe0nNEbwmBcHURX/1g2pqoctuPvGtk" +
+		"mANOylbwV2RYvlpaYGhhx2YPZgZoOWixbfd11X06gm6bQk6bT1BTyVUGXW9d5l3uZ/tsmXRzeAKKUJOWiN9XUF6nYytQtVCsUY1nAFTJWF5Zu1uwX2liTWOhaD1rc24IcH2Rx3KAeBV4JnltZY59MIPciMGPCZabUmRXKGdQf2qMoVG0V0KWKlg6aYqAtFSyXQ5X/HiV" +
+		"nfpPXFJKVItkPmYoZxRn9XqEe1Z9IpMvaFybrXs5UxlRilI3////////W99i9mSuZOZnLWu6hamW0XaQm9ZjTJMGm6t2v2ZSTglQmFPCXHFg6GSSZWNoX3Hmc8p1I3uXfoKGlYuDjNuReJkQZaxmq2uLTtVO1E86T39SOlP4U/JV41bbWOtZy1nJWf9bUFxNXgJeK1/X" +
+		"YB1jB2UvW1xlr2W9ZehnnWti//9re2wPc0V5SXnBfPh9GX0rgKKBAoHziZaKXoppimaKjIrujMeM3JbMmPxrb06LTzxPjVFQW1db+mFIYwFmQmshbstsu3I+dL111HjBeTqADIAzgeqElI+ebFCef18Pi1idK3r6jvhbjZbrTgNT8Vf3WTFayVukYIluf28Gdb6M6luf" +
+		"hQB74FByZ/SCnVxhhUp+HoIOUZlcBGNojWZlnHFueT59F4AFix2OypBuhseQqlAfUvpcOmdTcHxyNZFMkciTK4LlW8JfMWD5TjtT1luIYktnMWuKculz4HougWuNo5FSmZZRElPXVGpb/2OIajl9rJcAVtpTzlRo////////W5dcMV3eT+5hAWL+bTJ5wHnLfUJ+TX/S" +
+		"ge2CH4SQiEaJcouQjnSPL5AxkUuRbJbGkZxOwE9PUUVTQV+TYg5n1GxBbgtzY34mkc2Sg1PUWRlbv23ReV1+LnybWH5xn1H6iFOP8E/KXPtmJXeseuOCHJn/UcZfqmXsaW9riW3z//9ulm9kdv59FF3hkHWRh5gGUeZSHWJAZpFm2W4aXrZ90n9yZviFr4X3ivhSqVPZ" +
+		"WXNej1+QYFWS5JZkULdRH1LdUyBTR1PsVOhVRlUxVhdZaFm+WjxbtVwGXA9cEVwaXoReil7gX3Bif2KEYttjjGN3ZgdmDGYtZnZnfmiiah9qNWy8bYhuCW5YcTxxJnFndcd3AXhdeQF5ZXnweuB7EXynfTmAloPWhIuFSYhdiPOKH4o8ilSKc4xhjN6RpJJmk36UGJac" +
+		"l5hOCk4ITh5OV1GXUnBXzlg0WMxbIl44YMVk/mdhZ1ZtRHK2dXN6Y4S4i3KRuJMgVjFX9Jj+////////Yu1pDWuWce1+VIB3gnKJ5pjfh1WPsVw7TzhP4U+1VQdaIFvdW+lfw2FOYy9lsGZLaO5pm214bfF1M3W5dx95XnnmfTOB44KvhaqJqoo6jquPm5Aykd2XB066" +
+		"TsFSA1h1WOxcC3UaXD2BTooKj8WWY5dteyWKz5gIkWJW81Oo//+QF1Q5V4JeJWOobDRwindhfIt/4IhwkEKRVJMQkxiWj3RemsRdB11pZXBnoo2olttjbmdJaRmDxZgXlsCI/m+EZHpb+E4WcCx1XWYvUcRSNlLiWdNfgWAnYhBlP2V0Zh9mdGjyaBZrY24FcnJ1H3bb" +
+		"fL6AVljwiP2Jf4qgipOKy5AdkZKXUpdZZYl6DoEGlrteLWDcYhplpWYUZ5B383pNfE1+PoEKjKyNZI3hjl94qVIHYtljpWRCYpiKLXqDe8CKrJbqfXaCDIdJTtlRSFNDU2Bbo1wCXBZd3WImYkdksGgTaDRsyW1FbRdn029ccU5xfWXLen97rX3a////////fkp/qIF6" +
+		"ghuCOYWmim6Mzo31kHiQd5KtkpGVg5uuUk1VhG84cTZRaHmFflWBs3zOVkxYUVyoY6pm/mb9aVpy2XWPdY55DnlWed98l30gfUSGB4o0ljuQYZ8gUOdSdVPMU+JQCVWqWO5ZT3I9W4tcZFMdYONg82NcY4NjP2O7//9kzWXpZvld42nNaf1vFXHlTol16Xb4epN8333P" +
+		"fZyAYYNJg1iEbIS8hfuIxY1wkAGQbZOXlxyaElDPWJdhjoHThTWNCJAgT8NQdFJHU3Ngb2NJZ19uLI2zkB9P11xejMplz32aU1KIllF2Y8NbWFtrXApkDWdRkFxO1lkaWSpscIpRVT5YFVmlYPBiU2fBgjVpVZZAmcSaKE9TWAZb/oAQXLFeL1+FYCBhS2I0Zv9s8G7e" +
+		"gM6Bf4LUiIuMuJAAkC6Wip7bm9tO41PwWSd7LJGNmEyd+W7dcCdTU1VEW4ViWGKeYtNsom/vdCKKF5Q4b8GK/oM4UeeG+FPq////////U+lPRpBUj7BZaoExXf166o+/aNqMN3L4nEhqPYqwTjlTWFYGV2ZixWOiZeZrTm3hbltwrXfteu97qn27gD2AxobLipWTW1bj" +
+		"WMdfPmWtZpZqgGu1dTeKx1Akd+VXMF8bYGVmemxgdfR6Gn9ugfSHGJBFmbN7yXVcevl7UYTE//+QEHnpepKDNlrhd0BOLU7yW5lf4GK9Zjxn8WzohmuId4o7kU6S85nQahdwJnMqgueEV4yvTgFRRlHLVYtb9V4WXjNegV8UXzVfa1+0YfJjEWaiZx1vbnJSdTp3OoB0" +
+		"gTmBeId2ir+K3I2FjfOSmpV3mAKc5VLFY1d29GcVbIhzzYzDk66Wc20lWJxpDmnMj/2TmnXbkBpYWmgCY7Rp+09Dbyxn2I+7hSZ9tJNUaT9vcFdqWPdbLH0scipUCpHjnbROrU9OUFxQdVJDjJ5USFgkW5peHV6VXq1e918fYIxitWM6Y9Bor2xAeId5jnoLfeCCR4oC" +
+		"iuaORJAT////////kLiRLZHYnw5s5WRYZOJldW70doR7G5Bpk9FuulTyX7lkpI9Nj+2SRFF4WGtZKVxVXpdt+36PdRyMvI7imFtwuU8da79vsXUwlvtRTlQQWDVYV1msXGBfkmWXZ1xuIXZ7g9+M7ZAUkP2TTXgleDpSql6mVx9ZdGASUBJRWlGs//9RzVIAVRBYVFhY" +
+		"WVdblVz2XYtgvGKVZC1ncWhDaLxo33bXbdhub22bcG9xyF9Tddh5d3tJe1R7UnzWfXFSMIRjhWmF5IoOiwSMRo4PkAOQD5QZlnaYLZowldhQzVLVVAxYAlwOYadknm0ed7N65YD0hASQU5KFXOCdB1M/X5dfs22ccnl3Y3m/e+Rr0nLsiq1oA2phUfh6gWk0XEqc9oLr" +
+		"W8WRSXAeVnhcb2DHZWZsjIxakEGYE1RRZseSDVlIkKNRhU5NUeqFmYsOcFhjepNLaWKZtH4EdXdTV2lgjt+W42xdToxcPF8Qj+lTAozRgImGeV7/ZeVOc1Fl////////WYJcP5fuTvtZil/Nio1v4XmweWJb54RxcytxsV50X/Vje2SaccN8mE5DXvxOS1fcVqJgqW/D" +
+		"fQ2A/YEzgb+PsomXhqRd9GKKZK2Jh2d3bOJtPnQ2eDRaRn91gq2ZrE/zXsNi3WOSZVdnb3bDckyAzIC6jymRTVANV/lakmiF//9pc3Fkcv2Mt1jyjOCWapAZh3955HfnhClPL1JlU1pizWfPbMp2fXuUfJWCNoWEj+tm3W8gcgZ+G4OrmcGeplH9e7F4cnu4gId7SGro" +
+		"XmGAjHVRdWBRa5Jibox2epGXmupPEH9wYpx7T5WlnOlWelhZhuSWvE80UiRTSlPNU9teBmQsZZFnf2w+bE5ySHKvc+11VH5BgiyF6Yype8SRxnFpmBKY72M9Zml1anbkeNCFQ4buUypTUVQmWYNeh198YLJiSWJ5YqtlkGvUbMx1snaueJF52H3Lf3eApYirirmMu5B/" +
+		"l16Y22oLfDhQmVw+X65nh2vYdDV3CX+O////////nztnynoXUzl1i5rtX2aBnYPxgJhfPF/FdWJ7RpA8aGdZ61qbfRB2fossT/VfamoZbDdvAnTieWiIaIpVjHle32PPdcV50oLXkyiS8oSchu2cLVTBX2xljG1ccBWMp4zTmDtlT3T2Tg1O2FfgWStaZlvMUaheA16c" +
+		"YBZidmV3//9lp2ZubW5yNnsmgVCBmoKZi1yMoIzmjXSWHJZET65kq2tmgh6EYYVqkOhcAWlTmKiEeoVXTw9Sb1+pXkVnDXmPgXmJB4mGbfVfF2JVbLhOz3Jpm5JSBlQ7VnRYs2GkYm5xGllufIl83n0blvBlh4BeThlPdVF1WEBeY15zXwpnxE4mhT2ViZZbfHOYAVD7" +
+		"WMF2VninUiV3pYURe4ZQT1kJckd7x33oj7qP1JBNT79SyVopXwGXrU/dgheS6lcDY1VraXUriNyPFHpCUt9Yk2FVYgpmrmvNfD+D6VAjT/hTBVRGWDFZSVudXPBc710pXpZisWNnZT5luWcL////////bNVs4XD5eDJ+K4DegrOEDITshwKJEooqjEqQppLSmP2c851s" +
+		"Tk9OoVCNUlZXSlmoXj1f2F/ZYj9mtGcbZ9Bo0lGSfSGAqoGoiwCMjIy/kn6WMlQgmCxTF1DVU1xYqGSyZzRyZ3dmekaR5lLDbKFrhlgAXkxZVGcsf/tR4XbG//9kaXjom1Seu1fLWblmJ2eaa85U6WnZXlWBnGeVm6pn/pxSaF1Opk/jU8hiuWcrbKuPxE+tfm2ev04H" +
+		"YWJugG8rhRNUc2cqm0Vd83uVXKxbxoccbkqE0XoUgQhZmXyNbBF3IFLZWSJxIXJfd9uXJ51haQtaf1oYUaVUDVR9Zg5234/3kpic9Fnqcl1uxVFNaMl9v33sl2KeumR4aiGDAlmEW19r23MbdvJ9soAXhJlRMmcontl27mdiUv+ZBVwkYjt8foywVU9gtn0LlYBTAU5f" +
+		"UbZZHHI6gDaRzl8ld+JThF95fQSFrIozjo2XVmfzha6UU2EJYQhsuXZS////////iu2POFUvT1FRKlLHU8tbpV59YKBhgmPWZwln2m5nbYxzNnM3dTF5UIjVipiQSpCRkPWWxIeNWRVOiE9ZTg6KiY8/mBBQrV58WZZbuV64Y9pj+mTBZtxpSmnYbQtutnGUdSh6r3+K" +
+		"gACESYTJiYGLIY4KkGWWfZkKYX5ikWsy//9sg210f8x//G3Af4WHuoj4Z2WDsZg8lvdtG31hhD2Rak5xU3VdUGsEb+uFzYYtiadSKVQPXGVnTmiodAZ0g3XiiM+I4ZHMluKWeF+Lc4d6y4ROY6B1ZVKJbUFunHQJdVl4a3ySloZ63J+NT7ZhbmXFhlxOhk6uUNpOIVHM" +
+		"W+5lmWiBbbxzH3ZCd616HHzngm+K0pB8kc+WdZgYUpt90VArU5hnl23LcdB0M4HojyqWo5xXnp90YFhBbZl9L5heTuRPNk+LUbdSsV26YBxzsnk8gtOSNJa3lvaXCp6Xn2Jmpmt0UhdSo3DIiMJeyWBLYZBvI3FJfD599IBv////////hO6QI5MsVEKbb2rTcImMwo3v" +
+		"lzJStFpBXspfBGcXaXxplG1qbw9yYnL8e+2AAYB+h0uQzlFtnpN5hICLkzKK1lAtVIyKcWtqjMSBB2DRZ6Cd8k6ZTpicEIprhcGFaGkAbn54l4FV////////////////////////////////////////////////////////////////////////////////////////" +
+		"/////////////////////////////18MThBOFU4qTjFONk48Tj9OQk5WTlhOgk6FjGtOioISXw1Ojk6eTp9OoE6iTrBOs062Ts5OzU7ETsZOwk7XTt5O7U7fTvdPCU9aTzBPW09dT1dPR092T4hPj0+YT3tPaU9wT5FPb0+GT5ZRGE/UT99Pzk/YT9tP0U/aT9BP5E/l" +
+		"UBpQKFAUUCpQJVAFTxxP9lAhUClQLE/+T+9QEVAGUENQR2cDUFVQUFBIUFpQVlBsUHhQgFCaUIVQtFCy////////UMlQylCzUMJQ1lDeUOVQ7VDjUO5Q+VD1UQlRAVECURZRFVEUURpRIVE6UTdRPFE7UT9RQFFSUUxRVFFievhRaVFqUW5RgFGCVthRjFGJUY9RkVGT" +
+		"UZVRllGkUaZRolGpUapRq1GzUbFRslGwUbVRvVHFUclR21HghlVR6VHt//9R8FH1Uf5SBFILUhRSDlInUipSLlIzUjlST1JEUktSTFJeUlRSalJ0UmlSc1J/Un1SjVKUUpJScVKIUpGPqI+nUqxSrVK8UrVSwVLNUtdS3lLjUuaY7VLgUvNS9VL4UvlTBlMIdThTDVMQ" +
+		"Uw9TFVMaUyNTL1MxUzNTOFNAU0ZTRU4XU0lTTVHWU15TaVNuWRhTe1N3U4JTllOgU6ZTpVOuU7BTtlPDfBKW2VPfZvxx7lPuU+hT7VP6VAFUPVRAVCxULVQ8VC5UNlQpVB1UTlSPVHVUjlRfVHFUd1RwVJJUe1SAVHZUhFSQVIZUx1SiVLhUpVSsVMRUyFSo////////" +
+		"VKtUwlSkVL5UvFTYVOVU5lUPVRRU/VTuVO1U+lTiVTlVQFVjVUxVLlVcVUVVVlVXVThVM1VdVZlVgFSvVYpVn1V7VX5VmFWeVa5VfFWDValVh1WoVdpVxVXfVcRV3FXkVdRWFFX3VhZV/lX9VhtV+VZOVlBx31Y0VjZWMlY4//9Wa1ZkVi9WbFZqVoZWgFaKVqBWlFaP" +
+		"VqVWrla2VrRWwla8VsFWw1bAVshWzlbRVtNW11buVvlXAFb/VwRXCVcIVwtXDVcTVxhXFlXHVxxXJlc3VzhXTlc7V0BXT1dpV8BXiFdhV39XiVeTV6BXs1ekV6pXsFfDV8ZX1FfSV9NYClfWV+NYC1gZWB1YclghWGJYS1hwa8BYUlg9WHlYhVi5WJ9Yq1i6WN5Yu1i4" +
+		"WK5YxVjTWNFY11jZWNhY5VjcWORY31jvWPpY+Vj7WPxY/VkCWQpZEFkbaKZZJVksWS1ZMlk4WT560llVWVBZTllaWVhZYllgWWdZbFlp////////WXhZgVmdT15Pq1mjWbJZxlnoWdxZjVnZWdpaJVofWhFaHFoJWhpaQFpsWklaNVo2WmJaalqaWrxavlrLWsJavVrj" +
+		"Wtda5lrpWtZa+lr7WwxbC1sWWzJa0FsqWzZbPltDW0VbQFtRW1VbWltbW2VbaVtwW3NbdVt4ZYhbeluA//9bg1umW7hbw1vHW8lb1FvQW+Rb5lviW95b5VvrW/Bb9lvzXAVcB1wIXA1cE1wgXCJcKFw4XDlcQVxGXE5cU1xQXE9bcVxsXG5OYlx2XHlcjFyRXJRZm1yr" +
+		"XLtctly8XLdcxVy+XMdc2VzpXP1c+lztXYxc6l0LXRVdF11cXR9dG10RXRRdIl0aXRldGF1MXVJdTl1LXWxdc112XYddhF2CXaJdnV2sXa5dvV2QXbddvF3JXc1d013SXdZd213rXfJd9V4LXhpeGV4RXhteNl43XkReQ15AXk5eV15UXl9eYl5kXkdedV52XnqevF5/" +
+		"XqBewV7CXshe0F7P////////XtZe417dXtpe217iXuFe6F7pXuxe8V7zXvBe9F74Xv5fA18JX11fXF8LXxFfFl8pXy1fOF9BX0hfTF9OXy9fUV9WX1dfWV9hX21fc193X4Nfgl9/X4pfiF+RX4dfnl+ZX5hfoF+oX61fvF/WX/tf5F/4X/Ff3WCzX/9gIWBg//9gGWAQ" +
+		"YClgDmAxYBtgFWArYCZgD2A6YFpgQWBqYHdgX2BKYEZgTWBjYENgZGBCYGxga2BZYIFgjWDnYINgmmCEYJtglmCXYJJgp2CLYOFguGDgYNNgtF/wYL1gxmC1YNhhTWEVYQZg9mD3YQBg9GD6YQNhIWD7YPFhDWEOYUdhPmEoYSdhSmE/YTxhLGE0YT1hQmFEYXNhd2FY" +
+		"YVlhWmFrYXRhb2FlYXFhX2FdYVNhdWGZYZZhh2GsYZRhmmGKYZFhq2GuYcxhymHJYfdhyGHDYcZhumHLf3lhzWHmYeNh9mH6YfRh/2H9Yfxh/mIAYghiCWINYgxiFGIb////////Yh5iIWIqYi5iMGIyYjNiQWJOYl5iY2JbYmBiaGJ8YoJiiWJ+YpJik2KWYtRig2KU" +
+		"Ytdi0WK7Ys9i/2LGZNRiyGLcYsxiymLCYsdim2LJYwxi7mLxYydjAmMIYu9i9WNQYz5jTWQcY09jlmOOY4Bjq2N2Y6Njj2OJY59jtWNr//9jaWO+Y+ljwGPGY+NjyWPSY/ZjxGQWZDRkBmQTZCZkNmUdZBdkKGQPZGdkb2R2ZE5lKmSVZJNkpWSpZIhkvGTaZNJkxWTH" +
+		"ZLtk2GTCZPFk54IJZOBk4WKsZONk72UsZPZk9GTyZPplAGT9ZRhlHGUFZSRlI2UrZTRlNWU3ZTZlOHVLZUhlVmVVZU1lWGVeZV1lcmV4ZYJlg4uKZZtln2WrZbdlw2XGZcFlxGXMZdJl22XZZeBl4WXxZ3JmCmYDZftnc2Y1ZjZmNGYcZk9mRGZJZkFmXmZdZmRmZ2Zo" +
+		"Zl9mYmZwZoNmiGaOZolmhGaYZp1mwWa5Zslmvma8////////ZsRmuGbWZtpm4GY/ZuZm6WbwZvVm92cPZxZnHmcmZyeXOGcuZz9nNmdBZzhnN2dGZ15nYGdZZ2NnZGeJZ3BnqWd8Z2pnjGeLZ6ZnoWeFZ7dn72e0Z+xns2fpZ7hn5GfeZ91n4mfuZ7lnzmfGZ+dqnGge" +
+		"aEZoKWhAaE1oMmhO//9os2graFloY2h3aH9on2iPaK1olGidaJtog2quaLlodGi1aKBoumkPaI1ofmkBaMppCGjYaSJpJmjhaQxozWjUaOdo1Wk2aRJpBGjXaONpJWj5aOBo72koaSppGmkjaSFoxml5aXdpXGl4aWtpVGl+aW5pOWl0aT1pWWkwaWFpXmldaYFpammy" +
+		"aa5p0Gm/acFp02m+ac5b6GnKad1pu2nDaadqLmmRaaBpnGmVabRp3mnoagJqG2n/awpp+WnyaedqBWmxah5p7WoUaetqCmoSasFqI2oTakRqDGpyajZqeGpHamJqWWpmakhqOGoiapBqjWqgaoRqomqj////////apeGF2q7asNqwmq4arNqrGreatFq32qqatpq6mr7" +
+		"awWGFmr6axJrFpsxax9rOGs3dtxrOZjua0drQ2tJa1BrWWtUa1trX2tha3hreWt/a4BrhGuDa41rmGuVa55rpGuqa6trr2uya7Frs2u3a7xrxmvLa9Nr32vsa+tr82vv//+evmwIbBNsFGwbbCRsI2xebFVsYmxqbIJsjWyabIFsm2x+bGhsc2ySbJBsxGzxbNNsvWzX" +
+		"bMVs3WyubLFsvmy6bNts72zZbOptH4hNbTZtK209bThtGW01bTNtEm0MbWNtk21kbVpteW1ZbY5tlW/kbYVt+W4VbgpttW3HbeZtuG3Gbext3m3Mbeht0m3Fbfpt2W3kbdVt6m3ubi1ubm4ubhlucm5fbj5uI25rbitudm5Nbh9uQ246bk5uJG7/bh1uOG6CbqpumG7J" +
+		"brdu0269bq9uxG6ybtRu1W6PbqVuwm6fb0FvEXBMbuxu+G7+bz9u8m8xbu9vMm7M////////bz5vE273b4Zvem94b4FvgG9vb1tv829tb4JvfG9Yb45vkW/Cb2Zvs2+jb6FvpG+5b8Zvqm/fb9Vv7G/Ub9hv8W/ub9twCXALb/pwEXABcA9v/nAbcBpvdHAdcBhwH3Aw" +
+		"cD5wMnBRcGNwmXCScK9w8XCscLhws3CucN9wy3Dd//9w2XEJcP1xHHEZcWVxVXGIcWZxYnFMcVZxbHGPcftxhHGVcahxrHHXcblxvnHScclx1HHOceBx7HHncfVx/HH5cf9yDXIQchtyKHItcixyMHIycjtyPHI/ckByRnJLclhydHJ+coJygXKHcpJylnKicqdyuXKy" +
+		"csNyxnLEcs5y0nLicuBy4XL5cvdQD3MXcwpzHHMWcx1zNHMvcylzJXM+c05zT57Yc1dzanNoc3BzeHN1c3tzenPIc7NzznO7c8Bz5XPuc950onQFdG90JXP4dDJ0OnRVdD90X3RZdEF0XHRpdHB0Y3RqdHZ0fnSLdJ50p3TKdM901HPx////////dOB043TndOl07nTy" +
+		"dPB08XT4dPd1BHUDdQV1DHUOdQ11FXUTdR51JnUsdTx1RHVNdUp1SXVbdUZ1WnVpdWR1Z3VrdW11eHV2dYZ1h3V0dYp1iXWCdZR1mnWddaV1o3XCdbN1w3W1db11uHW8dbF1zXXKddJ12XXjdd51/nX///91/HYBdfB1+nXydfN2C3YNdgl2H3YndiB2IXYidiR2NHYw" +
+		"djt2R3ZIdkZ2XHZYdmF2YnZodml2anZndmx2cHZydnZ2eHZ8doB2g3aIdot2jnaWdpN2mXaadrB2tHa4drl2unbCds121nbSdt524Xbldud26oYvdvt3CHcHdwR3KXckdx53JXcmdxt3N3c4d0d3Wndod2t3W3dld393fnd5d453i3eRd6B3nnewd7Z3uXe/d7x3vXe7" +
+		"d8d3zXfXd9p33Hfjd+53/HgMeBJ5JnggeSp4RXiOeHR4hnh8eJp4jHijeLV4qniveNF4xnjLeNR4vni8eMV4ynjs////////eOd42nj9ePR5B3kSeRF5GXkseSt5QHlgeVd5X3laeVV5U3l6eX95inmdeaefS3mqea55s3m5ebp5yXnVeed57HnheeN6CHoNehh6GXog" +
+		"eh95gHoxejt6Pno3ekN6V3pJemF6Ynppn516cHp5en16iHqXepV6mHqWeql6yHqw//96tnrFesR6v5CDesd6ynrNes961XrTetl62nrdeuF64nrmeu168HsCew97CnsGezN7GHsZex57NXsoezZ7UHt6ewR7TXsLe0x7RXt1e2V7dHtne3B7cXtse257nXuYe597jXuc" +
+		"e5p7i3uSe497XXuZe8t7wXvMe897tHvGe9176XwRfBR75nvlfGB8AHwHfBN783v3fBd8DXv2fCN8J3wqfB98N3wrfD18THxDfFR8T3xAfFB8WHxffGR8VnxlfGx8dXyDfJB8pHytfKJ8q3yhfKh8s3yyfLF8rny5fL18wHzFfMJ82HzSfNx84ps7fO988nz0fPZ8+n0G" +
+		"////////fQJ9HH0VfQp9RX1LfS59Mn0/fTV9Rn1zfVZ9Tn1yfWh9bn1PfWN9k32JfVt9j319fZt9un2ufaN9tX3Hfb19q349faJ9r33cfbh9n32wfdh93X3kfd59+33yfeF+BX4KfiN+IX4SfjF+H34Jfgt+In5GfmZ+O341fjl+Q343//9+Mn46fmd+XX5Wfl5+WX5a" +
+		"fnl+an5pfnx+e36DfdV+fY+ufn9+iH6Jfox+kn6QfpN+lH6Wfo5+m36cfzh/On9Ff0x/TX9Of1B/UX9Vf1R/WH9ff2B/aH9pf2d/eH+Cf4Z/g3+If4d/jH+Uf55/nX+af6N/r3+yf7l/rn+2f7iLcX/Ff8Z/yn/Vf9R/4X/mf+l/83/5mNyABoAEgAuAEoAYgBmAHIAh" +
+		"gCiAP4A7gEqARoBSgFiAWoBfgGKAaIBzgHKAcIB2gHmAfYB/gISAhoCFgJuAk4CagK1RkICsgNuA5YDZgN2AxIDagNaBCYDvgPGBG4EpgSOBL4FL////////louBRoE+gVOBUYD8gXGBboFlgWaBdIGDgYiBioGAgYKBoIGVgaSBo4FfgZOBqYGwgbWBvoG4gb2BwIHC" +
+		"gbqByYHNgdGB2YHYgciB2oHfgeCB54H6gfuB/oIBggKCBYIHggqCDYIQghaCKYIrgjiCM4JAglmCWIJdglqCX4Jk//+CYoJogmqCa4IugnGCd4J4gn6CjYKSgquCn4K7gqyC4YLjgt+C0oL0gvOC+oOTgwOC+4L5gt6DBoLcgwmC2YM1gzSDFoMygzGDQIM5g1CDRYMv" +
+		"gyuDF4MYg4WDmoOqg5+DooOWgyODjoOHg4qDfIO1g3ODdYOgg4mDqIP0hBOD64POg/2EA4PYhAuDwYP3hAeD4IPyhA2EIoQgg72EOIUGg/uEbYQqhDyFWoSEhHeEa4SthG6EgoRphEaELIRvhHmENYTKhGKEuYS/hJ+E2YTNhLuE2oTQhMGExoTWhKGFIYT/hPSFF4UY" +
+		"hSyFH4UVhRSE/IVAhWOFWIVI////////hUGGAoVLhVWFgIWkhYiFkYWKhaiFbYWUhZuF6oWHhZyFd4V+hZCFyYW6hc+FuYXQhdWF3YXlhdyF+YYKhhOGC4X+hfqGBoYihhqGMIY/hk1OVYZUhl+GZ4ZxhpOGo4aphqqGi4aMhraGr4bEhsaGsIbJiCOGq4bUht6G6Ybs" +
+		"//+G34bbhu+HEocGhwiHAIcDhvuHEYcJhw2G+YcKhzSHP4c3hzuHJYcphxqHYIdfh3iHTIdOh3SHV4doh26HWYdTh2OHaogFh6KHn4eCh6+Hy4e9h8CH0JbWh6uHxIezh8eHxoe7h++H8ofgiA+IDYf+h/aH94gOh9KIEYgWiBWIIoghiDGINog5iCeIO4hEiEKIUohZ" +
+		"iF6IYohriIGIfoieiHWIfYi1iHKIgoiXiJKIroiZiKKIjYikiLCIv4ixiMOIxIjUiNiI2YjdiPmJAoj8iPSI6IjyiQSJDIkKiROJQ4keiSWJKokriUGJRIk7iTaJOIlMiR2JYIle////////iWaJZIltiWqJb4l0iXeJfomDiYiJiomTiZiJoYmpiaaJrImvibKJuom9" +
+		"ib+JwInaidyJ3YnnifSJ+IoDihaKEIoMihuKHYolijaKQYpbilKKRopIinyKbYpsimKKhYqCioSKqIqhipGKpYqmipqKo4rEis2KworaiuuK84rn//+K5IrxixSK4IriiveK3orbiwyLB4saiuGLFosQixeLIIszl6uLJosriz6LKItBi0yLT4tOi0mLVotbi1qLa4tf" +
+		"i2yLb4t0i32LgIuMi46LkouTi5aLmYuajDqMQYw/jEiMTIxOjFCMVYxijGyMeIx6jIKMiYyFjIqMjYyOjJSMfIyYYh2MrYyqjL2MsoyzjK6MtozIjMGM5IzjjNqM/Yz6jPuNBI0FjQqNB40PjQ2NEJ9OjROMzY0UjRaNZ41tjXGNc42BjZmNwo2+jbqNz43ajdaNzI3b" +
+		"jcuN6o3rjd+N4438jgiOCY3/jh2OHo4Qjh+OQo41jjCONI5K////////jkeOSY5MjlCOSI5ZjmSOYI4qjmOOVY52jnKOfI6BjoeOhY6EjouOio6TjpGOlI6ZjqqOoY6sjrCOxo6xjr6OxY7IjsuO247jjvyO+47rjv6PCo8FjxWPEo8ZjxOPHI8fjxuPDI8mjzOPO485" +
+		"j0WPQo8+j0yPSY9Gj06PV49c//+PYo9jj2SPnI+fj6OPrY+vj7eP2o/lj+KP6o/vkIeP9JAFj/mP+pARkBWQIZANkB6QFpALkCeQNpA1kDmP+JBPkFCQUZBSkA6QSZA+kFaQWJBekGiQb5B2lqiQcpCCkH2QgZCAkIqQiZCPkKiQr5CxkLWQ4pDkYkiQ25ECkRKRGZEy" +
+		"kTCRSpFWkViRY5FlkWmRc5FykYuRiZGCkaKRq5GvkaqRtZG0kbqRwJHBkcmRy5HQkdaR35HhkduR/JH1kfaSHpH/khSSLJIVkhGSXpJXkkWSSZJkkkiSlZI/kkuSUJKckpaSk5KbklqSz5K5kreS6ZMPkvqTRJMu////////kxmTIpMakyOTOpM1kzuTXJNgk3yTbpNW" +
+		"k7CTrJOtk5STuZPWk9eT6JPlk9iTw5Pdk9CTyJPklBqUFJQTlAOUB5QQlDaUK5Q1lCGUOpRBlFKURJRblGCUYpRelGqSKZRwlHWUd5R9lFqUfJR+lIGUf5WClYeVipWUlZaVmJWZ//+VoJWolaeVrZW8lbuVuZW+lcpv9pXDlc2VzJXVldSV1pXcleGV5ZXiliGWKJYu" +
+		"li+WQpZMlk+WS5Z3llyWXpZdll+WZpZylmyWjZaYlpWWl5aqlqeWsZaylrCWtJa2lriWuZbOlsuWyZbNiU2W3JcNltWW+ZcElwaXCJcTlw6XEZcPlxaXGZcklyqXMJc5lz2XPpdEl0aXSJdCl0mXXJdgl2SXZpdoUtKXa5dxl3mXhZd8l4GXepeGl4uXj5eQl5yXqJem" +
+		"l6OXs5e0l8OXxpfIl8uX3Jftn0+X8nrfl/aX9ZgPmAyYOJgkmCGYN5g9mEaYT5hLmGuYb5hw////////mHGYdJhzmKqYr5ixmLaYxJjDmMaY6ZjrmQOZCZkSmRSZGJkhmR2ZHpkkmSCZLJkumT2ZPplCmUmZRZlQmUuZUZlSmUyZVZmXmZiZpZmtma6ZvJnfmduZ3ZnY" +
+		"mdGZ7ZnumfGZ8pn7mfiaAZoPmgWZ4poZmiuaN5pFmkKaQJpD//+aPppVmk2aW5pXml+aYpplmmSaaZprmmqarZqwmryawJrPmtGa05rUmt6a35rimuOa5prvmuua7pr0mvGa95r7mwabGJsamx+bIpsjmyWbJ5somymbKpsumy+bMptEm0ObT5tNm06bUZtYm3Sbk5uD" +
+		"m5GblpuXm5+boJuom7SbwJvKm7mbxpvPm9Gb0pvjm+Kb5JvUm+GcOpvym/Gb8JwVnBScCZwTnAycBpwInBKcCpwEnC6cG5wlnCScIZwwnEecMpxGnD6cWpxgnGecdpx4nOec7JzwnQmdCJzrnQOdBp0qnSadr50jnR+dRJ0VnRKdQZ0/nT6dRp1I////////nV2dXp1k" +
+		"nVGdUJ1ZnXKdiZ2Hnaudb516nZqdpJ2pnbKdxJ3BnbuduJ26ncadz53Cndmd0534nead7Z3vnf2eGp4bnh6edZ55nn2egZ6InouejJ6SnpWekZ6dnqWeqZ64nqqerZdhnsyezp7PntCe1J7cnt6e3Z7gnuWe6J7v//+e9J72nvee+Z77nvye/Z8Hnwh2t58VnyGfLJ8+" +
+		"n0qfUp9Un2OfX59gn2GfZp9nn2yfap93n3Kfdp+Vn5yfoFgvaceQWXRkUdxxmf//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////" +
+		"////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////" +
+		"////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////" +
+		"/////////////////////////////////////////////w==";
+	
+	
+	private static short[] UNICODE_TO_QR_KANJI = new short[1 << 16];
+	
+	static {  // Unpack the Shift JIS table into a more computation-friendly form
+		Arrays.fill(UNICODE_TO_QR_KANJI, (short)-1);
+		byte[] bytes = Base64.getDecoder().decode(PACKED_QR_KANJI_TO_UNICODE);
+		for (int i = 0; i < bytes.length; i += 2) {
+			char c = (char)(((bytes[i] & 0xFF) << 8) | (bytes[i + 1] & 0xFF));
+			if (c == 0xFFFF)
+				continue;
+			assert UNICODE_TO_QR_KANJI[c] == -1;
+			UNICODE_TO_QR_KANJI[c] = (short)(i / 2);
+		}
+	}
+	
+	
+	
+	/*---- Miscellaneous ----*/
+	
+	private QrSegmentAdvanced() {}  // Not instantiable
+	
+}
diff --git a/Telegram/ThirdParty/QR/java/src/main/java/io/nayuki/qrcodegen/package-info.java b/Telegram/ThirdParty/QR/java/src/main/java/io/nayuki/qrcodegen/package-info.java
new file mode 100644
index 0000000..124b438
--- /dev/null
+++ b/Telegram/ThirdParty/QR/java/src/main/java/io/nayuki/qrcodegen/package-info.java
@@ -0,0 +1,52 @@
+/**
+ * Generates QR Codes from text strings and byte arrays.
+ * 
+ * <p>This project aims to be the best, clearest QR Code generator library. The primary goals are flexible options and absolute correctness. Secondary goals are compact implementation size and good documentation comments.</p>
+ * <p>Home page with live JavaScript demo, extensive descriptions, and competitor comparisons: <a href="https://www.nayuki.io/page/qr-code-generator-library">https://www.nayuki.io/page/qr-code-generator-library</a></p>
+ * 
+ * <h2>Features</h2>
+ * <p>Core features:</p>
+ * <ul>
+ *   <li><p>Available in 6 programming languages, all with nearly equal functionality: Java, TypeScript/JavaScript, Python, Rust, C++, C</p></li>
+ *   <li><p>Significantly shorter code but more documentation comments compared to competing libraries</p></li>
+ *   <li><p>Supports encoding all 40 versions (sizes) and all 4 error correction levels, as per the QR Code Model 2 standard</p></li>
+ *   <li><p>Output formats: Raw modules/pixels of the QR symbol, SVG XML string, {@code BufferedImage} raster bitmap</p></li>
+ *   <li><p>Encodes numeric and special-alphanumeric text in less space than general text</p></li>
+ *   <li><p>Open source code under the permissive MIT License</p></li>
+ * </ul>
+ * <p>Manual parameters:</p>
+ * <ul>
+ *   <li><p>User can specify minimum and maximum version numbers allowed, then library will automatically choose smallest version in the range that fits the data</p></li>
+ *   <li><p>User can specify mask pattern manually, otherwise library will automatically evaluate all 8 masks and select the optimal one</p></li>
+ *   <li><p>User can specify absolute error correction level, or allow the library to boost it if it doesn't increase the version number</p></li>
+ *   <li><p>User can create a list of data segments manually and add ECI segments</p></li>
+ * </ul>
+ * <p>Optional advanced features:</p>
+ * <ul>
+ *   <li><p>Encodes Japanese Unicode text in kanji mode to save a lot of space compared to UTF-8 bytes</p></li>
+ *   <li><p>Computes optimal segment mode switching for text with mixed numeric/alphanumeric/general/kanji parts</p></li>
+ * </ul>
+ * 
+ * <h2>Examples</h2>
+ * <p>Simple operation:</p>
+ * <pre style="margin-left:2em">import java.awt.image.BufferedImage;
+ *import java.io.File;
+ *import javax.imageio.ImageIO;
+ *import io.nayuki.qrcodegen.*;
+ *
+ *QrCode qr = QrCode.encodeText("Hello, world!", QrCode.Ecc.MEDIUM);
+ *BufferedImage img = qr.toImage(4, 10);
+ *ImageIO.write(img, "png", new File("qr-code.png"));</pre>
+ * <p>Manual operation:</p>
+ * <pre style="margin-left:2em">import java.util.List;
+ *import io.nayuki.qrcodegen.*;
+ *
+ *List&lt;QrSegment&gt; segs = QrSegment.makeSegments("3141592653589793238462643383");
+ *QrCode qr = QrCode.encodeSegments(segs, QrCode.Ecc.HIGH, 5, 5, 2, false);
+ *for (int y = 0; y &lt; qr.size; y++) {
+ *    for (int x = 0; x &lt; qr.size; x++) {
+ *        (... paint qr.getModule(x, y) ...)
+ *    }
+ *}</pre>
+ */
+package io.nayuki.qrcodegen;
diff --git a/Telegram/ThirdParty/QR/python/qrcodegen-batch-test.py b/Telegram/ThirdParty/QR/python/qrcodegen-batch-test.py
new file mode 100644
index 0000000..f0d3663
--- /dev/null
+++ b/Telegram/ThirdParty/QR/python/qrcodegen-batch-test.py
@@ -0,0 +1,137 @@
+# 
+# QR Code generator batch test (Python 3)
+# 
+# Runs various versions of the QR Code generator test worker as subprocesses,
+# feeds each one the same random input, and compares their output for equality.
+# 
+# Copyright (c) Project Nayuki. (MIT License)
+# https://www.nayuki.io/page/qr-code-generator-library
+# 
+# Permission is hereby granted, free of charge, to any person obtaining a copy of
+# this software and associated documentation files (the "Software"), to deal in
+# the Software without restriction, including without limitation the rights to
+# use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+# the Software, and to permit persons to whom the Software is furnished to do so,
+# subject to the following conditions:
+# - The above copyright notice and this permission notice shall be included in
+#   all copies or substantial portions of the Software.
+# - The Software is provided "as is", without warranty of any kind, express or
+#   implied, including but not limited to the warranties of merchantability,
+#   fitness for a particular purpose and noninfringement. In no event shall the
+#   authors or copyright holders be liable for any claim, damages or other
+#   liability, whether in an action of contract, tort or otherwise, arising from,
+#   out of or in connection with the Software or the use or other dealings in the
+#   Software.
+# 
+
+import itertools, random, subprocess, sys, time
+if sys.version_info.major < 3:
+	raise RuntimeError("Requires Python 3+")
+
+
+CHILD_PROGRAMS = [
+	["python2", "-B", "../python/qrcodegen-worker.py"],  # Python 2 program
+	["python3", "-B", "../python/qrcodegen-worker.py"],  # Python 3 program
+	["java", "-cp", "../java/src/main/java", "-ea:io.nayuki.qrcodegen...", "io/nayuki/qrcodegen/QrCodeGeneratorWorker"],  # Java program
+	["node", "../typescript/qrcodegen-worker.js"],  # TypeScript program
+	["../c/qrcodegen-worker"],  # C program
+	["../cpp/QrCodeGeneratorWorker"],  # C++ program
+	["../rust/target/debug/examples/qrcodegen-worker"],  # Rust program
+]
+
+
+subprocs = []
+
+def main():
+	# Launch workers
+	global subprocs
+	try:
+		for args in CHILD_PROGRAMS:
+			subprocs.append(subprocess.Popen(args, universal_newlines=True,
+				stdin=subprocess.PIPE, stdout=subprocess.PIPE))
+	except FileNotFoundError:
+		write_all(-1)
+		raise
+	
+	# Check if any died
+	time.sleep(0.3)
+	if any(proc.poll() is not None for proc in subprocs):
+		for proc in subprocs:
+			if proc.poll() is None:
+				print(-1, file=proc.stdin)
+				proc.stdin.flush()
+		sys.exit("Error: One or more workers failed to start")
+	
+	# Do tests
+	for i in itertools.count():
+		print("Trial {}: ".format(i), end="")
+		do_trial()
+		print()
+
+
+def do_trial():
+	mode = random.randrange(4)
+	if mode == 0:  # Numeric
+		length = round((2 * 7089) ** random.random())
+		data = [random.randrange(48, 58) for _ in range(length)]
+	elif mode == 1:  # Alphanumeric
+		length = round((2 * 4296) ** random.random())
+		data = [ord(random.choice("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:")) for _ in range(length)]
+	elif mode == 2:  # ASCII
+		length = round((2 * 2953) ** random.random())
+		data = [random.randrange(128) for _ in range(length)]
+	elif mode == 3:  # Byte
+		length = round((2 * 2953) ** random.random())
+		data = [random.randrange(256) for _ in range(length)]
+	else:
+		raise AssertionError()
+	
+	write_all(length)
+	for b in data:
+		write_all(b)
+	
+	errcorlvl = random.randrange(4)
+	minversion = random.randint(1, 40)
+	maxversion = random.randint(1, 40)
+	if minversion > maxversion:
+		minversion, maxversion = maxversion, minversion
+	mask = -1
+	if random.random() < 0.5:
+		mask = random.randrange(8)
+	boostecl = int(random.random() < 0.2)
+	print("mode={} len={} ecl={} minv={} maxv={} mask={} boost={}".format(mode, length, errcorlvl, minversion, maxversion, mask, boostecl), end="")
+	
+	write_all(errcorlvl)
+	write_all(minversion)
+	write_all(maxversion)
+	write_all(mask)
+	write_all(boostecl)
+	flush_all()
+	
+	version = read_verify()
+	print(" version={}".format(version), end="")
+	if version == -1:
+		return
+	size = version * 4 + 17
+	for _ in range(size**2):
+		read_verify()
+
+
+def write_all(val):
+	for proc in subprocs:
+		print(val, file=proc.stdin)
+
+def flush_all():
+	for proc in subprocs:
+		proc.stdin.flush()
+
+def read_verify():
+	val = subprocs[0].stdout.readline().rstrip("\r\n")
+	for proc in subprocs[1 : ]:
+		if proc.stdout.readline().rstrip("\r\n") != val:
+			raise ValueError("Mismatch")
+	return int(val)
+
+
+if __name__ == "__main__":
+	main()
diff --git a/Telegram/ThirdParty/QR/python/qrcodegen-demo.py b/Telegram/ThirdParty/QR/python/qrcodegen-demo.py
new file mode 100644
index 0000000..e809a6f
--- /dev/null
+++ b/Telegram/ThirdParty/QR/python/qrcodegen-demo.py
@@ -0,0 +1,186 @@
+# 
+# QR Code generator demo (Python 2, 3)
+# 
+# Run this command-line program with no arguments. The program computes a bunch of demonstration
+# QR Codes and prints them to the console. Also, the SVG code for one QR Code is printed as a sample.
+# 
+# Copyright (c) Project Nayuki. (MIT License)
+# https://www.nayuki.io/page/qr-code-generator-library
+# 
+# Permission is hereby granted, free of charge, to any person obtaining a copy of
+# this software and associated documentation files (the "Software"), to deal in
+# the Software without restriction, including without limitation the rights to
+# use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+# the Software, and to permit persons to whom the Software is furnished to do so,
+# subject to the following conditions:
+# - The above copyright notice and this permission notice shall be included in
+#   all copies or substantial portions of the Software.
+# - The Software is provided "as is", without warranty of any kind, express or
+#   implied, including but not limited to the warranties of merchantability,
+#   fitness for a particular purpose and noninfringement. In no event shall the
+#   authors or copyright holders be liable for any claim, damages or other
+#   liability, whether in an action of contract, tort or otherwise, arising from,
+#   out of or in connection with the Software or the use or other dealings in the
+#   Software.
+# 
+
+from __future__ import print_function
+from qrcodegen import QrCode, QrSegment
+
+
+def main():
+	"""The main application program."""
+	do_basic_demo()
+	do_variety_demo()
+	do_segment_demo()
+	do_mask_demo()
+
+
+
+# ---- Demo suite ----
+
+def do_basic_demo():
+	"""Creates a single QR Code, then prints it to the console."""
+	text = u"Hello, world!"     # User-supplied Unicode text
+	errcorlvl = QrCode.Ecc.LOW  # Error correction level
+	
+	# Make and print the QR Code symbol
+	qr = QrCode.encode_text(text, errcorlvl)
+	print_qr(qr)
+	print(qr.to_svg_str(4))
+
+
+def do_variety_demo():
+	"""Creates a variety of QR Codes that exercise different features of the library, and prints each one to the console."""
+	
+	# Numeric mode encoding (3.33 bits per digit)
+	qr = QrCode.encode_text("314159265358979323846264338327950288419716939937510", QrCode.Ecc.MEDIUM)
+	print_qr(qr)
+	
+	# Alphanumeric mode encoding (5.5 bits per character)
+	qr = QrCode.encode_text("DOLLAR-AMOUNT:$39.87 PERCENTAGE:100.00% OPERATIONS:+-*/", QrCode.Ecc.HIGH)
+	print_qr(qr)
+	
+	# Unicode text as UTF-8
+	qr = QrCode.encode_text(u"\u3053\u3093\u306B\u3061\u0077\u0061\u3001\u4E16\u754C\uFF01\u0020\u03B1\u03B2\u03B3\u03B4", QrCode.Ecc.QUARTILE)
+	print_qr(qr)
+	
+	# Moderately large QR Code using longer text (from Lewis Carroll's Alice in Wonderland)
+	qr = QrCode.encode_text(
+		"Alice was beginning to get very tired of sitting by her sister on the bank, "
+		"and of having nothing to do: once or twice she had peeped into the book her sister was reading, "
+		"but it had no pictures or conversations in it, 'and what is the use of a book,' thought Alice "
+		"'without pictures or conversations?' So she was considering in her own mind (as well as she could, "
+		"for the hot day made her feel very sleepy and stupid), whether the pleasure of making a "
+		"daisy-chain would be worth the trouble of getting up and picking the daisies, when suddenly "
+		"a White Rabbit with pink eyes ran close by her.", QrCode.Ecc.HIGH)
+	print_qr(qr)
+
+
+def do_segment_demo():
+	"""Creates QR Codes with manually specified segments for better compactness."""
+	
+	# Illustration "silver"
+	silver0 = "THE SQUARE ROOT OF 2 IS 1."
+	silver1 = "41421356237309504880168872420969807856967187537694807317667973799"
+	qr = QrCode.encode_text(silver0 + silver1, QrCode.Ecc.LOW)
+	print_qr(qr)
+	
+	segs = [
+		QrSegment.make_alphanumeric(silver0),
+		QrSegment.make_numeric(silver1)]
+	qr = QrCode.encode_segments(segs, QrCode.Ecc.LOW)
+	print_qr(qr)
+	
+	# Illustration "golden"
+	golden0 = u"Golden ratio \u03C6 = 1."
+	golden1 = u"6180339887498948482045868343656381177203091798057628621354486227052604628189024497072072041893911374"
+	golden2 = u"......"
+	qr = QrCode.encode_text(golden0 + golden1 + golden2, QrCode.Ecc.LOW)
+	print_qr(qr)
+	
+	segs = [
+		QrSegment.make_bytes(golden0.encode("UTF-8")),
+		QrSegment.make_numeric(golden1),
+		QrSegment.make_alphanumeric(golden2)]
+	qr = QrCode.encode_segments(segs, QrCode.Ecc.LOW)
+	print_qr(qr)
+	
+	# Illustration "Madoka": kanji, kana, Cyrillic, full-width Latin, Greek characters
+	madoka = u"\u300C\u9B54\u6CD5\u5C11\u5973\u307E\u3069\u304B\u2606\u30DE\u30AE\u30AB\u300D\u3063\u3066\u3001\u3000\u0418\u0410\u0418\u3000\uFF44\uFF45\uFF53\uFF55\u3000\u03BA\u03B1\uFF1F"
+	qr = QrCode.encode_text(madoka, QrCode.Ecc.LOW)
+	print_qr(qr)
+	
+	kanjicharbits = [  # Kanji mode encoding (13 bits per character)
+		0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1,
+		1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
+		0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
+		0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1,
+		0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1,
+		0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0,
+		0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1,
+		0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1,
+		0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1,
+		0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1,
+		0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1,
+		0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0,
+		0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0,
+		0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1,
+		0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0,
+		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
+		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+		0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1,
+		0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0,
+		0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1,
+		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+		0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0,
+		0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1,
+		0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1,
+		0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1,
+		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+		0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0,
+		0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+		0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
+	]
+	segs = [QrSegment(QrSegment.Mode.KANJI, len(kanjicharbits) // 13, kanjicharbits)]
+	qr = QrCode.encode_segments(segs, QrCode.Ecc.LOW)
+	print_qr(qr)
+
+
+def do_mask_demo():
+	"""Creates QR Codes with the same size and contents but different mask patterns."""
+	
+	# Project Nayuki URL
+	segs = QrSegment.make_segments("https://www.nayuki.io/")
+	print_qr(QrCode.encode_segments(segs, QrCode.Ecc.HIGH, mask=-1))  # Automatic mask
+	print_qr(QrCode.encode_segments(segs, QrCode.Ecc.HIGH, mask=3))  # Force mask 3
+	
+	# Chinese text as UTF-8
+	segs = QrSegment.make_segments(
+		u"\u7DAD\u57FA\u767E\u79D1\uFF08\u0057\u0069\u006B\u0069\u0070\u0065\u0064\u0069\u0061\uFF0C"
+		 "\u8046\u807D\u0069\u002F\u02CC\u0077\u026A\u006B\u1D7B\u02C8\u0070\u0069\u02D0\u0064\u0069"
+		 "\u002E\u0259\u002F\uFF09\u662F\u4E00\u500B\u81EA\u7531\u5167\u5BB9\u3001\u516C\u958B\u7DE8"
+		 "\u8F2F\u4E14\u591A\u8A9E\u8A00\u7684\u7DB2\u8DEF\u767E\u79D1\u5168\u66F8\u5354\u4F5C\u8A08"
+		 "\u756B")
+	print_qr(QrCode.encode_segments(segs, QrCode.Ecc.MEDIUM, mask=0))  # Force mask 0
+	print_qr(QrCode.encode_segments(segs, QrCode.Ecc.MEDIUM, mask=1))  # Force mask 1
+	print_qr(QrCode.encode_segments(segs, QrCode.Ecc.MEDIUM, mask=5))  # Force mask 5
+	print_qr(QrCode.encode_segments(segs, QrCode.Ecc.MEDIUM, mask=7))  # Force mask 7
+
+
+
+# ---- Utilities ----
+
+def print_qr(qrcode):
+	"""Prints the given QrCode object to the console."""
+	border = 4
+	for y in range(-border, qrcode.get_size() + border):
+		for x in range(-border, qrcode.get_size() + border):
+			print(u"\u2588 "[1 if qrcode.get_module(x,y) else 0] * 2, end="")
+		print()
+	print()
+
+
+# Run the main program
+if __name__ == "__main__":
+	main()
diff --git a/Telegram/ThirdParty/QR/python/qrcodegen-worker.py b/Telegram/ThirdParty/QR/python/qrcodegen-worker.py
new file mode 100644
index 0000000..b159bb6
--- /dev/null
+++ b/Telegram/ThirdParty/QR/python/qrcodegen-worker.py
@@ -0,0 +1,82 @@
+# 
+# QR Code generator test worker (Python 2, 3)
+# 
+# This program reads data and encoding parameters from standard input and writes
+# QR Code bitmaps to standard output. The I/O format is one integer per line.
+# Run with no command line arguments. The program is intended for automated
+# batch testing of end-to-end functionality of this QR Code generator library.
+# 
+# Copyright (c) Project Nayuki. (MIT License)
+# https://www.nayuki.io/page/qr-code-generator-library
+# 
+# Permission is hereby granted, free of charge, to any person obtaining a copy of
+# this software and associated documentation files (the "Software"), to deal in
+# the Software without restriction, including without limitation the rights to
+# use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+# the Software, and to permit persons to whom the Software is furnished to do so,
+# subject to the following conditions:
+# - The above copyright notice and this permission notice shall be included in
+#   all copies or substantial portions of the Software.
+# - The Software is provided "as is", without warranty of any kind, express or
+#   implied, including but not limited to the warranties of merchantability,
+#   fitness for a particular purpose and noninfringement. In no event shall the
+#   authors or copyright holders be liable for any claim, damages or other
+#   liability, whether in an action of contract, tort or otherwise, arising from,
+#   out of or in connection with the Software or the use or other dealings in the
+#   Software.
+# 
+
+import sys
+import qrcodegen
+py3 = sys.version_info.major >= 3
+
+
+def read_int():
+	return int((input if py3 else raw_input)())
+
+
+def main():
+	while True:
+		
+		# Read data or exit
+		length = read_int()
+		if length == -1:
+			break
+		data = bytearray(read_int() for _ in range(length))
+		
+		# Read encoding parameters
+		errcorlvl  = read_int()
+		minversion = read_int()
+		maxversion = read_int()
+		mask       = read_int()
+		boostecl   = read_int()
+		
+		# Make segments for encoding
+		if all((b < 128) for b in data):  # Is ASCII
+			segs = qrcodegen.QrSegment.make_segments(data.decode("ASCII"))
+		else:
+			segs = [qrcodegen.QrSegment.make_bytes(data)]
+		
+		try:  # Try to make QR Code symbol
+			qr = qrcodegen.QrCode.encode_segments(segs, ECC_LEVELS[errcorlvl], minversion, maxversion, mask, boostecl != 0)
+			# Print grid of modules
+			print(qr.get_version())
+			for y in range(qr.get_size()):
+				for x in range(qr.get_size()):
+					print(1 if qr.get_module(x, y) else 0)
+			
+		except qrcodegen.DataTooLongError:
+			print(-1)
+		sys.stdout.flush()
+
+
+ECC_LEVELS = (
+	qrcodegen.QrCode.Ecc.LOW,
+	qrcodegen.QrCode.Ecc.MEDIUM,
+	qrcodegen.QrCode.Ecc.QUARTILE,
+	qrcodegen.QrCode.Ecc.HIGH,
+)
+
+
+if __name__ == "__main__":
+	main()
diff --git a/Telegram/ThirdParty/QR/python/qrcodegen.py b/Telegram/ThirdParty/QR/python/qrcodegen.py
new file mode 100644
index 0000000..93c0e85
--- /dev/null
+++ b/Telegram/ThirdParty/QR/python/qrcodegen.py
@@ -0,0 +1,925 @@
+# 
+# QR Code generator library (Python 2, 3)
+# 
+# Copyright (c) Project Nayuki. (MIT License)
+# https://www.nayuki.io/page/qr-code-generator-library
+# 
+# Permission is hereby granted, free of charge, to any person obtaining a copy of
+# this software and associated documentation files (the "Software"), to deal in
+# the Software without restriction, including without limitation the rights to
+# use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+# the Software, and to permit persons to whom the Software is furnished to do so,
+# subject to the following conditions:
+# - The above copyright notice and this permission notice shall be included in
+#   all copies or substantial portions of the Software.
+# - The Software is provided "as is", without warranty of any kind, express or
+#   implied, including but not limited to the warranties of merchantability,
+#   fitness for a particular purpose and noninfringement. In no event shall the
+#   authors or copyright holders be liable for any claim, damages or other
+#   liability, whether in an action of contract, tort or otherwise, arising from,
+#   out of or in connection with the Software or the use or other dealings in the
+#   Software.
+# 
+
+import collections, itertools, re, sys
+
+
+"""
+This module "qrcodegen", public members:
+- Class QrCode:
+  - Function encode_text(str text, QrCode.Ecc ecl) -> QrCode
+  - Function encode_binary(bytes data, QrCode.Ecc ecl) -> QrCode
+  - Function encode_segments(list<QrSegment> segs, QrCode.Ecc ecl,
+        int minversion=1, int maxversion=40, mask=-1, boostecl=true) -> QrCode
+  - Constants int MIN_VERSION, MAX_VERSION
+  - Constructor QrCode(int version, QrCode.Ecc ecl, bytes datacodewords, int mask)
+  - Method get_version() -> int
+  - Method get_size() -> int
+  - Method get_error_correction_level() -> QrCode.Ecc
+  - Method get_mask() -> int
+  - Method get_module(int x, int y) -> bool
+  - Method to_svg_str(int border) -> str
+  - Enum Ecc:
+    - Constants LOW, MEDIUM, QUARTILE, HIGH
+    - Field int ordinal
+- Class QrSegment:
+  - Function make_bytes(bytes data) -> QrSegment
+  - Function make_numeric(str digits) -> QrSegment
+  - Function make_alphanumeric(str text) -> QrSegment
+  - Function make_segments(str text) -> list<QrSegment>
+  - Function make_eci(int assignval) -> QrSegment
+  - Constructor QrSegment(QrSegment.Mode mode, int numch, list<int> bitdata)
+  - Method get_mode() -> QrSegment.Mode
+  - Method get_num_chars() -> int
+  - Method get_data() -> list<int>
+  - Constants regex NUMERIC_REGEX, ALPHANUMERIC_REGEX
+  - Enum Mode:
+    - Constants NUMERIC, ALPHANUMERIC, BYTE, KANJI, ECI
+"""
+
+
+# ---- QR Code symbol class ----
+
+class QrCode(object):
+	"""A QR Code symbol, which is a type of two-dimension barcode.
+	Invented by Denso Wave and described in the ISO/IEC 18004 standard.
+	Instances of this class represent an immutable square grid of black and white cells.
+	The class provides static factory functions to create a QR Code from text or binary data.
+	The class covers the QR Code Model 2 specification, supporting all versions (sizes)
+	from 1 to 40, all 4 error correction levels, and 4 character encoding modes.
+	
+	Ways to create a QR Code object:
+	- High level: Take the payload data and call QrCode.encode_text() or QrCode.encode_binary().
+	- Mid level: Custom-make the list of segments and call QrCode.encode_segments().
+	- Low level: Custom-make the array of data codeword bytes (including
+	  segment headers and final padding, excluding error correction codewords),
+	  supply the appropriate version number, and call the QrCode() constructor.
+	(Note that all ways require supplying the desired error correction level.)"""
+	
+	# ---- Static factory functions (high level) ----
+	
+	@staticmethod
+	def encode_text(text, ecl):
+		"""Returns a QR Code representing the given Unicode text string at the given error correction level.
+		As a conservative upper bound, this function is guaranteed to succeed for strings that have 738 or fewer
+		Unicode code points (not UTF-16 code units) if the low error correction level is used. The smallest possible
+		QR Code version is automatically chosen for the output. The ECC level of the result may be higher than the
+		ecl argument if it can be done without increasing the version."""
+		segs = QrSegment.make_segments(text)
+		return QrCode.encode_segments(segs, ecl)
+	
+	
+	@staticmethod
+	def encode_binary(data, ecl):
+		"""Returns a QR Code representing the given binary data at the given error correction level.
+		This function always encodes using the binary segment mode, not any text mode. The maximum number of
+		bytes allowed is 2953. The smallest possible QR Code version is automatically chosen for the output.
+		The ECC level of the result may be higher than the ecl argument if it can be done without increasing the version."""
+		if not isinstance(data, (bytes, bytearray)):
+			raise TypeError("Byte string/list expected")
+		return QrCode.encode_segments([QrSegment.make_bytes(data)], ecl)
+	
+	
+	# ---- Static factory functions (mid level) ----
+	
+	@staticmethod
+	def encode_segments(segs, ecl, minversion=1, maxversion=40, mask=-1, boostecl=True):
+		"""Returns a QR Code representing the given segments with the given encoding parameters.
+		The smallest possible QR Code version within the given range is automatically
+		chosen for the output. Iff boostecl is true, then the ECC level of the result
+		may be higher than the ecl argument if it can be done without increasing the
+		version. The mask number is either between 0 to 7 (inclusive) to force that
+		mask, or -1 to automatically choose an appropriate mask (which may be slow).
+		This function allows the user to create a custom sequence of segments that switches
+		between modes (such as alphanumeric and byte) to encode text in less space.
+		This is a mid-level API; the high-level API is encode_text() and encode_binary()."""
+		
+		if not (QrCode.MIN_VERSION <= minversion <= maxversion <= QrCode.MAX_VERSION) or not (-1 <= mask <= 7):
+			raise ValueError("Invalid value")
+		
+		# Find the minimal version number to use
+		for version in range(minversion, maxversion + 1):
+			datacapacitybits = QrCode._get_num_data_codewords(version, ecl) * 8  # Number of data bits available
+			datausedbits = QrSegment.get_total_bits(segs, version)
+			if datausedbits is not None and datausedbits <= datacapacitybits:
+				break  # This version number is found to be suitable
+			if version >= maxversion:  # All versions in the range could not fit the given data
+				msg = "Segment too long"
+				if datausedbits is not None:
+					msg = "Data length = {} bits, Max capacity = {} bits".format(datausedbits, datacapacitybits)
+				raise DataTooLongError(msg)
+		if datausedbits is None:
+			raise AssertionError()
+		
+		# Increase the error correction level while the data still fits in the current version number
+		for newecl in (QrCode.Ecc.MEDIUM, QrCode.Ecc.QUARTILE, QrCode.Ecc.HIGH):  # From low to high
+			if boostecl and datausedbits <= QrCode._get_num_data_codewords(version, newecl) * 8:
+				ecl = newecl
+		
+		# Concatenate all segments to create the data bit string
+		bb = _BitBuffer()
+		for seg in segs:
+			bb.append_bits(seg.get_mode().get_mode_bits(), 4)
+			bb.append_bits(seg.get_num_chars(), seg.get_mode().num_char_count_bits(version))
+			bb.extend(seg._bitdata)
+		assert len(bb) == datausedbits
+		
+		# Add terminator and pad up to a byte if applicable
+		datacapacitybits = QrCode._get_num_data_codewords(version, ecl) * 8
+		assert len(bb) <= datacapacitybits
+		bb.append_bits(0, min(4, datacapacitybits - len(bb)))
+		bb.append_bits(0, -len(bb) % 8)  # Note: Python's modulo on negative numbers behaves better than C family languages
+		assert len(bb) % 8 == 0
+		
+		# Pad with alternating bytes until data capacity is reached
+		for padbyte in itertools.cycle((0xEC, 0x11)):
+			if len(bb) >= datacapacitybits:
+				break
+			bb.append_bits(padbyte, 8)
+		
+		# Pack bits into bytes in big endian
+		datacodewords = [0] * (len(bb) // 8)
+		for (i, bit) in enumerate(bb):
+			datacodewords[i >> 3] |= bit << (7 - (i & 7))
+		
+		# Create the QR Code object
+		return QrCode(version, ecl, datacodewords, mask)
+	
+	
+	# ---- Constructor (low level) ----
+	
+	def __init__(self, version, errcorlvl, datacodewords, mask):
+		"""Creates a new QR Code with the given version number,
+		error correction level, data codeword bytes, and mask number.
+		This is a low-level API that most users should not use directly.
+		A mid-level API is the encode_segments() function."""
+		
+		# Check scalar arguments and set fields
+		if not (QrCode.MIN_VERSION <= version <= QrCode.MAX_VERSION):
+			raise ValueError("Version value out of range")
+		if not (-1 <= mask <= 7):
+			raise ValueError("Mask value out of range")
+		if not isinstance(errcorlvl, QrCode.Ecc):
+			raise TypeError("QrCode.Ecc expected")
+		
+		# The version number of this QR Code, which is between 1 and 40 (inclusive).
+		# This determines the size of this barcode.
+		self._version = version
+		
+		# The width and height of this QR Code, measured in modules, between
+		# 21 and 177 (inclusive). This is equal to version * 4 + 17.
+		self._size = version * 4 + 17
+		
+		# The error correction level used in this QR Code.
+		self._errcorlvl = errcorlvl
+		
+		# Initialize both grids to be size*size arrays of Boolean false
+		# The modules of this QR Code (False = white, True = black).
+		# Immutable after constructor finishes. Accessed through get_module().
+		self._modules    = [[False] * self._size for _ in range(self._size)]  # Initially all white
+		# Indicates function modules that are not subjected to masking. Discarded when constructor finishes
+		self._isfunction = [[False] * self._size for _ in range(self._size)]
+		
+		# Compute ECC, draw modules
+		self._draw_function_patterns()
+		allcodewords = self._add_ecc_and_interleave(datacodewords)
+		self._draw_codewords(allcodewords)
+		
+		# Do masking
+		if mask == -1:  # Automatically choose best mask
+			minpenalty = 1 << 32
+			for i in range(8):
+				self._apply_mask(i)
+				self._draw_format_bits(i)
+				penalty = self._get_penalty_score()
+				if penalty < minpenalty:
+					mask = i
+					minpenalty = penalty
+				self._apply_mask(i)  # Undoes the mask due to XOR
+		assert 0 <= mask <= 7
+		self._apply_mask(mask)  # Apply the final choice of mask
+		self._draw_format_bits(mask)  # Overwrite old format bits
+		
+		# The index of the mask pattern used in this QR Code, which is between 0 and 7 (inclusive).
+		# Even if a QR Code is created with automatic masking requested (mask = -1),
+		# the resulting object still has a mask value between 0 and 7.
+		self._mask = mask
+		
+		del self._isfunction
+	
+	
+	# ---- Accessor methods ----
+	
+	def get_version(self):
+		"""Returns this QR Code's version number, in the range [1, 40]."""
+		return self._version
+	
+	def get_size(self):
+		"""Returns this QR Code's size, in the range [21, 177]."""
+		return self._size
+	
+	def get_error_correction_level(self):
+		"""Returns this QR Code's error correction level."""
+		return self._errcorlvl
+	
+	def get_mask(self):
+		"""Returns this QR Code's mask, in the range [0, 7]."""
+		return self._mask
+	
+	def get_module(self, x, y):
+		"""Returns the color of the module (pixel) at the given coordinates, which is False
+		for white or True for black. The top left corner has the coordinates (x=0, y=0).
+		If the given coordinates are out of bounds, then False (white) is returned."""
+		return (0 <= x < self._size) and (0 <= y < self._size) and self._modules[y][x]
+	
+	
+	# ---- Public instance methods ----
+	
+	def to_svg_str(self, border):
+		"""Returns a string of SVG code for an image depicting this QR Code, with the given number
+		of border modules. The string always uses Unix newlines (\n), regardless of the platform."""
+		if border < 0:
+			raise ValueError("Border must be non-negative")
+		parts = []
+		for y in range(self._size):
+			for x in range(self._size):
+				if self.get_module(x, y):
+					parts.append("M{},{}h1v1h-1z".format(x + border, y + border))
+		return """<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
+<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 {0} {0}" stroke="none">
+	<rect width="100%" height="100%" fill="#FFFFFF"/>
+	<path d="{1}" fill="#000000"/>
+</svg>
+""".format(self._size + border * 2, " ".join(parts))
+	
+	
+	# ---- Private helper methods for constructor: Drawing function modules ----
+	
+	def _draw_function_patterns(self):
+		"""Reads this object's version field, and draws and marks all function modules."""
+		# Draw horizontal and vertical timing patterns
+		for i in range(self._size):
+			self._set_function_module(6, i, i % 2 == 0)
+			self._set_function_module(i, 6, i % 2 == 0)
+		
+		# Draw 3 finder patterns (all corners except bottom right; overwrites some timing modules)
+		self._draw_finder_pattern(3, 3)
+		self._draw_finder_pattern(self._size - 4, 3)
+		self._draw_finder_pattern(3, self._size - 4)
+		
+		# Draw numerous alignment patterns
+		alignpatpos = self._get_alignment_pattern_positions()
+		numalign = len(alignpatpos)
+		skips = ((0, 0), (0, numalign - 1), (numalign - 1, 0))
+		for i in range(numalign):
+			for j in range(numalign):
+				if (i, j) not in skips:  # Don't draw on the three finder corners
+					self._draw_alignment_pattern(alignpatpos[i], alignpatpos[j])
+		
+		# Draw configuration data
+		self._draw_format_bits(0)  # Dummy mask value; overwritten later in the constructor
+		self._draw_version()
+	
+	
+	def _draw_format_bits(self, mask):
+		"""Draws two copies of the format bits (with its own error correction code)
+		based on the given mask and this object's error correction level field."""
+		# Calculate error correction code and pack bits
+		data = self._errcorlvl.formatbits << 3 | mask  # errCorrLvl is uint2, mask is uint3
+		rem = data
+		for _ in range(10):
+			rem = (rem << 1) ^ ((rem >> 9) * 0x537)
+		bits = (data << 10 | rem) ^ 0x5412  # uint15
+		assert bits >> 15 == 0
+		
+		# Draw first copy
+		for i in range(0, 6):
+			self._set_function_module(8, i, _get_bit(bits, i))
+		self._set_function_module(8, 7, _get_bit(bits, 6))
+		self._set_function_module(8, 8, _get_bit(bits, 7))
+		self._set_function_module(7, 8, _get_bit(bits, 8))
+		for i in range(9, 15):
+			self._set_function_module(14 - i, 8, _get_bit(bits, i))
+		
+		# Draw second copy
+		for i in range(0, 8):
+			self._set_function_module(self._size - 1 - i, 8, _get_bit(bits, i))
+		for i in range(8, 15):
+			self._set_function_module(8, self._size - 15 + i, _get_bit(bits, i))
+		self._set_function_module(8, self._size - 8, True)  # Always black
+	
+	
+	def _draw_version(self):
+		"""Draws two copies of the version bits (with its own error correction code),
+		based on this object's version field, iff 7 <= version <= 40."""
+		if self._version < 7:
+			return
+		
+		# Calculate error correction code and pack bits
+		rem = self._version  # version is uint6, in the range [7, 40]
+		for _ in range(12):
+			rem = (rem << 1) ^ ((rem >> 11) * 0x1F25)
+		bits = self._version << 12 | rem  # uint18
+		assert bits >> 18 == 0
+		
+		# Draw two copies
+		for i in range(18):
+			bit = _get_bit(bits, i)
+			a = self._size - 11 + i % 3
+			b = i // 3
+			self._set_function_module(a, b, bit)
+			self._set_function_module(b, a, bit)
+	
+	
+	def _draw_finder_pattern(self, x, y):
+		"""Draws a 9*9 finder pattern including the border separator,
+		with the center module at (x, y). Modules can be out of bounds."""
+		for dy in range(-4, 5):
+			for dx in range(-4, 5):
+				xx, yy = x + dx, y + dy
+				if (0 <= xx < self._size) and (0 <= yy < self._size):
+					# Chebyshev/infinity norm
+					self._set_function_module(xx, yy, max(abs(dx), abs(dy)) not in (2, 4))
+	
+	
+	def _draw_alignment_pattern(self, x, y):
+		"""Draws a 5*5 alignment pattern, with the center module
+		at (x, y). All modules must be in bounds."""
+		for dy in range(-2, 3):
+			for dx in range(-2, 3):
+				self._set_function_module(x + dx, y + dy, max(abs(dx), abs(dy)) != 1)
+	
+	
+	def _set_function_module(self, x, y, isblack):
+		"""Sets the color of a module and marks it as a function module.
+		Only used by the constructor. Coordinates must be in bounds."""
+		assert type(isblack) is bool
+		self._modules[y][x] = isblack
+		self._isfunction[y][x] = True
+	
+	
+	# ---- Private helper methods for constructor: Codewords and masking ----
+	
+	def _add_ecc_and_interleave(self, data):
+		"""Returns a new byte string representing the given data with the appropriate error correction
+		codewords appended to it, based on this object's version and error correction level."""
+		version = self._version
+		assert len(data) == QrCode._get_num_data_codewords(version, self._errcorlvl)
+		
+		# Calculate parameter numbers
+		numblocks = QrCode._NUM_ERROR_CORRECTION_BLOCKS[self._errcorlvl.ordinal][version]
+		blockecclen = QrCode._ECC_CODEWORDS_PER_BLOCK  [self._errcorlvl.ordinal][version]
+		rawcodewords = QrCode._get_num_raw_data_modules(version) // 8
+		numshortblocks = numblocks - rawcodewords % numblocks
+		shortblocklen = rawcodewords // numblocks
+		
+		# Split data into blocks and append ECC to each block
+		blocks = []
+		rsdiv = QrCode._reed_solomon_compute_divisor(blockecclen)
+		k = 0
+		for i in range(numblocks):
+			dat = data[k : k + shortblocklen - blockecclen + (0 if i < numshortblocks else 1)]
+			k += len(dat)
+			ecc = QrCode._reed_solomon_compute_remainder(dat, rsdiv)
+			if i < numshortblocks:
+				dat.append(0)
+			blocks.append(dat + ecc)
+		assert k == len(data)
+		
+		# Interleave (not concatenate) the bytes from every block into a single sequence
+		result = []
+		for i in range(len(blocks[0])):
+			for (j, blk) in enumerate(blocks):
+				# Skip the padding byte in short blocks
+				if i != shortblocklen - blockecclen or j >= numshortblocks:
+					result.append(blk[i])
+		assert len(result) == rawcodewords
+		return result
+	
+	
+	def _draw_codewords(self, data):
+		"""Draws the given sequence of 8-bit codewords (data and error correction) onto the entire
+		data area of this QR Code. Function modules need to be marked off before this is called."""
+		assert len(data) == QrCode._get_num_raw_data_modules(self._version) // 8
+		
+		i = 0  # Bit index into the data
+		# Do the funny zigzag scan
+		for right in range(self._size - 1, 0, -2):  # Index of right column in each column pair
+			if right <= 6:
+				right -= 1
+			for vert in range(self._size):  # Vertical counter
+				for j in range(2):
+					x = right - j  # Actual x coordinate
+					upward = (right + 1) & 2 == 0
+					y = (self._size - 1 - vert) if upward else vert  # Actual y coordinate
+					if not self._isfunction[y][x] and i < len(data) * 8:
+						self._modules[y][x] = _get_bit(data[i >> 3], 7 - (i & 7))
+						i += 1
+					# If this QR Code has any remainder bits (0 to 7), they were assigned as
+					# 0/false/white by the constructor and are left unchanged by this method
+		assert i == len(data) * 8
+	
+	
+	def _apply_mask(self, mask):
+		"""XORs the codeword modules in this QR Code with the given mask pattern.
+		The function modules must be marked and the codeword bits must be drawn
+		before masking. Due to the arithmetic of XOR, calling applyMask() with
+		the same mask value a second time will undo the mask. A final well-formed
+		QR Code needs exactly one (not zero, two, etc.) mask applied."""
+		if not (0 <= mask <= 7):
+			raise ValueError("Mask value out of range")
+		masker = QrCode._MASK_PATTERNS[mask]
+		for y in range(self._size):
+			for x in range(self._size):
+				self._modules[y][x] ^= (masker(x, y) == 0) and (not self._isfunction[y][x])
+	
+	
+	def _get_penalty_score(self):
+		"""Calculates and returns the penalty score based on state of this QR Code's current modules.
+		This is used by the automatic mask choice algorithm to find the mask pattern that yields the lowest score."""
+		result = 0
+		size = self._size
+		modules = self._modules
+		
+		# Adjacent modules in row having same color, and finder-like patterns
+		for y in range(size):
+			runcolor = False
+			runx = 0
+			runhistory = collections.deque([0] * 7, 7)
+			padrun = size  # Add white border to initial run
+			for x in range(size):
+				if modules[y][x] == runcolor:
+					runx += 1
+					if runx == 5:
+						result += QrCode._PENALTY_N1
+					elif runx > 5:
+						result += 1
+				else:
+					runhistory.appendleft(runx + padrun)
+					padrun = 0
+					if not runcolor:
+						result += self._finder_penalty_count_patterns(runhistory) * QrCode._PENALTY_N3
+					runcolor = modules[y][x]
+					runx = 1
+			result += self._finder_penalty_terminate_and_count(runcolor, runx + padrun, runhistory) * QrCode._PENALTY_N3
+		# Adjacent modules in column having same color, and finder-like patterns
+		for x in range(size):
+			runcolor = False
+			runy = 0
+			runhistory = collections.deque([0] * 7, 7)
+			padrun = size  # Add white border to initial run
+			for y in range(size):
+				if modules[y][x] == runcolor:
+					runy += 1
+					if runy == 5:
+						result += QrCode._PENALTY_N1
+					elif runy > 5:
+						result += 1
+				else:
+					runhistory.appendleft(runy + padrun)
+					padrun = 0
+					if not runcolor:
+						result += self._finder_penalty_count_patterns(runhistory) * QrCode._PENALTY_N3
+					runcolor = modules[y][x]
+					runy = 1
+			result += self._finder_penalty_terminate_and_count(runcolor, runy + padrun, runhistory) * QrCode._PENALTY_N3
+		
+		# 2*2 blocks of modules having same color
+		for y in range(size - 1):
+			for x in range(size - 1):
+				if modules[y][x] == modules[y][x + 1] == modules[y + 1][x] == modules[y + 1][x + 1]:
+					result += QrCode._PENALTY_N2
+		
+		# Balance of black and white modules
+		black = sum((1 if cell else 0) for row in modules for cell in row)
+		total = size**2  # Note that size is odd, so black/total != 1/2
+		# Compute the smallest integer k >= 0 such that (45-5k)% <= black/total <= (55+5k)%
+		k = (abs(black * 20 - total * 10) + total - 1) // total - 1
+		result += k * QrCode._PENALTY_N4
+		return result
+	
+	
+	# ---- Private helper functions ----
+	
+	def _get_alignment_pattern_positions(self):
+		"""Returns an ascending list of positions of alignment patterns for this version number.
+		Each position is in the range [0,177), and are used on both the x and y axes.
+		This could be implemented as lookup table of 40 variable-length lists of integers."""
+		ver = self._version
+		if ver == 1:
+			return []
+		else:
+			numalign = ver // 7 + 2
+			step = 26 if (ver == 32) else \
+				(ver*4 + numalign*2 + 1) // (numalign*2 - 2) * 2
+			result = [(self._size - 7 - i * step) for i in range(numalign - 1)] + [6]
+			return list(reversed(result))
+	
+	
+	@staticmethod
+	def _get_num_raw_data_modules(ver):
+		"""Returns the number of data bits that can be stored in a QR Code of the given version number, after
+		all function modules are excluded. This includes remainder bits, so it might not be a multiple of 8.
+		The result is in the range [208, 29648]. This could be implemented as a 40-entry lookup table."""
+		if not (QrCode.MIN_VERSION <= ver <= QrCode.MAX_VERSION):
+			raise ValueError("Version number out of range")
+		result = (16 * ver + 128) * ver + 64
+		if ver >= 2:
+			numalign = ver // 7 + 2
+			result -= (25 * numalign - 10) * numalign - 55
+			if ver >= 7:
+				result -= 36
+		assert 208 <= result <= 29648
+		return result
+	
+	
+	@staticmethod
+	def _get_num_data_codewords(ver, ecl):
+		"""Returns the number of 8-bit data (i.e. not error correction) codewords contained in any
+		QR Code of the given version number and error correction level, with remainder bits discarded.
+		This stateless pure function could be implemented as a (40*4)-cell lookup table."""
+		return QrCode._get_num_raw_data_modules(ver) // 8 \
+			- QrCode._ECC_CODEWORDS_PER_BLOCK    [ecl.ordinal][ver] \
+			* QrCode._NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver]
+	
+	
+	@staticmethod
+	def _reed_solomon_compute_divisor(degree):
+		"""Returns a Reed-Solomon ECC generator polynomial for the given degree. This could be
+		implemented as a lookup table over all possible parameter values, instead of as an algorithm."""
+		if not (1 <= degree <= 255):
+			raise ValueError("Degree out of range")
+		# Polynomial coefficients are stored from highest to lowest power, excluding the leading term which is always 1.
+		# For example the polynomial x^3 + 255x^2 + 8x + 93 is stored as the uint8 array [255, 8, 93].
+		result = [0] * (degree - 1) + [1]  # Start off with the monomial x^0
+		
+		# Compute the product polynomial (x - r^0) * (x - r^1) * (x - r^2) * ... * (x - r^{degree-1}),
+		# and drop the highest monomial term which is always 1x^degree.
+		# Note that r = 0x02, which is a generator element of this field GF(2^8/0x11D).
+		root = 1
+		for _ in range(degree):  # Unused variable i
+			# Multiply the current product by (x - r^i)
+			for j in range(degree):
+				result[j] = QrCode._reed_solomon_multiply(result[j], root)
+				if j + 1 < degree:
+					result[j] ^= result[j + 1]
+			root = QrCode._reed_solomon_multiply(root, 0x02)
+		return result
+	
+	
+	@staticmethod
+	def _reed_solomon_compute_remainder(data, divisor):
+		"""Returns the Reed-Solomon error correction codeword for the given data and divisor polynomials."""
+		result = [0] * len(divisor)
+		for b in data:  # Polynomial division
+			factor = b ^ result.pop(0)
+			result.append(0)
+			for (i, coef) in enumerate(divisor):
+				result[i] ^= QrCode._reed_solomon_multiply(coef, factor)
+		return result
+	
+	
+	@staticmethod
+	def _reed_solomon_multiply(x, y):
+		"""Returns the product of the two given field elements modulo GF(2^8/0x11D). The arguments and result
+		are unsigned 8-bit integers. This could be implemented as a lookup table of 256*256 entries of uint8."""
+		if x >> 8 != 0 or y >> 8 != 0:
+			raise ValueError("Byte out of range")
+		# Russian peasant multiplication
+		z = 0
+		for i in reversed(range(8)):
+			z = (z << 1) ^ ((z >> 7) * 0x11D)
+			z ^= ((y >> i) & 1) * x
+		assert z >> 8 == 0
+		return z
+	
+	
+	def _finder_penalty_count_patterns(self, runhistory):
+		"""Can only be called immediately after a white run is added, and
+		returns either 0, 1, or 2. A helper function for _get_penalty_score()."""
+		n = runhistory[1]
+		assert n <= self._size * 3
+		core = n > 0 and (runhistory[2] == runhistory[4] == runhistory[5] == n) and runhistory[3] == n * 3
+		return (1 if (core and runhistory[0] >= n * 4 and runhistory[6] >= n) else 0) \
+		     + (1 if (core and runhistory[6] >= n * 4 and runhistory[0] >= n) else 0)
+	
+	
+	def _finder_penalty_terminate_and_count(self, currentruncolor, currentrunlength, runhistory):
+		"""Must be called at the end of a line (row or column) of modules. A helper function for _get_penalty_score()."""
+		if currentruncolor:  # Terminate black run
+			runhistory.appendleft(currentrunlength)
+			currentrunlength = 0
+		currentrunlength += self._size  # Add white border to final run
+		runhistory.appendleft(currentrunlength)
+		return self._finder_penalty_count_patterns(runhistory)
+	
+	
+	# ---- Constants and tables ----
+	
+	MIN_VERSION =  1  # The minimum version number supported in the QR Code Model 2 standard
+	MAX_VERSION = 40  # The maximum version number supported in the QR Code Model 2 standard
+	
+	# For use in getPenaltyScore(), when evaluating which mask is best.
+	_PENALTY_N1 =  3
+	_PENALTY_N2 =  3
+	_PENALTY_N3 = 40
+	_PENALTY_N4 = 10
+	
+	_ECC_CODEWORDS_PER_BLOCK = (
+		# Version: (note that index 0 is for padding, and is set to an illegal value)
+		#   0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
+		(None,  7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30),  # Low
+		(None, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28),  # Medium
+		(None, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30),  # Quartile
+		(None, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30))  # High
+	
+	_NUM_ERROR_CORRECTION_BLOCKS = (
+		# Version: (note that index 0 is for padding, and is set to an illegal value)
+		#   0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
+		(None, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4,  4,  4,  4,  4,  6,  6,  6,  6,  7,  8,  8,  9,  9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25),  # Low
+		(None, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5,  5,  8,  9,  9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49),  # Medium
+		(None, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8,  8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68),  # Quartile
+		(None, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81))  # High
+	
+	_MASK_PATTERNS = (
+		(lambda x, y:  (x + y) % 2                  ),
+		(lambda x, y:  y % 2                        ),
+		(lambda x, y:  x % 3                        ),
+		(lambda x, y:  (x + y) % 3                  ),
+		(lambda x, y:  (x // 3 + y // 2) % 2        ),
+		(lambda x, y:  x * y % 2 + x * y % 3        ),
+		(lambda x, y:  (x * y % 2 + x * y % 3) % 2  ),
+		(lambda x, y:  ((x + y) % 2 + x * y % 3) % 2),
+	)
+	
+	
+	# ---- Public helper enumeration ----
+	
+	class Ecc(object):
+		"""The error correction level in a QR Code symbol. Immutable."""
+		# Private constructor
+		def __init__(self, i, fb):
+			self.ordinal = i  # (Public) In the range 0 to 3 (unsigned 2-bit integer)
+			self.formatbits = fb  # (Package-private) In the range 0 to 3 (unsigned 2-bit integer)
+	
+	# Public constants. Create them outside the class.
+	Ecc.LOW      = Ecc(0, 1)  # The QR Code can tolerate about  7% erroneous codewords
+	Ecc.MEDIUM   = Ecc(1, 0)  # The QR Code can tolerate about 15% erroneous codewords
+	Ecc.QUARTILE = Ecc(2, 3)  # The QR Code can tolerate about 25% erroneous codewords
+	Ecc.HIGH     = Ecc(3, 2)  # The QR Code can tolerate about 30% erroneous codewords
+
+
+
+# ---- Data segment class ----
+
+class QrSegment(object):
+	"""A segment of character/binary/control data in a QR Code symbol.
+	Instances of this class are immutable.
+	The mid-level way to create a segment is to take the payload data
+	and call a static factory function such as QrSegment.make_numeric().
+	The low-level way to create a segment is to custom-make the bit buffer
+	and call the QrSegment() constructor with appropriate values.
+	This segment class imposes no length restrictions, but QR Codes have restrictions.
+	Even in the most favorable conditions, a QR Code can only hold 7089 characters of data.
+	Any segment longer than this is meaningless for the purpose of generating QR Codes."""
+	
+	# ---- Static factory functions (mid level) ----
+	
+	@staticmethod
+	def make_bytes(data):
+		"""Returns a segment representing the given binary data encoded in byte mode.
+		All input byte lists are acceptable. Any text string can be converted to
+		UTF-8 bytes (s.encode("UTF-8")) and encoded as a byte mode segment."""
+		py3 = sys.version_info.major >= 3
+		if (py3 and isinstance(data, str)) or (not py3 and isinstance(data, unicode)):
+			raise TypeError("Byte string/list expected")
+		if not py3 and isinstance(data, str):
+			data = bytearray(data)
+		bb = _BitBuffer()
+		for b in data:
+			bb.append_bits(b, 8)
+		return QrSegment(QrSegment.Mode.BYTE, len(data), bb)
+	
+	
+	@staticmethod
+	def make_numeric(digits):
+		"""Returns a segment representing the given string of decimal digits encoded in numeric mode."""
+		if QrSegment.NUMERIC_REGEX.match(digits) is None:
+			raise ValueError("String contains non-numeric characters")
+		bb = _BitBuffer()
+		i = 0
+		while i < len(digits):  # Consume up to 3 digits per iteration
+			n = min(len(digits) - i, 3)
+			bb.append_bits(int(digits[i : i + n]), n * 3 + 1)
+			i += n
+		return QrSegment(QrSegment.Mode.NUMERIC, len(digits), bb)
+	
+	
+	@staticmethod
+	def make_alphanumeric(text):
+		"""Returns a segment representing the given text string encoded in alphanumeric mode.
+		The characters allowed are: 0 to 9, A to Z (uppercase only), space,
+		dollar, percent, asterisk, plus, hyphen, period, slash, colon."""
+		if QrSegment.ALPHANUMERIC_REGEX.match(text) is None:
+			raise ValueError("String contains unencodable characters in alphanumeric mode")
+		bb = _BitBuffer()
+		for i in range(0, len(text) - 1, 2):  # Process groups of 2
+			temp = QrSegment._ALPHANUMERIC_ENCODING_TABLE[text[i]] * 45
+			temp += QrSegment._ALPHANUMERIC_ENCODING_TABLE[text[i + 1]]
+			bb.append_bits(temp, 11)
+		if len(text) % 2 > 0:  # 1 character remaining
+			bb.append_bits(QrSegment._ALPHANUMERIC_ENCODING_TABLE[text[-1]], 6)
+		return QrSegment(QrSegment.Mode.ALPHANUMERIC, len(text), bb)
+	
+	
+	@staticmethod
+	def make_segments(text):
+		"""Returns a new mutable list of zero or more segments to represent the given Unicode text string.
+		The result may use various segment modes and switch modes to optimize the length of the bit stream."""
+		if not (isinstance(text, str) or (sys.version_info.major < 3 and isinstance(text, unicode))):
+			raise TypeError("Text string expected")
+		
+		# Select the most efficient segment encoding automatically
+		if text == "":
+			return []
+		elif QrSegment.NUMERIC_REGEX.match(text) is not None:
+			return [QrSegment.make_numeric(text)]
+		elif QrSegment.ALPHANUMERIC_REGEX.match(text) is not None:
+			return [QrSegment.make_alphanumeric(text)]
+		else:
+			return [QrSegment.make_bytes(text.encode("UTF-8"))]
+	
+	
+	@staticmethod
+	def make_eci(assignval):
+		"""Returns a segment representing an Extended Channel Interpretation
+		(ECI) designator with the given assignment value."""
+		bb = _BitBuffer()
+		if assignval < 0:
+			raise ValueError("ECI assignment value out of range")
+		elif assignval < (1 << 7):
+			bb.append_bits(assignval, 8)
+		elif assignval < (1 << 14):
+			bb.append_bits(2, 2)
+			bb.append_bits(assignval, 14)
+		elif assignval < 1000000:
+			bb.append_bits(6, 3)
+			bb.append_bits(assignval, 21)
+		else:
+			raise ValueError("ECI assignment value out of range")
+		return QrSegment(QrSegment.Mode.ECI, 0, bb)
+	
+	
+	# ---- Constructor (low level) ----
+	
+	def __init__(self, mode, numch, bitdata):
+		"""Creates a new QR Code segment with the given attributes and data.
+		The character count (numch) must agree with the mode and the bit buffer length,
+		but the constraint isn't checked. The given bit buffer is cloned and stored."""
+		if not isinstance(mode, QrSegment.Mode):
+			raise TypeError("QrSegment.Mode expected")
+		if numch < 0:
+			raise ValueError()
+		
+		# The mode indicator of this segment. Accessed through get_mode().
+		self._mode = mode
+		
+		# The length of this segment's unencoded data. Measured in characters for
+		# numeric/alphanumeric/kanji mode, bytes for byte mode, and 0 for ECI mode.
+		# Always zero or positive. Not the same as the data's bit length.
+		# Accessed through get_num_chars().
+		self._numchars = numch
+		
+		# The data bits of this segment. Accessed through get_data().
+		self._bitdata = list(bitdata)  # Make defensive copy
+	
+	
+	# ---- Accessor methods ----
+	
+	def get_mode(self):
+		"""Returns the mode field of this segment."""
+		return self._mode
+	
+	def get_num_chars(self):
+		"""Returns the character count field of this segment."""
+		return self._numchars
+	
+	def get_data(self):
+		"""Returns a new copy of the data bits of this segment."""
+		return list(self._bitdata)  # Make defensive copy
+	
+	
+	# Package-private function
+	@staticmethod
+	def get_total_bits(segs, version):
+		"""Calculates the number of bits needed to encode the given segments at
+		the given version. Returns a non-negative number if successful. Otherwise
+		returns None if a segment has too many characters to fit its length field."""
+		result = 0
+		for seg in segs:
+			ccbits = seg.get_mode().num_char_count_bits(version)
+			if seg.get_num_chars() >= (1 << ccbits):
+				return None  # The segment's length doesn't fit the field's bit width
+			result += 4 + ccbits + len(seg._bitdata)
+		return result
+	
+	
+	# ---- Constants ----
+	
+	# (Public) Describes precisely all strings that are encodable in numeric mode.
+	# To test whether a string s is encodable: ok = NUMERIC_REGEX.fullmatch(s) is not None
+	# A string is encodable iff each character is in the range 0 to 9.
+	NUMERIC_REGEX = re.compile(r"[0-9]*\Z")
+	
+	# (Public) Describes precisely all strings that are encodable in alphanumeric mode.
+	# To test whether a string s is encodable: ok = ALPHANUMERIC_REGEX.fullmatch(s) is not None
+	# A string is encodable iff each character is in the following set: 0 to 9, A to Z
+	# (uppercase only), space, dollar, percent, asterisk, plus, hyphen, period, slash, colon.
+
+	ALPHANUMERIC_REGEX = re.compile(r"[A-Z0-9 $%*+./:-]*\Z")
+	
+	# (Private) Dictionary of "0"->0, "A"->10, "$"->37, etc.
+	_ALPHANUMERIC_ENCODING_TABLE = {ch: i for (i, ch) in enumerate("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:")}
+	
+	
+	# ---- Public helper enumeration ----
+	
+	class Mode(object):
+		"""Describes how a segment's data bits are interpreted. Immutable."""
+		
+		# Private constructor
+		def __init__(self, modebits, charcounts):
+			self._modebits = modebits  # The mode indicator bits, which is a uint4 value (range 0 to 15)
+			self._charcounts = charcounts  # Number of character count bits for three different version ranges
+		
+		# Package-private method
+		def get_mode_bits(self):
+			"""Returns an unsigned 4-bit integer value (range 0 to 15) representing the mode indicator bits for this mode object."""
+			return self._modebits
+		
+		# Package-private method
+		def num_char_count_bits(self, ver):
+			"""Returns the bit width of the character count field for a segment in this mode
+			in a QR Code at the given version number. The result is in the range [0, 16]."""
+			return self._charcounts[(ver + 7) // 17]
+	
+	# Public constants. Create them outside the class.
+	Mode.NUMERIC      = Mode(0x1, (10, 12, 14))
+	Mode.ALPHANUMERIC = Mode(0x2, ( 9, 11, 13))
+	Mode.BYTE         = Mode(0x4, ( 8, 16, 16))
+	Mode.KANJI        = Mode(0x8, ( 8, 10, 12))
+	Mode.ECI          = Mode(0x7, ( 0,  0,  0))
+
+
+
+# ---- Private helper class ----
+
+class _BitBuffer(list):
+	"""An appendable sequence of bits (0s and 1s). Mainly used by QrSegment."""
+	
+	def append_bits(self, val, n):
+		"""Appends the given number of low-order bits of the given
+		value to this buffer. Requires n >= 0 and 0 <= val < 2^n."""
+		if n < 0 or val >> n != 0:
+			raise ValueError("Value out of range")
+		self.extend(((val >> i) & 1) for i in reversed(range(n)))
+
+
+def _get_bit(x, i):
+	"""Returns true iff the i'th bit of x is set to 1."""
+	return (x >> i) & 1 != 0
+
+
+
+class DataTooLongError(ValueError):
+	"""Raised when the supplied data does not fit any QR Code version. Ways to handle this exception include:
+	- Decrease the error correction level if it was greater than Ecc.LOW.
+	- If the encode_segments() function was called with a maxversion argument, then increase
+	  it if it was less than QrCode.MAX_VERSION. (This advice does not apply to the other
+	  factory functions because they search all versions up to QrCode.MAX_VERSION.)
+	- Split the text data into better or optimal segments in order to reduce the number of bits required.
+	- Change the text or binary data to be shorter.
+	- Change the text to fit the character set of a particular segment mode (e.g. alphanumeric).
+	- Propagate the error upward to the caller/user."""
+	pass
diff --git a/Telegram/ThirdParty/QR/python/setup.cfg b/Telegram/ThirdParty/QR/python/setup.cfg
new file mode 100644
index 0000000..2a9acf1
--- /dev/null
+++ b/Telegram/ThirdParty/QR/python/setup.cfg
@@ -0,0 +1,2 @@
+[bdist_wheel]
+universal = 1
diff --git a/Telegram/ThirdParty/QR/python/setup.py b/Telegram/ThirdParty/QR/python/setup.py
new file mode 100644
index 0000000..5bffaaf
--- /dev/null
+++ b/Telegram/ThirdParty/QR/python/setup.py
@@ -0,0 +1,113 @@
+# 
+# QR Code generator Distutils script (Python 2, 3)
+# 
+# Copyright (c) Project Nayuki. (MIT License)
+# https://www.nayuki.io/page/qr-code-generator-library
+# 
+# Permission is hereby granted, free of charge, to any person obtaining a copy of
+# this software and associated documentation files (the "Software"), to deal in
+# the Software without restriction, including without limitation the rights to
+# use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+# the Software, and to permit persons to whom the Software is furnished to do so,
+# subject to the following conditions:
+# - The above copyright notice and this permission notice shall be included in
+#   all copies or substantial portions of the Software.
+# - The Software is provided "as is", without warranty of any kind, express or
+#   implied, including but not limited to the warranties of merchantability,
+#   fitness for a particular purpose and noninfringement. In no event shall the
+#   authors or copyright holders be liable for any claim, damages or other
+#   liability, whether in an action of contract, tort or otherwise, arising from,
+#   out of or in connection with the Software or the use or other dealings in the
+#   Software.
+# 
+
+import setuptools
+
+
+setuptools.setup(
+	name = "qrcodegen",
+	description = "High quality QR Code generator library for Python 2 and 3",
+	version = "1.5.0",
+	platforms = "OS Independent",
+	license = "MIT License",
+	
+	author = "Project Nayuki",
+	author_email = "me@nayuki.io",
+	url = "https://www.nayuki.io/page/qr-code-generator-library",
+	
+	classifiers = [
+		"Development Status :: 5 - Production/Stable",
+		"Intended Audience :: Developers",
+		"Intended Audience :: Information Technology",
+		"License :: OSI Approved :: MIT License",
+		"Operating System :: OS Independent",
+		"Programming Language :: Python",
+		"Programming Language :: Python :: 2",
+		"Programming Language :: Python :: 3",
+		"Topic :: Multimedia :: Graphics",
+		"Topic :: Software Development :: Libraries :: Python Modules",
+	],
+	
+	long_description = """=========================
+QR Code generator library
+=========================
+
+
+Introduction
+------------
+
+This project aims to be the best, clearest QR Code generator library. The primary goals are flexible options and absolute correctness. Secondary goals are compact implementation size and good documentation comments.
+
+Home page with live JavaScript demo, extensive descriptions, and competitor comparisons: https://www.nayuki.io/page/qr-code-generator-library
+
+
+Features
+--------
+
+Core features:
+
+* Available in 6 programming languages, all with nearly equal functionality: Java, TypeScript/JavaScript, Python, Rust, C++, C
+* Significantly shorter code but more documentation comments compared to competing libraries
+* Supports encoding all 40 versions (sizes) and all 4 error correction levels, as per the QR Code Model 2 standard
+* Output formats: Raw modules/pixels of the QR symbol, SVG XML string
+* Encodes numeric and special-alphanumeric text in less space than general text
+* Open source code under the permissive MIT License
+
+Manual parameters:
+
+* User can specify minimum and maximum version numbers allowed, then library will automatically choose smallest version in the range that fits the data
+* User can specify mask pattern manually, otherwise library will automatically evaluate all 8 masks and select the optimal one
+* User can specify absolute error correction level, or allow the library to boost it if it doesn't increase the version number
+* User can create a list of data segments manually and add ECI segments
+
+
+Usage
+-----
+
+Install this package by downloading the source code ZIP file from PyPI_, or by running ``pip install qrcodegen``.
+
+Examples:
+
+::
+
+    from qrcodegen import *
+    
+    # Simple operation
+    qr0 = QrCode.encode_text("Hello, world!", QrCode.Ecc.MEDIUM)
+    svg = qr0.to_svg_str(4)
+    
+    # Manual operation
+    segs = QrSegment.make_segments("3141592653589793238462643383")
+    qr1 = QrCode.encode_segments(segs, QrCode.Ecc.HIGH, 5, 5, 2, False)
+    for y in range(qr1.get_size()):
+        for x in range(qr1.get_size()):
+            (... paint qr1.get_module(x, y) ...)
+
+More complete set of examples: https://github.com/nayuki/QR-Code-generator/blob/master/python/qrcodegen-demo.py .
+
+API documentation is in the source file itself, with a summary comment at the top: https://github.com/nayuki/QR-Code-generator/blob/master/python/qrcodegen.py .
+
+.. _PyPI: https://pypi.python.org/pypi/qrcodegen""",
+	
+	py_modules = ["qrcodegen"],
+)
diff --git a/Telegram/ThirdParty/QR/rust/Cargo.toml b/Telegram/ThirdParty/QR/rust/Cargo.toml
new file mode 100644
index 0000000..001b52d
--- /dev/null
+++ b/Telegram/ThirdParty/QR/rust/Cargo.toml
@@ -0,0 +1,11 @@
+[package]
+name = "qrcodegen"
+version = "1.5.0"
+authors = ["Project Nayuki"]
+description = "High-quality QR Code generator library"
+homepage = "https://www.nayuki.io/page/qr-code-generator-library"
+repository = "https://github.com/nayuki/QR-Code-generator"
+readme = "Readme.markdown"
+keywords = ["qr-code", "barcode", "encoder", "image"]
+categories = ["encoding", "multimedia::images"]
+license = "MIT"
diff --git a/Telegram/ThirdParty/QR/rust/Readme.markdown b/Telegram/ThirdParty/QR/rust/Readme.markdown
new file mode 100644
index 0000000..7a20c4a
--- /dev/null
+++ b/Telegram/ThirdParty/QR/rust/Readme.markdown
@@ -0,0 +1,58 @@
+QR Code generator library
+=========================
+
+
+Introduction
+------------
+
+This project aims to be the best, clearest QR Code generator library. The primary goals are flexible options and absolute correctness. Secondary goals are compact implementation size and good documentation comments.
+
+Home page with live JavaScript demo, extensive descriptions, and competitor comparisons: https://www.nayuki.io/page/qr-code-generator-library
+
+
+Features
+--------
+
+Core features:
+
+* Available in 6 programming languages, all with nearly equal functionality: Java, TypeScript/JavaScript, Python, Rust, C++, C
+* Significantly shorter code but more documentation comments compared to competing libraries
+* Supports encoding all 40 versions (sizes) and all 4 error correction levels, as per the QR Code Model 2 standard
+* Output formats: Raw modules/pixels of the QR symbol, SVG XML string
+* Detects finder-like penalty patterns more accurately than other implementations
+* Encodes numeric and special-alphanumeric text in less space than general text
+* Open source code under the permissive MIT License
+
+Manual parameters:
+
+* User can specify minimum and maximum version numbers allowed, then library will automatically choose smallest version in the range that fits the data
+* User can specify mask pattern manually, otherwise library will automatically evaluate all 8 masks and select the optimal one
+* User can specify absolute error correction level, or allow the library to boost it if it doesn't increase the version number
+* User can create a list of data segments manually and add ECI segments
+
+
+Examples
+--------
+
+    extern crate qrcodegen;
+    use qrcodegen::QrCode;
+    use qrcodegen::QrCodeEcc;
+    use qrcodegen::QrSegment;
+    
+    // Simple operation
+    let qr = QrCode::encode_text("Hello, world!",
+        QrCodeEcc::Medium).unwrap();
+    let svg = qr.to_svg_string(4);
+    
+    // Manual operation
+    let chrs: Vec<char> = "3141592653589793238462643383".chars().collect();
+    let segs = QrSegment::make_segments(&chrs);
+    let qr = QrCode::encode_segments_advanced(
+        &segs, QrCodeEcc::High, 5, 5, Some(Mask::new(2)), false).unwrap();
+    for y in 0 .. qr.size() {
+        for x in 0 .. qr.size() {
+            (... paint qr.get_module(x, y) ...)
+        }
+    }
+
+More complete set of examples: https://github.com/nayuki/QR-Code-generator/blob/master/rust/examples/qrcodegen-demo.rs .
diff --git a/Telegram/ThirdParty/QR/rust/examples/qrcodegen-demo.rs b/Telegram/ThirdParty/QR/rust/examples/qrcodegen-demo.rs
new file mode 100644
index 0000000..80b2b7a
--- /dev/null
+++ b/Telegram/ThirdParty/QR/rust/examples/qrcodegen-demo.rs
@@ -0,0 +1,184 @@
+/* 
+ * QR Code generator demo (Rust)
+ * 
+ * Run this command-line program with no arguments. The program computes a bunch of demonstration
+ * QR Codes and prints them to the console. Also, the SVG code for one QR Code is printed as a sample.
+ * 
+ * Copyright (c) Project Nayuki. (MIT License)
+ * https://www.nayuki.io/page/qr-code-generator-library
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ * - The above copyright notice and this permission notice shall be included in
+ *   all copies or substantial portions of the Software.
+ * - The Software is provided "as is", without warranty of any kind, express or
+ *   implied, including but not limited to the warranties of merchantability,
+ *   fitness for a particular purpose and noninfringement. In no event shall the
+ *   authors or copyright holders be liable for any claim, damages or other
+ *   liability, whether in an action of contract, tort or otherwise, arising from,
+ *   out of or in connection with the Software or the use or other dealings in the
+ *   Software.
+ */
+
+extern crate qrcodegen;
+use qrcodegen::Mask;
+use qrcodegen::QrCode;
+use qrcodegen::QrCodeEcc;
+use qrcodegen::QrSegment;
+use qrcodegen::QrCode_MAX_VERSION;
+use qrcodegen::QrCode_MIN_VERSION;
+
+
+// The main application program.
+fn main() {
+	do_basic_demo();
+	do_variety_demo();
+	do_segment_demo();
+	do_mask_demo();
+}
+
+
+
+/*---- Demo suite ----*/
+
+// Creates a single QR Code, then prints it to the console.
+fn do_basic_demo() {
+	let text: &'static str = "Hello, world!";   // User-supplied Unicode text
+	let errcorlvl: QrCodeEcc = QrCodeEcc::Low;  // Error correction level
+	
+	// Make and print the QR Code symbol
+	let qr: QrCode = QrCode::encode_text(text, errcorlvl).unwrap();
+	print_qr(&qr);
+	println!("{}", qr.to_svg_string(4));
+}
+
+
+// Creates a variety of QR Codes that exercise different features of the library, and prints each one to the console.
+fn do_variety_demo() {
+	// Numeric mode encoding (3.33 bits per digit)
+	let qr = QrCode::encode_text("314159265358979323846264338327950288419716939937510", QrCodeEcc::Medium).unwrap();
+	print_qr(&qr);
+	
+	// Alphanumeric mode encoding (5.5 bits per character)
+	let qr = QrCode::encode_text("DOLLAR-AMOUNT:$39.87 PERCENTAGE:100.00% OPERATIONS:+-*/", QrCodeEcc::High).unwrap();
+	print_qr(&qr);
+	
+	// Unicode text as UTF-8
+	let qr = QrCode::encode_text("こんにちwa、世界！ αβγδ", QrCodeEcc::Quartile).unwrap();
+	print_qr(&qr);
+	
+	// Moderately large QR Code using longer text (from Lewis Carroll's Alice in Wonderland)
+	let qr = QrCode::encode_text(concat!(
+		"Alice was beginning to get very tired of sitting by her sister on the bank, ",
+		"and of having nothing to do: once or twice she had peeped into the book her sister was reading, ",
+		"but it had no pictures or conversations in it, 'and what is the use of a book,' thought Alice ",
+		"'without pictures or conversations?' So she was considering in her own mind (as well as she could, ",
+		"for the hot day made her feel very sleepy and stupid), whether the pleasure of making a ",
+		"daisy-chain would be worth the trouble of getting up and picking the daisies, when suddenly ",
+		"a White Rabbit with pink eyes ran close by her."), QrCodeEcc::High).unwrap();
+	print_qr(&qr);
+}
+
+
+// Creates QR Codes with manually specified segments for better compactness.
+fn do_segment_demo() {
+	// Illustration "silver"
+	let silver0 = "THE SQUARE ROOT OF 2 IS 1.";
+	let silver1 = "41421356237309504880168872420969807856967187537694807317667973799";
+	let qr = QrCode::encode_text(&[silver0, silver1].concat(), QrCodeEcc::Low).unwrap();
+	print_qr(&qr);
+	
+	let segs = vec![
+		QrSegment::make_alphanumeric(&to_chars(silver0)),
+		QrSegment::make_numeric(&to_chars(silver1)),
+	];
+	let qr = QrCode::encode_segments(&segs, QrCodeEcc::Low).unwrap();
+	print_qr(&qr);
+	
+	// Illustration "golden"
+	let golden0 = "Golden ratio φ = 1.";
+	let golden1 = "6180339887498948482045868343656381177203091798057628621354486227052604628189024497072072041893911374";
+	let golden2 = "......";
+	let qr = QrCode::encode_text(&[golden0, golden1, golden2].concat(), QrCodeEcc::Low).unwrap();
+	print_qr(&qr);
+	
+	let segs = vec![
+		QrSegment::make_bytes(golden0.as_bytes()),
+		QrSegment::make_numeric(&to_chars(golden1)),
+		QrSegment::make_alphanumeric(&to_chars(golden2)),
+	];
+	let qr = QrCode::encode_segments(&segs, QrCodeEcc::Low).unwrap();
+	print_qr(&qr);
+	
+	// Illustration "Madoka": kanji, kana, Cyrillic, full-width Latin, Greek characters
+	let madoka = "「魔法少女まどか☆マギカ」って、　ИАИ　ｄｅｓｕ　κα？";
+	let qr = QrCode::encode_text(madoka, QrCodeEcc::Low).unwrap();
+	print_qr(&qr);
+	
+	let kanjichars: Vec<u32> = vec![  // Kanji mode encoding (13 bits per character)
+		0x0035, 0x1002, 0x0FC0, 0x0AED, 0x0AD7,
+		0x015C, 0x0147, 0x0129, 0x0059, 0x01BD,
+		0x018D, 0x018A, 0x0036, 0x0141, 0x0144,
+		0x0001, 0x0000, 0x0249, 0x0240, 0x0249,
+		0x0000, 0x0104, 0x0105, 0x0113, 0x0115,
+		0x0000, 0x0208, 0x01FF, 0x0008,
+	];
+	let mut bb = qrcodegen::BitBuffer(Vec::new());
+	for c in &kanjichars {
+		bb.append_bits(*c, 13);
+	}
+	let segs = vec![
+		QrSegment::new(qrcodegen::QrSegmentMode::Kanji, kanjichars.len(), bb.0),
+	];
+	let qr = QrCode::encode_segments(&segs, QrCodeEcc::Low).unwrap();
+	print_qr(&qr);
+}
+
+
+// Creates QR Codes with the same size and contents but different mask patterns.
+fn do_mask_demo() {
+	// Project Nayuki URL
+	let segs = QrSegment::make_segments(&to_chars("https://www.nayuki.io/"));
+	let qr = QrCode::encode_segments_advanced(&segs, QrCodeEcc::High, QrCode_MIN_VERSION, QrCode_MAX_VERSION, None, true).unwrap();  // Automatic mask
+	print_qr(&qr);
+	let qr = QrCode::encode_segments_advanced(&segs, QrCodeEcc::High, QrCode_MIN_VERSION, QrCode_MAX_VERSION, Some(Mask::new(3)), true).unwrap();  // Force mask 3
+	print_qr(&qr);
+	
+	// Chinese text as UTF-8
+	let segs = QrSegment::make_segments(&to_chars("維基百科（Wikipedia，聆聽i/ˌwɪkᵻˈpiːdi.ə/）是一個自由內容、公開編輯且多語言的網路百科全書協作計畫"));
+	let qr = QrCode::encode_segments_advanced(&segs, QrCodeEcc::Medium, QrCode_MIN_VERSION, QrCode_MAX_VERSION, Some(Mask::new(0)), true).unwrap();  // Force mask 0
+	print_qr(&qr);
+	let qr = QrCode::encode_segments_advanced(&segs, QrCodeEcc::Medium, QrCode_MIN_VERSION, QrCode_MAX_VERSION, Some(Mask::new(1)), true).unwrap();  // Force mask 1
+	print_qr(&qr);
+	let qr = QrCode::encode_segments_advanced(&segs, QrCodeEcc::Medium, QrCode_MIN_VERSION, QrCode_MAX_VERSION, Some(Mask::new(5)), true).unwrap();  // Force mask 5
+	print_qr(&qr);
+	let qr = QrCode::encode_segments_advanced(&segs, QrCodeEcc::Medium, QrCode_MIN_VERSION, QrCode_MAX_VERSION, Some(Mask::new(7)), true).unwrap();  // Force mask 7
+	print_qr(&qr);
+}
+
+
+
+/*---- Utilities ----*/
+
+// Prints the given QrCode object to the console.
+fn print_qr(qr: &QrCode) {
+	let border: i32 = 4;
+	for y in -border .. qr.size() + border {
+		for x in -border .. qr.size() + border {
+			let c: char = if qr.get_module(x, y) { '█' } else { ' ' };
+			print!("{0}{0}", c);
+		}
+		println!();
+	}
+	println!();
+}
+
+
+// Converts the given borrowed string slice to a new character vector.
+fn to_chars(text: &str) -> Vec<char> {
+	text.chars().collect()
+}
diff --git a/Telegram/ThirdParty/QR/rust/examples/qrcodegen-worker.rs b/Telegram/ThirdParty/QR/rust/examples/qrcodegen-worker.rs
new file mode 100644
index 0000000..da9a0a3
--- /dev/null
+++ b/Telegram/ThirdParty/QR/rust/examples/qrcodegen-worker.rs
@@ -0,0 +1,113 @@
+/* 
+ * QR Code generator test worker (Rust)
+ * 
+ * This program reads data and encoding parameters from standard input and writes
+ * QR Code bitmaps to standard output. The I/O format is one integer per line.
+ * Run with no command line arguments. The program is intended for automated
+ * batch testing of end-to-end functionality of this QR Code generator library.
+ * 
+ * Copyright (c) Project Nayuki. (MIT License)
+ * https://www.nayuki.io/page/qr-code-generator-library
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ * - The above copyright notice and this permission notice shall be included in
+ *   all copies or substantial portions of the Software.
+ * - The Software is provided "as is", without warranty of any kind, express or
+ *   implied, including but not limited to the warranties of merchantability,
+ *   fitness for a particular purpose and noninfringement. In no event shall the
+ *   authors or copyright holders be liable for any claim, damages or other
+ *   liability, whether in an action of contract, tort or otherwise, arising from,
+ *   out of or in connection with the Software or the use or other dealings in the
+ *   Software.
+ */
+
+extern crate qrcodegen;
+use qrcodegen::Mask;
+use qrcodegen::QrCode;
+use qrcodegen::QrCodeEcc;
+use qrcodegen::QrSegment;
+use qrcodegen::Version;
+
+
+fn main() {
+	loop {
+		
+		// Read data length or exit
+		let length: i16 = read_int();
+		if length == -1 {
+			break;
+		}
+		
+		// Read data bytes
+		let mut data = Vec::<u8>::with_capacity(length as usize);
+		for _ in 0 .. length {
+			let b: i16 = read_int();
+			assert_eq!(i16::from(b as u8), b, "Byte value out of range");
+			data.push(b as u8);
+		}
+		let isascii: bool = data.iter().all(|b| *b < 128);
+		
+		// Read encoding parameters
+		let errcorlvl  = read_int();
+		let minversion = read_int();
+		let maxversion = read_int();
+		let mask       = read_int();
+		let boostecl   = read_int();
+		assert!(0 <= errcorlvl && errcorlvl <= 3);
+		assert!(i16::from(qrcodegen::QrCode_MIN_VERSION.value()) <= minversion
+			&& minversion <= maxversion
+			&& maxversion <= i16::from(qrcodegen::QrCode_MAX_VERSION.value()));
+		assert!(-1 <= mask && mask <= 7);
+		assert!(boostecl >> 1 == 0);
+		
+		// Make segments for encoding
+		let segs: Vec<QrSegment> = if isascii {
+			let chrs: Vec<char> = std::str::from_utf8(&data).unwrap().chars().collect();
+			QrSegment::make_segments(&chrs)
+		} else {
+			vec![QrSegment::make_bytes(&data)]
+		};
+		
+		// Try to make QR Code symbol
+		let msk = if mask == -1 { None } else { Some(Mask::new(mask as u8)) };
+		match QrCode::encode_segments_advanced(&segs, ECC_LEVELS[errcorlvl as usize],
+				Version::new(minversion as u8), Version::new(maxversion as u8), msk, boostecl != 0) {
+		
+			Ok(qr) => {
+				// Print grid of modules
+				println!("{}", qr.version().value());
+				for y in 0 .. qr.size() {
+					for x in 0 .. qr.size() {
+						println!("{}", qr.get_module(x, y) as i8);
+					}
+				}
+			},
+			Err(_) => println!("-1"),
+		}
+		use std::io::Write;
+		std::io::stdout().flush().unwrap();
+	}
+}
+
+
+fn read_int() -> i16 {
+	let mut line = String::new();
+	std::io::stdin().read_line(&mut line).unwrap();
+	let mut chrs: Vec<char> = line.chars().collect();
+	assert_eq!(chrs.pop().unwrap(), '\n');
+	let line: String = chrs.iter().cloned().collect();
+	line.parse::<i16>().expect("Invalid number")
+}
+
+
+static ECC_LEVELS: [QrCodeEcc; 4] = [
+	QrCodeEcc::Low,
+	QrCodeEcc::Medium,
+	QrCodeEcc::Quartile,
+	QrCodeEcc::High,
+];
diff --git a/Telegram/ThirdParty/QR/rust/src/lib.rs b/Telegram/ThirdParty/QR/rust/src/lib.rs
new file mode 100644
index 0000000..be7303c
--- /dev/null
+++ b/Telegram/ThirdParty/QR/rust/src/lib.rs
@@ -0,0 +1,1297 @@
+/* 
+ * QR Code generator library (Rust)
+ * 
+ * Copyright (c) Project Nayuki. (MIT License)
+ * https://www.nayuki.io/page/qr-code-generator-library
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ * - The above copyright notice and this permission notice shall be included in
+ *   all copies or substantial portions of the Software.
+ * - The Software is provided "as is", without warranty of any kind, express or
+ *   implied, including but not limited to the warranties of merchantability,
+ *   fitness for a particular purpose and noninfringement. In no event shall the
+ *   authors or copyright holders be liable for any claim, damages or other
+ *   liability, whether in an action of contract, tort or otherwise, arising from,
+ *   out of or in connection with the Software or the use or other dealings in the
+ *   Software.
+ */
+
+
+//! Generates QR Codes from text strings and byte arrays.
+//! 
+//! This project aims to be the best, clearest QR Code generator library.
+//! The primary goals are flexible options and absolute correctness.
+//! Secondary goals are compact implementation size and good documentation comments.
+//! 
+//! Home page with live JavaScript demo, extensive descriptions, and competitor comparisons:
+//! [https://www.nayuki.io/page/qr-code-generator-library](https://www.nayuki.io/page/qr-code-generator-library)
+//! 
+//! # Features
+//! 
+//! Core features:
+//! 
+//! - Available in 6 programming languages, all with nearly equal functionality: Java, TypeScript/JavaScript, Python, Rust, C++, C
+//! - Significantly shorter code but more documentation comments compared to competing libraries
+//! - Supports encoding all 40 versions (sizes) and all 4 error correction levels, as per the QR Code Model 2 standard
+//! - Output formats: Raw modules/pixels of the QR symbol, SVG XML string
+//! - Detects finder-like penalty patterns more accurately than other implementations
+//! - Encodes numeric and special-alphanumeric text in less space than general text
+//! - Open source code under the permissive MIT License
+//! 
+//! Manual parameters:
+//! 
+//! - User can specify minimum and maximum version numbers allowed, then library will automatically choose smallest version in the range that fits the data
+//! - User can specify mask pattern manually, otherwise library will automatically evaluate all 8 masks and select the optimal one
+//! - User can specify absolute error correction level, or allow the library to boost it if it doesn't increase the version number
+//! - User can create a list of data segments manually and add ECI segments
+//! 
+//! # Examples
+//! 
+//! ```
+//! extern crate qrcodegen;
+//! use qrcodegen::QrCode;
+//! use qrcodegen::QrCodeEcc;
+//! use qrcodegen::QrSegment;
+//! ```
+//! 
+//! Simple operation:
+//! 
+//! ```
+//! let qr = QrCode::encode_text("Hello, world!",
+//!     QrCodeEcc::Medium).unwrap();
+//! let svg = qr.to_svg_string(4);
+//! ```
+//! 
+//! Manual operation:
+//! 
+//! ```
+//! let chrs: Vec<char> = "3141592653589793238462643383".chars().collect();
+//! let segs = QrSegment::make_segments(&chrs);
+//! let qr = QrCode::encode_segments_advanced(
+//!     &segs, QrCodeEcc::High, 5, 5, Some(Mask::new(2)), false).unwrap();
+//! for y in 0 .. qr.size() {
+//!     for x in 0 .. qr.size() {
+//!         (... paint qr.get_module(x, y) ...)
+//!     }
+//! }
+//! ```
+
+
+/*---- QrCode functionality ----*/
+
+/// A QR Code symbol, which is a type of two-dimension barcode.
+/// 
+/// Invented by Denso Wave and described in the ISO/IEC 18004 standard.
+/// 
+/// Instances of this struct represent an immutable square grid of black and white cells.
+/// The impl provides static factory functions to create a QR Code from text or binary data.
+/// The struct and impl cover the QR Code Model 2 specification, supporting all versions
+/// (sizes) from 1 to 40, all 4 error correction levels, and 4 character encoding modes.
+/// 
+/// Ways to create a QR Code object:
+/// 
+/// - High level: Take the payload data and call `QrCode::encode_text()` or `QrCode::encode_binary()`.
+/// - Mid level: Custom-make the list of segments and call
+///   `QrCode::encode_segments()` or `QrCode::encode_segments_advanced()`.
+/// - Low level: Custom-make the array of data codeword bytes (including segment
+///   headers and final padding, excluding error correction codewords), supply the
+///   appropriate version number, and call the `QrCode::encode_codewords()` constructor.
+/// 
+/// (Note that all ways require supplying the desired error correction level.)
+#[derive(Clone)]
+pub struct QrCode {
+	
+	// Scalar parameters:
+	
+	// The version number of this QR Code, which is between 1 and 40 (inclusive).
+	// This determines the size of this barcode.
+	version: Version,
+	
+	// The width and height of this QR Code, measured in modules, between
+	// 21 and 177 (inclusive). This is equal to version * 4 + 17.
+	size: i32,
+	
+	// The error correction level used in this QR Code.
+	errorcorrectionlevel: QrCodeEcc,
+	
+	// The index of the mask pattern used in this QR Code, which is between 0 and 7 (inclusive).
+	// Even if a QR Code is created with automatic masking requested (mask = None),
+	// the resulting object still has a mask value between 0 and 7.
+	mask: Mask,
+	
+	// Grids of modules/pixels, with dimensions of size*size:
+	
+	// The modules of this QR Code (false = white, true = black).
+	// Immutable after constructor finishes. Accessed through get_module().
+	modules: Vec<bool>,
+	
+	// Indicates function modules that are not subjected to masking. Discarded when constructor finishes.
+	isfunction: Vec<bool>,
+	
+}
+
+
+impl QrCode {
+	
+	/*---- Static factory functions (high level) ----*/
+	
+	/// Returns a QR Code representing the given Unicode text string at the given error correction level.
+	/// 
+	/// As a conservative upper bound, this function is guaranteed to succeed for strings that have 738 or fewer Unicode
+	/// code points (not UTF-8 code units) if the low error correction level is used. The smallest possible
+	/// QR Code version is automatically chosen for the output. The ECC level of the result may be higher than
+	/// the ecl argument if it can be done without increasing the version.
+	/// 
+	/// Returns a wrapped `QrCode` if successful, or `Err` if the
+	/// data is too long to fit in any version at the given ECC level.
+	pub fn encode_text(text: &str, ecl: QrCodeEcc) -> Result<Self,DataTooLong> {
+		let chrs: Vec<char> = text.chars().collect();
+		let segs: Vec<QrSegment> = QrSegment::make_segments(&chrs);
+		QrCode::encode_segments(&segs, ecl)
+	}
+	
+	
+	/// Returns a QR Code representing the given binary data at the given error correction level.
+	/// 
+	/// This function always encodes using the binary segment mode, not any text mode. The maximum number of
+	/// bytes allowed is 2953. The smallest possible QR Code version is automatically chosen for the output.
+	/// The ECC level of the result may be higher than the ecl argument if it can be done without increasing the version.
+	/// 
+	/// Returns a wrapped `QrCode` if successful, or `Err` if the
+	/// data is too long to fit in any version at the given ECC level.
+	pub fn encode_binary(data: &[u8], ecl: QrCodeEcc) -> Result<Self,DataTooLong> {
+		let segs: [QrSegment; 1] = [QrSegment::make_bytes(data)];
+		QrCode::encode_segments(&segs, ecl)
+	}
+	
+	
+	/*---- Static factory functions (mid level) ----*/
+	
+	/// Returns a QR Code representing the given segments at the given error correction level.
+	/// 
+	/// The smallest possible QR Code version is automatically chosen for the output. The ECC level
+	/// of the result may be higher than the ecl argument if it can be done without increasing the version.
+	/// 
+	/// This function allows the user to create a custom sequence of segments that switches
+	/// between modes (such as alphanumeric and byte) to encode text in less space.
+	/// This is a mid-level API; the high-level API is `encode_text()` and `encode_binary()`.
+	/// 
+	/// Returns a wrapped `QrCode` if successful, or `Err` if the
+	/// data is too long to fit in any version at the given ECC level.
+	pub fn encode_segments(segs: &[QrSegment], ecl: QrCodeEcc) -> Result<Self,DataTooLong> {
+		QrCode::encode_segments_advanced(segs, ecl, QrCode_MIN_VERSION, QrCode_MAX_VERSION, None, true)
+	}
+	
+	
+	/// Returns a QR Code representing the given segments with the given encoding parameters.
+	/// 
+	/// The smallest possible QR Code version within the given range is automatically
+	/// chosen for the output. Iff boostecl is `true`, then the ECC level of the result
+	/// may be higher than the ecl argument if it can be done without increasing the
+	/// version. The mask number is either between 0 to 7 (inclusive) to force that
+	/// mask, or `None` to automatically choose an appropriate mask (which may be slow).
+	/// 
+	/// This function allows the user to create a custom sequence of segments that switches
+	/// between modes (such as alphanumeric and byte) to encode text in less space.
+	/// This is a mid-level API; the high-level API is `encode_text()` and `encode_binary()`.
+	/// 
+	/// Returns a wrapped `QrCode` if successful, or `Err` if the data is too
+	/// long to fit in any version in the given range at the given ECC level.
+	pub fn encode_segments_advanced(segs: &[QrSegment], mut ecl: QrCodeEcc,
+			minversion: Version, maxversion: Version, mask: Option<Mask>, boostecl: bool) -> Result<Self,DataTooLong> {
+		assert!(minversion.value() <= maxversion.value(), "Invalid value");
+		
+		// Find the minimal version number to use
+		let mut version = minversion;
+		let datausedbits: usize = loop {
+			// Number of data bits available
+			let datacapacitybits: usize = QrCode::get_num_data_codewords(version, ecl) * 8;
+			let dataused: Option<usize> = QrSegment::get_total_bits(segs, version);
+			if dataused.map_or(false, |n| n <= datacapacitybits) {
+				break dataused.unwrap();  // This version number is found to be suitable
+			} else if version.value() >= maxversion.value() {  // All versions in the range could not fit the given data
+				let msg: String = match dataused {
+					None => String::from("Segment too long"),
+					Some(n) => format!("Data length = {} bits, Max capacity = {} bits",
+						n, datacapacitybits),
+				};
+				return Err(DataTooLong(msg));
+			} else {
+				version = Version::new(version.value() + 1);
+			}
+		};
+		
+		// Increase the error correction level while the data still fits in the current version number
+		for &newecl in &[QrCodeEcc::Medium, QrCodeEcc::Quartile, QrCodeEcc::High] {  // From low to high
+			if boostecl && datausedbits <= QrCode::get_num_data_codewords(version, newecl) * 8 {
+				ecl = newecl;
+			}
+		}
+		
+		// Concatenate all segments to create the data bit string
+		let mut bb = BitBuffer(Vec::new());
+		for seg in segs {
+			bb.append_bits(seg.mode.mode_bits(), 4);
+			bb.append_bits(seg.numchars as u32, seg.mode.num_char_count_bits(version));
+			bb.0.extend_from_slice(&seg.data);
+		}
+		assert_eq!(bb.0.len(), datausedbits);
+		
+		// Add terminator and pad up to a byte if applicable
+		let datacapacitybits: usize = QrCode::get_num_data_codewords(version, ecl) * 8;
+		assert!(bb.0.len() <= datacapacitybits);
+		let numzerobits = std::cmp::min(4, datacapacitybits - bb.0.len());
+		bb.append_bits(0, numzerobits as u8);
+		let numzerobits = bb.0.len().wrapping_neg() & 7;
+		bb.append_bits(0, numzerobits as u8);
+		assert_eq!(bb.0.len() % 8, 0, "Assertion error");
+		
+		// Pad with alternating bytes until data capacity is reached
+		for &padbyte in [0xEC, 0x11].iter().cycle() {
+			if bb.0.len() >= datacapacitybits {
+				break;
+			}
+			bb.append_bits(padbyte, 8);
+		}
+		
+		// Pack bits into bytes in big endian
+		let mut datacodewords = vec![0u8; bb.0.len() / 8];
+		for (i, &bit) in bb.0.iter().enumerate() {
+			datacodewords[i >> 3] |= u8::from(bit) << (7 - (i & 7));
+		}
+		
+		// Create the QR Code object
+		Ok(QrCode::encode_codewords(version, ecl, &datacodewords, mask))
+	}
+	
+	
+	/*---- Constructor (low level) ----*/
+	
+	/// Creates a new QR Code with the given version number,
+	/// error correction level, data codeword bytes, and mask number.
+	/// 
+	/// This is a low-level API that most users should not use directly.
+	/// A mid-level API is the `encode_segments()` function.
+	pub fn encode_codewords(ver: Version, ecl: QrCodeEcc, datacodewords: &[u8], mut mask: Option<Mask>) -> Self {
+		// Initialize fields
+		let size = usize::from(ver.value()) * 4 + 17;
+		let mut result = Self {
+			version: ver,
+			size: size as i32,
+			mask: Mask::new(0),  // Dummy value
+			errorcorrectionlevel: ecl,
+			modules   : vec![false; size * size],  // Initially all white
+			isfunction: vec![false; size * size],
+		};
+		
+		// Compute ECC, draw modules
+		result.draw_function_patterns();
+		let allcodewords: Vec<u8> = result.add_ecc_and_interleave(datacodewords);
+		result.draw_codewords(&allcodewords);
+		
+		// Do masking
+		if mask.is_none() {  // Automatically choose best mask
+			let mut minpenalty: i32 = std::i32::MAX;
+			for i in 0u8 .. 8 {
+				let newmask = Mask::new(i);
+				result.apply_mask(newmask);
+				result.draw_format_bits(newmask);
+				let penalty: i32 = result.get_penalty_score();
+				if penalty < minpenalty {
+					mask = Some(newmask);
+					minpenalty = penalty;
+				}
+				result.apply_mask(newmask);  // Undoes the mask due to XOR
+			}
+		}
+		let mask: Mask = mask.unwrap();
+		result.mask = mask;
+		result.apply_mask(mask);  // Apply the final choice of mask
+		result.draw_format_bits(mask);  // Overwrite old format bits
+		
+		result.isfunction.clear();
+		result.isfunction.shrink_to_fit();
+		result
+	}
+	
+	
+	/*---- Public methods ----*/
+	
+	/// Returns this QR Code's version, in the range [1, 40].
+	pub fn version(&self) -> Version {
+		self.version
+	}
+	
+	
+	/// Returns this QR Code's size, in the range [21, 177].
+	pub fn size(&self) -> i32 {
+		self.size
+	}
+	
+	
+	/// Returns this QR Code's error correction level.
+	pub fn error_correction_level(&self) -> QrCodeEcc {
+		self.errorcorrectionlevel
+	}
+	
+	
+	/// Returns this QR Code's mask, in the range [0, 7].
+	pub fn mask(&self) -> Mask {
+		self.mask
+	}
+	
+	
+	/// Returns the color of the module (pixel) at the given coordinates,
+	/// which is `false` for white or `true` for black.
+	/// 
+	/// The top left corner has the coordinates (x=0, y=0). If the given
+	/// coordinates are out of bounds, then `false` (white) is returned.
+	pub fn get_module(&self, x: i32, y: i32) -> bool {
+		0 <= x && x < self.size && 0 <= y && y < self.size && self.module(x, y)
+	}
+	
+	
+	// Returns the color of the module at the given coordinates, which must be in bounds.
+	fn module(&self, x: i32, y: i32) -> bool {
+		self.modules[(y * self.size + x) as usize]
+	}
+	
+	
+	// Returns a mutable reference to the module's color at the given coordinates, which must be in bounds.
+	fn module_mut(&mut self, x: i32, y: i32) -> &mut bool {
+		&mut self.modules[(y * self.size + x) as usize]
+	}
+	
+	
+	/// Returns a string of SVG code for an image depicting
+	/// this QR Code, with the given number of border modules.
+	/// 
+	/// The string always uses Unix newlines (\n), regardless of the platform.
+	pub fn to_svg_string(&self, border: i32) -> String {
+		assert!(border >= 0, "Border must be non-negative");
+		let mut result = String::new();
+		result += "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
+		result += "<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n";
+		let dimension = self.size.checked_add(border.checked_mul(2).unwrap()).unwrap();
+		result += &format!(
+			"<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" viewBox=\"0 0 {0} {0}\" stroke=\"none\">\n", dimension);
+		result += "\t<rect width=\"100%\" height=\"100%\" fill=\"#FFFFFF\"/>\n";
+		result += "\t<path d=\"";
+		for y in 0 .. self.size {
+			for x in 0 .. self.size {
+				if self.get_module(x, y) {
+					if x != 0 || y != 0 {
+						result += " ";
+					}
+					result += &format!("M{},{}h1v1h-1z", x + border, y + border);
+				}
+			}
+		}
+		result += "\" fill=\"#000000\"/>\n";
+		result += "</svg>\n";
+		result
+	}
+	
+	
+	/*---- Private helper methods for constructor: Drawing function modules ----*/
+	
+	// Reads this object's version field, and draws and marks all function modules.
+	fn draw_function_patterns(&mut self) {
+		// Draw horizontal and vertical timing patterns
+		let size: i32 = self.size;
+		for i in 0 .. size {
+			self.set_function_module(6, i, i % 2 == 0);
+			self.set_function_module(i, 6, i % 2 == 0);
+		}
+		
+		// Draw 3 finder patterns (all corners except bottom right; overwrites some timing modules)
+		self.draw_finder_pattern(3, 3);
+		self.draw_finder_pattern(size - 4, 3);
+		self.draw_finder_pattern(3, size - 4);
+		
+		// Draw numerous alignment patterns
+		let alignpatpos: Vec<i32> = self.get_alignment_pattern_positions();
+		let numalign: usize = alignpatpos.len();
+		for i in 0 .. numalign {
+			for j in 0 .. numalign {
+				// Don't draw on the three finder corners
+				if !(i == 0 && j == 0 || i == 0 && j == numalign - 1 || i == numalign - 1 && j == 0) {
+					self.draw_alignment_pattern(alignpatpos[i], alignpatpos[j]);
+				}
+			}
+		}
+		
+		// Draw configuration data
+		self.draw_format_bits(Mask::new(0));  // Dummy mask value; overwritten later in the constructor
+		self.draw_version();
+	}
+	
+	
+	// Draws two copies of the format bits (with its own error correction code)
+	// based on the given mask and this object's error correction level field.
+	fn draw_format_bits(&mut self, mask: Mask) {
+		// Calculate error correction code and pack bits
+		let bits: u32 = {
+			// errcorrlvl is uint2, mask is uint3
+			let data: u32 = self.errorcorrectionlevel.format_bits() << 3 | u32::from(mask.value());
+			let mut rem: u32 = data;
+			for _ in 0 .. 10 {
+				rem = (rem << 1) ^ ((rem >> 9) * 0x537);
+			}
+			(data << 10 | rem) ^ 0x5412  // uint15
+		};
+		assert_eq!(bits >> 15, 0, "Assertion error");
+		
+		// Draw first copy
+		for i in 0 .. 6 {
+			self.set_function_module(8, i, get_bit(bits, i));
+		}
+		self.set_function_module(8, 7, get_bit(bits, 6));
+		self.set_function_module(8, 8, get_bit(bits, 7));
+		self.set_function_module(7, 8, get_bit(bits, 8));
+		for i in 9 .. 15 {
+			self.set_function_module(14 - i, 8, get_bit(bits, i));
+		}
+		
+		// Draw second copy
+		let size: i32 = self.size;
+		for i in 0 .. 8 {
+			self.set_function_module(size - 1 - i, 8, get_bit(bits, i));
+		}
+		for i in 8 .. 15 {
+			self.set_function_module(8, size - 15 + i, get_bit(bits, i));
+		}
+		self.set_function_module(8, size - 8, true);  // Always black
+	}
+	
+	
+	// Draws two copies of the version bits (with its own error correction code),
+	// based on this object's version field, iff 7 <= version <= 40.
+	fn draw_version(&mut self) {
+		if self.version.value() < 7 {
+			return;
+		}
+		
+		// Calculate error correction code and pack bits
+		let bits: u32 = {
+			let data = u32::from(self.version.value());  // uint6, in the range [7, 40]
+			let mut rem: u32 = data;
+			for _ in 0 .. 12 {
+				rem = (rem << 1) ^ ((rem >> 11) * 0x1F25);
+			}
+			data << 12 | rem  // uint18
+		};
+		assert!(bits >> 18 == 0, "Assertion error");
+		
+		// Draw two copies
+		for i in 0 .. 18 {
+			let bit: bool = get_bit(bits, i);
+			let a: i32 = self.size - 11 + i % 3;
+			let b: i32 = i / 3;
+			self.set_function_module(a, b, bit);
+			self.set_function_module(b, a, bit);
+		}
+	}
+	
+	
+	// Draws a 9*9 finder pattern including the border separator,
+	// with the center module at (x, y). Modules can be out of bounds.
+	fn draw_finder_pattern(&mut self, x: i32, y: i32) {
+		for dy in -4 ..= 4 {
+			for dx in -4 ..= 4 {
+				let xx: i32 = x + dx;
+				let yy: i32 = y + dy;
+				if 0 <= xx && xx < self.size && 0 <= yy && yy < self.size {
+					let dist: i32 = std::cmp::max(dx.abs(), dy.abs());  // Chebyshev/infinity norm
+					self.set_function_module(xx, yy, dist != 2 && dist != 4);
+				}
+			}
+		}
+	}
+	
+	
+	// Draws a 5*5 alignment pattern, with the center module
+	// at (x, y). All modules must be in bounds.
+	fn draw_alignment_pattern(&mut self, x: i32, y: i32) {
+		for dy in -2 ..= 2 {
+			for dx in -2 ..= 2 {
+				self.set_function_module(x + dx, y + dy, std::cmp::max(dx.abs(), dy.abs()) != 1);
+			}
+		}
+	}
+	
+	
+	// Sets the color of a module and marks it as a function module.
+	// Only used by the constructor. Coordinates must be in bounds.
+	fn set_function_module(&mut self, x: i32, y: i32, isblack: bool) {
+		*self.module_mut(x, y) = isblack;
+		self.isfunction[(y * self.size + x) as usize] = true;
+	}
+	
+	
+	/*---- Private helper methods for constructor: Codewords and masking ----*/
+	
+	// Returns a new byte string representing the given data with the appropriate error correction
+	// codewords appended to it, based on this object's version and error correction level.
+	fn add_ecc_and_interleave(&self, data: &[u8]) -> Vec<u8> {
+		let ver = self.version;
+		let ecl = self.errorcorrectionlevel;
+		assert_eq!(data.len(), QrCode::get_num_data_codewords(ver, ecl), "Illegal argument");
+		
+		// Calculate parameter numbers
+		let numblocks: usize = QrCode::table_get(&NUM_ERROR_CORRECTION_BLOCKS, ver, ecl);
+		let blockecclen: usize = QrCode::table_get(&ECC_CODEWORDS_PER_BLOCK  , ver, ecl);
+		let rawcodewords: usize = QrCode::get_num_raw_data_modules(ver) / 8;
+		let numshortblocks: usize = numblocks - rawcodewords % numblocks;
+		let shortblocklen: usize = rawcodewords / numblocks;
+		
+		// Split data into blocks and append ECC to each block
+		let mut blocks = Vec::<Vec<u8>>::with_capacity(numblocks);
+		let rsdiv: Vec<u8> = QrCode::reed_solomon_compute_divisor(blockecclen);
+		let mut k: usize = 0;
+		for i in 0 .. numblocks {
+			let datlen: usize = shortblocklen - blockecclen + usize::from(i >= numshortblocks);
+			let mut dat = data[k .. k + datlen].to_vec();
+			k += datlen;
+			let ecc: Vec<u8> = QrCode::reed_solomon_compute_remainder(&dat, &rsdiv);
+			if i < numshortblocks {
+				dat.push(0);
+			}
+			dat.extend_from_slice(&ecc);
+			blocks.push(dat);
+		}
+		
+		// Interleave (not concatenate) the bytes from every block into a single sequence
+		let mut result = Vec::<u8>::with_capacity(rawcodewords);
+		for i in 0 ..= shortblocklen {
+			for (j, block) in blocks.iter().enumerate() {
+				// Skip the padding byte in short blocks
+				if i != shortblocklen - blockecclen || j >= numshortblocks {
+					result.push(block[i]);
+				}
+			}
+		}
+		result
+	}
+	
+	
+	// Draws the given sequence of 8-bit codewords (data and error correction) onto the entire
+	// data area of this QR Code. Function modules need to be marked off before this is called.
+	fn draw_codewords(&mut self, data: &[u8]) {
+		assert_eq!(data.len(), QrCode::get_num_raw_data_modules(self.version) / 8, "Illegal argument");
+		
+		let mut i: usize = 0;  // Bit index into the data
+		// Do the funny zigzag scan
+		let mut right: i32 = self.size - 1;
+		while right >= 1 {  // Index of right column in each column pair
+			if right == 6 {
+				right = 5;
+			}
+			for vert in 0 .. self.size {  // Vertical counter
+				for j in 0 .. 2 {
+					let x: i32 = right - j;  // Actual x coordinate
+					let upward: bool = (right + 1) & 2 == 0;
+					let y: i32 = if upward { self.size - 1 - vert } else { vert };  // Actual y coordinate
+					if !self.isfunction[(y * self.size + x) as usize] && i < data.len() * 8 {
+						*self.module_mut(x, y) = get_bit(u32::from(data[i >> 3]), 7 - ((i & 7) as i32));
+						i += 1;
+					}
+					// If this QR Code has any remainder bits (0 to 7), they were assigned as
+					// 0/false/white by the constructor and are left unchanged by this method
+				}
+			}
+			right -= 2;
+		}
+		assert_eq!(i, data.len() * 8, "Assertion error");
+	}
+	
+	
+	// XORs the codeword modules in this QR Code with the given mask pattern.
+	// The function modules must be marked and the codeword bits must be drawn
+	// before masking. Due to the arithmetic of XOR, calling applyMask() with
+	// the same mask value a second time will undo the mask. A final well-formed
+	// QR Code needs exactly one (not zero, two, etc.) mask applied.
+	fn apply_mask(&mut self, mask: Mask) {
+		let mask: u8 = mask.value();
+		for y in 0 .. self.size {
+			for x in 0 .. self.size {
+				let invert: bool = match mask {
+					0 => (x + y) % 2 == 0,
+					1 => y % 2 == 0,
+					2 => x % 3 == 0,
+					3 => (x + y) % 3 == 0,
+					4 => (x / 3 + y / 2) % 2 == 0,
+					5 => x * y % 2 + x * y % 3 == 0,
+					6 => (x * y % 2 + x * y % 3) % 2 == 0,
+					7 => ((x + y) % 2 + x * y % 3) % 2 == 0,
+					_ => unreachable!(),
+				};
+				*self.module_mut(x, y) ^= invert & !self.isfunction[(y * self.size + x) as usize];
+			}
+		}
+	}
+	
+	
+	// Calculates and returns the penalty score based on state of this QR Code's current modules.
+	// This is used by the automatic mask choice algorithm to find the mask pattern that yields the lowest score.
+	fn get_penalty_score(&self) -> i32 {
+		let mut result: i32 = 0;
+		let size: i32 = self.size;
+		
+		// Adjacent modules in row having same color, and finder-like patterns
+		for y in 0 .. size {
+			let mut runcolor = false;
+			let mut runx: i32 = 0;
+			let mut runhistory = [0i32; 7];
+			let mut padrun = size;  // Add white border to initial run
+			for x in 0 .. size {
+				if self.module(x, y) == runcolor {
+					runx += 1;
+					if runx == 5 {
+						result += PENALTY_N1;
+					} else if runx > 5 {
+						result += 1;
+					}
+				} else {
+					QrCode::finder_penalty_add_history(runx + padrun, &mut runhistory);
+					padrun = 0;
+					if !runcolor {
+						result += self.finder_penalty_count_patterns(&runhistory) * PENALTY_N3;
+					}
+					runcolor = self.module(x, y);
+					runx = 1;
+				}
+			}
+			result += self.finder_penalty_terminate_and_count(runcolor, runx + padrun, &mut runhistory) * PENALTY_N3;
+		}
+		// Adjacent modules in column having same color, and finder-like patterns
+		for x in 0 .. size {
+			let mut runcolor = false;
+			let mut runy: i32 = 0;
+			let mut runhistory = [0i32; 7];
+			let mut padrun = size;  // Add white border to initial run
+			for y in 0 .. size {
+				if self.module(x, y) == runcolor {
+					runy += 1;
+					if runy == 5 {
+						result += PENALTY_N1;
+					} else if runy > 5 {
+						result += 1;
+					}
+				} else {
+					QrCode::finder_penalty_add_history(runy + padrun, &mut runhistory);
+					padrun = 0;
+					if !runcolor {
+						result += self.finder_penalty_count_patterns(&runhistory) * PENALTY_N3;
+					}
+					runcolor = self.module(x, y);
+					runy = 1;
+				}
+			}
+			result += self.finder_penalty_terminate_and_count(runcolor, runy + padrun, &mut runhistory) * PENALTY_N3;
+		}
+		
+		// 2*2 blocks of modules having same color
+		for y in 0 .. size - 1 {
+			for x in 0 .. size - 1 {
+				let color: bool = self.module(x, y);
+				if color == self.module(x + 1, y) &&
+				   color == self.module(x, y + 1) &&
+				   color == self.module(x + 1, y + 1) {
+					result += PENALTY_N2;
+				}
+			}
+		}
+		
+		// Balance of black and white modules
+		let black: i32 = self.modules.iter().copied().map(i32::from).sum();
+		let total: i32 = size * size;  // Note that size is odd, so black/total != 1/2
+		// Compute the smallest integer k >= 0 such that (45-5k)% <= black/total <= (55+5k)%
+		let k: i32 = ((black * 20 - total * 10).abs() + total - 1) / total - 1;
+		result += k * PENALTY_N4;
+		result
+	}
+	
+	
+	/*---- Private helper functions ----*/
+	
+	// Returns an ascending list of positions of alignment patterns for this version number.
+	// Each position is in the range [0,177), and are used on both the x and y axes.
+	// This could be implemented as lookup table of 40 variable-length lists of unsigned bytes.
+	fn get_alignment_pattern_positions(&self) -> Vec<i32> {
+		let ver = self.version.value();
+		if ver == 1 {
+			vec![]
+		} else {
+			let numalign = i32::from(ver) / 7 + 2;
+			let step: i32 = if ver == 32 { 26 } else
+				{(i32::from(ver)*4 + numalign*2 + 1) / (numalign*2 - 2) * 2};
+			let mut result: Vec<i32> = (0 .. numalign - 1).map(
+				|i| self.size - 7 - i * step).collect();
+			result.push(6);
+			result.reverse();
+			result
+		}
+	}
+	
+	
+	// Returns the number of data bits that can be stored in a QR Code of the given version number, after
+	// all function modules are excluded. This includes remainder bits, so it might not be a multiple of 8.
+	// The result is in the range [208, 29648]. This could be implemented as a 40-entry lookup table.
+	fn get_num_raw_data_modules(ver: Version) -> usize {
+		let ver = usize::from(ver.value());
+		let mut result: usize = (16 * ver + 128) * ver + 64;
+		if ver >= 2 {
+			let numalign: usize = ver / 7 + 2;
+			result -= (25 * numalign - 10) * numalign - 55;
+			if ver >= 7 {
+				result -= 36;
+			}
+		}
+		assert!(208 <= result && result <= 29648);
+		result
+	}
+	
+	
+	// Returns the number of 8-bit data (i.e. not error correction) codewords contained in any
+	// QR Code of the given version number and error correction level, with remainder bits discarded.
+	// This stateless pure function could be implemented as a (40*4)-cell lookup table.
+	fn get_num_data_codewords(ver: Version, ecl: QrCodeEcc) -> usize {
+		QrCode::get_num_raw_data_modules(ver) / 8
+			- QrCode::table_get(&ECC_CODEWORDS_PER_BLOCK    , ver, ecl)
+			* QrCode::table_get(&NUM_ERROR_CORRECTION_BLOCKS, ver, ecl)
+	}
+	
+	
+	// Returns an entry from the given table based on the given values.
+	fn table_get(table: &'static [[i8; 41]; 4], ver: Version, ecl: QrCodeEcc) -> usize {
+		table[ecl.ordinal()][usize::from(ver.value())] as usize
+	}
+	
+	
+	// Returns a Reed-Solomon ECC generator polynomial for the given degree. This could be
+	// implemented as a lookup table over all possible parameter values, instead of as an algorithm.
+	fn reed_solomon_compute_divisor(degree: usize) -> Vec<u8> {
+		assert!(1 <= degree && degree <= 255, "Degree out of range");
+		// Polynomial coefficients are stored from highest to lowest power, excluding the leading term which is always 1.
+		// For example the polynomial x^3 + 255x^2 + 8x + 93 is stored as the uint8 array [255, 8, 93].
+		let mut result = vec![0u8; degree - 1];
+		result.push(1);  // Start off with the monomial x^0
+		
+		// Compute the product polynomial (x - r^0) * (x - r^1) * (x - r^2) * ... * (x - r^{degree-1}),
+		// and drop the highest monomial term which is always 1x^degree.
+		// Note that r = 0x02, which is a generator element of this field GF(2^8/0x11D).
+		let mut root: u8 = 1;
+		for _ in 0 .. degree {  // Unused variable i
+			// Multiply the current product by (x - r^i)
+			for j in 0 .. degree {
+				result[j] = QrCode::reed_solomon_multiply(result[j], root);
+				if j + 1 < result.len() {
+					result[j] ^= result[j + 1];
+				}
+			}
+			root = QrCode::reed_solomon_multiply(root, 0x02);
+		}
+		result
+	}
+	
+	
+	// Returns the Reed-Solomon error correction codeword for the given data and divisor polynomials.
+	fn reed_solomon_compute_remainder(data: &[u8], divisor: &[u8]) -> Vec<u8> {
+		let mut result = vec![0u8; divisor.len()];
+		for b in data {  // Polynomial division
+			let factor: u8 = b ^ result.remove(0);
+			result.push(0);
+			for (x, &y) in result.iter_mut().zip(divisor.iter()) {
+				*x ^= QrCode::reed_solomon_multiply(y, factor);
+			}
+		}
+		result
+	}
+	
+	
+	// Returns the product of the two given field elements modulo GF(2^8/0x11D).
+	// All inputs are valid. This could be implemented as a 256*256 lookup table.
+	fn reed_solomon_multiply(x: u8, y: u8) -> u8 {
+		// Russian peasant multiplication
+		let mut z: u8 = 0;
+		for i in (0 .. 8).rev() {
+			z = (z << 1) ^ ((z >> 7) * 0x1D);
+			z ^= ((y >> i) & 1) * x;
+		}
+		z
+	}
+	
+	
+	// Can only be called immediately after a white run is added, and
+	// returns either 0, 1, or 2. A helper function for get_penalty_score().
+	fn finder_penalty_count_patterns(&self, runhistory: &[i32;7]) -> i32 {
+		let n = runhistory[1];
+		assert!(n <= self.size * 3);
+		let core = n > 0 && runhistory[2] == n && runhistory[3] == n * 3 && runhistory[4] == n && runhistory[5] == n;
+		( i32::from(core && runhistory[0] >= n * 4 && runhistory[6] >= n)
+		+ i32::from(core && runhistory[6] >= n * 4 && runhistory[0] >= n))
+	}
+	
+	
+	// Must be called at the end of a line (row or column) of modules. A helper function for get_penalty_score().
+	fn finder_penalty_terminate_and_count(&self, currentruncolor: bool, mut currentrunlength: i32, runhistory: &mut [i32;7]) -> i32 {
+		if currentruncolor {  // Terminate black run
+			QrCode::finder_penalty_add_history(currentrunlength, runhistory);
+			currentrunlength = 0;
+		}
+		currentrunlength += self.size;  // Add white border to final run
+		QrCode::finder_penalty_add_history(currentrunlength, runhistory);
+		self.finder_penalty_count_patterns(runhistory)
+	}
+	
+	
+	// Pushes the given value to the front and drops the last value. A helper function for get_penalty_score().
+	fn finder_penalty_add_history(currentrunlength: i32, runhistory: &mut [i32;7]) {
+		for i in (0 .. runhistory.len()-1).rev() {
+			runhistory[i + 1] = runhistory[i];
+		}
+		runhistory[0] = currentrunlength;
+	}
+	
+}
+
+
+/*---- Cconstants and tables ----*/
+
+/// The minimum version number supported in the QR Code Model 2 standard.
+pub const QrCode_MIN_VERSION: Version = Version( 1);
+
+/// The maximum version number supported in the QR Code Model 2 standard.
+pub const QrCode_MAX_VERSION: Version = Version(40);
+
+
+// For use in get_penalty_score(), when evaluating which mask is best.
+const PENALTY_N1: i32 =  3;
+const PENALTY_N2: i32 =  3;
+const PENALTY_N3: i32 = 40;
+const PENALTY_N4: i32 = 10;
+
+
+static ECC_CODEWORDS_PER_BLOCK: [[i8; 41]; 4] = [
+	// Version: (note that index 0 is for padding, and is set to an illegal value)
+	//0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
+	[-1,  7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],  // Low
+	[-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28],  // Medium
+	[-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],  // Quartile
+	[-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],  // High
+];
+
+static NUM_ERROR_CORRECTION_BLOCKS: [[i8; 41]; 4] = [
+	// Version: (note that index 0 is for padding, and is set to an illegal value)
+	//0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
+	[-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4,  4,  4,  4,  4,  6,  6,  6,  6,  7,  8,  8,  9,  9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25],  // Low
+	[-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5,  5,  8,  9,  9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49],  // Medium
+	[-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8,  8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68],  // Quartile
+	[-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81],  // High
+];
+
+
+
+/*---- QrCodeEcc functionality ----*/
+
+/// The error correction level in a QR Code symbol.
+#[derive(Clone, Copy)]
+pub enum QrCodeEcc {
+	/// The QR Code can tolerate about  7% erroneous codewords.
+	Low     ,
+	/// The QR Code can tolerate about 15% erroneous codewords.
+	Medium  ,
+	/// The QR Code can tolerate about 25% erroneous codewords.
+	Quartile,
+	/// The QR Code can tolerate about 30% erroneous codewords.
+	High    ,
+}
+
+
+impl QrCodeEcc {
+	
+	// Returns an unsigned 2-bit integer (in the range 0 to 3).
+	fn ordinal(self) -> usize {
+		use QrCodeEcc::*;
+		match self {
+			Low      => 0,
+			Medium   => 1,
+			Quartile => 2,
+			High     => 3,
+		}
+	}
+	
+	
+	// Returns an unsigned 2-bit integer (in the range 0 to 3).
+	fn format_bits(self) -> u32 {
+		use QrCodeEcc::*;
+		match self {
+			Low      => 1,
+			Medium   => 0,
+			Quartile => 3,
+			High     => 2,
+		}
+	}
+	
+}
+
+
+
+/*---- QrSegment functionality ----*/
+
+/// A segment of character/binary/control data in a QR Code symbol.
+/// 
+/// Instances of this struct are immutable.
+/// 
+/// The mid-level way to create a segment is to take the payload data
+/// and call a static factory function such as `QrSegment::make_numeric()`.
+/// The low-level way to create a segment is to custom-make the bit buffer
+/// and call the `QrSegment::new()` constructor with appropriate values.
+/// 
+/// This segment struct imposes no length restrictions, but QR Codes have restrictions.
+/// Even in the most favorable conditions, a QR Code can only hold 7089 characters of data.
+/// Any segment longer than this is meaningless for the purpose of generating QR Codes.
+#[derive(Clone)]
+pub struct QrSegment {
+	
+	// The mode indicator of this segment. Accessed through mode().
+	mode: QrSegmentMode,
+	
+	// The length of this segment's unencoded data. Measured in characters for
+	// numeric/alphanumeric/kanji mode, bytes for byte mode, and 0 for ECI mode.
+	// Not the same as the data's bit length. Accessed through num_chars().
+	numchars: usize,
+	
+	// The data bits of this segment. Accessed through data().
+	data: Vec<bool>,
+	
+}
+
+
+impl QrSegment {
+	
+	/*---- Static factory functions (mid level) ----*/
+	
+	/// Returns a segment representing the given binary data encoded in byte mode.
+	/// 
+	/// All input byte slices are acceptable.
+	/// 
+	/// Any text string can be converted to UTF-8 bytes and encoded as a byte mode segment.
+	pub fn make_bytes(data: &[u8]) -> Self {
+		let mut bb = BitBuffer(Vec::with_capacity(data.len() * 8));
+		for &b in data {
+			bb.append_bits(u32::from(b), 8);
+		}
+		QrSegment::new(QrSegmentMode::Byte, data.len(), bb.0)
+	}
+	
+	
+	/// Returns a segment representing the given string of decimal digits encoded in numeric mode.
+	/// 
+	/// Panics if the string contains non-digit characters.
+	pub fn make_numeric(text: &[char]) -> Self {
+		let mut bb = BitBuffer(Vec::with_capacity(text.len() * 3 + (text.len() + 2) / 3));
+		let mut accumdata: u32 = 0;
+		let mut accumcount: u8 = 0;
+		for &c in text {
+			assert!('0' <= c && c <= '9', "String contains non-numeric characters");
+			accumdata = accumdata * 10 + (u32::from(c) - u32::from('0'));
+			accumcount += 1;
+			if accumcount == 3 {
+				bb.append_bits(accumdata, 10);
+				accumdata = 0;
+				accumcount = 0;
+			}
+		}
+		if accumcount > 0 {  // 1 or 2 digits remaining
+			bb.append_bits(accumdata, accumcount * 3 + 1);
+		}
+		QrSegment::new(QrSegmentMode::Numeric, text.len(), bb.0)
+	}
+	
+	
+	/// Returns a segment representing the given text string encoded in alphanumeric mode.
+	/// 
+	/// The characters allowed are: 0 to 9, A to Z (uppercase only), space,
+	/// dollar, percent, asterisk, plus, hyphen, period, slash, colon.
+	/// 
+	/// Panics if the string contains non-encodable characters.
+	pub fn make_alphanumeric(text: &[char]) -> Self {
+		let mut bb = BitBuffer(Vec::with_capacity(text.len() * 5 + (text.len() + 1) / 2));
+		let mut accumdata: u32 = 0;
+		let mut accumcount: u32 = 0;
+		for &c in text {
+			let i = ALPHANUMERIC_CHARSET.iter().position(|&x| x == c)
+				.expect("String contains unencodable characters in alphanumeric mode");
+			accumdata = accumdata * 45 + (i as u32);
+			accumcount += 1;
+			if accumcount == 2 {
+				bb.append_bits(accumdata, 11);
+				accumdata = 0;
+				accumcount = 0;
+			}
+		}
+		if accumcount > 0 {  // 1 character remaining
+			bb.append_bits(accumdata, 6);
+		}
+		QrSegment::new(QrSegmentMode::Alphanumeric, text.len(), bb.0)
+	}
+	
+	
+	/// Returns a list of zero or more segments to represent the given Unicode text string.
+	/// 
+	/// The result may use various segment modes and switch
+	/// modes to optimize the length of the bit stream.
+	pub fn make_segments(text: &[char]) -> Vec<Self> {
+		if text.is_empty() {
+			vec![]
+		} else if QrSegment::is_numeric(text) {
+			vec![QrSegment::make_numeric(text)]
+		} else if QrSegment::is_alphanumeric(text) {
+			vec![QrSegment::make_alphanumeric(text)]
+		} else {
+			let s: String = text.iter().cloned().collect();
+			vec![QrSegment::make_bytes(s.as_bytes())]
+		}
+	}
+	
+	
+	/// Returns a segment representing an Extended Channel Interpretation
+	/// (ECI) designator with the given assignment value.
+	pub fn make_eci(assignval: u32) -> Self {
+		let mut bb = BitBuffer(Vec::with_capacity(24));
+		if assignval < (1 << 7) {
+			bb.append_bits(assignval, 8);
+		} else if assignval < (1 << 14) {
+			bb.append_bits(2, 2);
+			bb.append_bits(assignval, 14);
+		} else if assignval < 1_000_000 {
+			bb.append_bits(6, 3);
+			bb.append_bits(assignval, 21);
+		} else {
+			panic!("ECI assignment value out of range");
+		}
+		QrSegment::new(QrSegmentMode::Eci, 0, bb.0)
+	}
+	
+	
+	/*---- Constructor (low level) ----*/
+	
+	/// Creates a new QR Code segment with the given attributes and data.
+	/// 
+	/// The character count (numchars) must agree with the mode and
+	/// the bit buffer length, but the constraint isn't checked.
+	pub fn new(mode: QrSegmentMode, numchars: usize, data: Vec<bool>) -> Self {
+		Self { mode, numchars, data }
+	}
+	
+	
+	/*---- Instance field getters ----*/
+	
+	/// Returns the mode indicator of this segment.
+	pub fn mode(&self) -> QrSegmentMode {
+		self.mode
+	}
+	
+	
+	/// Returns the character count field of this segment.
+	pub fn num_chars(&self) -> usize {
+		self.numchars
+	}
+	
+	
+	/// Returns the data bits of this segment.
+	pub fn data(&self) -> &Vec<bool> {
+		&self.data
+	}
+	
+	
+	/*---- Other static functions ----*/
+	
+	// Calculates and returns the number of bits needed to encode the given
+	// segments at the given version. The result is None if a segment has too many
+	// characters to fit its length field, or the total bits exceeds usize::MAX.
+	fn get_total_bits(segs: &[Self], version: Version) -> Option<usize> {
+		let mut result: usize = 0;
+		for seg in segs {
+			let ccbits = seg.mode.num_char_count_bits(version);
+			if seg.numchars >= 1 << ccbits {
+				return None;  // The segment's length doesn't fit the field's bit width
+			}
+			result = result.checked_add(4 + usize::from(ccbits) + seg.data.len())?;
+		}
+		Some(result)
+	}
+	
+	
+	// Tests whether the given string can be encoded as a segment in alphanumeric mode.
+	// A string is encodable iff each character is in the following set: 0 to 9, A to Z
+	// (uppercase only), space, dollar, percent, asterisk, plus, hyphen, period, slash, colon.
+	fn is_alphanumeric(text: &[char]) -> bool {
+		text.iter().all(|c| ALPHANUMERIC_CHARSET.contains(c))
+	}
+	
+	
+	// Tests whether the given string can be encoded as a segment in numeric mode.
+	// A string is encodable iff each character is in the range 0 to 9.
+	fn is_numeric(text: &[char]) -> bool {
+		text.iter().all(|&c| '0' <= c && c <= '9')
+	}
+	
+}
+
+
+// The set of all legal characters in alphanumeric mode,
+// where each character value maps to the index in the string.
+static ALPHANUMERIC_CHARSET: [char; 45] = ['0','1','2','3','4','5','6','7','8','9',
+	'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
+	' ','$','%','*','+','-','.','/',':'];
+
+
+
+/*---- QrSegmentMode functionality ----*/
+
+/// Describes how a segment's data bits are interpreted.
+#[derive(Clone, Copy)]
+pub enum QrSegmentMode {
+	Numeric,
+	Alphanumeric,
+	Byte,
+	Kanji,
+	Eci,
+}
+
+
+impl QrSegmentMode {
+	
+	// Returns an unsigned 4-bit integer value (range 0 to 15)
+	// representing the mode indicator bits for this mode object.
+	fn mode_bits(self) -> u32 {
+		use QrSegmentMode::*;
+		match self {
+			Numeric      => 0x1,
+			Alphanumeric => 0x2,
+			Byte         => 0x4,
+			Kanji        => 0x8,
+			Eci          => 0x7,
+		}
+	}
+	
+	
+	// Returns the bit width of the character count field for a segment in this mode
+	// in a QR Code at the given version number. The result is in the range [0, 16].
+	fn num_char_count_bits(self, ver: Version) -> u8 {
+		use QrSegmentMode::*;
+		(match self {
+			Numeric      => [10, 12, 14],
+			Alphanumeric => [ 9, 11, 13],
+			Byte         => [ 8, 16, 16],
+			Kanji        => [ 8, 10, 12],
+			Eci          => [ 0,  0,  0],
+		})[usize::from((ver.value() + 7) / 17)]
+	}
+	
+}
+
+
+
+/*---- Bit buffer functionality ----*/
+
+/// An appendable sequence of bits (0s and 1s).
+/// 
+/// Mainly used by QrSegment.
+pub struct BitBuffer(pub Vec<bool>);
+
+
+impl BitBuffer {
+	/// Appends the given number of low-order bits of the given value to this buffer.
+	/// 
+	/// Requires len &#x2264; 31 and val &lt; 2<sup>len</sup>.
+	pub fn append_bits(&mut self, val: u32, len: u8) {
+		assert!(len <= 31 && (val >> len) == 0, "Value out of range");
+		self.0.extend((0 .. i32::from(len)).rev().map(|i| get_bit(val, i)));  // Append bit by bit
+	}
+}
+
+
+
+/*---- Miscellaneous values ----*/
+
+/// The error type when the supplied data does not fit any QR Code version.
+///
+/// Ways to handle this exception include:
+/// 
+/// - Decrease the error correction level if it was greater than `QrCodeEcc::Low`.
+/// - If the `encode_segments_advanced()` function was called, then increase the maxversion
+///   argument if it was less than `QrCode_MAX_VERSION`. (This advice does not apply to the
+///   other factory functions because they search all versions up to `QrCode_MAX_VERSION`.)
+/// - Split the text data into better or optimal segments in order to reduce the number of bits required.
+/// - Change the text or binary data to be shorter.
+/// - Change the text to fit the character set of a particular segment mode (e.g. alphanumeric).
+/// - Propagate the error upward to the caller/user.
+#[derive(Debug, Clone)]
+pub struct DataTooLong(String);
+
+impl std::error::Error for DataTooLong {
+	fn description(&self) -> &str {
+		&self.0
+	}
+}
+
+impl std::fmt::Display for DataTooLong {
+	fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
+		f.write_str(&self.0)
+	}
+}
+
+
+/// A number between 1 and 40 (inclusive).
+#[derive(Copy, Clone)]
+pub struct Version(u8);
+
+impl Version {
+	/// Creates a version object from the given number.
+	/// 
+	/// Panics if the number is outside the range [1, 40].
+	pub fn new(ver: u8) -> Self {
+		assert!(QrCode_MIN_VERSION.value() <= ver && ver <= QrCode_MAX_VERSION.value(), "Version number out of range");
+		Self(ver)
+	}
+	
+	/// Returns the value, which is in the range [1, 40].
+	pub fn value(self) -> u8 {
+		self.0
+	}
+}
+
+
+/// A number between 0 and 7 (inclusive).
+#[derive(Copy, Clone)]
+pub struct Mask(u8);
+
+impl Mask {
+	/// Creates a mask object from the given number.
+	/// 
+	/// Panics if the number is outside the range [0, 7].
+	pub fn new(mask: u8) -> Self {
+		assert!(mask <= 7, "Mask value out of range");
+		Self(mask)
+	}
+	
+	/// Returns the value, which is in the range [0, 7].
+	pub fn value(self) -> u8 {
+		self.0
+	}
+}
+
+
+// Returns true iff the i'th bit of x is set to 1.
+fn get_bit(x: u32, i: i32) -> bool {
+	(x >> i) & 1 != 0
+}
diff --git a/Telegram/ThirdParty/QR/typescript-javascript/build.sh b/Telegram/ThirdParty/QR/typescript-javascript/build.sh
new file mode 100644
index 0000000..f1689aa
--- /dev/null
+++ b/Telegram/ThirdParty/QR/typescript-javascript/build.sh
@@ -0,0 +1,30 @@
+# 
+# Build script for QR Code generator (TypeScript)
+# 
+# Copyright (c) Project Nayuki. (MIT License)
+# https://www.nayuki.io/page/qr-code-generator-library
+# 
+# Permission is hereby granted, free of charge, to any person obtaining a copy of
+# this software and associated documentation files (the "Software"), to deal in
+# the Software without restriction, including without limitation the rights to
+# use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+# the Software, and to permit persons to whom the Software is furnished to do so,
+# subject to the following conditions:
+# - The above copyright notice and this permission notice shall be included in
+#   all copies or substantial portions of the Software.
+# - The Software is provided "as is", without warranty of any kind, express or
+#   implied, including but not limited to the warranties of merchantability,
+#   fitness for a particular purpose and noninfringement. In no event shall the
+#   authors or copyright holders be liable for any claim, damages or other
+#   liability, whether in an action of contract, tort or otherwise, arising from,
+#   out of or in connection with the Software or the use or other dealings in the
+#   Software.
+# 
+
+tsc --strict --lib DOM,DOM.Iterable,ES6 --target ES6 qrcodegen.ts qrcodegen-input-demo.ts
+tsc --strict --lib DOM,DOM.Iterable,ES6 --target ES6 qrcodegen.ts qrcodegen-output-demo.ts
+
+if [ '!' -d node_modules ]; then
+	npm install @types/node
+fi
+tsc --strict --target ES2017 --outFile qrcodegen-worker.js qrcodegen.ts qrcodegen-worker.ts
diff --git a/Telegram/ThirdParty/QR/typescript-javascript/qrcodegen-input-demo.html b/Telegram/ThirdParty/QR/typescript-javascript/qrcodegen-input-demo.html
new file mode 100644
index 0000000..d136412
--- /dev/null
+++ b/Telegram/ThirdParty/QR/typescript-javascript/qrcodegen-input-demo.html
@@ -0,0 +1,134 @@
+<!--
+  - QR Code generator input demo (HTML+JavaScript)
+  - 
+  - Copyright (c) Project Nayuki. (MIT License)
+  - https://www.nayuki.io/page/qr-code-generator-library
+  - 
+  - Permission is hereby granted, free of charge, to any person obtaining a copy of
+  - this software and associated documentation files (the "Software"), to deal in
+  - the Software without restriction, including without limitation the rights to
+  - use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+  - the Software, and to permit persons to whom the Software is furnished to do so,
+  - subject to the following conditions:
+  - * The above copyright notice and this permission notice shall be included in
+  -   all copies or substantial portions of the Software.
+  - * The Software is provided "as is", without warranty of any kind, express or
+  -   implied, including but not limited to the warranties of merchantability,
+  -   fitness for a particular purpose and noninfringement. In no event shall the
+  -   authors or copyright holders be liable for any claim, damages or other
+  -   liability, whether in an action of contract, tort or otherwise, arising from,
+  -   out of or in connection with the Software or the use or other dealings in the
+  -   Software.
+  -->
+<!DOCTYPE html>
+<html>
+	<head>
+		<meta charset="UTF-8">
+		<title>QR Code generator input demo (JavaScript)</title>
+		<style type="text/css">
+			html {
+				font-family: sans-serif;
+			}
+			td {
+				vertical-align: top;
+				padding-top: 0.2em;
+				padding-bottom: 0.2em;
+			}
+			td:first-child {
+				white-space: pre;
+				padding-right: 0.5em;
+			}
+			input[type=radio], input[type=checkbox] {
+				margin: 0em;
+				padding: 0em;
+			}
+			input[type=radio] + label, input[type=checkbox] + label {
+				margin-right: 0.8em;
+				padding-left: 0.2em;
+			}
+		</style>
+	</head>
+	
+	<body>
+		<h1>QR Code generator input demo (JavaScript)</h1>
+		<div id="loading">
+			<p>Loading application...</p>
+			<p>(Are the JavaScript files missing?)</p>
+			<p>(The JavaScript code needs to be compiled from the TypeScript code.)</p>
+		</div>
+		<form id="loaded" style="display:none" action="#" method="get" onsubmit="return false;">
+			<table class="noborder" style="width:100%">
+				<tbody>
+					<tr>
+						<td><strong>Text string:</strong></td>
+						<td style="width:100%"><textarea placeholder="Enter your text to be put into the QR Code" id="text-input" style="width:100%; max-width:30em; height:5em; font-family:inherit"></textarea></td>
+					</tr>
+					<tr>
+						<td><strong>QR Code:</strong></td>
+						<td>
+							<canvas id="qrcode-canvas" style="padding:1em; background-color:#E8E8E8"></canvas>
+							<svg id="qrcode-svg" style="width:30em; height:30em; padding:1em; background-color:#E8E8E8">
+								<rect width="100%" height="100%" fill="#FFFFFF" stroke-width="0"></rect>
+								<path d="" fill="#000000" stroke-width="0"></path>
+							</svg>
+						</td>
+					</tr>
+					<tr>
+						<td><strong>Error correction:</strong></td>
+						<td>
+							<input type="radio" name="errcorlvl" id="errcorlvl-low" checked="checked"><label for="errcorlvl-low">Low</label>
+							<input type="radio" name="errcorlvl" id="errcorlvl-medium"><label for="errcorlvl-medium">Medium</label>
+							<input type="radio" name="errcorlvl" id="errcorlvl-quartile"><label for="errcorlvl-quartile">Quartile</label>
+							<input type="radio" name="errcorlvl" id="errcorlvl-high"><label for="errcorlvl-high">High</label>
+						</td>
+					</tr>
+					<tr>
+						<td>Output format:</td>
+						<td>
+							<input type="radio" name="output-format" id="output-format-bitmap" checked="checked"><label for="output-format-bitmap">Bitmap</label>
+							<input type="radio" name="output-format" id="output-format-vector"><label for="output-format-vector">Vector</label>
+						</td>
+					</tr>
+					<tr>
+						<td>Border:</td>
+						<td><input type="number" value="4" min="0" max="100" step="1" id="border-input" style="width:4em"> modules</td>
+					</tr>
+					<tr id="scale-row">
+						<td>Scale:</td>
+						<td><input type="number" value="8" min="1" max="30" step="1" id="scale-input" style="width:4em"> pixels per module</td>
+					</tr>
+					<tr>
+						<td>Version range:</td>
+						<td>
+							Minimum = <input type="number" value="1"  min="1" max="40" step="1" id="version-min-input" style="width:4em" oninput="app.handleVersionMinMax('min');">,
+							maximum = <input type="number" value="40" min="1" max="40" step="1" id="version-max-input" style="width:4em" oninput="app.handleVersionMinMax('max');">
+						</td>
+					</tr>
+					<tr>
+						<td>Mask pattern:</td>
+						<td><input type="number" value="-1" min="-1" max="7" step="1" id="mask-input" style="width:4em"> (−1 for automatic, 0 to 7 for manual)</td>
+					</tr>
+					<tr>
+						<td>Boost ECC:</td>
+						<td><input type="checkbox" checked="checked" id="boost-ecc-input"><label for="boost-ecc-input">Increase <abbr title="error-correcting code">ECC</abbr> level within same version</label></td>
+					</tr>
+					<tr>
+						<td>Statistics:</td>
+						<td id="statistics-output" style="white-space:pre"></td>
+					</tr>
+					<tr id="svg-xml-row">
+						<td>SVG XML code:</td>
+						<td>
+							<textarea id="svg-xml-output" readonly="readonly" style="width:100%; max-width:50em; height:15em; font-family:monospace"></textarea>
+						</td>
+					</tr>
+				</tbody>
+			</table>
+		</form>
+		<script type="application/javascript" src="qrcodegen.js"></script>
+		<script type="application/javascript" src="qrcodegen-input-demo.js"></script>
+		
+		<hr>
+		<p>Copyright © Project Nayuki – <a href="https://www.nayuki.io/page/qr-code-generator-library">https://www.nayuki.io/page/qr-code-generator-library</a></p>
+	</body>
+</html>
diff --git a/Telegram/ThirdParty/QR/typescript-javascript/qrcodegen-input-demo.ts b/Telegram/ThirdParty/QR/typescript-javascript/qrcodegen-input-demo.ts
new file mode 100644
index 0000000..ea1c4c6
--- /dev/null
+++ b/Telegram/ThirdParty/QR/typescript-javascript/qrcodegen-input-demo.ts
@@ -0,0 +1,185 @@
+/* 
+ * QR Code generator input demo (TypeScript)
+ * 
+ * Copyright (c) Project Nayuki. (MIT License)
+ * https://www.nayuki.io/page/qr-code-generator-library
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ * - The above copyright notice and this permission notice shall be included in
+ *   all copies or substantial portions of the Software.
+ * - The Software is provided "as is", without warranty of any kind, express or
+ *   implied, including but not limited to the warranties of merchantability,
+ *   fitness for a particular purpose and noninfringement. In no event shall the
+ *   authors or copyright holders be liable for any claim, damages or other
+ *   liability, whether in an action of contract, tort or otherwise, arising from,
+ *   out of or in connection with the Software or the use or other dealings in the
+ *   Software.
+ */
+
+"use strict";
+
+
+namespace app {
+	
+	function initialize(): void {
+		getElem("loading").style.display = "none";
+		getElem("loaded").style.removeProperty("display");
+		let elems = document.querySelectorAll("input[type=number], textarea");
+		for (let el of elems) {
+			if (el.id.indexOf("version-") != 0)
+				(el as any).oninput = redrawQrCode;
+		}
+		elems = document.querySelectorAll("input[type=radio], input[type=checkbox]");
+		for (let el of elems)
+			(el as HTMLInputElement).onchange = redrawQrCode;
+		redrawQrCode();
+	}
+	
+	
+	function redrawQrCode(): void {
+		// Show/hide rows based on bitmap/vector image output
+		const bitmapOutput: boolean = getInput("output-format-bitmap").checked;
+		const scaleRow : HTMLElement = getElem("scale-row");
+		const svgXmlRow: HTMLElement = getElem("svg-xml-row");
+		if (bitmapOutput) {
+			scaleRow.style.removeProperty("display");
+			svgXmlRow.style.display = "none";
+		} else {
+			scaleRow.style.display = "none";
+			svgXmlRow.style.removeProperty("display");
+		}
+		const svgXml = getElem("svg-xml-output") as HTMLTextAreaElement;
+		svgXml.value = "";
+		
+		// Reset output images in case of early termination
+		const canvas = getElem("qrcode-canvas") as HTMLCanvasElement;
+		const svg = (document.getElementById("qrcode-svg") as Element) as SVGElement;
+		canvas.style.display = "none";
+		svg.style.display = "none";
+		
+		// Returns a QrCode.Ecc object based on the radio buttons in the HTML form.
+		function getInputErrorCorrectionLevel(): qrcodegen.QrCode.Ecc {
+			if (getInput("errcorlvl-medium").checked)
+				return qrcodegen.QrCode.Ecc.MEDIUM;
+			else if (getInput("errcorlvl-quartile").checked)
+				return qrcodegen.QrCode.Ecc.QUARTILE;
+			else if (getInput("errcorlvl-high").checked)
+				return qrcodegen.QrCode.Ecc.HIGH;
+			else  // In case no radio button is depressed
+				return qrcodegen.QrCode.Ecc.LOW;
+		}
+		
+		// Get form inputs and compute QR Code
+		const ecl: qrcodegen.QrCode.Ecc = getInputErrorCorrectionLevel();
+		const text: string = (getElem("text-input") as HTMLTextAreaElement).value;
+		const segs: Array<qrcodegen.QrSegment> = qrcodegen.QrSegment.makeSegments(text);
+		const minVer: number = parseInt(getInput("version-min-input").value, 10);
+		const maxVer: number = parseInt(getInput("version-max-input").value, 10);
+		const mask: number = parseInt(getInput("mask-input").value, 10);
+		const boostEcc: boolean = getInput("boost-ecc-input").checked;
+		const qr: qrcodegen.QrCode = qrcodegen.QrCode.encodeSegments(segs, ecl, minVer, maxVer, mask, boostEcc);
+		
+		// Draw image output
+		const border: number = parseInt(getInput("border-input").value, 10);
+		if (border < 0 || border > 100)
+			return;
+		if (bitmapOutput) {
+			const scale: number = parseInt(getInput("scale-input").value, 10);
+			if (scale <= 0 || scale > 30)
+				return;
+			qr.drawCanvas(scale, border, canvas);
+			canvas.style.removeProperty("display");
+		} else {
+			const code: string = qr.toSvgString(border);
+			const viewBox: string = (/ viewBox="([^"]*)"/.exec(code) as RegExpExecArray)[1];
+			const pathD: string = (/ d="([^"]*)"/.exec(code) as RegExpExecArray)[1];
+			svg.setAttribute("viewBox", viewBox);
+			(svg.querySelector("path") as Element).setAttribute("d", pathD);
+			svg.style.removeProperty("display");
+			svgXml.value = qr.toSvgString(border);
+		}
+		
+		// Returns a string to describe the given list of segments.
+		function describeSegments(segs: Array<qrcodegen.QrSegment>): string {
+			if (segs.length == 0)
+				return "none";
+			else if (segs.length == 1) {
+				const mode: qrcodegen.QrSegment.Mode = segs[0].mode;
+				const Mode = qrcodegen.QrSegment.Mode;
+				if (mode == Mode.NUMERIC     )  return "numeric";
+				if (mode == Mode.ALPHANUMERIC)  return "alphanumeric";
+				if (mode == Mode.BYTE        )  return "byte";
+				if (mode == Mode.KANJI       )  return "kanji";
+				return "unknown";
+			} else
+				return "multiple";
+		}
+		
+		// Returns the number of Unicode code points in the given UTF-16 string.
+		function countUnicodeChars(str: string): number {
+			let result: number = 0;
+			for (let i = 0; i < str.length; i++, result++) {
+				const c: number = str.charCodeAt(i);
+				if (c < 0xD800 || c >= 0xE000)
+					continue;
+				else if (0xD800 <= c && c < 0xDC00 && i + 1 < str.length) {  // High surrogate
+					i++;
+					const d: number = str.charCodeAt(i);
+					if (0xDC00 <= d && d < 0xE000)  // Low surrogate
+						continue;
+				}
+				throw "Invalid UTF-16 string";
+			}
+			return result;
+		}
+		
+		// Show the QR Code symbol's statistics as a string
+		getElem("statistics-output").textContent = `QR Code version = ${qr.version}, ` +
+			`mask pattern = ${qr.mask}, ` +
+			`character count = ${countUnicodeChars(text)},\n` +
+			`encoding mode = ${describeSegments(segs)}, ` +
+			`error correction = level ${"LMQH".charAt(qr.errorCorrectionLevel.ordinal)}, ` +
+			`data bits = ${qrcodegen.QrSegment.getTotalBits(segs, qr.version) as number}.`;
+	}
+	
+	
+	export function handleVersionMinMax(which: "min"|"max"): void {
+		const minElem: HTMLInputElement = getInput("version-min-input");
+		const maxElem: HTMLInputElement = getInput("version-max-input");
+		let minVal: number = parseInt(minElem.value, 10);
+		let maxVal: number = parseInt(maxElem.value, 10);
+		minVal = Math.max(Math.min(minVal, qrcodegen.QrCode.MAX_VERSION), qrcodegen.QrCode.MIN_VERSION);
+		maxVal = Math.max(Math.min(maxVal, qrcodegen.QrCode.MAX_VERSION), qrcodegen.QrCode.MIN_VERSION);
+		if (which == "min" && minVal > maxVal)
+			maxVal = minVal;
+		else if (which == "max" && maxVal < minVal)
+			minVal = maxVal;
+		minElem.value = minVal.toString();
+		maxElem.value = maxVal.toString();
+		redrawQrCode();
+	}
+	
+	
+	function getElem(id: string): HTMLElement {
+		const result: HTMLElement|null = document.getElementById(id);
+		if (result instanceof HTMLElement)
+			return result;
+		throw "Assertion error";
+	}
+	
+	
+	function getInput(id: string): HTMLInputElement {
+		const result: HTMLElement = getElem(id);
+		if (result instanceof HTMLInputElement)
+			return result;
+		throw "Assertion error";
+	}
+	
+	
+	initialize();
+}
diff --git a/Telegram/ThirdParty/QR/typescript-javascript/qrcodegen-output-demo.html b/Telegram/ThirdParty/QR/typescript-javascript/qrcodegen-output-demo.html
new file mode 100644
index 0000000..f356d6f
--- /dev/null
+++ b/Telegram/ThirdParty/QR/typescript-javascript/qrcodegen-output-demo.html
@@ -0,0 +1,56 @@
+<!--
+  - QR Code generator output demo (HTML+JavaScript)
+  - 
+  - Copyright (c) Project Nayuki. (MIT License)
+  - https://www.nayuki.io/page/qr-code-generator-library
+  - 
+  - Permission is hereby granted, free of charge, to any person obtaining a copy of
+  - this software and associated documentation files (the "Software"), to deal in
+  - the Software without restriction, including without limitation the rights to
+  - use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+  - the Software, and to permit persons to whom the Software is furnished to do so,
+  - subject to the following conditions:
+  - * The above copyright notice and this permission notice shall be included in
+  -   all copies or substantial portions of the Software.
+  - * The Software is provided "as is", without warranty of any kind, express or
+  -   implied, including but not limited to the warranties of merchantability,
+  -   fitness for a particular purpose and noninfringement. In no event shall the
+  -   authors or copyright holders be liable for any claim, damages or other
+  -   liability, whether in an action of contract, tort or otherwise, arising from,
+  -   out of or in connection with the Software or the use or other dealings in the
+  -   Software.
+  -->
+<!DOCTYPE html>
+<html>
+	<head>
+		<meta charset="UTF-8">
+		<title>QR Code generator output demo (JavaScript)</title>
+		<style type="text/css">
+			html {
+				font-family: sans-serif;
+			}
+			#output p {
+				margin-top: 0.5em;
+				margin-bottom: 0.5em;
+			}
+			#output canvas {
+				display: block;
+				margin-bottom: 1.5em;
+				border: 1px solid #C0C0C0;
+			}
+		</style>
+	</head>
+	
+	<body>
+		<h1>QR Code generator output demo (JavaScript)</h1>
+		<div id="output">
+			<p>Loading application...</p>
+			<p>(Are the JavaScript files missing?)</p>
+			<p>(The JavaScript code needs to be compiled from the TypeScript code.)</p>
+		</div>
+		<script type="application/javascript" src="qrcodegen.js"></script>
+		<script type="application/javascript" src="qrcodegen-output-demo.js"></script>
+		<hr>
+		<p>Copyright © Project Nayuki – <a href="https://www.nayuki.io/page/qr-code-generator-library">https://www.nayuki.io/page/qr-code-generator-library</a></p>
+	</body>
+</html>
diff --git a/Telegram/ThirdParty/QR/typescript-javascript/qrcodegen-output-demo.ts b/Telegram/ThirdParty/QR/typescript-javascript/qrcodegen-output-demo.ts
new file mode 100644
index 0000000..ffc4fbc
--- /dev/null
+++ b/Telegram/ThirdParty/QR/typescript-javascript/qrcodegen-output-demo.ts
@@ -0,0 +1,220 @@
+/* 
+ * QR Code generator output demo (TypeScript)
+ * 
+ * Copyright (c) Project Nayuki. (MIT License)
+ * https://www.nayuki.io/page/qr-code-generator-library
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ * - The above copyright notice and this permission notice shall be included in
+ *   all copies or substantial portions of the Software.
+ * - The Software is provided "as is", without warranty of any kind, express or
+ *   implied, including but not limited to the warranties of merchantability,
+ *   fitness for a particular purpose and noninfringement. In no event shall the
+ *   authors or copyright holders be liable for any claim, damages or other
+ *   liability, whether in an action of contract, tort or otherwise, arising from,
+ *   out of or in connection with the Software or the use or other dealings in the
+ *   Software.
+ */
+
+"use strict";
+
+
+namespace app {
+	
+	let outputElem = document.getElementById("output") as HTMLElement;
+	
+	
+	// The main application program.
+	function main(): void {
+		while (outputElem.firstChild !== null)
+			outputElem.removeChild(outputElem.firstChild);
+		doBasicDemo();
+		doVarietyDemo();
+		doSegmentDemo();
+		doMaskDemo();
+	}
+	
+	
+	// Creates a single QR Code, then appends it to the document.
+	function doBasicDemo(): void {
+		appendHeading("Basic");
+		const text: string = "Hello, world!";  // User-supplied Unicode text
+		const errCorLvl: qrcodegen.QrCode.Ecc = qrcodegen.QrCode.Ecc.LOW;  // Error correction level
+		const qr: qrcodegen.QrCode = qrcodegen.QrCode.encodeText(text, errCorLvl);  // Make the QR Code symbol
+		qr.drawCanvas(10, 4, appendCanvas("hello-world-QR"));  // Draw it on screen
+	}
+	
+	
+	// Creates a variety of QR Codes that exercise different features of the library, and appends each one to the document.
+	function doVarietyDemo(): void {
+		appendHeading("Variety");
+		let qr: qrcodegen.QrCode;
+		const QrCode = qrcodegen.QrCode;  // Abbreviation
+		
+		// Numeric mode encoding (3.33 bits per digit)
+		qr = QrCode.encodeText("314159265358979323846264338327950288419716939937510", QrCode.Ecc.MEDIUM);
+		qr.drawCanvas(13, 1, appendCanvas("pi-digits-QR"));
+		
+		// Alphanumeric mode encoding (5.5 bits per character)
+		qr = QrCode.encodeText("DOLLAR-AMOUNT:$39.87 PERCENTAGE:100.00% OPERATIONS:+-*/", QrCode.Ecc.HIGH);
+		qr.drawCanvas(10, 2, appendCanvas("alphanumeric-QR"));
+		
+		// Unicode text as UTF-8
+		qr = QrCode.encodeText("\u3053\u3093\u306B\u3061wa\u3001\u4E16\u754C\uFF01 \u03B1\u03B2\u03B3\u03B4", QrCode.Ecc.QUARTILE);
+		qr.drawCanvas(10, 3, appendCanvas("unicode-QR"));
+		
+		// Moderately large QR Code using longer text (from Lewis Carroll's Alice in Wonderland)
+		qr = QrCode.encodeText(
+			"Alice was beginning to get very tired of sitting by her sister on the bank, "
+			+ "and of having nothing to do: once or twice she had peeped into the book her sister was reading, "
+			+ "but it had no pictures or conversations in it, 'and what is the use of a book,' thought Alice "
+			+ "'without pictures or conversations?' So she was considering in her own mind (as well as she could, "
+			+ "for the hot day made her feel very sleepy and stupid), whether the pleasure of making a "
+			+ "daisy-chain would be worth the trouble of getting up and picking the daisies, when suddenly "
+			+ "a White Rabbit with pink eyes ran close by her.", QrCode.Ecc.HIGH);
+		qr.drawCanvas(6, 10, appendCanvas("alice-wonderland-QR"));
+	}
+	
+	
+	// Creates QR Codes with manually specified segments for better compactness.
+	function doSegmentDemo(): void {
+		appendHeading("Segment");
+		let qr: qrcodegen.QrCode;
+		let segs: Array<qrcodegen.QrSegment>;
+		const QrCode = qrcodegen.QrCode;  // Abbreviation
+		const QrSegment = qrcodegen.QrSegment;  // Abbreviation
+		
+		// Illustration "silver"
+		const silver0: string = "THE SQUARE ROOT OF 2 IS 1.";
+		const silver1: string = "41421356237309504880168872420969807856967187537694807317667973799";
+		qr = QrCode.encodeText(silver0 + silver1, QrCode.Ecc.LOW);
+		qr.drawCanvas(10, 3, appendCanvas("sqrt2-monolithic-QR"));
+		
+		segs = [
+			QrSegment.makeAlphanumeric(silver0),
+			QrSegment.makeNumeric(silver1)];
+		qr = QrCode.encodeSegments(segs, QrCode.Ecc.LOW);
+		qr.drawCanvas(10, 3, appendCanvas("sqrt2-segmented-QR"));
+		
+		// Illustration "golden"
+		const golden0: string = "Golden ratio \u03C6 = 1.";
+		const golden1: string = "6180339887498948482045868343656381177203091798057628621354486227052604628189024497072072041893911374";
+		const golden2: string = "......";
+		qr = QrCode.encodeText(golden0 + golden1 + golden2, QrCode.Ecc.LOW);
+		qr.drawCanvas(8, 5, appendCanvas("phi-monolithic-QR"));
+		
+		segs = [
+			QrSegment.makeBytes(toUtf8ByteArray(golden0)),
+			QrSegment.makeNumeric(golden1),
+			QrSegment.makeAlphanumeric(golden2)];
+		qr = QrCode.encodeSegments(segs, QrCode.Ecc.LOW);
+		qr.drawCanvas(8, 5, appendCanvas("phi-segmented-QR"));
+		
+		// Illustration "Madoka": kanji, kana, Cyrillic, full-width Latin, Greek characters
+		const madoka: string = "\u300C\u9B54\u6CD5\u5C11\u5973\u307E\u3069\u304B\u2606\u30DE\u30AE\u30AB\u300D\u3063\u3066\u3001\u3000\u0418\u0410\u0418\u3000\uFF44\uFF45\uFF53\uFF55\u3000\u03BA\u03B1\uFF1F";
+		qr = QrCode.encodeText(madoka, QrCode.Ecc.LOW);
+		qr.drawCanvas(9, 4, appendCanvas("madoka-utf8-QR"));
+		
+		const kanjiCharBits: Array<number> = [  // Kanji mode encoding (13 bits per character)
+			0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1,
+			1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
+			0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
+			0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1,
+			0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1,
+			0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0,
+			0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1,
+			0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1,
+			0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1,
+			0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1,
+			0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1,
+			0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0,
+			0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0,
+			0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1,
+			0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0,
+			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
+			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+			0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1,
+			0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0,
+			0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1,
+			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+			0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0,
+			0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1,
+			0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1,
+			0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1,
+			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+			0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0,
+			0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+			0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
+		];
+		segs = [new QrSegment(QrSegment.Mode.KANJI, kanjiCharBits.length / 13, kanjiCharBits)];
+		qr = QrCode.encodeSegments(segs, QrCode.Ecc.LOW);
+		qr.drawCanvas(9, 4, appendCanvas("madoka-kanji-QR"));
+	}
+	
+	
+	// Creates QR Codes with the same size and contents but different mask patterns.
+	function doMaskDemo(): void {
+		appendHeading("Mask");
+		let qr: qrcodegen.QrCode;
+		let segs: Array<qrcodegen.QrSegment>;
+		const QrCode = qrcodegen.QrCode;  // Abbreviation
+		
+		// Project Nayuki URL
+		segs = qrcodegen.QrSegment.makeSegments("https://www.nayuki.io/");
+		qr = QrCode.encodeSegments(segs, QrCode.Ecc.HIGH, QrCode.MIN_VERSION, QrCode.MAX_VERSION, -1, true);  // Automatic mask
+		qr.drawCanvas(8, 6, appendCanvas("project-nayuki-automask-QR"));
+		qr = QrCode.encodeSegments(segs, QrCode.Ecc.HIGH, QrCode.MIN_VERSION, QrCode.MAX_VERSION, 3, true);  // Force mask 3
+		qr.drawCanvas(8, 6, appendCanvas("project-nayuki-mask3-QR"));
+		
+		// Chinese text as UTF-8
+		segs = qrcodegen.QrSegment.makeSegments("\u7DAD\u57FA\u767E\u79D1\uFF08Wikipedia\uFF0C\u8046\u807Di/\u02CCw\u026Ak\u1D7B\u02C8pi\u02D0di.\u0259/\uFF09\u662F\u4E00"
+			+ "\u500B\u81EA\u7531\u5167\u5BB9\u3001\u516C\u958B\u7DE8\u8F2F\u4E14\u591A\u8A9E\u8A00\u7684\u7DB2\u8DEF\u767E\u79D1\u5168\u66F8\u5354\u4F5C\u8A08\u756B");
+		qr = QrCode.encodeSegments(segs, QrCode.Ecc.MEDIUM, QrCode.MIN_VERSION, QrCode.MAX_VERSION, 0, true);  // Force mask 0
+		qr.drawCanvas(10, 3, appendCanvas("unicode-mask0-QR"));
+		qr = QrCode.encodeSegments(segs, QrCode.Ecc.MEDIUM, QrCode.MIN_VERSION, QrCode.MAX_VERSION, 1, true);  // Force mask 1
+		qr.drawCanvas(10, 3, appendCanvas("unicode-mask1-QR"));
+		qr = QrCode.encodeSegments(segs, QrCode.Ecc.MEDIUM, QrCode.MIN_VERSION, QrCode.MAX_VERSION, 5, true);  // Force mask 5
+		qr.drawCanvas(10, 3, appendCanvas("unicode-mask5-QR"));
+		qr = QrCode.encodeSegments(segs, QrCode.Ecc.MEDIUM, QrCode.MIN_VERSION, QrCode.MAX_VERSION, 7, true);  // Force mask 7
+		qr.drawCanvas(10, 3, appendCanvas("unicode-mask7-QR"));
+	}
+	
+	
+	function appendHeading(text: string): void {
+		let h2 = outputElem.appendChild(document.createElement("h2"));
+		h2.textContent = text;
+	}
+	
+	
+	function appendCanvas(caption: string): HTMLCanvasElement {
+		let p = outputElem.appendChild(document.createElement("p"));
+		p.textContent = caption + ":";
+		let result = document.createElement("canvas");
+		outputElem.appendChild(result);
+		return result;
+	}
+	
+	
+	function toUtf8ByteArray(str: string): Array<number> {
+		str = encodeURI(str);
+		let result: Array<number> = [];
+		for (let i = 0; i < str.length; i++) {
+			if (str.charAt(i) != "%")
+				result.push(str.charCodeAt(i));
+			else {
+				result.push(parseInt(str.substr(i + 1, 2), 16));
+				i += 2;
+			}
+		}
+		return result;
+	}
+	
+	
+	main();
+	
+}
diff --git a/Telegram/ThirdParty/QR/typescript-javascript/qrcodegen-worker.ts b/Telegram/ThirdParty/QR/typescript-javascript/qrcodegen-worker.ts
new file mode 100644
index 0000000..92a728c
--- /dev/null
+++ b/Telegram/ThirdParty/QR/typescript-javascript/qrcodegen-worker.ts
@@ -0,0 +1,130 @@
+/* 
+ * QR Code generator test worker (TypeScript)
+ * 
+ * This program reads data and encoding parameters from standard input and writes
+ * QR Code bitmaps to standard output. The I/O format is one integer per line.
+ * Run with no command line arguments. The program is intended for automated
+ * batch testing of end-to-end functionality of this QR Code generator library.
+ * 
+ * Copyright (c) Project Nayuki. (MIT License)
+ * https://www.nayuki.io/page/qr-code-generator-library
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ * - The above copyright notice and this permission notice shall be included in
+ *   all copies or substantial portions of the Software.
+ * - The Software is provided "as is", without warranty of any kind, express or
+ *   implied, including but not limited to the warranties of merchantability,
+ *   fitness for a particular purpose and noninfringement. In no event shall the
+ *   authors or copyright holders be liable for any claim, damages or other
+ *   liability, whether in an action of contract, tort or otherwise, arising from,
+ *   out of or in connection with the Software or the use or other dealings in the
+ *   Software.
+ */
+
+"use strict";
+
+
+async function main(): Promise<void> {
+	while (true) {
+		// Read data or exit
+		const length: number = await input.readInt();
+		if (length == -1)
+			break;
+		let data: Array<number> = [];
+		for (let i = 0; i < length; i++)
+			data.push(await input.readInt());
+		
+		// Read encoding parameters
+		const errCorLvl : number = await input.readInt();
+		const minVersion: number = await input.readInt();
+		const maxVersion: number = await input.readInt();
+		const mask      : number = await input.readInt();
+		const boostEcl  : number = await input.readInt();
+		
+		// Make segments for encoding
+		let segs: Array<qrcodegen.QrSegment>;
+		if (data.every(b => b < 128)) {  // Is ASCII
+			const s: string = data.map(b => String.fromCharCode(b)).join("");
+			segs = qrcodegen.QrSegment.makeSegments(s);
+		} else
+			segs = [qrcodegen.QrSegment.makeBytes(data)];
+		
+		try {  // Try to make QR Code symbol
+			const qr = qrcodegen.QrCode.encodeSegments(
+				segs, ECC_LEVELS[errCorLvl], minVersion, maxVersion, mask, boostEcl != 0);
+			// Print grid of modules
+			await printLine(qr.version);
+			for (let y = 0; y < qr.size; y++) {
+				for (let x = 0; x < qr.size; x++)
+					await printLine(qr.getModule(x, y) ? 1 : 0);
+			}
+			
+		} catch (e) {
+			if (e == "Data too long")
+				await printLine(-1);
+		}
+	}
+}
+
+
+namespace input {
+	
+	let queue: Array<string> = [];
+	let callback: ((line:string)=>void)|null = null;
+	
+	const readline = require("readline");
+	let reader = readline.createInterface({
+		input: process.stdin,
+		terminal: false,
+	});
+	reader.on("line", (line: string) => {
+		queue.push(line);
+		if (callback !== null) {
+			callback(queue.shift() as string);
+			callback = null;
+		}
+	});
+	
+	
+	async function readLine(): Promise<string> {
+		return new Promise(resolve => {
+			if (callback !== null)
+				throw "Illegal state";
+			if (queue.length > 0)
+				resolve(queue.shift() as string);
+			else
+				callback = resolve;
+		});
+	}
+	
+	
+	export async function readInt(): Promise<number> {
+		let s = await readLine();
+		if (!/^-?\d+$/.test(s))
+			throw "Invalid number syntax";
+		return parseInt(s, 10);
+	}
+	
+}
+
+
+async function printLine(x: Object): Promise<void> {
+	return new Promise(resolve =>
+		process.stdout.write(x + "\n", "utf-8", ()=>resolve()));
+}
+
+
+const ECC_LEVELS: Array<qrcodegen.QrCode.Ecc> = [
+	qrcodegen.QrCode.Ecc.LOW,
+	qrcodegen.QrCode.Ecc.MEDIUM,
+	qrcodegen.QrCode.Ecc.QUARTILE,
+	qrcodegen.QrCode.Ecc.HIGH,
+];
+
+
+main();
diff --git a/Telegram/ThirdParty/QR/typescript-javascript/qrcodegen.ts b/Telegram/ThirdParty/QR/typescript-javascript/qrcodegen.ts
new file mode 100644
index 0000000..9b75c06
--- /dev/null
+++ b/Telegram/ThirdParty/QR/typescript-javascript/qrcodegen.ts
@@ -0,0 +1,1031 @@
+/* 
+ * QR Code generator library (TypeScript)
+ * 
+ * Copyright (c) Project Nayuki. (MIT License)
+ * https://www.nayuki.io/page/qr-code-generator-library
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ * - The above copyright notice and this permission notice shall be included in
+ *   all copies or substantial portions of the Software.
+ * - The Software is provided "as is", without warranty of any kind, express or
+ *   implied, including but not limited to the warranties of merchantability,
+ *   fitness for a particular purpose and noninfringement. In no event shall the
+ *   authors or copyright holders be liable for any claim, damages or other
+ *   liability, whether in an action of contract, tort or otherwise, arising from,
+ *   out of or in connection with the Software or the use or other dealings in the
+ *   Software.
+ */
+
+"use strict";
+
+
+namespace qrcodegen {
+	
+	type bit  = number;
+	type byte = number;
+	type int  = number;
+	
+	
+	/*---- QR Code symbol class ----*/
+	
+	/* 
+	 * A QR Code symbol, which is a type of two-dimension barcode.
+	 * Invented by Denso Wave and described in the ISO/IEC 18004 standard.
+	 * Instances of this class represent an immutable square grid of black and white cells.
+	 * The class provides static factory functions to create a QR Code from text or binary data.
+	 * The class covers the QR Code Model 2 specification, supporting all versions (sizes)
+	 * from 1 to 40, all 4 error correction levels, and 4 character encoding modes.
+	 * 
+	 * Ways to create a QR Code object:
+	 * - High level: Take the payload data and call QrCode.encodeText() or QrCode.encodeBinary().
+	 * - Mid level: Custom-make the list of segments and call QrCode.encodeSegments().
+	 * - Low level: Custom-make the array of data codeword bytes (including
+	 *   segment headers and final padding, excluding error correction codewords),
+	 *   supply the appropriate version number, and call the QrCode() constructor.
+	 * (Note that all ways require supplying the desired error correction level.)
+	 */
+	export class QrCode {
+		
+		/*-- Static factory functions (high level) --*/
+		
+		// Returns a QR Code representing the given Unicode text string at the given error correction level.
+		// As a conservative upper bound, this function is guaranteed to succeed for strings that have 738 or fewer
+		// Unicode code points (not UTF-16 code units) if the low error correction level is used. The smallest possible
+		// QR Code version is automatically chosen for the output. The ECC level of the result may be higher than the
+		// ecl argument if it can be done without increasing the version.
+		public static encodeText(text: string, ecl: QrCode.Ecc): QrCode {
+			const segs: Array<QrSegment> = qrcodegen.QrSegment.makeSegments(text);
+			return QrCode.encodeSegments(segs, ecl);
+		}
+		
+		
+		// Returns a QR Code representing the given binary data at the given error correction level.
+		// This function always encodes using the binary segment mode, not any text mode. The maximum number of
+		// bytes allowed is 2953. The smallest possible QR Code version is automatically chosen for the output.
+		// The ECC level of the result may be higher than the ecl argument if it can be done without increasing the version.
+		public static encodeBinary(data: Array<byte>, ecl: QrCode.Ecc): QrCode {
+			const seg: QrSegment = qrcodegen.QrSegment.makeBytes(data);
+			return QrCode.encodeSegments([seg], ecl);
+		}
+		
+		
+		/*-- Static factory functions (mid level) --*/
+		
+		// Returns a QR Code representing the given segments with the given encoding parameters.
+		// The smallest possible QR Code version within the given range is automatically
+		// chosen for the output. Iff boostEcl is true, then the ECC level of the result
+		// may be higher than the ecl argument if it can be done without increasing the
+		// version. The mask number is either between 0 to 7 (inclusive) to force that
+		// mask, or -1 to automatically choose an appropriate mask (which may be slow).
+		// This function allows the user to create a custom sequence of segments that switches
+		// between modes (such as alphanumeric and byte) to encode text in less space.
+		// This is a mid-level API; the high-level API is encodeText() and encodeBinary().
+		public static encodeSegments(segs: Array<QrSegment>, ecl: QrCode.Ecc,
+				minVersion: int = 1, maxVersion: int = 40,
+				mask: int = -1, boostEcl: boolean = true): QrCode {
+			
+			if (!(QrCode.MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= QrCode.MAX_VERSION)
+					|| mask < -1 || mask > 7)
+				throw "Invalid value";
+			
+			// Find the minimal version number to use
+			let version: int;
+			let dataUsedBits: int;
+			for (version = minVersion; ; version++) {
+				const dataCapacityBits: int = QrCode.getNumDataCodewords(version, ecl) * 8;  // Number of data bits available
+				const usedBits: number = QrSegment.getTotalBits(segs, version);
+				if (usedBits <= dataCapacityBits) {
+					dataUsedBits = usedBits;
+					break;  // This version number is found to be suitable
+				}
+				if (version >= maxVersion)  // All versions in the range could not fit the given data
+					throw "Data too long";
+			}
+			
+			// Increase the error correction level while the data still fits in the current version number
+			for (const newEcl of [QrCode.Ecc.MEDIUM, QrCode.Ecc.QUARTILE, QrCode.Ecc.HIGH]) {  // From low to high
+				if (boostEcl && dataUsedBits <= QrCode.getNumDataCodewords(version, newEcl) * 8)
+					ecl = newEcl;
+			}
+			
+			// Concatenate all segments to create the data bit string
+			let bb: Array<bit> = []
+			for (const seg of segs) {
+				appendBits(seg.mode.modeBits, 4, bb);
+				appendBits(seg.numChars, seg.mode.numCharCountBits(version), bb);
+				for (const b of seg.getData())
+					bb.push(b);
+			}
+			if (bb.length != dataUsedBits)
+				throw "Assertion error";
+			
+			// Add terminator and pad up to a byte if applicable
+			const dataCapacityBits: int = QrCode.getNumDataCodewords(version, ecl) * 8;
+			if (bb.length > dataCapacityBits)
+				throw "Assertion error";
+			appendBits(0, Math.min(4, dataCapacityBits - bb.length), bb);
+			appendBits(0, (8 - bb.length % 8) % 8, bb);
+			if (bb.length % 8 != 0)
+				throw "Assertion error";
+			
+			// Pad with alternating bytes until data capacity is reached
+			for (let padByte = 0xEC; bb.length < dataCapacityBits; padByte ^= 0xEC ^ 0x11)
+				appendBits(padByte, 8, bb);
+			
+			// Pack bits into bytes in big endian
+			let dataCodewords: Array<byte> = [];
+			while (dataCodewords.length * 8 < bb.length)
+				dataCodewords.push(0);
+			bb.forEach((b: bit, i: int) =>
+				dataCodewords[i >>> 3] |= b << (7 - (i & 7)));
+			
+			// Create the QR Code object
+			return new QrCode(version, ecl, dataCodewords, mask);
+		}
+		
+		
+		/*-- Fields --*/
+		
+		// The width and height of this QR Code, measured in modules, between
+		// 21 and 177 (inclusive). This is equal to version * 4 + 17.
+		public readonly size: int;
+		
+		// The modules of this QR Code (false = white, true = black).
+		// Immutable after constructor finishes. Accessed through getModule().
+		private readonly modules   : Array<Array<boolean>> = [];
+		
+		// Indicates function modules that are not subjected to masking. Discarded when constructor finishes.
+		private readonly isFunction: Array<Array<boolean>> = [];
+		
+		
+		/*-- Constructor (low level) and fields --*/
+		
+		// Creates a new QR Code with the given version number,
+		// error correction level, data codeword bytes, and mask number.
+		// This is a low-level API that most users should not use directly.
+		// A mid-level API is the encodeSegments() function.
+		public constructor(
+				// The version number of this QR Code, which is between 1 and 40 (inclusive).
+				// This determines the size of this barcode.
+				public readonly version: int,
+				
+				// The error correction level used in this QR Code.
+				public readonly errorCorrectionLevel: QrCode.Ecc,
+				
+				dataCodewords: Array<byte>,
+				
+				// The index of the mask pattern used in this QR Code, which is between 0 and 7 (inclusive).
+				// Even if a QR Code is created with automatic masking requested (mask = -1),
+				// the resulting object still has a mask value between 0 and 7.
+				public readonly mask: int) {
+			
+			// Check scalar arguments
+			if (version < QrCode.MIN_VERSION || version > QrCode.MAX_VERSION)
+				throw "Version value out of range";
+			if (mask < -1 || mask > 7)
+				throw "Mask value out of range";
+			this.size = version * 4 + 17;
+			
+			// Initialize both grids to be size*size arrays of Boolean false
+			let row: Array<boolean> = [];
+			for (let i = 0; i < this.size; i++)
+				row.push(false);
+			for (let i = 0; i < this.size; i++) {
+				this.modules   .push(row.slice());  // Initially all white
+				this.isFunction.push(row.slice());
+			}
+			
+			// Compute ECC, draw modules
+			this.drawFunctionPatterns();
+			const allCodewords: Array<byte> = this.addEccAndInterleave(dataCodewords);
+			this.drawCodewords(allCodewords);
+			
+			// Do masking
+			if (mask == -1) {  // Automatically choose best mask
+				let minPenalty: int = 1000000000;
+				for (let i = 0; i < 8; i++) {
+					this.applyMask(i);
+					this.drawFormatBits(i);
+					const penalty: int = this.getPenaltyScore();
+					if (penalty < minPenalty) {
+						mask = i;
+						minPenalty = penalty;
+					}
+					this.applyMask(i);  // Undoes the mask due to XOR
+				}
+			}
+			if (mask < 0 || mask > 7)
+				throw "Assertion error";
+			this.mask = mask;
+			this.applyMask(mask);  // Apply the final choice of mask
+			this.drawFormatBits(mask);  // Overwrite old format bits
+			
+			this.isFunction = [];
+		}
+		
+		
+		/*-- Accessor methods --*/
+		
+		// Returns the color of the module (pixel) at the given coordinates, which is false
+		// for white or true for black. The top left corner has the coordinates (x=0, y=0).
+		// If the given coordinates are out of bounds, then false (white) is returned.
+		public getModule(x: int, y: int): boolean {
+			return 0 <= x && x < this.size && 0 <= y && y < this.size && this.modules[y][x];
+		}
+		
+		
+		/*-- Public instance methods --*/
+		
+		// Draws this QR Code, with the given module scale and border modules, onto the given HTML
+		// canvas element. The canvas's width and height is resized to (this.size + border * 2) * scale.
+		// The drawn image is be purely black and white, and fully opaque.
+		// The scale must be a positive integer and the border must be a non-negative integer.
+		public drawCanvas(scale: int, border: int, canvas: HTMLCanvasElement): void {
+			if (scale <= 0 || border < 0)
+				throw "Value out of range";
+			const width: int = (this.size + border * 2) * scale;
+			canvas.width = width;
+			canvas.height = width;
+			let ctx = canvas.getContext("2d") as CanvasRenderingContext2D;
+			for (let y = -border; y < this.size + border; y++) {
+				for (let x = -border; x < this.size + border; x++) {
+					ctx.fillStyle = this.getModule(x, y) ? "#000000" : "#FFFFFF";
+					ctx.fillRect((x + border) * scale, (y + border) * scale, scale, scale);
+				}
+			}
+		}
+		
+		
+		// Returns a string of SVG code for an image depicting this QR Code, with the given number
+		// of border modules. The string always uses Unix newlines (\n), regardless of the platform.
+		public toSvgString(border: int): string {
+			if (border < 0)
+				throw "Border must be non-negative";
+			let parts: Array<string> = [];
+			for (let y = 0; y < this.size; y++) {
+				for (let x = 0; x < this.size; x++) {
+					if (this.getModule(x, y))
+						parts.push(`M${x + border},${y + border}h1v1h-1z`);
+				}
+			}
+			return `<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
+<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 ${this.size + border * 2} ${this.size + border * 2}" stroke="none">
+	<rect width="100%" height="100%" fill="#FFFFFF"/>
+	<path d="${parts.join(" ")}" fill="#000000"/>
+</svg>
+`
+		}
+		
+		
+		/*-- Private helper methods for constructor: Drawing function modules --*/
+		
+		// Reads this object's version field, and draws and marks all function modules.
+		private drawFunctionPatterns(): void {
+			// Draw horizontal and vertical timing patterns
+			for (let i = 0; i < this.size; i++) {
+				this.setFunctionModule(6, i, i % 2 == 0);
+				this.setFunctionModule(i, 6, i % 2 == 0);
+			}
+			
+			// Draw 3 finder patterns (all corners except bottom right; overwrites some timing modules)
+			this.drawFinderPattern(3, 3);
+			this.drawFinderPattern(this.size - 4, 3);
+			this.drawFinderPattern(3, this.size - 4);
+			
+			// Draw numerous alignment patterns
+			const alignPatPos: Array<int> = this.getAlignmentPatternPositions();
+			const numAlign: int = alignPatPos.length;
+			for (let i = 0; i < numAlign; i++) {
+				for (let j = 0; j < numAlign; j++) {
+					// Don't draw on the three finder corners
+					if (!(i == 0 && j == 0 || i == 0 && j == numAlign - 1 || i == numAlign - 1 && j == 0))
+						this.drawAlignmentPattern(alignPatPos[i], alignPatPos[j]);
+				}
+			}
+			
+			// Draw configuration data
+			this.drawFormatBits(0);  // Dummy mask value; overwritten later in the constructor
+			this.drawVersion();
+		}
+		
+		
+		// Draws two copies of the format bits (with its own error correction code)
+		// based on the given mask and this object's error correction level field.
+		private drawFormatBits(mask: int): void {
+			// Calculate error correction code and pack bits
+			const data: int = this.errorCorrectionLevel.formatBits << 3 | mask;  // errCorrLvl is uint2, mask is uint3
+			let rem: int = data;
+			for (let i = 0; i < 10; i++)
+				rem = (rem << 1) ^ ((rem >>> 9) * 0x537);
+			const bits = (data << 10 | rem) ^ 0x5412;  // uint15
+			if (bits >>> 15 != 0)
+				throw "Assertion error";
+			
+			// Draw first copy
+			for (let i = 0; i <= 5; i++)
+				this.setFunctionModule(8, i, getBit(bits, i));
+			this.setFunctionModule(8, 7, getBit(bits, 6));
+			this.setFunctionModule(8, 8, getBit(bits, 7));
+			this.setFunctionModule(7, 8, getBit(bits, 8));
+			for (let i = 9; i < 15; i++)
+				this.setFunctionModule(14 - i, 8, getBit(bits, i));
+			
+			// Draw second copy
+			for (let i = 0; i < 8; i++)
+				this.setFunctionModule(this.size - 1 - i, 8, getBit(bits, i));
+			for (let i = 8; i < 15; i++)
+				this.setFunctionModule(8, this.size - 15 + i, getBit(bits, i));
+			this.setFunctionModule(8, this.size - 8, true);  // Always black
+		}
+		
+		
+		// Draws two copies of the version bits (with its own error correction code),
+		// based on this object's version field, iff 7 <= version <= 40.
+		private drawVersion(): void {
+			if (this.version < 7)
+				return;
+			
+			// Calculate error correction code and pack bits
+			let rem: int = this.version;  // version is uint6, in the range [7, 40]
+			for (let i = 0; i < 12; i++)
+				rem = (rem << 1) ^ ((rem >>> 11) * 0x1F25);
+			const bits: int = this.version << 12 | rem;  // uint18
+			if (bits >>> 18 != 0)
+				throw "Assertion error";
+			
+			// Draw two copies
+			for (let i = 0; i < 18; i++) {
+				const color: boolean = getBit(bits, i);
+				const a: int = this.size - 11 + i % 3;
+				const b: int = Math.floor(i / 3);
+				this.setFunctionModule(a, b, color);
+				this.setFunctionModule(b, a, color);
+			}
+		}
+		
+		
+		// Draws a 9*9 finder pattern including the border separator,
+		// with the center module at (x, y). Modules can be out of bounds.
+		private drawFinderPattern(x: int, y: int): void {
+			for (let dy = -4; dy <= 4; dy++) {
+				for (let dx = -4; dx <= 4; dx++) {
+					const dist: int = Math.max(Math.abs(dx), Math.abs(dy));  // Chebyshev/infinity norm
+					const xx: int = x + dx;
+					const yy: int = y + dy;
+					if (0 <= xx && xx < this.size && 0 <= yy && yy < this.size)
+						this.setFunctionModule(xx, yy, dist != 2 && dist != 4);
+				}
+			}
+		}
+		
+		
+		// Draws a 5*5 alignment pattern, with the center module
+		// at (x, y). All modules must be in bounds.
+		private drawAlignmentPattern(x: int, y: int): void {
+			for (let dy = -2; dy <= 2; dy++) {
+				for (let dx = -2; dx <= 2; dx++)
+					this.setFunctionModule(x + dx, y + dy, Math.max(Math.abs(dx), Math.abs(dy)) != 1);
+			}
+		}
+		
+		
+		// Sets the color of a module and marks it as a function module.
+		// Only used by the constructor. Coordinates must be in bounds.
+		private setFunctionModule(x: int, y: int, isBlack: boolean): void {
+			this.modules[y][x] = isBlack;
+			this.isFunction[y][x] = true;
+		}
+		
+		
+		/*-- Private helper methods for constructor: Codewords and masking --*/
+		
+		// Returns a new byte string representing the given data with the appropriate error correction
+		// codewords appended to it, based on this object's version and error correction level.
+		private addEccAndInterleave(data: Array<byte>): Array<byte> {
+			const ver: int = this.version;
+			const ecl: QrCode.Ecc = this.errorCorrectionLevel;
+			if (data.length != QrCode.getNumDataCodewords(ver, ecl))
+				throw "Invalid argument";
+			
+			// Calculate parameter numbers
+			const numBlocks: int = QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
+			const blockEccLen: int = QrCode.ECC_CODEWORDS_PER_BLOCK  [ecl.ordinal][ver];
+			const rawCodewords: int = Math.floor(QrCode.getNumRawDataModules(ver) / 8);
+			const numShortBlocks: int = numBlocks - rawCodewords % numBlocks;
+			const shortBlockLen: int = Math.floor(rawCodewords / numBlocks);
+			
+			// Split data into blocks and append ECC to each block
+			let blocks: Array<Array<byte>> = [];
+			const rsDiv: Array<byte> = QrCode.reedSolomonComputeDivisor(blockEccLen);
+			for (let i = 0, k = 0; i < numBlocks; i++) {
+				let dat: Array<byte> = data.slice(k, k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1));
+				k += dat.length;
+				const ecc: Array<byte> = QrCode.reedSolomonComputeRemainder(dat, rsDiv);
+				if (i < numShortBlocks)
+					dat.push(0);
+				blocks.push(dat.concat(ecc));
+			}
+			
+			// Interleave (not concatenate) the bytes from every block into a single sequence
+			let result: Array<byte> = [];
+			for (let i = 0; i < blocks[0].length; i++) {
+				blocks.forEach((block, j) => {
+					// Skip the padding byte in short blocks
+					if (i != shortBlockLen - blockEccLen || j >= numShortBlocks)
+						result.push(block[i]);
+				});
+			}
+			if (result.length != rawCodewords)
+				throw "Assertion error";
+			return result;
+		}
+		
+		
+		// Draws the given sequence of 8-bit codewords (data and error correction) onto the entire
+		// data area of this QR Code. Function modules need to be marked off before this is called.
+		private drawCodewords(data: Array<byte>): void {
+			if (data.length != Math.floor(QrCode.getNumRawDataModules(this.version) / 8))
+				throw "Invalid argument";
+			let i: int = 0;  // Bit index into the data
+			// Do the funny zigzag scan
+			for (let right = this.size - 1; right >= 1; right -= 2) {  // Index of right column in each column pair
+				if (right == 6)
+					right = 5;
+				for (let vert = 0; vert < this.size; vert++) {  // Vertical counter
+					for (let j = 0; j < 2; j++) {
+						const x: int = right - j;  // Actual x coordinate
+						const upward: boolean = ((right + 1) & 2) == 0;
+						const y: int = upward ? this.size - 1 - vert : vert;  // Actual y coordinate
+						if (!this.isFunction[y][x] && i < data.length * 8) {
+							this.modules[y][x] = getBit(data[i >>> 3], 7 - (i & 7));
+							i++;
+						}
+						// If this QR Code has any remainder bits (0 to 7), they were assigned as
+						// 0/false/white by the constructor and are left unchanged by this method
+					}
+				}
+			}
+			if (i != data.length * 8)
+				throw "Assertion error";
+		}
+		
+		
+		// XORs the codeword modules in this QR Code with the given mask pattern.
+		// The function modules must be marked and the codeword bits must be drawn
+		// before masking. Due to the arithmetic of XOR, calling applyMask() with
+		// the same mask value a second time will undo the mask. A final well-formed
+		// QR Code needs exactly one (not zero, two, etc.) mask applied.
+		private applyMask(mask: int): void {
+			if (mask < 0 || mask > 7)
+				throw "Mask value out of range";
+			for (let y = 0; y < this.size; y++) {
+				for (let x = 0; x < this.size; x++) {
+					let invert: boolean;
+					switch (mask) {
+						case 0:  invert = (x + y) % 2 == 0;                                  break;
+						case 1:  invert = y % 2 == 0;                                        break;
+						case 2:  invert = x % 3 == 0;                                        break;
+						case 3:  invert = (x + y) % 3 == 0;                                  break;
+						case 4:  invert = (Math.floor(x / 3) + Math.floor(y / 2)) % 2 == 0;  break;
+						case 5:  invert = x * y % 2 + x * y % 3 == 0;                        break;
+						case 6:  invert = (x * y % 2 + x * y % 3) % 2 == 0;                  break;
+						case 7:  invert = ((x + y) % 2 + x * y % 3) % 2 == 0;                break;
+						default:  throw "Assertion error";
+					}
+					if (!this.isFunction[y][x] && invert)
+						this.modules[y][x] = !this.modules[y][x];
+				}
+			}
+		}
+		
+		
+		// Calculates and returns the penalty score based on state of this QR Code's current modules.
+		// This is used by the automatic mask choice algorithm to find the mask pattern that yields the lowest score.
+		private getPenaltyScore(): int {
+			let result: int = 0;
+			
+			// Adjacent modules in row having same color, and finder-like patterns
+			for (let y = 0; y < this.size; y++) {
+				let runColor = false;
+				let runX = 0;
+				let runHistory = [0,0,0,0,0,0,0];
+				let padRun = this.size;
+				for (let x = 0; x < this.size; x++) {
+					if (this.modules[y][x] == runColor) {
+						runX++;
+						if (runX == 5)
+							result += QrCode.PENALTY_N1;
+						else if (runX > 5)
+							result++;
+					} else {
+						QrCode.finderPenaltyAddHistory(runX + padRun, runHistory);
+						padRun = 0;
+						if (!runColor)
+							result += this.finderPenaltyCountPatterns(runHistory) * QrCode.PENALTY_N3;
+						runColor = this.modules[y][x];
+						runX = 1;
+					}
+				}
+				result += this.finderPenaltyTerminateAndCount(runColor, runX + padRun, runHistory) * QrCode.PENALTY_N3;
+			}
+			// Adjacent modules in column having same color, and finder-like patterns
+			for (let x = 0; x < this.size; x++) {
+				let runColor = false;
+				let runY = 0;
+				let runHistory = [0,0,0,0,0,0,0];
+				let padRun = this.size;
+				for (let y = 0; y < this.size; y++) {
+					if (this.modules[y][x] == runColor) {
+						runY++;
+						if (runY == 5)
+							result += QrCode.PENALTY_N1;
+						else if (runY > 5)
+							result++;
+					} else {
+						QrCode.finderPenaltyAddHistory(runY + padRun, runHistory);
+						padRun = 0;
+						if (!runColor)
+							result += this.finderPenaltyCountPatterns(runHistory) * QrCode.PENALTY_N3;
+						runColor = this.modules[y][x];
+						runY = 1;
+					}
+				}
+				result += this.finderPenaltyTerminateAndCount(runColor, runY + padRun, runHistory) * QrCode.PENALTY_N3;
+			}
+			
+			// 2*2 blocks of modules having same color
+			for (let y = 0; y < this.size - 1; y++) {
+				for (let x = 0; x < this.size - 1; x++) {
+					const color: boolean = this.modules[y][x];
+					if (  color == this.modules[y][x + 1] &&
+					      color == this.modules[y + 1][x] &&
+					      color == this.modules[y + 1][x + 1])
+						result += QrCode.PENALTY_N2;
+				}
+			}
+			
+			// Balance of black and white modules
+			let black: int = 0;
+			for (const row of this.modules) {
+				for (const color of row) {
+					if (color)
+						black++;
+				}
+			}
+			const total: int = this.size * this.size;  // Note that size is odd, so black/total != 1/2
+			// Compute the smallest integer k >= 0 such that (45-5k)% <= black/total <= (55+5k)%
+			const k: int = Math.ceil(Math.abs(black * 20 - total * 10) / total) - 1;
+			result += k * QrCode.PENALTY_N4;
+			return result;
+		}
+		
+		
+		/*-- Private helper functions --*/
+		
+		// Returns an ascending list of positions of alignment patterns for this version number.
+		// Each position is in the range [0,177), and are used on both the x and y axes.
+		// This could be implemented as lookup table of 40 variable-length lists of integers.
+		private getAlignmentPatternPositions(): Array<int> {
+			if (this.version == 1)
+				return [];
+			else {
+				const numAlign: int = Math.floor(this.version / 7) + 2;
+				const step: int = (this.version == 32) ? 26 :
+					Math.ceil((this.size - 13) / (numAlign*2 - 2)) * 2;
+				let result: Array<int> = [6];
+				for (let pos = this.size - 7; result.length < numAlign; pos -= step)
+					result.splice(1, 0, pos);
+				return result;
+			}
+		}
+		
+		
+		// Returns the number of data bits that can be stored in a QR Code of the given version number, after
+		// all function modules are excluded. This includes remainder bits, so it might not be a multiple of 8.
+		// The result is in the range [208, 29648]. This could be implemented as a 40-entry lookup table.
+		private static getNumRawDataModules(ver: int): int {
+			if (ver < QrCode.MIN_VERSION || ver > QrCode.MAX_VERSION)
+				throw "Version number out of range";
+			let result: int = (16 * ver + 128) * ver + 64;
+			if (ver >= 2) {
+				const numAlign: int = Math.floor(ver / 7) + 2;
+				result -= (25 * numAlign - 10) * numAlign - 55;
+				if (ver >= 7)
+					result -= 36;
+			}
+			if (!(208 <= result && result <= 29648))
+				throw "Assertion error";
+			return result;
+		}
+		
+		
+		// Returns the number of 8-bit data (i.e. not error correction) codewords contained in any
+		// QR Code of the given version number and error correction level, with remainder bits discarded.
+		// This stateless pure function could be implemented as a (40*4)-cell lookup table.
+		private static getNumDataCodewords(ver: int, ecl: QrCode.Ecc): int {
+			return Math.floor(QrCode.getNumRawDataModules(ver) / 8) -
+				QrCode.ECC_CODEWORDS_PER_BLOCK    [ecl.ordinal][ver] *
+				QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
+		}
+		
+		
+		// Returns a Reed-Solomon ECC generator polynomial for the given degree. This could be
+		// implemented as a lookup table over all possible parameter values, instead of as an algorithm.
+		private static reedSolomonComputeDivisor(degree: int): Array<byte> {
+			if (degree < 1 || degree > 255)
+				throw "Degree out of range";
+			// Polynomial coefficients are stored from highest to lowest power, excluding the leading term which is always 1.
+			// For example the polynomial x^3 + 255x^2 + 8x + 93 is stored as the uint8 array [255, 8, 93].
+			let result: Array<byte> = [];
+			for (let i = 0; i < degree - 1; i++)
+				result.push(0);
+			result.push(1);  // Start off with the monomial x^0
+			
+			// Compute the product polynomial (x - r^0) * (x - r^1) * (x - r^2) * ... * (x - r^{degree-1}),
+			// and drop the highest monomial term which is always 1x^degree.
+			// Note that r = 0x02, which is a generator element of this field GF(2^8/0x11D).
+			let root = 1;
+			for (let i = 0; i < degree; i++) {
+				// Multiply the current product by (x - r^i)
+				for (let j = 0; j < result.length; j++) {
+					result[j] = QrCode.reedSolomonMultiply(result[j], root);
+					if (j + 1 < result.length)
+						result[j] ^= result[j + 1];
+				}
+				root = QrCode.reedSolomonMultiply(root, 0x02);
+			}
+			return result;
+		}
+		
+		
+		// Returns the Reed-Solomon error correction codeword for the given data and divisor polynomials.
+		private static reedSolomonComputeRemainder(data: Array<byte>, divisor: Array<byte>): Array<byte> {
+			let result: Array<byte> = divisor.map(_ => 0);
+			for (const b of data) {  // Polynomial division
+				const factor: byte = b ^ (result.shift() as byte);
+				result.push(0);
+				divisor.forEach((coef, i) =>
+					result[i] ^= QrCode.reedSolomonMultiply(coef, factor));
+			}
+			return result;
+		}
+		
+		
+		// Returns the product of the two given field elements modulo GF(2^8/0x11D). The arguments and result
+		// are unsigned 8-bit integers. This could be implemented as a lookup table of 256*256 entries of uint8.
+		private static reedSolomonMultiply(x: byte, y: byte): byte {
+			if (x >>> 8 != 0 || y >>> 8 != 0)
+				throw "Byte out of range";
+			// Russian peasant multiplication
+			let z: int = 0;
+			for (let i = 7; i >= 0; i--) {
+				z = (z << 1) ^ ((z >>> 7) * 0x11D);
+				z ^= ((y >>> i) & 1) * x;
+			}
+			if (z >>> 8 != 0)
+				throw "Assertion error";
+			return z as byte;
+		}
+		
+		
+		// Can only be called immediately after a white run is added, and
+		// returns either 0, 1, or 2. A helper function for getPenaltyScore().
+		private finderPenaltyCountPatterns(runHistory: Array<int>): int {
+			const n: int = runHistory[1];
+			if (n > this.size * 3)
+				throw "Assertion error";
+			const core: boolean = n > 0 && runHistory[2] == n && runHistory[3] == n * 3 && runHistory[4] == n && runHistory[5] == n;
+			return (core && runHistory[0] >= n * 4 && runHistory[6] >= n ? 1 : 0)
+			     + (core && runHistory[6] >= n * 4 && runHistory[0] >= n ? 1 : 0);
+		}
+		
+		
+		// Must be called at the end of a line (row or column) of modules. A helper function for getPenaltyScore().
+		private finderPenaltyTerminateAndCount(currentRunColor: boolean, currentRunLength: int, runHistory: Array<int>): int {
+			if (currentRunColor) {  // Terminate black run
+				QrCode.finderPenaltyAddHistory(currentRunLength, runHistory);
+				currentRunLength = 0;
+			}
+			currentRunLength += this.size;  // Add white border to final run
+			QrCode.finderPenaltyAddHistory(currentRunLength, runHistory);
+			return this.finderPenaltyCountPatterns(runHistory);
+		}
+		
+		
+		// Pushes the given value to the front and drops the last value. A helper function for getPenaltyScore().
+		private static finderPenaltyAddHistory(currentRunLength: int, runHistory: Array<int>): void {
+			runHistory.pop();
+			runHistory.unshift(currentRunLength);
+		}
+		
+		
+		/*-- Constants and tables --*/
+		
+		// The minimum version number supported in the QR Code Model 2 standard.
+		public static readonly MIN_VERSION: int =  1;
+		// The maximum version number supported in the QR Code Model 2 standard.
+		public static readonly MAX_VERSION: int = 40;
+		
+		// For use in getPenaltyScore(), when evaluating which mask is best.
+		private static readonly PENALTY_N1: int =  3;
+		private static readonly PENALTY_N2: int =  3;
+		private static readonly PENALTY_N3: int = 40;
+		private static readonly PENALTY_N4: int = 10;
+		
+		private static readonly ECC_CODEWORDS_PER_BLOCK: Array<Array<int>> = [
+			// Version: (note that index 0 is for padding, and is set to an illegal value)
+			//0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
+			[-1,  7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],  // Low
+			[-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28],  // Medium
+			[-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],  // Quartile
+			[-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],  // High
+		];
+		
+		private static readonly NUM_ERROR_CORRECTION_BLOCKS: Array<Array<int>> = [
+			// Version: (note that index 0 is for padding, and is set to an illegal value)
+			//0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
+			[-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4,  4,  4,  4,  4,  6,  6,  6,  6,  7,  8,  8,  9,  9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25],  // Low
+			[-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5,  5,  8,  9,  9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49],  // Medium
+			[-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8,  8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68],  // Quartile
+			[-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81],  // High
+		];
+		
+	}
+	
+	
+	// Appends the given number of low-order bits of the given value
+	// to the given buffer. Requires 0 <= len <= 31 and 0 <= val < 2^len.
+	function appendBits(val: int, len: int, bb: Array<bit>): void {
+		if (len < 0 || len > 31 || val >>> len != 0)
+			throw "Value out of range";
+		for (let i = len - 1; i >= 0; i--)  // Append bit by bit
+			bb.push((val >>> i) & 1);
+	}
+	
+	
+	// Returns true iff the i'th bit of x is set to 1.
+	function getBit(x: int, i: int): boolean {
+		return ((x >>> i) & 1) != 0;
+	}
+	
+	
+	
+	/*---- Data segment class ----*/
+	
+	/* 
+	 * A segment of character/binary/control data in a QR Code symbol.
+	 * Instances of this class are immutable.
+	 * The mid-level way to create a segment is to take the payload data
+	 * and call a static factory function such as QrSegment.makeNumeric().
+	 * The low-level way to create a segment is to custom-make the bit buffer
+	 * and call the QrSegment() constructor with appropriate values.
+	 * This segment class imposes no length restrictions, but QR Codes have restrictions.
+	 * Even in the most favorable conditions, a QR Code can only hold 7089 characters of data.
+	 * Any segment longer than this is meaningless for the purpose of generating QR Codes.
+	 */
+	export class QrSegment {
+		
+		/*-- Static factory functions (mid level) --*/
+		
+		// Returns a segment representing the given binary data encoded in
+		// byte mode. All input byte arrays are acceptable. Any text string
+		// can be converted to UTF-8 bytes and encoded as a byte mode segment.
+		public static makeBytes(data: Array<byte>): QrSegment {
+			let bb: Array<bit> = []
+			for (const b of data)
+				appendBits(b, 8, bb);
+			return new QrSegment(QrSegment.Mode.BYTE, data.length, bb);
+		}
+		
+		
+		// Returns a segment representing the given string of decimal digits encoded in numeric mode.
+		public static makeNumeric(digits: string): QrSegment {
+			if (!this.NUMERIC_REGEX.test(digits))
+				throw "String contains non-numeric characters";
+			let bb: Array<bit> = []
+			for (let i = 0; i < digits.length; ) {  // Consume up to 3 digits per iteration
+				const n: int = Math.min(digits.length - i, 3);
+				appendBits(parseInt(digits.substr(i, n), 10), n * 3 + 1, bb);
+				i += n;
+			}
+			return new QrSegment(QrSegment.Mode.NUMERIC, digits.length, bb);
+		}
+		
+		
+		// Returns a segment representing the given text string encoded in alphanumeric mode.
+		// The characters allowed are: 0 to 9, A to Z (uppercase only), space,
+		// dollar, percent, asterisk, plus, hyphen, period, slash, colon.
+		public static makeAlphanumeric(text: string): QrSegment {
+			if (!this.ALPHANUMERIC_REGEX.test(text))
+				throw "String contains unencodable characters in alphanumeric mode";
+			let bb: Array<bit> = []
+			let i: int;
+			for (i = 0; i + 2 <= text.length; i += 2) {  // Process groups of 2
+				let temp: int = QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)) * 45;
+				temp += QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i + 1));
+				appendBits(temp, 11, bb);
+			}
+			if (i < text.length)  // 1 character remaining
+				appendBits(QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)), 6, bb);
+			return new QrSegment(QrSegment.Mode.ALPHANUMERIC, text.length, bb);
+		}
+		
+		
+		// Returns a new mutable list of zero or more segments to represent the given Unicode text string.
+		// The result may use various segment modes and switch modes to optimize the length of the bit stream.
+		public static makeSegments(text: string): Array<QrSegment> {
+			// Select the most efficient segment encoding automatically
+			if (text == "")
+				return [];
+			else if (this.NUMERIC_REGEX.test(text))
+				return [QrSegment.makeNumeric(text)];
+			else if (this.ALPHANUMERIC_REGEX.test(text))
+				return [QrSegment.makeAlphanumeric(text)];
+			else
+				return [QrSegment.makeBytes(QrSegment.toUtf8ByteArray(text))];
+		}
+		
+		
+		// Returns a segment representing an Extended Channel Interpretation
+		// (ECI) designator with the given assignment value.
+		public static makeEci(assignVal: int): QrSegment {
+			let bb: Array<bit> = []
+			if (assignVal < 0)
+				throw "ECI assignment value out of range";
+			else if (assignVal < (1 << 7))
+				appendBits(assignVal, 8, bb);
+			else if (assignVal < (1 << 14)) {
+				appendBits(2, 2, bb);
+				appendBits(assignVal, 14, bb);
+			} else if (assignVal < 1000000) {
+				appendBits(6, 3, bb);
+				appendBits(assignVal, 21, bb);
+			} else
+				throw "ECI assignment value out of range";
+			return new QrSegment(QrSegment.Mode.ECI, 0, bb);
+		}
+		
+		
+		/*-- Constructor (low level) and fields --*/
+		
+		// Creates a new QR Code segment with the given attributes and data.
+		// The character count (numChars) must agree with the mode and the bit buffer length,
+		// but the constraint isn't checked. The given bit buffer is cloned and stored.
+		public constructor(
+				// The mode indicator of this segment.
+				public readonly mode: QrSegment.Mode,
+				
+				// The length of this segment's unencoded data. Measured in characters for
+				// numeric/alphanumeric/kanji mode, bytes for byte mode, and 0 for ECI mode.
+				// Always zero or positive. Not the same as the data's bit length.
+				public readonly numChars: int,
+				
+				// The data bits of this segment. Accessed through getData().
+				private readonly bitData: Array<bit>) {
+			
+			if (numChars < 0)
+				throw "Invalid argument";
+			this.bitData = bitData.slice();  // Make defensive copy
+		}
+		
+		
+		/*-- Methods --*/
+		
+		// Returns a new copy of the data bits of this segment.
+		public getData(): Array<bit> {
+			return this.bitData.slice();  // Make defensive copy
+		}
+		
+		
+		// (Package-private) Calculates and returns the number of bits needed to encode the given segments at
+		// the given version. The result is infinity if a segment has too many characters to fit its length field.
+		public static getTotalBits(segs: Array<QrSegment>, version: int): number {
+			let result: number = 0;
+			for (const seg of segs) {
+				const ccbits: int = seg.mode.numCharCountBits(version);
+				if (seg.numChars >= (1 << ccbits))
+					return Infinity;  // The segment's length doesn't fit the field's bit width
+				result += 4 + ccbits + seg.bitData.length;
+			}
+			return result;
+		}
+		
+		
+		// Returns a new array of bytes representing the given string encoded in UTF-8.
+		private static toUtf8ByteArray(str: string): Array<byte> {
+			str = encodeURI(str);
+			let result: Array<byte> = [];
+			for (let i = 0; i < str.length; i++) {
+				if (str.charAt(i) != "%")
+					result.push(str.charCodeAt(i));
+				else {
+					result.push(parseInt(str.substr(i + 1, 2), 16));
+					i += 2;
+				}
+			}
+			return result;
+		}
+		
+		
+		/*-- Constants --*/
+		
+		// Describes precisely all strings that are encodable in numeric mode. To test
+		// whether a string s is encodable: let ok: boolean = NUMERIC_REGEX.test(s);
+		// A string is encodable iff each character is in the range 0 to 9.
+		public static readonly NUMERIC_REGEX: RegExp = /^[0-9]*$/;
+		
+		// Describes precisely all strings that are encodable in alphanumeric mode. To test
+		// whether a string s is encodable: let ok: boolean = ALPHANUMERIC_REGEX.test(s);
+		// A string is encodable iff each character is in the following set: 0 to 9, A to Z
+		// (uppercase only), space, dollar, percent, asterisk, plus, hyphen, period, slash, colon.
+		public static readonly ALPHANUMERIC_REGEX: RegExp = /^[A-Z0-9 $%*+.\/:-]*$/;
+		
+		// The set of all legal characters in alphanumeric mode,
+		// where each character value maps to the index in the string.
+		private static readonly ALPHANUMERIC_CHARSET: string = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";
+		
+	}
+	
+}
+
+
+
+/*---- Public helper enumeration ----*/
+
+namespace qrcodegen.QrCode {
+	
+	type int = number;
+	
+	
+	/* 
+	 * The error correction level in a QR Code symbol. Immutable.
+	 */
+	export class Ecc {
+		
+		/*-- Constants --*/
+		
+		public static readonly LOW      = new Ecc(0, 1);  // The QR Code can tolerate about  7% erroneous codewords
+		public static readonly MEDIUM   = new Ecc(1, 0);  // The QR Code can tolerate about 15% erroneous codewords
+		public static readonly QUARTILE = new Ecc(2, 3);  // The QR Code can tolerate about 25% erroneous codewords
+		public static readonly HIGH     = new Ecc(3, 2);  // The QR Code can tolerate about 30% erroneous codewords
+		
+		
+		/*-- Constructor and fields --*/
+		
+		private constructor(
+			// In the range 0 to 3 (unsigned 2-bit integer).
+			public readonly ordinal: int,
+			// (Package-private) In the range 0 to 3 (unsigned 2-bit integer).
+			public readonly formatBits: int) {}
+		
+	}
+}
+
+
+
+/*---- Public helper enumeration ----*/
+
+namespace qrcodegen.QrSegment {
+	
+	type int = number;
+	
+	
+	/* 
+	 * Describes how a segment's data bits are interpreted. Immutable.
+	 */
+	export class Mode {
+		
+		/*-- Constants --*/
+		
+		public static readonly NUMERIC      = new Mode(0x1, [10, 12, 14]);
+		public static readonly ALPHANUMERIC = new Mode(0x2, [ 9, 11, 13]);
+		public static readonly BYTE         = new Mode(0x4, [ 8, 16, 16]);
+		public static readonly KANJI        = new Mode(0x8, [ 8, 10, 12]);
+		public static readonly ECI          = new Mode(0x7, [ 0,  0,  0]);
+		
+		
+		/*-- Constructor and fields --*/
+		
+		private constructor(
+			// The mode indicator bits, which is a uint4 value (range 0 to 15).
+			public readonly modeBits: int,
+			// Number of character count bits for three different version ranges.
+			private readonly numBitsCharCount: [int,int,int]) {}
+		
+		
+		/*-- Method --*/
+		
+		// (Package-private) Returns the bit width of the character count field for a segment in
+		// this mode in a QR Code at the given version number. The result is in the range [0, 16].
+		public numCharCountBits(ver: int): int {
+			return this.numBitsCharCount[Math.floor((ver + 7) / 17)];
+		}
+		
+	}
+}
Submodule Telegram/ThirdParty/expected 000000000...1d9c5d8c0 (new submodule)
diff --git a/Telegram/ThirdParty/expected/.appveyor.yml b/Telegram/ThirdParty/expected/.appveyor.yml
new file mode 100644
index 0000000..fd52576
--- /dev/null
+++ b/Telegram/ThirdParty/expected/.appveyor.yml
@@ -0,0 +1,8 @@
+os:
+- Visual Studio 2015
+- Visual Studio 2017
+
+build_script:
+  - cmake -Bbuild -S.
+  - cmake --build build
+  - cmake --build build --target RUN_TESTS
diff --git a/Telegram/ThirdParty/expected/.clang-format b/Telegram/ThirdParty/expected/.clang-format
new file mode 100644
index 0000000..9b3aa8b
--- /dev/null
+++ b/Telegram/ThirdParty/expected/.clang-format
@@ -0,0 +1 @@
+BasedOnStyle: LLVM
diff --git a/Telegram/ThirdParty/expected/.gitignore b/Telegram/ThirdParty/expected/.gitignore
new file mode 100644
index 0000000..7876dc6
--- /dev/null
+++ b/Telegram/ThirdParty/expected/.gitignore
@@ -0,0 +1,3 @@
+\#*
+.\#*
+/build/
diff --git a/Telegram/ThirdParty/expected/.gitmodules b/Telegram/ThirdParty/expected/.gitmodules
new file mode 100644
index 0000000..e6488b5
--- /dev/null
+++ b/Telegram/ThirdParty/expected/.gitmodules
@@ -0,0 +1,3 @@
+[submodule "cmake/tl-cmake"]
+	path = cmake/tl-cmake
+	url = https://github.com/TartanLlama/tl-cmake.git
diff --git a/Telegram/ThirdParty/expected/.travis.yml b/Telegram/ThirdParty/expected/.travis.yml
new file mode 100644
index 0000000..06845cc
--- /dev/null
+++ b/Telegram/ThirdParty/expected/.travis.yml
@@ -0,0 +1,268 @@
+language: cpp
+
+dist: xenial
+
+matrix:
+  include:
+    - compiler: gcc
+      addons:
+        apt:
+          sources:
+             - ubuntu-toolchain-r-test
+          packages:
+             - g++-5
+      env: COMPILER=g++-5 CXXSTD=11  
+    - compiler: gcc
+      addons:
+        apt:
+          sources:
+             - ubuntu-toolchain-r-test
+          packages:
+             - g++-6
+      env: COMPILER=g++-6 CXXSTD=11
+    - compiler: gcc
+      addons:
+        apt:
+          sources:
+             - ubuntu-toolchain-r-test
+          packages:
+             - g++-7
+      env: COMPILER=g++-7 CXXSTD=11
+    - compiler: gcc
+      addons:
+        apt:
+          sources:
+             - ubuntu-toolchain-r-test
+          packages:
+             - g++-8
+      env: COMPILER=g++-8 CXXSTD=11
+    - compiler: gcc
+      addons:
+        apt:
+          sources:
+             - ubuntu-toolchain-r-test
+          packages:
+             - g++-4.9
+      env: COMPILER=g++-4.9 CXXSTD=11
+    - compiler: gcc
+      addons:
+        apt:
+          sources:
+             - ubuntu-toolchain-r-test
+          packages:
+             - g++-4.8
+      env: COMPILER=g++-4.8 CXXSTD=11
+    - compiler: clang
+      addons:
+        apt:
+          sources:
+             - llvm-toolchain-precise-3.5
+             - ubuntu-toolchain-r-test
+          packages:
+             - clang++-3.5
+             - libc++-dev
+      env: COMPILER=clang++-3.5 CXXSTD=11
+    - compiler: clang
+      addons:
+        apt:
+          sources:
+             - llvm-toolchain-precise-3.6
+             - ubuntu-toolchain-r-test
+          packages:
+             - clang++-3.6
+             - libc++-dev
+      env: COMPILER=clang++-3.6 CXXSTD=11
+    - compiler: clang
+      addons:
+        apt:
+          sources:
+             - llvm-toolchain-precise-3.7
+             - ubuntu-toolchain-r-test
+          packages:
+             - clang++-3.7
+             - libc++-dev
+      env: COMPILER=clang++-3.7 CXXSTD=11
+    - compiler: clang
+      addons:
+        apt:
+          sources:
+            - sourceline: "deb http://apt.llvm.org/xenial/ llvm-toolchain-xenial-3.8 main"
+              key_url: "http://apt.llvm.org/llvm-snapshot.gpg.key"
+            - ubuntu-toolchain-r-test
+          packages:
+             - clang++-3.8
+             - libc++-dev
+      env: COMPILER=clang++-3.8 CXXSTD=11
+    - compiler: clang
+      addons:
+        apt:
+          sources:
+            - sourceline: "deb http://apt.llvm.org/xenial/ llvm-toolchain-xenial-3.9 main"
+              key_url: "http://apt.llvm.org/llvm-snapshot.gpg.key"
+            - ubuntu-toolchain-r-test
+          packages:
+            - clang++-3.9
+            - libc++-dev
+      env: COMPILER=clang++-3.9 CXXSTD=11
+    - compiler: clang
+      addons:
+        apt:
+          sources:
+             - llvm-toolchain-xenial-4.0
+             - ubuntu-toolchain-r-test
+          packages:
+             - clang++-4.0
+             - libc++-dev
+      env: COMPILER=clang++-4.0 CXXSTD=11
+    - compiler: clang
+      addons:
+        apt:
+          sources:
+             - llvm-toolchain-xenial-5.0
+             - ubuntu-toolchain-r-test
+          packages:
+             - clang++-5.0
+             - libc++-dev
+      env: COMPILER=clang++-5.0 CXXSTD=11             
+    - compiler: clang
+      addons:
+        apt:
+          sources:
+             - llvm-toolchain-xenial-6.0
+             - ubuntu-toolchain-r-test
+          packages:
+             - clang++-6.0
+             - libc++-dev
+      env: COMPILER=clang++-6.0 CXXSTD=11             
+
+    - compiler: gcc
+      addons:
+        apt:
+          sources:
+             - ubuntu-toolchain-r-test
+          packages:
+             - g++-5
+      env: COMPILER=g++-5 CXXSTD=14
+    - compiler: gcc
+      addons:
+        apt:
+          sources:
+             - ubuntu-toolchain-r-test
+          packages:
+             - g++-6
+      env: COMPILER=g++-6 CXXSTD=14
+    - compiler: gcc
+      addons:
+        apt:
+          sources:
+             - ubuntu-toolchain-r-test
+          packages:
+             - g++-7
+      env: COMPILER=g++-7 CXXSTD=14
+    - compiler: gcc
+      addons:
+        apt:
+          sources:
+             - ubuntu-toolchain-r-test
+          packages:
+             - g++-8
+      env: COMPILER=g++-8 CXXSTD=14      
+    - compiler: clang
+      addons:
+        apt:
+          sources:
+             - llvm-toolchain-precise-3.5
+             - ubuntu-toolchain-r-test
+          packages:
+             - clang++-3.5
+             - libc++-dev
+      env: COMPILER=clang++-3.5 CXXSTD=14
+    - compiler: clang
+      addons:
+        apt:
+          sources:
+             - llvm-toolchain-precise-3.6
+             - ubuntu-toolchain-r-test
+          packages:
+             - clang++-3.6
+             - libc++-dev
+      env: COMPILER=clang++-3.6 CXXSTD=14
+    - compiler: clang
+      addons:
+        apt:
+          sources:
+             - llvm-toolchain-precise-3.7
+             - ubuntu-toolchain-r-test
+          packages:
+             - clang++-3.7
+             - libc++-dev
+      env: COMPILER=clang++-3.7 CXXSTD=14
+    - compiler: clang
+      addons:
+        apt:
+          sources:
+            - sourceline: "deb http://apt.llvm.org/xenial/ llvm-toolchain-xenial-3.8 main"
+              key_url: "http://apt.llvm.org/llvm-snapshot.gpg.key"
+            - ubuntu-toolchain-r-test
+          packages:
+             - clang++-3.8
+             - libc++-dev
+      env: COMPILER=clang++-3.8 CXXSTD=14
+    - compiler: clang
+      addons:
+        apt:
+          sources:
+            - sourceline: "deb http://apt.llvm.org/xenial/ llvm-toolchain-xenial-3.9 main"
+              key_url: "http://apt.llvm.org/llvm-snapshot.gpg.key"
+            - ubuntu-toolchain-r-test
+          packages:
+            - clang++-3.9
+            - libc++-dev
+      env: COMPILER=clang++-3.9 CXXSTD=14
+    - compiler: clang
+      addons:
+        apt:
+          sources:
+             - llvm-toolchain-xenial-4.0
+             - ubuntu-toolchain-r-test
+          packages:
+             - clang++-4.0
+             - libc++-dev
+      env: COMPILER=clang++-4.0 CXXSTD=14
+    - compiler: clang
+      addons:
+        apt:
+          sources:
+             - llvm-toolchain-xenial-5.0
+             - ubuntu-toolchain-r-test
+          packages:
+             - clang++-5.0
+             - libc++-dev
+      env: COMPILER=clang++-5.0 CXXSTD=14      
+    - compiler: clang
+      addons:
+        apt:
+          sources:
+             - llvm-toolchain-xenial-6.0
+             - ubuntu-toolchain-r-test
+          packages:
+             - clang++-6.0
+             - libc++-dev
+      env: COMPILER=clang++-6.0 CXXSTD=14      
+      
+before_install:
+  - sudo apt update
+  - sudo apt install -y apt-transport-https ca-certificates gnupg software-properties-common 
+  - curl -L https://apt.kitware.com/keys/kitware-archive-latest.asc | sudo apt-key add -
+  - sudo apt-add-repository 'deb https://apt.kitware.com/ubuntu/ xenial main' 
+  - sudo apt update
+
+install:
+  - if [ "$CXX" = "clang++" ]; then export CXX="$COMPILER -stdlib=libc++"; fi
+  - if [ "$CXX" = "g++" ]; then export CXX="$COMPILER"; fi
+  - sudo apt install -y cmake
+
+script:
+  - /usr/bin/cmake -B build -S . "-DCMAKE_CXX_STANDARD=$CXXSTD"
+  - /usr/bin/cmake --build build
+  - /usr/bin/cmake --build build --target test
diff --git a/Telegram/ThirdParty/expected/CMakeLists.txt b/Telegram/ThirdParty/expected/CMakeLists.txt
new file mode 100644
index 0000000..8df9107
--- /dev/null
+++ b/Telegram/ThirdParty/expected/CMakeLists.txt
@@ -0,0 +1,117 @@
+cmake_minimum_required(VERSION 3.14)
+project(tl-expected
+  HOMEPAGE_URL https://tl.tartanllama.xyz
+  DESCRIPTION "C++11/14/17 std::expected with functional-style extensions"
+  VERSION 1.0.0
+  LANGUAGES CXX)
+
+include(CMakePackageConfigHelpers)
+include(CMakeDependentOption)
+include(GNUInstallDirs)
+include(FetchContent)
+include(CTest)
+
+if (NOT DEFINED CMAKE_CXX_STANDARD)
+  set(CMAKE_CXX_STANDARD 14)
+endif()
+
+option(EXPECTED_BUILD_PACKAGE "Build package files as well" ON)
+
+cmake_dependent_option(EXPECTED_BUILD_TESTS
+  "Enable tl::expected tests" ON
+  "BUILD_TESTING" OFF)
+
+cmake_dependent_option(EXPECTED_BUILD_PACKAGE_DEB
+  "Create a DEB" ON
+  "EXPECTED_BUILD_PACKAGE" OFF)
+
+add_library(expected INTERFACE)
+target_include_directories(expected
+  INTERFACE
+    $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}/include>
+    $<INSTALL_INTERFACE:include>)
+
+if (NOT CMAKE_SOURCE_DIR STREQUAL PROJECT_SOURCE_DIR)
+  add_library(tl::expected ALIAS expected)
+endif()
+
+# Installation help
+configure_package_config_file(
+  "${PROJECT_SOURCE_DIR}/cmake/${PROJECT_NAME}-config.cmake.in"
+  "${PROJECT_BINARY_DIR}/${PROJECT_NAME}-config.cmake"
+  INSTALL_DESTINATION "share/cmake/${PROJECT_NAME}")
+
+write_basic_package_version_file(
+  "${PROJECT_BINARY_DIR}/${PROJECT_NAME}-config-version.cmake"
+  COMPATIBILITY SameMajorVersion
+  ARCH_INDEPENDENT)
+
+install(TARGETS expected
+  EXPORT ${PROJECT_NAME}-targets
+  INCLUDES DESTINATION "${CMAKE_INSTALL_DATADIR}")
+
+install(EXPORT ${PROJECT_NAME}-targets
+  DESTINATION "${CMAKE_INSTALL_DATADIR}/cmake/${PROJECT_NAME}"
+  NAMESPACE tl::
+  FILE "${PROJECT_NAME}-targets.cmake")
+
+install(FILES
+  "${PROJECT_BINARY_DIR}/${PROJECT_NAME}-config-version.cmake"
+  "${PROJECT_BINARY_DIR}/${PROJECT_NAME}-config.cmake"
+  DESTINATION "${CMAKE_INSTALL_DATADIR}/cmake/${PROJECT_NAME}")
+
+install(DIRECTORY "include/" TYPE INCLUDE)
+
+if(EXPECTED_BUILD_TESTS)
+  set(CMAKE_POLICY_DEFAULT_CMP0077 NEW)
+  set(CATCH_INSTALL_HELPERS OFF)
+  set(CATCH_BUILD_TESTING OFF)
+  set(CATCH_INSTALL_DOCS OFF)
+  FetchContent_Declare(Catch2 URL
+    https://github.com/catchorg/Catch2/archive/v2.9.2.zip) 
+  FetchContent_MakeAvailable(Catch2)
+
+  file(GLOB test-sources CONFIGURE_DEPENDS tests/*.cpp)
+  list(FILTER test-sources EXCLUDE REGEX "tests/test.cpp")
+  add_executable(${PROJECT_NAME}-tests "${test-sources}")
+  target_compile_options(${PROJECT_NAME}-tests PRIVATE
+    $<$<NOT:$<CXX_COMPILER_ID:MSVC>>:-Wall -Wextra>)
+
+  target_link_libraries(${PROJECT_NAME}-tests
+    PRIVATE
+      Catch2::Catch2
+      expected)
+  add_test(NAME tl::expected::tests COMMAND ${PROJECT_NAME}-tests)
+endif()
+
+if (NOT EXPECTED_BUILD_PACKAGE)
+  return()
+endif()
+
+list(APPEND source-generators TBZ2 TGZ TXZ ZIP)
+
+if (CMAKE_HOST_WIN32)
+  list(APPEND binary-generators "WIX")
+endif()
+
+if (EXPECTED_BUILD_PACKAGE_DEB)
+  list(APPEND binary-generators "DEB")
+endif()
+
+if (EXPECTED_BUILD_RPM)
+  list(APPEND binary-generators "RPM")
+endif()
+
+
+set(CPACK_SOURCE_GENERATOR ${source-generators})
+set(CPACK_GENERATOR ${binary-generators})
+
+set(CPACK_PACKAGE_FILE_NAME "${PROJECT_NAME}-${PROJECT_VERSION}")
+set(CPACK_SOURCE_PACKAGE_FILE_NAME "${CPACK_PACKAGE_FILE_NAME}")
+
+set(CPACK_DEBIAN_PACKAGE_MAINTAINER "Sy Brand")
+
+list(APPEND CPACK_SOURCE_IGNORE_FILES /.git/ /build/ .gitignore .DS_Store)
+
+include(CPack)
+
diff --git a/Telegram/ThirdParty/expected/COPYING b/Telegram/ThirdParty/expected/COPYING
new file mode 100644
index 0000000..0e259d4
--- /dev/null
+++ b/Telegram/ThirdParty/expected/COPYING
@@ -0,0 +1,121 @@
+Creative Commons Legal Code
+
+CC0 1.0 Universal
+
+    CREATIVE COMMONS CORPORATION IS NOT A LAW FIRM AND DOES NOT PROVIDE
+    LEGAL SERVICES. DISTRIBUTION OF THIS DOCUMENT DOES NOT CREATE AN
+    ATTORNEY-CLIENT RELATIONSHIP. CREATIVE COMMONS PROVIDES THIS
+    INFORMATION ON AN "AS-IS" BASIS. CREATIVE COMMONS MAKES NO WARRANTIES
+    REGARDING THE USE OF THIS DOCUMENT OR THE INFORMATION OR WORKS
+    PROVIDED HEREUNDER, AND DISCLAIMS LIABILITY FOR DAMAGES RESULTING FROM
+    THE USE OF THIS DOCUMENT OR THE INFORMATION OR WORKS PROVIDED
+    HEREUNDER.
+
+Statement of Purpose
+
+The laws of most jurisdictions throughout the world automatically confer
+exclusive Copyright and Related Rights (defined below) upon the creator
+and subsequent owner(s) (each and all, an "owner") of an original work of
+authorship and/or a database (each, a "Work").
+
+Certain owners wish to permanently relinquish those rights to a Work for
+the purpose of contributing to a commons of creative, cultural and
+scientific works ("Commons") that the public can reliably and without fear
+of later claims of infringement build upon, modify, incorporate in other
+works, reuse and redistribute as freely as possible in any form whatsoever
+and for any purposes, including without limitation commercial purposes.
+These owners may contribute to the Commons to promote the ideal of a free
+culture and the further production of creative, cultural and scientific
+works, or to gain reputation or greater distribution for their Work in
+part through the use and efforts of others.
+
+For these and/or other purposes and motivations, and without any
+expectation of additional consideration or compensation, the person
+associating CC0 with a Work (the "Affirmer"), to the extent that he or she
+is an owner of Copyright and Related Rights in the Work, voluntarily
+elects to apply CC0 to the Work and publicly distribute the Work under its
+terms, with knowledge of his or her Copyright and Related Rights in the
+Work and the meaning and intended legal effect of CC0 on those rights.
+
+1. Copyright and Related Rights. A Work made available under CC0 may be
+protected by copyright and related or neighboring rights ("Copyright and
+Related Rights"). Copyright and Related Rights include, but are not
+limited to, the following:
+
+  i. the right to reproduce, adapt, distribute, perform, display,
+     communicate, and translate a Work;
+ ii. moral rights retained by the original author(s) and/or performer(s);
+iii. publicity and privacy rights pertaining to a person's image or
+     likeness depicted in a Work;
+ iv. rights protecting against unfair competition in regards to a Work,
+     subject to the limitations in paragraph 4(a), below;
+  v. rights protecting the extraction, dissemination, use and reuse of data
+     in a Work;
+ vi. database rights (such as those arising under Directive 96/9/EC of the
+     European Parliament and of the Council of 11 March 1996 on the legal
+     protection of databases, and under any national implementation
+     thereof, including any amended or successor version of such
+     directive); and
+vii. other similar, equivalent or corresponding rights throughout the
+     world based on applicable law or treaty, and any national
+     implementations thereof.
+
+2. Waiver. To the greatest extent permitted by, but not in contravention
+of, applicable law, Affirmer hereby overtly, fully, permanently,
+irrevocably and unconditionally waives, abandons, and surrenders all of
+Affirmer's Copyright and Related Rights and associated claims and causes
+of action, whether now known or unknown (including existing as well as
+future claims and causes of action), in the Work (i) in all territories
+worldwide, (ii) for the maximum duration provided by applicable law or
+treaty (including future time extensions), (iii) in any current or future
+medium and for any number of copies, and (iv) for any purpose whatsoever,
+including without limitation commercial, advertising or promotional
+purposes (the "Waiver"). Affirmer makes the Waiver for the benefit of each
+member of the public at large and to the detriment of Affirmer's heirs and
+successors, fully intending that such Waiver shall not be subject to
+revocation, rescission, cancellation, termination, or any other legal or
+equitable action to disrupt the quiet enjoyment of the Work by the public
+as contemplated by Affirmer's express Statement of Purpose.
+
+3. Public License Fallback. Should any part of the Waiver for any reason
+be judged legally invalid or ineffective under applicable law, then the
+Waiver shall be preserved to the maximum extent permitted taking into
+account Affirmer's express Statement of Purpose. In addition, to the
+extent the Waiver is so judged Affirmer hereby grants to each affected
+person a royalty-free, non transferable, non sublicensable, non exclusive,
+irrevocable and unconditional license to exercise Affirmer's Copyright and
+Related Rights in the Work (i) in all territories worldwide, (ii) for the
+maximum duration provided by applicable law or treaty (including future
+time extensions), (iii) in any current or future medium and for any number
+of copies, and (iv) for any purpose whatsoever, including without
+limitation commercial, advertising or promotional purposes (the
+"License"). The License shall be deemed effective as of the date CC0 was
+applied by Affirmer to the Work. Should any part of the License for any
+reason be judged legally invalid or ineffective under applicable law, such
+partial invalidity or ineffectiveness shall not invalidate the remainder
+of the License, and in such case Affirmer hereby affirms that he or she
+will not (i) exercise any of his or her remaining Copyright and Related
+Rights in the Work or (ii) assert any associated claims and causes of
+action with respect to the Work, in either case contrary to Affirmer's
+express Statement of Purpose.
+
+4. Limitations and Disclaimers.
+
+ a. No trademark or patent rights held by Affirmer are waived, abandoned,
+    surrendered, licensed or otherwise affected by this document.
+ b. Affirmer offers the Work as-is and makes no representations or
+    warranties of any kind concerning the Work, express, implied,
+    statutory or otherwise, including without limitation warranties of
+    title, merchantability, fitness for a particular purpose, non
+    infringement, or the absence of latent or other defects, accuracy, or
+    the present or absence of errors, whether or not discoverable, all to
+    the greatest extent permissible under applicable law.
+ c. Affirmer disclaims responsibility for clearing rights of other persons
+    that may apply to the Work or any use thereof, including without
+    limitation any person's Copyright and Related Rights in the Work.
+    Further, Affirmer disclaims responsibility for obtaining any necessary
+    consents, permissions or other rights required for any use of the
+    Work.
+ d. Affirmer understands and acknowledges that Creative Commons is not a
+    party to this document and has no duty or obligation with respect to
+    this CC0 or use of the Work.
diff --git a/Telegram/ThirdParty/expected/README.md b/Telegram/ThirdParty/expected/README.md
new file mode 100644
index 0000000..9802985
--- /dev/null
+++ b/Telegram/ThirdParty/expected/README.md
@@ -0,0 +1,97 @@
+# expected
+Single header implementation of `std::expected` with functional-style extensions.
+
+[![Documentation Status](https://readthedocs.org/projects/tl-docs/badge/?version=latest)](https://tl.tartanllama.xyz/en/latest/?badge=latest)
+Clang + GCC: [![Linux Build Status](https://travis-ci.org/TartanLlama/expected.png?branch=master)](https://travis-ci.org/TartanLlama/expected)
+MSVC: [![Windows Build Status](https://ci.appveyor.com/api/projects/status/k5x00xa11y3s5wsg?svg=true)](https://ci.appveyor.com/project/TartanLlama/expected)
+
+Available on [Vcpkg](https://github.com/microsoft/vcpkg/tree/master/ports/tl-expected) and [Conan](https://github.com/yipdw/conan-tl-expected).
+
+[`std::expected`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0323r3.pdf) is proposed as the preferred way to represent object which will either have an expected value, or an unexpected value giving information about why something failed. Unfortunately, chaining together many computations which may fail can be verbose, as error-checking code will be mixed in with the actual programming logic. This implementation provides a number of utilities to make coding with `expected` cleaner.
+
+For example, instead of writing this code:
+
+```cpp
+std::expected<image,fail_reason> get_cute_cat (const image& img) {
+    auto cropped = crop_to_cat(img);
+    if (!cropped) {
+      return cropped;
+    }
+
+    auto with_tie = add_bow_tie(*cropped);
+    if (!with_tie) {
+      return with_tie;
+    }
+
+    auto with_sparkles = make_eyes_sparkle(*with_tie);
+    if (!with_sparkles) {
+       return with_sparkles;
+    }
+
+    return add_rainbow(make_smaller(*with_sparkles));
+}
+```
+
+You can do this:
+
+```cpp
+tl::expected<image,fail_reason> get_cute_cat (const image& img) {
+    return crop_to_cat(img)
+           .and_then(add_bow_tie)
+           .and_then(make_eyes_sparkle)
+           .map(make_smaller)
+           .map(add_rainbow);
+}
+```
+
+The interface is the same as `std::expected` as proposed in [p0323r3](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0323r3.pdf), but the following member functions are also defined. Explicit types are for clarity.
+
+- `map`: carries out some operation on the stored object if there is one.
+  * `tl::expected<std::size_t,std::error_code> s = exp_string.map(&std::string::size);`
+- `map_error`: carries out some operation on the unexpected object if there is one.
+  * `my_error_code translate_error (std::error_code);`
+  * `tl::expected<int,my_error_code> s = exp_int.map_error(translate_error);`
+- `and_then`: like `map`, but for operations which return a `tl::expected`.
+  * `tl::expected<ast, fail_reason> parse (const std::string& s);`
+  * `tl::expected<ast, fail_reason> exp_ast = exp_string.and_then(parse);`
+- `or_else`: calls some function if there is no value stored.
+  * `exp.or_else([] { throw std::runtime_error{"oh no"}; });`
+
+### Compiler support
+
+Tested on:
+
+- Linux
+  * clang 6.0.1
+  * clang 5.0.2
+  * clang 4.0.1
+  * clang 3.9
+  * clang 3.8
+  * clang 3.7
+  * clang 3.6
+  * clang 3.5
+  * g++ 8.0.1  
+  * g++ 7.3  
+  * g++ 6.4
+  * g++ 5.5  
+  * g++ 4.9
+  * g++ 4.8
+- Windows
+  * MSVC 2015
+  * MSVC 2017
+
+### Dependencies
+
+Requires [Standardese](https://github.com/foonathan/standardese) for generating documentation.
+
+Requires [Catch](https://github.com/philsquared/Catch) for testing. This is bundled in the test directory.
+
+### Acknowledgements
+
+Thanks to [Kévin Alexandre Boissonneault](https://github.com/KABoissonneault) and [Björn Fahller](https://github.com/rollbear) for various bug fixes.
+
+----------
+
+[![CC0](http://i.creativecommons.org/p/zero/1.0/88x31.png)]("http://creativecommons.org/publicdomain/zero/1.0/")
+
+To the extent possible under law, [Simon Brand](https://twitter.com/TartanLlama) has waived all copyright and related or neighboring rights to the `expected` library. This work is published from: United Kingdom.
Submodule cmake/tl-cmake 0000000...284c6a3 (new submodule)
diff --git a/Telegram/ThirdParty/expected/cmake/tl-cmake/add-tl.cmake b/Telegram/ThirdParty/expected/cmake/tl-cmake/add-tl.cmake
new file mode 100644
index 0000000..60770f5
--- /dev/null
+++ b/Telegram/ThirdParty/expected/cmake/tl-cmake/add-tl.cmake
@@ -0,0 +1,44 @@
+cmake_minimum_required(VERSION 3.8)
+
+function (tl_add_library name)
+  cmake_parse_arguments(ARG "" "" "SOURCES")
+  add_library(${name} INTERFACE)
+  target_sources(${name} INTERFACE 
+                 $<BUILD_INTERFACE:${ARG_SOURCES}>)
+  target_include_directories(${name} INTERFACE
+    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
+    $<INSTALL_INTERFACE:include>
+ )
+
+  include(CMakePackageConfigHelpers)
+  write_basic_package_version_file(
+    "${PROJECT_BINARY_DIR}/tl-${name}-config-version.cmake"
+    COMPATIBILITY SameMajorVersion
+)
+
+  include(GNUInstallDirs)
+  install(TARGETS ${name}
+    EXPORT tl-targets
+    INCLUDES DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}
+  )
+
+  configure_package_config_file(
+    "${PROJECT_SOURCE_DIR}/cmake/tl-${name}-config.cmake.in"
+    "${PROJECT_BINARY_DIR}/tl-${name}-config.cmake"
+    INSTALL_DESTINATION ${CMAKE_INSTALL_DATADIR}/cmake/tl-${name}
+  )
+
+  install(EXPORT tl-targets
+    FILE
+      tl-${name}-targets.cmake
+    NAMESPACE
+      tl::
+    DESTINATION
+      ${CMAKE_INSTALL_DATADIR}/cmake/tl-${name}
+  )
+
+  install(FILES "${PROJECT_BINARY_DIR}/tl-${name}-config-version.cmake"
+                "${PROJECT_BINARY_DIR}/tl-${name}-config.cmake"
+          DESTINATION ${CMAKE_INSTALL_DATADIR}/cmake/tl-${name})
+  install(DIRECTORY ${PROJECT_SOURCE_DIR}/include/ DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})
+endfunction()
diff --git a/Telegram/ThirdParty/expected/cmake/tl-expected-config.cmake.in b/Telegram/ThirdParty/expected/cmake/tl-expected-config.cmake.in
new file mode 100644
index 0000000..12e3c35
--- /dev/null
+++ b/Telegram/ThirdParty/expected/cmake/tl-expected-config.cmake.in
@@ -0,0 +1,3 @@
+@PACKAGE_INIT@
+
+include("${CMAKE_CURRENT_LIST_DIR}/tl-expected-targets.cmake")
\ No newline at end of file
diff --git a/Telegram/ThirdParty/expected/include/tl/expected.hpp b/Telegram/ThirdParty/expected/include/tl/expected.hpp
new file mode 100644
index 0000000..31a5193
--- /dev/null
+++ b/Telegram/ThirdParty/expected/include/tl/expected.hpp
@@ -0,0 +1,2326 @@
+///
+// expected - An implementation of std::expected with extensions
+// Written in 2017 by Simon Brand (simonrbrand@gmail.com, @TartanLlama)
+//
+// Documentation available at http://tl.tartanllama.xyz/
+//
+// To the extent possible under law, the author(s) have dedicated all
+// copyright and related and neighboring rights to this software to the
+// public domain worldwide. This software is distributed without any warranty.
+//
+// You should have received a copy of the CC0 Public Domain Dedication
+// along with this software. If not, see
+// <http://creativecommons.org/publicdomain/zero/1.0/>.
+///
+
+#ifndef TL_EXPECTED_HPP
+#define TL_EXPECTED_HPP
+
+#define TL_EXPECTED_VERSION_MAJOR 1
+#define TL_EXPECTED_VERSION_MINOR 0
+#define TL_EXPECTED_VERSION_PATCH 1
+
+#include <exception>
+#include <functional>
+#include <type_traits>
+#include <utility>
+
+#if defined(__EXCEPTIONS) || defined(_CPPUNWIND)
+#define TL_EXPECTED_EXCEPTIONS_ENABLED
+#endif
+
+#if (defined(_MSC_VER) && _MSC_VER == 1900)
+#define TL_EXPECTED_MSVC2015
+#define TL_EXPECTED_MSVC2015_CONSTEXPR
+#else
+#define TL_EXPECTED_MSVC2015_CONSTEXPR constexpr
+#endif
+
+#if (defined(__GNUC__) && __GNUC__ == 4 && __GNUC_MINOR__ <= 9 &&              \
+     !defined(__clang__))
+#define TL_EXPECTED_GCC49
+#endif
+
+#if (defined(__GNUC__) && __GNUC__ == 5 && __GNUC_MINOR__ <= 4 &&              \
+     !defined(__clang__))
+#define TL_EXPECTED_GCC54
+#endif
+
+#if (defined(__GNUC__) && __GNUC__ == 5 && __GNUC_MINOR__ <= 5 &&              \
+     !defined(__clang__))
+#define TL_EXPECTED_GCC55
+#endif
+
+#if (defined(__GNUC__) && __GNUC__ == 4 && __GNUC_MINOR__ <= 9 &&              \
+     !defined(__clang__))
+// GCC < 5 doesn't support overloading on const&& for member functions
+
+#define TL_EXPECTED_NO_CONSTRR
+// GCC < 5 doesn't support some standard C++11 type traits
+#define TL_EXPECTED_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(T)                         \
+  std::has_trivial_copy_constructor<T>
+#define TL_EXPECTED_IS_TRIVIALLY_COPY_ASSIGNABLE(T)                            \
+  std::has_trivial_copy_assign<T>
+
+// This one will be different for GCC 5.7 if it's ever supported
+#define TL_EXPECTED_IS_TRIVIALLY_DESTRUCTIBLE(T)                               \
+  std::is_trivially_destructible<T>
+
+// GCC 5 < v < 8 has a bug in is_trivially_copy_constructible which breaks std::vector
+// for non-copyable types
+#elif (defined(__GNUC__) && __GNUC__ < 8 &&                                                \
+     !defined(__clang__))
+#ifndef TL_GCC_LESS_8_TRIVIALLY_COPY_CONSTRUCTIBLE_MUTEX
+#define TL_GCC_LESS_8_TRIVIALLY_COPY_CONSTRUCTIBLE_MUTEX
+namespace tl {
+  namespace detail {
+      template<class T>
+      struct is_trivially_copy_constructible : std::is_trivially_copy_constructible<T>{};
+#ifdef _GLIBCXX_VECTOR
+      template<class T, class A>
+      struct is_trivially_copy_constructible<std::vector<T,A>>
+          : std::false_type{};
+#endif
+  }
+}
+#endif
+
+#define TL_EXPECTED_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(T)                                     \
+  tl::detail::is_trivially_copy_constructible<T>
+#define TL_EXPECTED_IS_TRIVIALLY_COPY_ASSIGNABLE(T)                                        \
+  std::is_trivially_copy_assignable<T>
+#define TL_EXPECTED_IS_TRIVIALLY_DESTRUCTIBLE(T) std::is_trivially_destructible<T>
+#else
+#define TL_EXPECTED_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(T)                         \
+  std::is_trivially_copy_constructible<T>
+#define TL_EXPECTED_IS_TRIVIALLY_COPY_ASSIGNABLE(T)                            \
+  std::is_trivially_copy_assignable<T>
+#define TL_EXPECTED_IS_TRIVIALLY_DESTRUCTIBLE(T)                               \
+  std::is_trivially_destructible<T>
+#endif
+
+#if __cplusplus > 201103L
+#define TL_EXPECTED_CXX14
+#endif
+
+#ifdef TL_EXPECTED_GCC49
+#define TL_EXPECTED_GCC49_CONSTEXPR
+#else
+#define TL_EXPECTED_GCC49_CONSTEXPR constexpr
+#endif
+
+#if (__cplusplus == 201103L || defined(TL_EXPECTED_MSVC2015) ||                \
+     defined(TL_EXPECTED_GCC49))
+#define TL_EXPECTED_11_CONSTEXPR
+#else
+#define TL_EXPECTED_11_CONSTEXPR constexpr
+#endif
+
+namespace tl {
+template <class T, class E> class expected;
+
+#ifndef TL_MONOSTATE_INPLACE_MUTEX
+#define TL_MONOSTATE_INPLACE_MUTEX
+class monostate {};
+
+struct in_place_t {
+  explicit in_place_t() = default;
+};
+static constexpr in_place_t in_place{};
+#endif
+
+template <class E> class unexpected {
+public:
+  static_assert(!std::is_same<E, void>::value, "E must not be void");
+
+  unexpected() = delete;
+  constexpr explicit unexpected(const E &e) : m_val(e) {}
+
+  constexpr explicit unexpected(E &&e) : m_val(std::move(e)) {}
+
+  constexpr const E &value() const & { return m_val; }
+  TL_EXPECTED_11_CONSTEXPR E &value() & { return m_val; }
+  TL_EXPECTED_11_CONSTEXPR E &&value() && { return std::move(m_val); }
+  constexpr const E &&value() const && { return std::move(m_val); }
+
+private:
+  E m_val;
+};
+
+template <class E>
+constexpr bool operator==(const unexpected<E> &lhs, const unexpected<E> &rhs) {
+  return lhs.value() == rhs.value();
+}
+template <class E>
+constexpr bool operator!=(const unexpected<E> &lhs, const unexpected<E> &rhs) {
+  return lhs.value() != rhs.value();
+}
+template <class E>
+constexpr bool operator<(const unexpected<E> &lhs, const unexpected<E> &rhs) {
+  return lhs.value() < rhs.value();
+}
+template <class E>
+constexpr bool operator<=(const unexpected<E> &lhs, const unexpected<E> &rhs) {
+  return lhs.value() <= rhs.value();
+}
+template <class E>
+constexpr bool operator>(const unexpected<E> &lhs, const unexpected<E> &rhs) {
+  return lhs.value() > rhs.value();
+}
+template <class E>
+constexpr bool operator>=(const unexpected<E> &lhs, const unexpected<E> &rhs) {
+  return lhs.value() >= rhs.value();
+}
+
+template <class E>
+unexpected<typename std::decay<E>::type> make_unexpected(E &&e) {
+  return unexpected<typename std::decay<E>::type>(std::forward<E>(e));
+}
+
+struct unexpect_t {
+  unexpect_t() = default;
+};
+static constexpr unexpect_t unexpect{};
+
+namespace detail {
+template<typename E>
+[[noreturn]] TL_EXPECTED_11_CONSTEXPR void throw_exception(E &&e) {
+#ifdef TL_EXPECTED_EXCEPTIONS_ENABLED
+    throw std::forward<E>(e);
+#else
+  #ifdef _MSC_VER
+    __assume(0);
+  #else
+    __builtin_unreachable();
+  #endif
+#endif
+}
+
+#ifndef TL_TRAITS_MUTEX
+#define TL_TRAITS_MUTEX
+// C++14-style aliases for brevity
+template <class T> using remove_const_t = typename std::remove_const<T>::type;
+template <class T>
+using remove_reference_t = typename std::remove_reference<T>::type;
+template <class T> using decay_t = typename std::decay<T>::type;
+template <bool E, class T = void>
+using enable_if_t = typename std::enable_if<E, T>::type;
+template <bool B, class T, class F>
+using conditional_t = typename std::conditional<B, T, F>::type;
+
+// std::conjunction from C++17
+template <class...> struct conjunction : std::true_type {};
+template <class B> struct conjunction<B> : B {};
+template <class B, class... Bs>
+struct conjunction<B, Bs...>
+  : std::conditional<bool(B::value), conjunction<Bs...>, B>::type {};
+
+#if defined(_LIBCPP_VERSION) && __cplusplus == 201103L
+#define TL_TRAITS_LIBCXX_MEM_FN_WORKAROUND
+#endif
+
+// In C++11 mode, there's an issue in libc++'s std::mem_fn
+// which results in a hard-error when using it in a noexcept expression
+// in some cases. This is a check to workaround the common failing case.
+#ifdef TL_TRAITS_LIBCXX_MEM_FN_WORKAROUND
+template <class T> struct is_pointer_to_non_const_member_func : std::false_type {};
+template <class T, class Ret, class... Args>
+struct is_pointer_to_non_const_member_func<Ret(T::*) (Args...)> : std::true_type {};
+template <class T, class Ret, class... Args>
+struct is_pointer_to_non_const_member_func<Ret(T::*) (Args...)&> : std::true_type {};
+template <class T, class Ret, class... Args>
+struct is_pointer_to_non_const_member_func<Ret(T::*) (Args...) &&> : std::true_type {};
+template <class T, class Ret, class... Args>
+struct is_pointer_to_non_const_member_func<Ret(T::*) (Args...) volatile> : std::true_type {};
+template <class T, class Ret, class... Args>
+struct is_pointer_to_non_const_member_func<Ret(T::*) (Args...) volatile &> : std::true_type {};
+template <class T, class Ret, class... Args>
+struct is_pointer_to_non_const_member_func<Ret(T::*) (Args...) volatile &&> : std::true_type {};
+
+template <class T> struct is_const_or_const_ref : std::false_type {};
+template <class T> struct is_const_or_const_ref<T const&> : std::true_type {};
+template <class T> struct is_const_or_const_ref<T const> : std::true_type {};
+#endif
+
+// std::invoke from C++17
+// https://stackoverflow.com/questions/38288042/c11-14-invoke-workaround
+template <typename Fn, typename... Args,
+#ifdef TL_TRAITS_LIBCXX_MEM_FN_WORKAROUND
+  typename = enable_if_t<!(is_pointer_to_non_const_member_func<Fn>::value
+    && is_const_or_const_ref<Args...>::value)>,
+#endif
+  typename = enable_if_t<std::is_member_pointer<decay_t<Fn>>::value>,
+  int = 0>
+  constexpr auto invoke(Fn && f, Args && ... args) noexcept(
+    noexcept(std::mem_fn(f)(std::forward<Args>(args)...)))
+  -> decltype(std::mem_fn(f)(std::forward<Args>(args)...)) {
+  return std::mem_fn(f)(std::forward<Args>(args)...);
+}
+
+template <typename Fn, typename... Args,
+  typename = enable_if_t<!std::is_member_pointer<decay_t<Fn>>::value>>
+  constexpr auto invoke(Fn && f, Args && ... args) noexcept(
+    noexcept(std::forward<Fn>(f)(std::forward<Args>(args)...)))
+  -> decltype(std::forward<Fn>(f)(std::forward<Args>(args)...)) {
+  return std::forward<Fn>(f)(std::forward<Args>(args)...);
+}
+
+// std::invoke_result from C++17
+template <class F, class, class... Us> struct invoke_result_impl;
+
+template <class F, class... Us>
+struct invoke_result_impl<
+  F, decltype(detail::invoke(std::declval<F>(), std::declval<Us>()...), void()),
+  Us...> {
+  using type = decltype(detail::invoke(std::declval<F>(), std::declval<Us>()...));
+};
+
+template <class F, class... Us>
+using invoke_result = invoke_result_impl<F, void, Us...>;
+
+template <class F, class... Us>
+using invoke_result_t = typename invoke_result<F, Us...>::type;
+
+#if defined(_MSC_VER) && _MSC_VER <= 1900
+// TODO make a version which works with MSVC 2015
+template <class T, class U = T> struct is_swappable : std::true_type {};
+
+template <class T, class U = T> struct is_nothrow_swappable : std::true_type {};
+#else
+// https://stackoverflow.com/questions/26744589/what-is-a-proper-way-to-implement-is-swappable-to-test-for-the-swappable-concept
+namespace swap_adl_tests {
+  // if swap ADL finds this then it would call std::swap otherwise (same
+  // signature)
+  struct tag {};
+
+  template <class T> tag swap(T&, T&);
+  template <class T, std::size_t N> tag swap(T(&a)[N], T(&b)[N]);
+
+  // helper functions to test if an unqualified swap is possible, and if it
+  // becomes std::swap
+  template <class, class> std::false_type can_swap(...) noexcept(false);
+  template <class T, class U,
+    class = decltype(swap(std::declval<T&>(), std::declval<U&>()))>
+    std::true_type can_swap(int) noexcept(noexcept(swap(std::declval<T&>(),
+      std::declval<U&>())));
+
+  template <class, class> std::false_type uses_std(...);
+  template <class T, class U>
+  std::is_same<decltype(swap(std::declval<T&>(), std::declval<U&>())), tag>
+    uses_std(int);
+
+  template <class T>
+  struct is_std_swap_noexcept
+    : std::integral_constant<bool,
+    std::is_nothrow_move_constructible<T>::value&&
+    std::is_nothrow_move_assignable<T>::value> {};
+
+  template <class T, std::size_t N>
+  struct is_std_swap_noexcept<T[N]> : is_std_swap_noexcept<T> {};
+
+  template <class T, class U>
+  struct is_adl_swap_noexcept
+    : std::integral_constant<bool, noexcept(can_swap<T, U>(0))> {};
+} // namespace swap_adl_tests
+
+template <class T, class U = T>
+struct is_swappable
+  : std::integral_constant<
+  bool,
+  decltype(detail::swap_adl_tests::can_swap<T, U>(0))::value &&
+  (!decltype(detail::swap_adl_tests::uses_std<T, U>(0))::value ||
+  (std::is_move_assignable<T>::value &&
+    std::is_move_constructible<T>::value))> {};
+
+template <class T, std::size_t N>
+struct is_swappable<T[N], T[N]>
+  : std::integral_constant<
+  bool,
+  decltype(detail::swap_adl_tests::can_swap<T[N], T[N]>(0))::value &&
+  (!decltype(
+    detail::swap_adl_tests::uses_std<T[N], T[N]>(0))::value ||
+    is_swappable<T, T>::value)> {};
+
+template <class T, class U = T>
+struct is_nothrow_swappable
+  : std::integral_constant<
+  bool,
+  is_swappable<T, U>::value &&
+  ((decltype(detail::swap_adl_tests::uses_std<T, U>(0))::value
+    && detail::swap_adl_tests::is_std_swap_noexcept<T>::value) ||
+    (!decltype(detail::swap_adl_tests::uses_std<T, U>(0))::value &&
+      detail::swap_adl_tests::is_adl_swap_noexcept<T,
+      U>::value))> {
+};
+#endif
+#endif
+
+// Trait for checking if a type is a tl::expected
+template <class T> struct is_expected_impl : std::false_type {};
+template <class T, class E>
+struct is_expected_impl<expected<T, E>> : std::true_type {};
+template <class T> using is_expected = is_expected_impl<decay_t<T>>;
+
+template <class T, class E, class U>
+using expected_enable_forward_value = detail::enable_if_t<
+    std::is_constructible<T, U &&>::value &&
+    !std::is_same<detail::decay_t<U>, in_place_t>::value &&
+    !std::is_same<expected<T, E>, detail::decay_t<U>>::value &&
+    !std::is_same<unexpected<E>, detail::decay_t<U>>::value>;
+
+template <class T, class E, class U, class G, class UR, class GR>
+using expected_enable_from_other = detail::enable_if_t<
+    std::is_constructible<T, UR>::value &&
+    std::is_constructible<E, GR>::value &&
+    !std::is_constructible<T, expected<U, G> &>::value &&
+    !std::is_constructible<T, expected<U, G> &&>::value &&
+    !std::is_constructible<T, const expected<U, G> &>::value &&
+    !std::is_constructible<T, const expected<U, G> &&>::value &&
+    !std::is_convertible<expected<U, G> &, T>::value &&
+    !std::is_convertible<expected<U, G> &&, T>::value &&
+    !std::is_convertible<const expected<U, G> &, T>::value &&
+    !std::is_convertible<const expected<U, G> &&, T>::value>;
+
+template <class T, class U>
+using is_void_or = conditional_t<std::is_void<T>::value, std::true_type, U>;
+
+template <class T>
+using is_copy_constructible_or_void =
+    is_void_or<T, std::is_copy_constructible<T>>;
+
+template <class T>
+using is_move_constructible_or_void =
+    is_void_or<T, std::is_move_constructible<T>>;
+
+template <class T>
+using is_copy_assignable_or_void =
+    is_void_or<T, std::is_copy_assignable<T>>;
+
+
+template <class T>
+using is_move_assignable_or_void =
+    is_void_or<T, std::is_move_assignable<T>>;
+    
+
+} // namespace detail
+
+namespace detail {
+struct no_init_t {};
+static constexpr no_init_t no_init{};
+
+// Implements the storage of the values, and ensures that the destructor is
+// trivial if it can be.
+//
+// This specialization is for where neither `T` or `E` is trivially
+// destructible, so the destructors must be called on destruction of the
+// `expected`
+template <class T, class E, bool = std::is_trivially_destructible<T>::value,
+          bool = std::is_trivially_destructible<E>::value>
+struct expected_storage_base {
+  constexpr expected_storage_base() : m_val(T{}), m_has_val(true) {}
+  constexpr expected_storage_base(no_init_t) : m_no_init(), m_has_val(false) {}
+
+  template <class... Args,
+            detail::enable_if_t<std::is_constructible<T, Args &&...>::value> * =
+                nullptr>
+  constexpr expected_storage_base(in_place_t, Args &&... args)
+      : m_val(std::forward<Args>(args)...), m_has_val(true) {}
+
+  template <class U, class... Args,
+            detail::enable_if_t<std::is_constructible<
+                T, std::initializer_list<U> &, Args &&...>::value> * = nullptr>
+  constexpr expected_storage_base(in_place_t, std::initializer_list<U> il,
+                                  Args &&... args)
+      : m_val(il, std::forward<Args>(args)...), m_has_val(true) {}
+  template <class... Args,
+            detail::enable_if_t<std::is_constructible<E, Args &&...>::value> * =
+                nullptr>
+  constexpr explicit expected_storage_base(unexpect_t, Args &&... args)
+      : m_unexpect(std::forward<Args>(args)...), m_has_val(false) {}
+
+  template <class U, class... Args,
+            detail::enable_if_t<std::is_constructible<
+                E, std::initializer_list<U> &, Args &&...>::value> * = nullptr>
+  constexpr explicit expected_storage_base(unexpect_t,
+                                           std::initializer_list<U> il,
+                                           Args &&... args)
+      : m_unexpect(il, std::forward<Args>(args)...), m_has_val(false) {}
+
+  ~expected_storage_base() {
+    if (m_has_val) {
+      m_val.~T();
+    } else {
+      m_unexpect.~unexpected<E>();
+    }
+  }
+  union {
+    T m_val;
+    unexpected<E> m_unexpect;
+    char m_no_init;
+  };
+  bool m_has_val;
+};
+
+// This specialization is for when both `T` and `E` are trivially-destructible,
+// so the destructor of the `expected` can be trivial.
+template <class T, class E> struct expected_storage_base<T, E, true, true> {
+  constexpr expected_storage_base() : m_val(T{}), m_has_val(true) {}
+  constexpr expected_storage_base(no_init_t) : m_no_init(), m_has_val(false) {}
+
+  template <class... Args,
+            detail::enable_if_t<std::is_constructible<T, Args &&...>::value> * =
+                nullptr>
+  constexpr expected_storage_base(in_place_t, Args &&... args)
+      : m_val(std::forward<Args>(args)...), m_has_val(true) {}
+
+  template <class U, class... Args,
+            detail::enable_if_t<std::is_constructible<
+                T, std::initializer_list<U> &, Args &&...>::value> * = nullptr>
+  constexpr expected_storage_base(in_place_t, std::initializer_list<U> il,
+                                  Args &&... args)
+      : m_val(il, std::forward<Args>(args)...), m_has_val(true) {}
+  template <class... Args,
+            detail::enable_if_t<std::is_constructible<E, Args &&...>::value> * =
+                nullptr>
+  constexpr explicit expected_storage_base(unexpect_t, Args &&... args)
+      : m_unexpect(std::forward<Args>(args)...), m_has_val(false) {}
+
+  template <class U, class... Args,
+            detail::enable_if_t<std::is_constructible<
+                E, std::initializer_list<U> &, Args &&...>::value> * = nullptr>
+  constexpr explicit expected_storage_base(unexpect_t,
+                                           std::initializer_list<U> il,
+                                           Args &&... args)
+      : m_unexpect(il, std::forward<Args>(args)...), m_has_val(false) {}
+
+  ~expected_storage_base() = default;
+  union {
+    T m_val;
+    unexpected<E> m_unexpect;
+    char m_no_init;
+  };
+  bool m_has_val;
+};
+
+// T is trivial, E is not.
+template <class T, class E> struct expected_storage_base<T, E, true, false> {
+  constexpr expected_storage_base() : m_val(T{}), m_has_val(true) {}
+  TL_EXPECTED_MSVC2015_CONSTEXPR expected_storage_base(no_init_t)
+      : m_no_init(), m_has_val(false) {}
+
+  template <class... Args,
+            detail::enable_if_t<std::is_constructible<T, Args &&...>::value> * =
+                nullptr>
+  constexpr expected_storage_base(in_place_t, Args &&... args)
+      : m_val(std::forward<Args>(args)...), m_has_val(true) {}
+
+  template <class U, class... Args,
+            detail::enable_if_t<std::is_constructible<
+                T, std::initializer_list<U> &, Args &&...>::value> * = nullptr>
+  constexpr expected_storage_base(in_place_t, std::initializer_list<U> il,
+                                  Args &&... args)
+      : m_val(il, std::forward<Args>(args)...), m_has_val(true) {}
+  template <class... Args,
+            detail::enable_if_t<std::is_constructible<E, Args &&...>::value> * =
+                nullptr>
+  constexpr explicit expected_storage_base(unexpect_t, Args &&... args)
+      : m_unexpect(std::forward<Args>(args)...), m_has_val(false) {}
+
+  template <class U, class... Args,
+            detail::enable_if_t<std::is_constructible<
+                E, std::initializer_list<U> &, Args &&...>::value> * = nullptr>
+  constexpr explicit expected_storage_base(unexpect_t,
+                                           std::initializer_list<U> il,
+                                           Args &&... args)
+      : m_unexpect(il, std::forward<Args>(args)...), m_has_val(false) {}
+
+  ~expected_storage_base() {
+    if (!m_has_val) {
+      m_unexpect.~unexpected<E>();
+    }
+  }
+
+  union {
+    T m_val;
+    unexpected<E> m_unexpect;
+    char m_no_init;
+  };
+  bool m_has_val;
+};
+
+// E is trivial, T is not.
+template <class T, class E> struct expected_storage_base<T, E, false, true> {
+  constexpr expected_storage_base() : m_val(T{}), m_has_val(true) {}
+  constexpr expected_storage_base(no_init_t) : m_no_init(), m_has_val(false) {}
+
+  template <class... Args,
+            detail::enable_if_t<std::is_constructible<T, Args &&...>::value> * =
+                nullptr>
+  constexpr expected_storage_base(in_place_t, Args &&... args)
+      : m_val(std::forward<Args>(args)...), m_has_val(true) {}
+
+  template <class U, class... Args,
+            detail::enable_if_t<std::is_constructible<
+                T, std::initializer_list<U> &, Args &&...>::value> * = nullptr>
+  constexpr expected_storage_base(in_place_t, std::initializer_list<U> il,
+                                  Args &&... args)
+      : m_val(il, std::forward<Args>(args)...), m_has_val(true) {}
+  template <class... Args,
+            detail::enable_if_t<std::is_constructible<E, Args &&...>::value> * =
+                nullptr>
+  constexpr explicit expected_storage_base(unexpect_t, Args &&... args)
+      : m_unexpect(std::forward<Args>(args)...), m_has_val(false) {}
+
+  template <class U, class... Args,
+            detail::enable_if_t<std::is_constructible<
+                E, std::initializer_list<U> &, Args &&...>::value> * = nullptr>
+  constexpr explicit expected_storage_base(unexpect_t,
+                                           std::initializer_list<U> il,
+                                           Args &&... args)
+      : m_unexpect(il, std::forward<Args>(args)...), m_has_val(false) {}
+
+  ~expected_storage_base() {
+    if (m_has_val) {
+      m_val.~T();
+    }
+  }
+  union {
+    T m_val;
+    unexpected<E> m_unexpect;
+    char m_no_init;
+  };
+  bool m_has_val;
+};
+
+// `T` is `void`, `E` is trivially-destructible
+template <class E> struct expected_storage_base<void, E, false, true> {
+  TL_EXPECTED_MSVC2015_CONSTEXPR expected_storage_base() : m_has_val(true) {}
+  constexpr expected_storage_base(no_init_t) : m_val(), m_has_val(false) {}
+
+  constexpr expected_storage_base(in_place_t) : m_has_val(true) {}
+
+  template <class... Args,
+            detail::enable_if_t<std::is_constructible<E, Args &&...>::value> * =
+                nullptr>
+  constexpr explicit expected_storage_base(unexpect_t, Args &&... args)
+      : m_unexpect(std::forward<Args>(args)...), m_has_val(false) {}
+
+  template <class U, class... Args,
+            detail::enable_if_t<std::is_constructible<
+                E, std::initializer_list<U> &, Args &&...>::value> * = nullptr>
+  constexpr explicit expected_storage_base(unexpect_t,
+                                           std::initializer_list<U> il,
+                                           Args &&... args)
+      : m_unexpect(il, std::forward<Args>(args)...), m_has_val(false) {}
+
+  ~expected_storage_base() = default;
+  struct dummy {};
+  union {
+    unexpected<E> m_unexpect;
+    dummy m_val;
+  };
+  bool m_has_val;
+};
+
+// `T` is `void`, `E` is not trivially-destructible
+template <class E> struct expected_storage_base<void, E, false, false> {
+  constexpr expected_storage_base() : m_dummy(), m_has_val(true) {}
+  constexpr expected_storage_base(no_init_t) : m_dummy(), m_has_val(false) {}
+
+  constexpr expected_storage_base(in_place_t) : m_dummy(), m_has_val(true) {}
+
+  template <class... Args,
+            detail::enable_if_t<std::is_constructible<E, Args &&...>::value> * =
+                nullptr>
+  constexpr explicit expected_storage_base(unexpect_t, Args &&... args)
+      : m_unexpect(std::forward<Args>(args)...), m_has_val(false) {}
+
+  template <class U, class... Args,
+            detail::enable_if_t<std::is_constructible<
+                E, std::initializer_list<U> &, Args &&...>::value> * = nullptr>
+  constexpr explicit expected_storage_base(unexpect_t,
+                                           std::initializer_list<U> il,
+                                           Args &&... args)
+      : m_unexpect(il, std::forward<Args>(args)...), m_has_val(false) {}
+
+  ~expected_storage_base() {
+    if (!m_has_val) {
+      m_unexpect.~unexpected<E>();
+    }
+  }
+
+  union {
+    unexpected<E> m_unexpect;
+    char m_dummy;
+  };
+  bool m_has_val;
+};
+
+// This base class provides some handy member functions which can be used in
+// further derived classes
+template <class T, class E>
+struct expected_operations_base : expected_storage_base<T, E> {
+  using expected_storage_base<T, E>::expected_storage_base;
+
+  template <class... Args> void construct(Args &&... args) noexcept {
+    new (std::addressof(this->m_val)) T(std::forward<Args>(args)...);
+    this->m_has_val = true;
+  }
+
+  template <class Rhs> void construct_with(Rhs &&rhs) noexcept {
+    new (std::addressof(this->m_val)) T(std::forward<Rhs>(rhs).get());
+    this->m_has_val = true;
+  }
+
+  template <class... Args> void construct_error(Args &&... args) noexcept {
+    new (std::addressof(this->m_unexpect))
+        unexpected<E>(std::forward<Args>(args)...);
+    this->m_has_val = false;
+  }
+
+  #ifdef TL_EXPECTED_EXCEPTIONS_ENABLED
+
+  // These assign overloads ensure that the most efficient assignment
+  // implementation is used while maintaining the strong exception guarantee.
+  // The problematic case is where rhs has a value, but *this does not.
+  //
+  // This overload handles the case where we can just copy-construct `T`
+  // directly into place without throwing.
+  template <class U = T,
+            detail::enable_if_t<std::is_nothrow_copy_constructible<U>::value>
+                * = nullptr>
+  void assign(const expected_operations_base &rhs) noexcept {
+    if (!this->m_has_val && rhs.m_has_val) {
+      geterr().~unexpected<E>();
+      construct(rhs.get());
+    } else {
+      assign_common(rhs);
+    }
+  }
+
+  // This overload handles the case where we can attempt to create a copy of
+  // `T`, then no-throw move it into place if the copy was successful.
+  template <class U = T,
+            detail::enable_if_t<!std::is_nothrow_copy_constructible<U>::value &&
+                                std::is_nothrow_move_constructible<U>::value>
+                * = nullptr>
+  void assign(const expected_operations_base &rhs) noexcept {
+    if (!this->m_has_val && rhs.m_has_val) {
+      T tmp = rhs.get();
+      geterr().~unexpected<E>();
+      construct(std::move(tmp));
+    } else {
+      assign_common(rhs);
+    }
+  }
+
+  // This overload is the worst-case, where we have to move-construct the
+  // unexpected value into temporary storage, then try to copy the T into place.
+  // If the construction succeeds, then everything is fine, but if it throws,
+  // then we move the old unexpected value back into place before rethrowing the
+  // exception.
+  template <class U = T,
+            detail::enable_if_t<!std::is_nothrow_copy_constructible<U>::value &&
+                                !std::is_nothrow_move_constructible<U>::value>
+                * = nullptr>
+  void assign(const expected_operations_base &rhs) {
+    if (!this->m_has_val && rhs.m_has_val) {
+      auto tmp = std::move(geterr());
+      geterr().~unexpected<E>();
+
+#ifdef TL_EXPECTED_EXCEPTIONS_ENABLED
+      try {
+        construct(rhs.get());
+      } catch (...) {
+        geterr() = std::move(tmp);
+        throw;
+      }
+#else
+      construct(rhs.get());
+#endif
+    } else {
+      assign_common(rhs);
+    }
+  }
+
+  // These overloads do the same as above, but for rvalues
+  template <class U = T,
+            detail::enable_if_t<std::is_nothrow_move_constructible<U>::value>
+                * = nullptr>
+  void assign(expected_operations_base &&rhs) noexcept {
+    if (!this->m_has_val && rhs.m_has_val) {
+      geterr().~unexpected<E>();
+      construct(std::move(rhs).get());
+    } else {
+      assign_common(std::move(rhs));
+    }
+  }
+
+  template <class U = T,
+            detail::enable_if_t<!std::is_nothrow_move_constructible<U>::value>
+                * = nullptr>
+  void assign(expected_operations_base &&rhs) {
+    if (!this->m_has_val && rhs.m_has_val) {
+      auto tmp = std::move(geterr());
+      geterr().~unexpected<E>();
+#ifdef TL_EXPECTED_EXCEPTIONS_ENABLED
+      try {
+        construct(std::move(rhs).get());
+      } catch (...) {
+        geterr() = std::move(tmp);
+        throw;
+      }
+#else
+      construct(std::move(rhs).get());
+#endif
+    } else {
+      assign_common(std::move(rhs));
+    }
+  }
+
+  #else
+
+  // If exceptions are disabled then we can just copy-construct
+  void assign(const expected_operations_base &rhs) noexcept {
+    if (!this->m_has_val && rhs.m_has_val) {
+      geterr().~unexpected<E>();
+      construct(rhs.get());
+    } else {
+      assign_common(rhs);
+    }
+  }
+
+  void assign(expected_operations_base &&rhs) noexcept {
+    if (!this->m_has_val && rhs.m_has_val) {
+      geterr().~unexpected<E>();
+      construct(std::move(rhs).get());
+    } else {
+      assign_common(rhs);
+    }
+  }
+
+  #endif
+
+  // The common part of move/copy assigning
+  template <class Rhs> void assign_common(Rhs &&rhs) {
+    if (this->m_has_val) {
+      if (rhs.m_has_val) {
+        get() = std::forward<Rhs>(rhs).get();
+      } else {
+		destroy_val();
+        construct_error(std::forward<Rhs>(rhs).geterr());
+      }
+    } else {
+      if (!rhs.m_has_val) {
+        geterr() = std::forward<Rhs>(rhs).geterr();
+      }
+    }
+  }
+
+  bool has_value() const { return this->m_has_val; }
+
+  TL_EXPECTED_11_CONSTEXPR T &get() & { return this->m_val; }
+  constexpr const T &get() const & { return this->m_val; }
+  TL_EXPECTED_11_CONSTEXPR T &&get() && { return std::move(this->m_val); }
+#ifndef TL_EXPECTED_NO_CONSTRR
+  constexpr const T &&get() const && { return std::move(this->m_val); }
+#endif
+
+  TL_EXPECTED_11_CONSTEXPR unexpected<E> &geterr() & {
+    return this->m_unexpect;
+  }
+  constexpr const unexpected<E> &geterr() const & { return this->m_unexpect; }
+  TL_EXPECTED_11_CONSTEXPR unexpected<E> &&geterr() && {
+    return std::move(this->m_unexpect);
+  }
+#ifndef TL_EXPECTED_NO_CONSTRR
+  constexpr const unexpected<E> &&geterr() const && {
+    return std::move(this->m_unexpect);
+  }
+#endif
+
+  TL_EXPECTED_11_CONSTEXPR void destroy_val() {
+	get().~T();
+  }
+};
+
+// This base class provides some handy member functions which can be used in
+// further derived classes
+template <class E>
+struct expected_operations_base<void, E> : expected_storage_base<void, E> {
+  using expected_storage_base<void, E>::expected_storage_base;
+
+  template <class... Args> void construct() noexcept { this->m_has_val = true; }
+
+  // This function doesn't use its argument, but needs it so that code in
+  // levels above this can work independently of whether T is void
+  template <class Rhs> void construct_with(Rhs &&) noexcept {
+    this->m_has_val = true;
+  }
+
+  template <class... Args> void construct_error(Args &&... args) noexcept {
+    new (std::addressof(this->m_unexpect))
+        unexpected<E>(std::forward<Args>(args)...);
+    this->m_has_val = false;
+  }
+
+  template <class Rhs> void assign(Rhs &&rhs) noexcept {
+    if (!this->m_has_val) {
+      if (rhs.m_has_val) {
+        geterr().~unexpected<E>();
+        construct();
+      } else {
+        geterr() = std::forward<Rhs>(rhs).geterr();
+      }
+    } else {
+      if (!rhs.m_has_val) {
+        construct_error(std::forward<Rhs>(rhs).geterr());
+      }
+    }
+  }
+
+  bool has_value() const { return this->m_has_val; }
+
+  TL_EXPECTED_11_CONSTEXPR unexpected<E> &geterr() & {
+    return this->m_unexpect;
+  }
+  constexpr const unexpected<E> &geterr() const & { return this->m_unexpect; }
+  TL_EXPECTED_11_CONSTEXPR unexpected<E> &&geterr() && {
+    return std::move(this->m_unexpect);
+  }
+#ifndef TL_EXPECTED_NO_CONSTRR
+  constexpr const unexpected<E> &&geterr() const && {
+    return std::move(this->m_unexpect);
+  }
+#endif
+
+  TL_EXPECTED_11_CONSTEXPR void destroy_val() {
+	  //no-op
+  }
+};
+
+// This class manages conditionally having a trivial copy constructor
+// This specialization is for when T and E are trivially copy constructible
+template <class T, class E,
+          bool = is_void_or<T, TL_EXPECTED_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(T)>::
+              value &&TL_EXPECTED_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(E)::value>
+struct expected_copy_base : expected_operations_base<T, E> {
+  using expected_operations_base<T, E>::expected_operations_base;
+};
+
+// This specialization is for when T or E are not trivially copy constructible
+template <class T, class E>
+struct expected_copy_base<T, E, false> : expected_operations_base<T, E> {
+  using expected_operations_base<T, E>::expected_operations_base;
+
+  expected_copy_base() = default;
+  expected_copy_base(const expected_copy_base &rhs)
+      : expected_operations_base<T, E>(no_init) {
+    if (rhs.has_value()) {
+      this->construct_with(rhs);
+    } else {
+      this->construct_error(rhs.geterr());
+    }
+  }
+
+  expected_copy_base(expected_copy_base &&rhs) = default;
+  expected_copy_base &operator=(const expected_copy_base &rhs) = default;
+  expected_copy_base &operator=(expected_copy_base &&rhs) = default;
+};
+
+// This class manages conditionally having a trivial move constructor
+// Unfortunately there's no way to achieve this in GCC < 5 AFAIK, since it
+// doesn't implement an analogue to std::is_trivially_move_constructible. We
+// have to make do with a non-trivial move constructor even if T is trivially
+// move constructible
+#ifndef TL_EXPECTED_GCC49
+template <class T, class E,
+          bool = is_void_or<T, std::is_trivially_move_constructible<T>>::value
+              &&std::is_trivially_move_constructible<E>::value>
+struct expected_move_base : expected_copy_base<T, E> {
+  using expected_copy_base<T, E>::expected_copy_base;
+};
+#else
+template <class T, class E, bool = false> struct expected_move_base;
+#endif
+template <class T, class E>
+struct expected_move_base<T, E, false> : expected_copy_base<T, E> {
+  using expected_copy_base<T, E>::expected_copy_base;
+
+  expected_move_base() = default;
+  expected_move_base(const expected_move_base &rhs) = default;
+
+  expected_move_base(expected_move_base &&rhs) noexcept(
+      std::is_nothrow_move_constructible<T>::value)
+      : expected_copy_base<T, E>(no_init) {
+    if (rhs.has_value()) {
+      this->construct_with(std::move(rhs));
+    } else {
+      this->construct_error(std::move(rhs.geterr()));
+    }
+  }
+  expected_move_base &operator=(const expected_move_base &rhs) = default;
+  expected_move_base &operator=(expected_move_base &&rhs) = default;
+};
+
+// This class manages conditionally having a trivial copy assignment operator
+template <class T, class E,
+          bool = is_void_or<
+              T, conjunction<TL_EXPECTED_IS_TRIVIALLY_COPY_ASSIGNABLE(T),
+                             TL_EXPECTED_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(T),
+                             TL_EXPECTED_IS_TRIVIALLY_DESTRUCTIBLE(T)>>::value
+              &&TL_EXPECTED_IS_TRIVIALLY_COPY_ASSIGNABLE(E)::value
+                  &&TL_EXPECTED_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(E)::value
+                      &&TL_EXPECTED_IS_TRIVIALLY_DESTRUCTIBLE(E)::value>
+struct expected_copy_assign_base : expected_move_base<T, E> {
+  using expected_move_base<T, E>::expected_move_base;
+};
+
+template <class T, class E>
+struct expected_copy_assign_base<T, E, false> : expected_move_base<T, E> {
+  using expected_move_base<T, E>::expected_move_base;
+
+  expected_copy_assign_base() = default;
+  expected_copy_assign_base(const expected_copy_assign_base &rhs) = default;
+
+  expected_copy_assign_base(expected_copy_assign_base &&rhs) = default;
+  expected_copy_assign_base &operator=(const expected_copy_assign_base &rhs) {
+    this->assign(rhs);
+    return *this;
+  }
+  expected_copy_assign_base &
+  operator=(expected_copy_assign_base &&rhs) = default;
+};
+
+// This class manages conditionally having a trivial move assignment operator
+// Unfortunately there's no way to achieve this in GCC < 5 AFAIK, since it
+// doesn't implement an analogue to std::is_trivially_move_assignable. We have
+// to make do with a non-trivial move assignment operator even if T is trivially
+// move assignable
+#ifndef TL_EXPECTED_GCC49
+template <class T, class E,
+          bool =
+              is_void_or<T, conjunction<std::is_trivially_destructible<T>,
+                                        std::is_trivially_move_constructible<T>,
+                                        std::is_trivially_move_assignable<T>>>::
+                  value &&std::is_trivially_destructible<E>::value
+                      &&std::is_trivially_move_constructible<E>::value
+                          &&std::is_trivially_move_assignable<E>::value>
+struct expected_move_assign_base : expected_copy_assign_base<T, E> {
+  using expected_copy_assign_base<T, E>::expected_copy_assign_base;
+};
+#else
+template <class T, class E, bool = false> struct expected_move_assign_base;
+#endif
+
+template <class T, class E>
+struct expected_move_assign_base<T, E, false>
+    : expected_copy_assign_base<T, E> {
+  using expected_copy_assign_base<T, E>::expected_copy_assign_base;
+
+  expected_move_assign_base() = default;
+  expected_move_assign_base(const expected_move_assign_base &rhs) = default;
+
+  expected_move_assign_base(expected_move_assign_base &&rhs) = default;
+
+  expected_move_assign_base &
+  operator=(const expected_move_assign_base &rhs) = default;
+
+  expected_move_assign_base &
+  operator=(expected_move_assign_base &&rhs) noexcept(
+      std::is_nothrow_move_constructible<T>::value
+          &&std::is_nothrow_move_assignable<T>::value) {
+    this->assign(std::move(rhs));
+    return *this;
+  }
+};
+
+// expected_delete_ctor_base will conditionally delete copy and move
+// constructors depending on whether T is copy/move constructible
+template <class T, class E,
+          bool EnableCopy = (is_copy_constructible_or_void<T>::value &&
+                             std::is_copy_constructible<E>::value),
+          bool EnableMove = (is_move_constructible_or_void<T>::value &&
+                             std::is_move_constructible<E>::value)>
+struct expected_delete_ctor_base {
+  expected_delete_ctor_base() = default;
+  expected_delete_ctor_base(const expected_delete_ctor_base &) = default;
+  expected_delete_ctor_base(expected_delete_ctor_base &&) noexcept = default;
+  expected_delete_ctor_base &
+  operator=(const expected_delete_ctor_base &) = default;
+  expected_delete_ctor_base &
+  operator=(expected_delete_ctor_base &&) noexcept = default;
+};
+
+template <class T, class E>
+struct expected_delete_ctor_base<T, E, true, false> {
+  expected_delete_ctor_base() = default;
+  expected_delete_ctor_base(const expected_delete_ctor_base &) = default;
+  expected_delete_ctor_base(expected_delete_ctor_base &&) noexcept = delete;
+  expected_delete_ctor_base &
+  operator=(const expected_delete_ctor_base &) = default;
+  expected_delete_ctor_base &
+  operator=(expected_delete_ctor_base &&) noexcept = default;
+};
+
+template <class T, class E>
+struct expected_delete_ctor_base<T, E, false, true> {
+  expected_delete_ctor_base() = default;
+  expected_delete_ctor_base(const expected_delete_ctor_base &) = delete;
+  expected_delete_ctor_base(expected_delete_ctor_base &&) noexcept = default;
+  expected_delete_ctor_base &
+  operator=(const expected_delete_ctor_base &) = default;
+  expected_delete_ctor_base &
+  operator=(expected_delete_ctor_base &&) noexcept = default;
+};
+
+template <class T, class E>
+struct expected_delete_ctor_base<T, E, false, false> {
+  expected_delete_ctor_base() = default;
+  expected_delete_ctor_base(const expected_delete_ctor_base &) = delete;
+  expected_delete_ctor_base(expected_delete_ctor_base &&) noexcept = delete;
+  expected_delete_ctor_base &
+  operator=(const expected_delete_ctor_base &) = default;
+  expected_delete_ctor_base &
+  operator=(expected_delete_ctor_base &&) noexcept = default;
+};
+
+// expected_delete_assign_base will conditionally delete copy and move
+// constructors depending on whether T and E are copy/move constructible +
+// assignable
+template <class T, class E,
+          bool EnableCopy = (is_copy_constructible_or_void<T>::value &&
+                             std::is_copy_constructible<E>::value &&
+                             is_copy_assignable_or_void<T>::value &&
+                             std::is_copy_assignable<E>::value),
+          bool EnableMove = (is_move_constructible_or_void<T>::value &&
+                             std::is_move_constructible<E>::value &&
+                             is_move_assignable_or_void<T>::value &&
+                             std::is_move_assignable<E>::value)>
+struct expected_delete_assign_base {
+  expected_delete_assign_base() = default;
+  expected_delete_assign_base(const expected_delete_assign_base &) = default;
+  expected_delete_assign_base(expected_delete_assign_base &&) noexcept =
+      default;
+  expected_delete_assign_base &
+  operator=(const expected_delete_assign_base &) = default;
+  expected_delete_assign_base &
+  operator=(expected_delete_assign_base &&) noexcept = default;
+};
+
+template <class T, class E>
+struct expected_delete_assign_base<T, E, true, false> {
+  expected_delete_assign_base() = default;
+  expected_delete_assign_base(const expected_delete_assign_base &) = default;
+  expected_delete_assign_base(expected_delete_assign_base &&) noexcept =
+      default;
+  expected_delete_assign_base &
+  operator=(const expected_delete_assign_base &) = default;
+  expected_delete_assign_base &
+  operator=(expected_delete_assign_base &&) noexcept = delete;
+};
+
+template <class T, class E>
+struct expected_delete_assign_base<T, E, false, true> {
+  expected_delete_assign_base() = default;
+  expected_delete_assign_base(const expected_delete_assign_base &) = default;
+  expected_delete_assign_base(expected_delete_assign_base &&) noexcept =
+      default;
+  expected_delete_assign_base &
+  operator=(const expected_delete_assign_base &) = delete;
+  expected_delete_assign_base &
+  operator=(expected_delete_assign_base &&) noexcept = default;
+};
+
+template <class T, class E>
+struct expected_delete_assign_base<T, E, false, false> {
+  expected_delete_assign_base() = default;
+  expected_delete_assign_base(const expected_delete_assign_base &) = default;
+  expected_delete_assign_base(expected_delete_assign_base &&) noexcept =
+      default;
+  expected_delete_assign_base &
+  operator=(const expected_delete_assign_base &) = delete;
+  expected_delete_assign_base &
+  operator=(expected_delete_assign_base &&) noexcept = delete;
+};
+
+// This is needed to be able to construct the expected_default_ctor_base which
+// follows, while still conditionally deleting the default constructor.
+struct default_constructor_tag {
+  explicit constexpr default_constructor_tag() = default;
+};
+
+// expected_default_ctor_base will ensure that expected has a deleted default
+// consturctor if T is not default constructible.
+// This specialization is for when T is default constructible
+template <class T, class E,
+          bool Enable =
+              std::is_default_constructible<T>::value || std::is_void<T>::value>
+struct expected_default_ctor_base {
+  constexpr expected_default_ctor_base() noexcept = default;
+  constexpr expected_default_ctor_base(
+      expected_default_ctor_base const &) noexcept = default;
+  constexpr expected_default_ctor_base(expected_default_ctor_base &&) noexcept =
+      default;
+  expected_default_ctor_base &
+  operator=(expected_default_ctor_base const &) noexcept = default;
+  expected_default_ctor_base &
+  operator=(expected_default_ctor_base &&) noexcept = default;
+
+  constexpr explicit expected_default_ctor_base(default_constructor_tag) {}
+};
+
+// This specialization is for when T is not default constructible
+template <class T, class E> struct expected_default_ctor_base<T, E, false> {
+  constexpr expected_default_ctor_base() noexcept = delete;
+  constexpr expected_default_ctor_base(
+      expected_default_ctor_base const &) noexcept = default;
+  constexpr expected_default_ctor_base(expected_default_ctor_base &&) noexcept =
+      default;
+  expected_default_ctor_base &
+  operator=(expected_default_ctor_base const &) noexcept = default;
+  expected_default_ctor_base &
+  operator=(expected_default_ctor_base &&) noexcept = default;
+
+  constexpr explicit expected_default_ctor_base(default_constructor_tag) {}
+};
+} // namespace detail
+
+template <class E> class bad_expected_access : public std::exception {
+public:
+  explicit bad_expected_access(E e) : m_val(std::move(e)) {}
+
+  virtual const char *what() const noexcept override {
+    return "Bad expected access";
+  }
+
+  const E &error() const & { return m_val; }
+  E &error() & { return m_val; }
+  const E &&error() const && { return std::move(m_val); }
+  E &&error() && { return std::move(m_val); }
+
+private:
+  E m_val;
+};
+
+/// An `expected<T, E>` object is an object that contains the storage for
+/// another object and manages the lifetime of this contained object `T`.
+/// Alternatively it could contain the storage for another unexpected object
+/// `E`. The contained object may not be initialized after the expected object
+/// has been initialized, and may not be destroyed before the expected object
+/// has been destroyed. The initialization state of the contained object is
+/// tracked by the expected object.
+template <class T, class E>
+class expected : private detail::expected_move_assign_base<T, E>,
+                 private detail::expected_delete_ctor_base<T, E>,
+                 private detail::expected_delete_assign_base<T, E>,
+                 private detail::expected_default_ctor_base<T, E> {
+  static_assert(!std::is_reference<T>::value, "T must not be a reference");
+  static_assert(!std::is_same<T, std::remove_cv<in_place_t>>::value,
+                "T must not be in_place_t");
+  static_assert(!std::is_same<T, std::remove_cv<unexpect_t>>::value,
+                "T must not be unexpect_t");
+  static_assert(!std::is_same<T, std::remove_cv<unexpected<E>>>::value,
+                "T must not be unexpected<E>");
+  static_assert(!std::is_reference<E>::value, "E must not be a reference");
+
+  T *valptr() { return std::addressof(this->m_val); }
+  const T *valptr() const { return std::addressof(this->m_val); }    
+  unexpected<E> *errptr() { return std::addressof(this->m_unexpect); }
+  const unexpected<E> *errptr() const { return std::addressof(this->m_unexpect); }    
+
+  template <class U = T,
+            detail::enable_if_t<!std::is_void<U>::value> * = nullptr>
+  TL_EXPECTED_11_CONSTEXPR U &val() {
+    return this->m_val;
+  }
+  TL_EXPECTED_11_CONSTEXPR unexpected<E> &err() { return this->m_unexpect; }
+
+  template <class U = T,
+            detail::enable_if_t<!std::is_void<U>::value> * = nullptr>
+  constexpr const U &val() const {
+    return this->m_val;
+  }
+  constexpr const unexpected<E> &err() const { return this->m_unexpect; }
+
+  using impl_base = detail::expected_move_assign_base<T, E>;
+  using ctor_base = detail::expected_default_ctor_base<T, E>;
+
+public:
+  typedef T value_type;
+  typedef E error_type;
+  typedef unexpected<E> unexpected_type;
+
+#if defined(TL_EXPECTED_CXX14) && !defined(TL_EXPECTED_GCC49) &&               \
+    !defined(TL_EXPECTED_GCC54) && !defined(TL_EXPECTED_GCC55)
+  template <class F> TL_EXPECTED_11_CONSTEXPR auto and_then(F &&f) & {
+    return and_then_impl(*this, std::forward<F>(f));
+  }
+  template <class F> TL_EXPECTED_11_CONSTEXPR auto and_then(F &&f) && {
+    return and_then_impl(std::move(*this), std::forward<F>(f));
+  }
+  template <class F> constexpr auto and_then(F &&f) const & {
+    return and_then_impl(*this, std::forward<F>(f));
+  }
+
+#ifndef TL_EXPECTED_NO_CONSTRR
+  template <class F> constexpr auto and_then(F &&f) const && {
+    return and_then_impl(std::move(*this), std::forward<F>(f));
+  }
+#endif
+
+#else
+  template <class F>
+  TL_EXPECTED_11_CONSTEXPR auto
+  and_then(F &&f) & -> decltype(and_then_impl(std::declval<expected&>(), std::forward<F>(f))) {
+    return and_then_impl(*this, std::forward<F>(f));
+  }
+  template <class F>
+  TL_EXPECTED_11_CONSTEXPR auto and_then(F &&f) && -> decltype(
+      and_then_impl(std::declval<expected&&>(), std::forward<F>(f))) {
+    return and_then_impl(std::move(*this), std::forward<F>(f));
+  }
+  template <class F>
+  constexpr auto and_then(F &&f) const & -> decltype(
+      and_then_impl(std::declval<expected const&>(), std::forward<F>(f))) {
+    return and_then_impl(*this, std::forward<F>(f));
+  }
+
+#ifndef TL_EXPECTED_NO_CONSTRR
+  template <class F>
+  constexpr auto and_then(F &&f) const && -> decltype(
+      and_then_impl(std::declval<expected const&&>(), std::forward<F>(f))) {
+    return and_then_impl(std::move(*this), std::forward<F>(f));
+  }
+#endif
+#endif
+
+#if defined(TL_EXPECTED_CXX14) && !defined(TL_EXPECTED_GCC49) &&               \
+    !defined(TL_EXPECTED_GCC54) && !defined(TL_EXPECTED_GCC55)
+    template <class F> TL_EXPECTED_11_CONSTEXPR auto map(F &&f) & {
+    return expected_map_impl(*this, std::forward<F>(f));
+  }
+  template <class F> TL_EXPECTED_11_CONSTEXPR auto map(F &&f) && {
+    return expected_map_impl(std::move(*this), std::forward<F>(f));
+  }
+  template <class F> constexpr auto map(F &&f) const & {
+    return expected_map_impl(*this, std::forward<F>(f));
+  }
+  template <class F> constexpr auto map(F &&f) const && {
+    return expected_map_impl(std::move(*this), std::forward<F>(f));
+  }
+#else
+  template <class F>
+  TL_EXPECTED_11_CONSTEXPR decltype(
+      expected_map_impl(std::declval<expected &>(), std::declval<F &&>()))
+  map(F &&f) & {
+    return expected_map_impl(*this, std::forward<F>(f));
+  }
+  template <class F>
+  TL_EXPECTED_11_CONSTEXPR decltype(
+      expected_map_impl(std::declval<expected>(), std::declval<F &&>()))
+  map(F &&f) && {
+    return expected_map_impl(std::move(*this), std::forward<F>(f));
+  }
+  template <class F>
+  constexpr decltype(expected_map_impl(std::declval<const expected &>(),
+                                       std::declval<F &&>()))
+  map(F &&f) const & {
+    return expected_map_impl(*this, std::forward<F>(f));
+  }
+
+#ifndef TL_EXPECTED_NO_CONSTRR
+  template <class F>
+  constexpr decltype(expected_map_impl(std::declval<const expected &&>(),
+                                       std::declval<F &&>()))
+  map(F &&f) const && {
+    return expected_map_impl(std::move(*this), std::forward<F>(f));
+  }
+#endif
+#endif
+
+#if defined(TL_EXPECTED_CXX14) && !defined(TL_EXPECTED_GCC49) &&               \
+    !defined(TL_EXPECTED_GCC54) && !defined(TL_EXPECTED_GCC55)
+    template <class F> TL_EXPECTED_11_CONSTEXPR auto transform(F &&f) & {
+    return expected_map_impl(*this, std::forward<F>(f));
+  }
+  template <class F> TL_EXPECTED_11_CONSTEXPR auto transform(F &&f) && {
+    return expected_map_impl(std::move(*this), std::forward<F>(f));
+  }
+  template <class F> constexpr auto transform(F &&f) const & {
+    return expected_map_impl(*this, std::forward<F>(f));
+  }
+  template <class F> constexpr auto transform(F &&f) const && {
+    return expected_map_impl(std::move(*this), std::forward<F>(f));
+  }
+#else
+    template <class F>
+  TL_EXPECTED_11_CONSTEXPR decltype(
+      expected_map_impl(std::declval<expected &>(), std::declval<F &&>()))
+  transform(F &&f) & {
+    return expected_map_impl(*this, std::forward<F>(f));
+  }
+  template <class F>
+  TL_EXPECTED_11_CONSTEXPR decltype(
+      expected_map_impl(std::declval<expected>(), std::declval<F &&>()))
+  transform(F &&f) && {
+    return expected_map_impl(std::move(*this), std::forward<F>(f));
+  }
+  template <class F>
+  constexpr decltype(expected_map_impl(std::declval<const expected &>(),
+                                       std::declval<F &&>()))
+  transform(F &&f) const & {
+    return expected_map_impl(*this, std::forward<F>(f));
+  }
+
+#ifndef TL_EXPECTED_NO_CONSTRR
+  template <class F>
+  constexpr decltype(expected_map_impl(std::declval<const expected &&>(),
+                                       std::declval<F &&>()))
+  transform(F &&f) const && {
+    return expected_map_impl(std::move(*this), std::forward<F>(f));
+  }
+#endif
+#endif
+
+#if defined(TL_EXPECTED_CXX14) && !defined(TL_EXPECTED_GCC49) &&               \
+    !defined(TL_EXPECTED_GCC54) && !defined(TL_EXPECTED_GCC55)
+  template <class F> TL_EXPECTED_11_CONSTEXPR auto map_error(F &&f) & {
+    return map_error_impl(*this, std::forward<F>(f));
+  }
+  template <class F> TL_EXPECTED_11_CONSTEXPR auto map_error(F &&f) && {
+    return map_error_impl(std::move(*this), std::forward<F>(f));
+  }
+  template <class F> constexpr auto map_error(F &&f) const & {
+    return map_error_impl(*this, std::forward<F>(f));
+  }
+  template <class F> constexpr auto map_error(F &&f) const && {
+    return map_error_impl(std::move(*this), std::forward<F>(f));
+  }
+#else
+  template <class F>
+  TL_EXPECTED_11_CONSTEXPR decltype(map_error_impl(std::declval<expected &>(),
+                                                   std::declval<F &&>()))
+  map_error(F &&f) & {
+    return map_error_impl(*this, std::forward<F>(f));
+  }
+  template <class F>
+  TL_EXPECTED_11_CONSTEXPR decltype(map_error_impl(std::declval<expected &&>(),
+                                                   std::declval<F &&>()))
+  map_error(F &&f) && {
+    return map_error_impl(std::move(*this), std::forward<F>(f));
+  }
+  template <class F>
+  constexpr decltype(map_error_impl(std::declval<const expected &>(),
+                                    std::declval<F &&>()))
+  map_error(F &&f) const & {
+    return map_error_impl(*this, std::forward<F>(f));
+  }
+
+#ifndef TL_EXPECTED_NO_CONSTRR
+  template <class F>
+  constexpr decltype(map_error_impl(std::declval<const expected &&>(),
+                                    std::declval<F &&>()))
+  map_error(F &&f) const && {
+    return map_error_impl(std::move(*this), std::forward<F>(f));
+  }
+#endif
+#endif
+  template <class F> expected TL_EXPECTED_11_CONSTEXPR or_else(F &&f) & {
+    return or_else_impl(*this, std::forward<F>(f));
+  }
+
+  template <class F> expected TL_EXPECTED_11_CONSTEXPR or_else(F &&f) && {
+    return or_else_impl(std::move(*this), std::forward<F>(f));
+  }
+
+  template <class F> expected constexpr or_else(F &&f) const & {
+    return or_else_impl(*this, std::forward<F>(f));
+  }
+
+#ifndef TL_EXPECTED_NO_CONSTRR
+  template <class F> expected constexpr or_else(F &&f) const && {
+    return or_else_impl(std::move(*this), std::forward<F>(f));
+  }
+#endif
+  constexpr expected() = default;
+  constexpr expected(const expected &rhs) = default;
+  constexpr expected(expected &&rhs) = default;
+  expected &operator=(const expected &rhs) = default;
+  expected &operator=(expected &&rhs) = default;
+
+  template <class... Args,
+            detail::enable_if_t<std::is_constructible<T, Args &&...>::value> * =
+                nullptr>
+  constexpr expected(in_place_t, Args &&... args)
+      : impl_base(in_place, std::forward<Args>(args)...),
+        ctor_base(detail::default_constructor_tag{}) {}
+
+  template <class U, class... Args,
+            detail::enable_if_t<std::is_constructible<
+                T, std::initializer_list<U> &, Args &&...>::value> * = nullptr>
+  constexpr expected(in_place_t, std::initializer_list<U> il, Args &&... args)
+      : impl_base(in_place, il, std::forward<Args>(args)...),
+        ctor_base(detail::default_constructor_tag{}) {}
+
+  template <class G = E,
+            detail::enable_if_t<std::is_constructible<E, const G &>::value> * =
+                nullptr,
+            detail::enable_if_t<!std::is_convertible<const G &, E>::value> * =
+                nullptr>
+  explicit constexpr expected(const unexpected<G> &e)
+      : impl_base(unexpect, e.value()),
+        ctor_base(detail::default_constructor_tag{}) {}
+
+    template <
+      class G = E,
+      detail::enable_if_t<std::is_constructible<E, const G &>::value> * =
+          nullptr,
+      detail::enable_if_t<std::is_convertible<const G &, E>::value> * = nullptr>
+  constexpr expected(unexpected<G> const &e)
+      : impl_base(unexpect, e.value()),
+        ctor_base(detail::default_constructor_tag{}) {}
+
+  template <
+      class G = E,
+      detail::enable_if_t<std::is_constructible<E, G &&>::value> * = nullptr,
+      detail::enable_if_t<!std::is_convertible<G &&, E>::value> * = nullptr>
+  explicit constexpr expected(unexpected<G> &&e) noexcept(
+      std::is_nothrow_constructible<E, G &&>::value)
+      : impl_base(unexpect, std::move(e.value())),
+        ctor_base(detail::default_constructor_tag{}) {}
+
+    template <
+      class G = E,
+      detail::enable_if_t<std::is_constructible<E, G &&>::value> * = nullptr,
+      detail::enable_if_t<std::is_convertible<G &&, E>::value> * = nullptr>
+  constexpr expected(unexpected<G> &&e) noexcept(
+      std::is_nothrow_constructible<E, G &&>::value)
+      : impl_base(unexpect, std::move(e.value())),
+        ctor_base(detail::default_constructor_tag{}) {}
+
+  template <class... Args,
+            detail::enable_if_t<std::is_constructible<E, Args &&...>::value> * =
+                nullptr>
+  constexpr explicit expected(unexpect_t, Args &&... args)
+      : impl_base(unexpect, std::forward<Args>(args)...),
+        ctor_base(detail::default_constructor_tag{}) {}
+
+    template <class U, class... Args,
+            detail::enable_if_t<std::is_constructible<
+                E, std::initializer_list<U> &, Args &&...>::value> * = nullptr>
+  constexpr explicit expected(unexpect_t, std::initializer_list<U> il,
+                              Args &&... args)
+      : impl_base(unexpect, il, std::forward<Args>(args)...),
+        ctor_base(detail::default_constructor_tag{}) {}
+
+  template <class U, class G,
+            detail::enable_if_t<!(std::is_convertible<U const &, T>::value &&
+                                  std::is_convertible<G const &, E>::value)> * =
+                nullptr,
+            detail::expected_enable_from_other<T, E, U, G, const U &, const G &>
+                * = nullptr>
+  explicit TL_EXPECTED_11_CONSTEXPR expected(const expected<U, G> &rhs)
+      : ctor_base(detail::default_constructor_tag{}) {
+    if (rhs.has_value()) {
+      this->construct(*rhs);
+    } else {
+      this->construct_error(rhs.error());        
+    }
+  }
+
+    template <class U, class G,
+            detail::enable_if_t<(std::is_convertible<U const &, T>::value &&
+                                 std::is_convertible<G const &, E>::value)> * =
+                nullptr,
+            detail::expected_enable_from_other<T, E, U, G, const U &, const G &>
+                * = nullptr>
+  TL_EXPECTED_11_CONSTEXPR expected(const expected<U, G> &rhs)
+      : ctor_base(detail::default_constructor_tag{}) {
+    if (rhs.has_value()) {
+      this->construct(*rhs);
+    } else {
+      this->construct_error(rhs.error());        
+    }      
+  }
+
+  template <
+      class U, class G,
+      detail::enable_if_t<!(std::is_convertible<U &&, T>::value &&
+                            std::is_convertible<G &&, E>::value)> * = nullptr,
+      detail::expected_enable_from_other<T, E, U, G, U &&, G &&> * = nullptr>
+  explicit TL_EXPECTED_11_CONSTEXPR expected(expected<U, G> &&rhs)
+      : ctor_base(detail::default_constructor_tag{}) {
+    if (rhs.has_value()) {
+      this->construct(std::move(*rhs));
+    } else {
+      this->construct_error(std::move(rhs.error()));        
+    }            
+  }
+
+    template <
+      class U, class G,
+      detail::enable_if_t<(std::is_convertible<U &&, T>::value &&
+                           std::is_convertible<G &&, E>::value)> * = nullptr,
+      detail::expected_enable_from_other<T, E, U, G, U &&, G &&> * = nullptr>
+  TL_EXPECTED_11_CONSTEXPR expected(expected<U, G> &&rhs)
+      : ctor_base(detail::default_constructor_tag{}) {
+    if (rhs.has_value()) {
+      this->construct(std::move(*rhs));
+    } else {
+      this->construct_error(std::move(rhs.error()));        
+    }                  
+  }
+
+  template <
+      class U = T,
+      detail::enable_if_t<!std::is_convertible<U &&, T>::value> * = nullptr,
+      detail::expected_enable_forward_value<T, E, U> * = nullptr>
+  explicit TL_EXPECTED_MSVC2015_CONSTEXPR expected(U &&v)
+      : expected(in_place, std::forward<U>(v)) {}
+
+    template <
+      class U = T,
+      detail::enable_if_t<std::is_convertible<U &&, T>::value> * = nullptr,
+      detail::expected_enable_forward_value<T, E, U> * = nullptr>
+  TL_EXPECTED_MSVC2015_CONSTEXPR expected(U &&v)
+      : expected(in_place, std::forward<U>(v)) {}
+
+  template <
+      class U = T, class G = T,
+      detail::enable_if_t<std::is_nothrow_constructible<T, U &&>::value> * =
+          nullptr,
+      detail::enable_if_t<!std::is_void<G>::value> * = nullptr,
+      detail::enable_if_t<
+          (!std::is_same<expected<T, E>, detail::decay_t<U>>::value &&
+           !detail::conjunction<std::is_scalar<T>,
+                                std::is_same<T, detail::decay_t<U>>>::value &&
+           std::is_constructible<T, U>::value &&
+           std::is_assignable<G &, U>::value &&
+           std::is_nothrow_move_constructible<E>::value)> * = nullptr>
+  expected &operator=(U &&v) {
+    if (has_value()) {
+      val() = std::forward<U>(v);
+    } else {
+      err().~unexpected<E>();
+      ::new (valptr()) T(std::forward<U>(v));
+      this->m_has_val = true;
+    }
+
+    return *this;
+  }
+
+    template <
+      class U = T, class G = T,
+      detail::enable_if_t<!std::is_nothrow_constructible<T, U &&>::value> * =
+          nullptr,
+      detail::enable_if_t<!std::is_void<U>::value> * = nullptr,
+      detail::enable_if_t<
+          (!std::is_same<expected<T, E>, detail::decay_t<U>>::value &&
+           !detail::conjunction<std::is_scalar<T>,
+                                std::is_same<T, detail::decay_t<U>>>::value &&
+           std::is_constructible<T, U>::value &&
+           std::is_assignable<G &, U>::value &&
+           std::is_nothrow_move_constructible<E>::value)> * = nullptr>
+  expected &operator=(U &&v) {
+    if (has_value()) {
+      val() = std::forward<U>(v);
+    } else {
+      auto tmp = std::move(err());
+      err().~unexpected<E>();
+
+      #ifdef TL_EXPECTED_EXCEPTIONS_ENABLED
+      try {
+        ::new (valptr()) T(std::forward<U>(v));
+        this->m_has_val = true;
+      } catch (...) {
+        err() = std::move(tmp);
+        throw;
+      }
+      #else
+        ::new (valptr()) T(std::forward<U>(v));
+        this->m_has_val = true;
+      #endif
+    }
+
+    return *this;
+  }
+
+  template <class G = E,
+            detail::enable_if_t<std::is_nothrow_copy_constructible<G>::value &&
+                                std::is_assignable<G &, G>::value> * = nullptr>
+  expected &operator=(const unexpected<G> &rhs) {
+    if (!has_value()) {
+      err() = rhs;
+    } else {
+      this->destroy_val();
+      ::new (errptr()) unexpected<E>(rhs);
+      this->m_has_val = false;
+    }
+
+    return *this;
+  }
+
+  template <class G = E,
+            detail::enable_if_t<std::is_nothrow_move_constructible<G>::value &&
+                                std::is_move_assignable<G>::value> * = nullptr>
+  expected &operator=(unexpected<G> &&rhs) noexcept {
+    if (!has_value()) {
+      err() = std::move(rhs);
+    } else {
+      this->destroy_val();
+      ::new (errptr()) unexpected<E>(std::move(rhs));
+      this->m_has_val = false;
+    }
+
+    return *this;
+  }
+
+  template <class... Args, detail::enable_if_t<std::is_nothrow_constructible<
+                               T, Args &&...>::value> * = nullptr>
+  void emplace(Args &&... args) {
+    if (has_value()) {
+      val() = T(std::forward<Args>(args)...);
+    } else {
+      err().~unexpected<E>();
+      ::new (valptr()) T(std::forward<Args>(args)...);
+      this->m_has_val = true;
+    }
+  }
+
+    template <class... Args, detail::enable_if_t<!std::is_nothrow_constructible<
+                               T, Args &&...>::value> * = nullptr>
+  void emplace(Args &&... args) {
+    if (has_value()) {
+      val() = T(std::forward<Args>(args)...);
+    } else {
+      auto tmp = std::move(err());
+      err().~unexpected<E>();
+
+      #ifdef TL_EXPECTED_EXCEPTIONS_ENABLED
+      try {
+        ::new (valptr()) T(std::forward<Args>(args)...);
+        this->m_has_val = true;
+      } catch (...) {
+        err() = std::move(tmp);
+        throw;
+      }
+      #else
+      ::new (valptr()) T(std::forward<Args>(args)...);
+      this->m_has_val = true;
+      #endif
+    }
+  }
+
+  template <class U, class... Args,
+            detail::enable_if_t<std::is_nothrow_constructible<
+                T, std::initializer_list<U> &, Args &&...>::value> * = nullptr>
+  void emplace(std::initializer_list<U> il, Args &&... args) {
+    if (has_value()) {
+      T t(il, std::forward<Args>(args)...);
+      val() = std::move(t);
+    } else {
+      err().~unexpected<E>();
+      ::new (valptr()) T(il, std::forward<Args>(args)...);
+      this->m_has_val = true;
+    }
+  }
+
+    template <class U, class... Args,
+            detail::enable_if_t<!std::is_nothrow_constructible<
+                T, std::initializer_list<U> &, Args &&...>::value> * = nullptr>
+  void emplace(std::initializer_list<U> il, Args &&... args) {
+    if (has_value()) {
+      T t(il, std::forward<Args>(args)...);
+      val() = std::move(t);
+    } else {
+      auto tmp = std::move(err());
+      err().~unexpected<E>();
+
+      #ifdef TL_EXPECTED_EXCEPTIONS_ENABLED
+      try {
+        ::new (valptr()) T(il, std::forward<Args>(args)...);
+        this->m_has_val = true;
+      } catch (...) {
+        err() = std::move(tmp);
+        throw;
+      }
+      #else
+      ::new (valptr()) T(il, std::forward<Args>(args)...);
+      this->m_has_val = true;
+      #endif
+    }
+  }
+
+private:
+  using t_is_void = std::true_type;
+  using t_is_not_void = std::false_type;
+  using t_is_nothrow_move_constructible = std::true_type;
+  using move_constructing_t_can_throw = std::false_type;
+  using e_is_nothrow_move_constructible = std::true_type;
+  using move_constructing_e_can_throw = std::false_type;
+
+  void swap_where_both_have_value(expected &/*rhs*/ , t_is_void) noexcept {
+    // swapping void is a no-op
+  }
+
+  void swap_where_both_have_value(expected &rhs, t_is_not_void) {
+    using std::swap;
+    swap(val(), rhs.val());
+  }
+
+  void swap_where_only_one_has_value(expected &rhs, t_is_void) noexcept(
+      std::is_nothrow_move_constructible<E>::value) {
+    ::new (errptr()) unexpected_type(std::move(rhs.err()));
+    rhs.err().~unexpected_type();
+    std::swap(this->m_has_val, rhs.m_has_val);
+  }
+
+  void swap_where_only_one_has_value(expected &rhs, t_is_not_void) {
+    swap_where_only_one_has_value_and_t_is_not_void(
+        rhs, typename std::is_nothrow_move_constructible<T>::type{},
+        typename std::is_nothrow_move_constructible<E>::type{});
+  }
+
+  void swap_where_only_one_has_value_and_t_is_not_void(
+      expected &rhs, t_is_nothrow_move_constructible,
+      e_is_nothrow_move_constructible) noexcept {
+    auto temp = std::move(val());
+    val().~T();
+    ::new (errptr()) unexpected_type(std::move(rhs.err()));
+    rhs.err().~unexpected_type();
+    ::new (rhs.valptr()) T(std::move(temp));
+    std::swap(this->m_has_val, rhs.m_has_val);
+  }
+
+  void swap_where_only_one_has_value_and_t_is_not_void(
+      expected &rhs, t_is_nothrow_move_constructible,
+      move_constructing_e_can_throw) {
+    auto temp = std::move(val());
+    val().~T();
+#ifdef TL_EXPECTED_EXCEPTIONS_ENABLED
+    try {
+      ::new (errptr()) unexpected_type(std::move(rhs.err()));
+      rhs.err().~unexpected_type();
+      ::new (rhs.valptr()) T(std::move(temp));
+      std::swap(this->m_has_val, rhs.m_has_val);
+    } catch (...) {
+      val() = std::move(temp);
+      throw;
+    }
+#else
+    ::new (errptr()) unexpected_type(std::move(rhs.err()));
+    rhs.err().~unexpected_type();
+    ::new (rhs.valptr()) T(std::move(temp));
+    std::swap(this->m_has_val, rhs.m_has_val);
+#endif
+  }
+
+  void swap_where_only_one_has_value_and_t_is_not_void(
+      expected &rhs, move_constructing_t_can_throw,
+      t_is_nothrow_move_constructible) {
+    auto temp = std::move(rhs.err());
+    rhs.err().~unexpected_type();
+#ifdef TL_EXPECTED_EXCEPTIONS_ENABLED
+    try {
+      ::new (rhs.valptr()) T(val());
+      val().~T();
+      ::new (errptr()) unexpected_type(std::move(temp));
+      std::swap(this->m_has_val, rhs.m_has_val);
+    } catch (...) {
+      rhs.err() = std::move(temp);
+      throw;
+    }
+#else
+    ::new (rhs.valptr()) T(val());
+    val().~T();
+    ::new (errptr()) unexpected_type(std::move(temp));
+    std::swap(this->m_has_val, rhs.m_has_val);
+#endif
+  }
+
+public:
+  template <class OT = T, class OE = E>
+  detail::enable_if_t<detail::is_swappable<OT>::value &&
+                      detail::is_swappable<OE>::value &&
+                      (std::is_nothrow_move_constructible<OT>::value ||
+                       std::is_nothrow_move_constructible<OE>::value)>
+  swap(expected &rhs) noexcept(
+      std::is_nothrow_move_constructible<T>::value
+          &&detail::is_nothrow_swappable<T>::value
+              &&std::is_nothrow_move_constructible<E>::value
+                  &&detail::is_nothrow_swappable<E>::value) {
+    if (has_value() && rhs.has_value()) {
+      swap_where_both_have_value(rhs, typename std::is_void<T>::type{});
+    } else if (!has_value() && rhs.has_value()) {
+      rhs.swap(*this);
+    } else if (has_value()) {
+      swap_where_only_one_has_value(rhs, typename std::is_void<T>::type{});
+    } else {
+      using std::swap;
+      swap(err(), rhs.err());
+    }
+  }
+
+  constexpr const T *operator->() const { return valptr(); }
+  TL_EXPECTED_11_CONSTEXPR T *operator->() { return valptr(); }
+
+  template <class U = T,
+            detail::enable_if_t<!std::is_void<U>::value> * = nullptr>
+  constexpr const U &operator*() const & {
+    return val();
+  }
+  template <class U = T,
+            detail::enable_if_t<!std::is_void<U>::value> * = nullptr>
+  TL_EXPECTED_11_CONSTEXPR U &operator*() & {
+    return val();
+  }
+  template <class U = T,
+            detail::enable_if_t<!std::is_void<U>::value> * = nullptr>
+  constexpr const U &&operator*() const && {
+    return std::move(val());
+  }
+  template <class U = T,
+            detail::enable_if_t<!std::is_void<U>::value> * = nullptr>
+  TL_EXPECTED_11_CONSTEXPR U &&operator*() && {
+    return std::move(val());
+  }
+
+  constexpr bool has_value() const noexcept { return this->m_has_val; }
+  constexpr explicit operator bool() const noexcept { return this->m_has_val; }
+
+  template <class U = T,
+            detail::enable_if_t<!std::is_void<U>::value> * = nullptr>
+  TL_EXPECTED_11_CONSTEXPR const U &value() const & {
+    if (!has_value())
+      detail::throw_exception(bad_expected_access<E>(err().value()));
+    return val();
+  }
+  template <class U = T,
+            detail::enable_if_t<!std::is_void<U>::value> * = nullptr>
+  TL_EXPECTED_11_CONSTEXPR U &value() & {
+    if (!has_value())
+      detail::throw_exception(bad_expected_access<E>(err().value()));
+    return val();
+  }
+  template <class U = T,
+            detail::enable_if_t<!std::is_void<U>::value> * = nullptr>
+  TL_EXPECTED_11_CONSTEXPR const U &&value() const && {
+    if (!has_value())
+      detail::throw_exception(bad_expected_access<E>(std::move(err()).value()));
+    return std::move(val());
+  }
+  template <class U = T,
+            detail::enable_if_t<!std::is_void<U>::value> * = nullptr>
+  TL_EXPECTED_11_CONSTEXPR U &&value() && {
+    if (!has_value())
+      detail::throw_exception(bad_expected_access<E>(std::move(err()).value()));
+    return std::move(val());
+  }
+
+  constexpr const E &error() const & { return err().value(); }
+  TL_EXPECTED_11_CONSTEXPR E &error() & { return err().value(); }
+  constexpr const E &&error() const && { return std::move(err().value()); }
+  TL_EXPECTED_11_CONSTEXPR E &&error() && { return std::move(err().value()); }
+
+  template <class U> constexpr T value_or(U &&v) const & {
+    static_assert(std::is_copy_constructible<T>::value &&
+                      std::is_convertible<U &&, T>::value,
+                  "T must be copy-constructible and convertible to from U&&");
+    return bool(*this) ? **this : static_cast<T>(std::forward<U>(v));
+  }
+  template <class U> TL_EXPECTED_11_CONSTEXPR T value_or(U &&v) && {
+    static_assert(std::is_move_constructible<T>::value &&
+                      std::is_convertible<U &&, T>::value,
+                  "T must be move-constructible and convertible to from U&&");
+    return bool(*this) ? std::move(**this) : static_cast<T>(std::forward<U>(v));
+  }
+};
+
+namespace detail {
+template <class Exp> using exp_t = typename detail::decay_t<Exp>::value_type;
+template <class Exp> using err_t = typename detail::decay_t<Exp>::error_type;
+template <class Exp, class Ret> using ret_t = expected<Ret, err_t<Exp>>;
+
+#ifdef TL_EXPECTED_CXX14
+template <class Exp, class F,
+          detail::enable_if_t<!std::is_void<exp_t<Exp>>::value> * = nullptr,
+          class Ret = decltype(detail::invoke(std::declval<F>(),
+                                              *std::declval<Exp>()))>
+constexpr auto and_then_impl(Exp &&exp, F &&f) {
+  static_assert(detail::is_expected<Ret>::value, "F must return an expected");
+
+  return exp.has_value()
+             ? detail::invoke(std::forward<F>(f), *std::forward<Exp>(exp))
+             : Ret(unexpect, std::forward<Exp>(exp).error());
+}
+
+template <class Exp, class F,
+          detail::enable_if_t<std::is_void<exp_t<Exp>>::value> * = nullptr,
+          class Ret = decltype(detail::invoke(std::declval<F>()))>
+constexpr auto and_then_impl(Exp &&exp, F &&f) {
+  static_assert(detail::is_expected<Ret>::value, "F must return an expected");
+
+  return exp.has_value() ? detail::invoke(std::forward<F>(f))
+                         : Ret(unexpect, std::forward<Exp>(exp).error());
+}
+#else
+template <class> struct TC;
+template <class Exp, class F,
+          class Ret = decltype(detail::invoke(std::declval<F>(),
+                                              *std::declval<Exp>())),
+          detail::enable_if_t<!std::is_void<exp_t<Exp>>::value> * = nullptr>
+auto and_then_impl(Exp &&exp, F &&f) -> Ret {
+  static_assert(detail::is_expected<Ret>::value, "F must return an expected");
+
+  return exp.has_value()
+             ? detail::invoke(std::forward<F>(f), *std::forward<Exp>(exp))
+             : Ret(unexpect, std::forward<Exp>(exp).error());
+}
+
+template <class Exp, class F,
+          class Ret = decltype(detail::invoke(std::declval<F>())),
+          detail::enable_if_t<std::is_void<exp_t<Exp>>::value> * = nullptr>
+constexpr auto and_then_impl(Exp &&exp, F &&f) -> Ret {
+  static_assert(detail::is_expected<Ret>::value, "F must return an expected");
+
+  return exp.has_value() ? detail::invoke(std::forward<F>(f))
+                         : Ret(unexpect, std::forward<Exp>(exp).error());
+}
+#endif
+
+#ifdef TL_EXPECTED_CXX14
+template <class Exp, class F,
+          detail::enable_if_t<!std::is_void<exp_t<Exp>>::value> * = nullptr,          
+          class Ret = decltype(detail::invoke(std::declval<F>(),
+                                              *std::declval<Exp>())),
+          detail::enable_if_t<!std::is_void<Ret>::value> * = nullptr>
+constexpr auto expected_map_impl(Exp &&exp, F &&f) {
+  using result = ret_t<Exp, detail::decay_t<Ret>>;
+  return exp.has_value() ? result(detail::invoke(std::forward<F>(f),
+                                                 *std::forward<Exp>(exp)))
+                         : result(unexpect, std::forward<Exp>(exp).error());
+}
+
+template <class Exp, class F,
+          detail::enable_if_t<!std::is_void<exp_t<Exp>>::value> * = nullptr,          
+          class Ret = decltype(detail::invoke(std::declval<F>(),
+                                              *std::declval<Exp>())),
+          detail::enable_if_t<std::is_void<Ret>::value> * = nullptr>
+auto expected_map_impl(Exp &&exp, F &&f) {
+  using result = expected<void, err_t<Exp>>;
+  if (exp.has_value()) {
+    detail::invoke(std::forward<F>(f), *std::forward<Exp>(exp));
+    return result();
+  }
+
+  return result(unexpect, std::forward<Exp>(exp).error());
+}
+
+template <class Exp, class F,
+          detail::enable_if_t<std::is_void<exp_t<Exp>>::value> * = nullptr,
+          class Ret = decltype(detail::invoke(std::declval<F>())),
+          detail::enable_if_t<!std::is_void<Ret>::value> * = nullptr>
+constexpr auto expected_map_impl(Exp &&exp, F &&f) {
+  using result = ret_t<Exp, detail::decay_t<Ret>>;
+  return exp.has_value() ? result(detail::invoke(std::forward<F>(f)))
+                         : result(unexpect, std::forward<Exp>(exp).error());
+}
+
+template <class Exp, class F,
+          detail::enable_if_t<std::is_void<exp_t<Exp>>::value> * = nullptr,          
+          class Ret = decltype(detail::invoke(std::declval<F>())),
+          detail::enable_if_t<std::is_void<Ret>::value> * = nullptr>
+auto expected_map_impl(Exp &&exp, F &&f) {
+  using result = expected<void, err_t<Exp>>;
+  if (exp.has_value()) {
+    detail::invoke(std::forward<F>(f));
+    return result();
+  }
+
+  return result(unexpect, std::forward<Exp>(exp).error());
+}    
+#else
+template <class Exp, class F,
+          detail::enable_if_t<!std::is_void<exp_t<Exp>>::value> * = nullptr,          
+          class Ret = decltype(detail::invoke(std::declval<F>(),
+                                              *std::declval<Exp>())),
+          detail::enable_if_t<!std::is_void<Ret>::value> * = nullptr>
+
+constexpr auto expected_map_impl(Exp &&exp, F &&f)
+    -> ret_t<Exp, detail::decay_t<Ret>> {
+  using result = ret_t<Exp, detail::decay_t<Ret>>;
+
+  return exp.has_value() ? result(detail::invoke(std::forward<F>(f),
+                                                 *std::forward<Exp>(exp)))
+                         : result(unexpect, std::forward<Exp>(exp).error());
+}
+
+template <class Exp, class F,
+          detail::enable_if_t<!std::is_void<exp_t<Exp>>::value> * = nullptr,                    
+          class Ret = decltype(detail::invoke(std::declval<F>(),
+                                              *std::declval<Exp>())),
+          detail::enable_if_t<std::is_void<Ret>::value> * = nullptr>
+
+auto expected_map_impl(Exp &&exp, F &&f) -> expected<void, err_t<Exp>> {
+  if (exp.has_value()) {
+    detail::invoke(std::forward<F>(f), *std::forward<Exp>(exp));
+    return {};
+  }
+
+  return unexpected<err_t<Exp>>(std::forward<Exp>(exp).error());
+}
+
+template <class Exp, class F,
+          detail::enable_if_t<std::is_void<exp_t<Exp>>::value> * = nullptr,                              
+          class Ret = decltype(detail::invoke(std::declval<F>())),
+          detail::enable_if_t<!std::is_void<Ret>::value> * = nullptr>
+
+constexpr auto expected_map_impl(Exp &&exp, F &&f)
+    -> ret_t<Exp, detail::decay_t<Ret>> {
+  using result = ret_t<Exp, detail::decay_t<Ret>>;
+
+  return exp.has_value() ? result(detail::invoke(std::forward<F>(f)))
+                         : result(unexpect, std::forward<Exp>(exp).error());
+}
+
+template <class Exp, class F,
+          detail::enable_if_t<std::is_void<exp_t<Exp>>::value> * = nullptr,                                        
+          class Ret = decltype(detail::invoke(std::declval<F>())),
+          detail::enable_if_t<std::is_void<Ret>::value> * = nullptr>
+
+auto expected_map_impl(Exp &&exp, F &&f) -> expected<void, err_t<Exp>> {
+  if (exp.has_value()) {
+    detail::invoke(std::forward<F>(f));
+    return {};
+  }
+
+  return unexpected<err_t<Exp>>(std::forward<Exp>(exp).error());
+}    
+#endif
+
+#if defined(TL_EXPECTED_CXX14) && !defined(TL_EXPECTED_GCC49) &&               \
+    !defined(TL_EXPECTED_GCC54) && !defined(TL_EXPECTED_GCC55)
+template <class Exp, class F,
+          detail::enable_if_t<!std::is_void<exp_t<Exp>>::value> * = nullptr,          
+          class Ret = decltype(detail::invoke(std::declval<F>(),
+                                              std::declval<Exp>().error())),
+          detail::enable_if_t<!std::is_void<Ret>::value> * = nullptr>
+constexpr auto map_error_impl(Exp &&exp, F &&f) {
+  using result = expected<exp_t<Exp>, detail::decay_t<Ret>>;
+  return exp.has_value()
+             ? result(*std::forward<Exp>(exp))
+             : result(unexpect, detail::invoke(std::forward<F>(f),
+                                               std::forward<Exp>(exp).error()));
+}
+template <class Exp, class F,
+          detail::enable_if_t<!std::is_void<exp_t<Exp>>::value> * = nullptr,                    
+          class Ret = decltype(detail::invoke(std::declval<F>(),
+                                              std::declval<Exp>().error())),
+          detail::enable_if_t<std::is_void<Ret>::value> * = nullptr>
+auto map_error_impl(Exp &&exp, F &&f) {
+  using result = expected<exp_t<Exp>, monostate>;
+  if (exp.has_value()) {
+    return result(*std::forward<Exp>(exp));
+  }
+
+  detail::invoke(std::forward<F>(f), std::forward<Exp>(exp).error());
+  return result(unexpect, monostate{});
+}
+template <class Exp, class F,
+          detail::enable_if_t<std::is_void<exp_t<Exp>>::value> * = nullptr,          
+          class Ret = decltype(detail::invoke(std::declval<F>(),
+                                              std::declval<Exp>().error())),
+          detail::enable_if_t<!std::is_void<Ret>::value> * = nullptr>
+constexpr auto map_error_impl(Exp &&exp, F &&f) {
+  using result = expected<exp_t<Exp>, detail::decay_t<Ret>>;
+  return exp.has_value()
+             ? result()
+             : result(unexpect, detail::invoke(std::forward<F>(f),
+                                               std::forward<Exp>(exp).error()));
+}
+template <class Exp, class F,
+          detail::enable_if_t<std::is_void<exp_t<Exp>>::value> * = nullptr,                    
+          class Ret = decltype(detail::invoke(std::declval<F>(),
+                                              std::declval<Exp>().error())),
+          detail::enable_if_t<std::is_void<Ret>::value> * = nullptr>
+auto map_error_impl(Exp &&exp, F &&f) {
+  using result = expected<exp_t<Exp>, monostate>;
+  if (exp.has_value()) {
+    return result();
+  }
+
+  detail::invoke(std::forward<F>(f), std::forward<Exp>(exp).error());
+  return result(unexpect, monostate{});
+}    
+#else
+template <class Exp, class F,
+          detail::enable_if_t<!std::is_void<exp_t<Exp>>::value> * = nullptr,                              
+          class Ret = decltype(detail::invoke(std::declval<F>(),
+                                              std::declval<Exp>().error())),
+          detail::enable_if_t<!std::is_void<Ret>::value> * = nullptr>
+constexpr auto map_error_impl(Exp &&exp, F &&f)
+    -> expected<exp_t<Exp>, detail::decay_t<Ret>> {
+  using result = expected<exp_t<Exp>, detail::decay_t<Ret>>;
+
+  return exp.has_value()
+             ? result(*std::forward<Exp>(exp))
+             : result(unexpect, detail::invoke(std::forward<F>(f),
+                                               std::forward<Exp>(exp).error()));
+}
+
+template <class Exp, class F,
+          detail::enable_if_t<!std::is_void<exp_t<Exp>>::value> * = nullptr,                                        
+          class Ret = decltype(detail::invoke(std::declval<F>(),
+                                              std::declval<Exp>().error())),
+          detail::enable_if_t<std::is_void<Ret>::value> * = nullptr>
+auto map_error_impl(Exp &&exp, F &&f) -> expected<exp_t<Exp>, monostate> {
+  using result = expected<exp_t<Exp>, monostate>;
+  if (exp.has_value()) {
+    return result(*std::forward<Exp>(exp));
+  }
+
+  detail::invoke(std::forward<F>(f), std::forward<Exp>(exp).error());
+  return result(unexpect, monostate{});
+}
+
+template <class Exp, class F,
+          detail::enable_if_t<std::is_void<exp_t<Exp>>::value> * = nullptr,                              
+          class Ret = decltype(detail::invoke(std::declval<F>(),
+                                              std::declval<Exp>().error())),
+          detail::enable_if_t<!std::is_void<Ret>::value> * = nullptr>
+constexpr auto map_error_impl(Exp &&exp, F &&f)
+    -> expected<exp_t<Exp>, detail::decay_t<Ret>> {
+  using result = expected<exp_t<Exp>, detail::decay_t<Ret>>;
+
+  return exp.has_value()
+             ? result()
+             : result(unexpect, detail::invoke(std::forward<F>(f),
+                                               std::forward<Exp>(exp).error()));
+}
+
+template <class Exp, class F,
+          detail::enable_if_t<std::is_void<exp_t<Exp>>::value> * = nullptr,                                        
+          class Ret = decltype(detail::invoke(std::declval<F>(),
+                                              std::declval<Exp>().error())),
+          detail::enable_if_t<std::is_void<Ret>::value> * = nullptr>
+auto map_error_impl(Exp &&exp, F &&f) -> expected<exp_t<Exp>, monostate> {
+  using result = expected<exp_t<Exp>, monostate>;
+  if (exp.has_value()) {
+    return result();
+  }
+
+  detail::invoke(std::forward<F>(f), std::forward<Exp>(exp).error());
+  return result(unexpect, monostate{});
+}    
+#endif
+
+#ifdef TL_EXPECTED_CXX14
+template <class Exp, class F,
+          class Ret = decltype(detail::invoke(std::declval<F>(),
+                                              std::declval<Exp>().error())),
+          detail::enable_if_t<!std::is_void<Ret>::value> * = nullptr>
+constexpr auto or_else_impl(Exp &&exp, F &&f) {
+  static_assert(detail::is_expected<Ret>::value, "F must return an expected");
+  return exp.has_value()
+  ? std::forward<Exp>(exp)
+  : detail::invoke(std::forward<F>(f), std::forward<Exp>(exp).error());
+}
+
+template <class Exp, class F,
+          class Ret = decltype(detail::invoke(std::declval<F>(),
+                                              std::declval<Exp>().error())),
+          detail::enable_if_t<std::is_void<Ret>::value> * = nullptr>
+detail::decay_t<Exp> or_else_impl(Exp &&exp, F &&f) {
+  return exp.has_value()
+  ? std::forward<Exp>(exp)
+  : (detail::invoke(std::forward<F>(f), std::forward<Exp>(exp).error()),
+    std::forward<Exp>(exp));
+}
+#else
+template <class Exp, class F,
+          class Ret = decltype(detail::invoke(std::declval<F>(),
+                                              std::declval<Exp>().error())),
+  detail::enable_if_t<!std::is_void<Ret>::value> * = nullptr>
+auto or_else_impl(Exp &&exp, F &&f) -> Ret {
+  static_assert(detail::is_expected<Ret>::value, "F must return an expected");
+  return exp.has_value()
+         ? std::forward<Exp>(exp)
+         : detail::invoke(std::forward<F>(f), std::forward<Exp>(exp).error());
+}
+
+template <class Exp, class F,
+          class Ret = decltype(detail::invoke(std::declval<F>(),
+                                              std::declval<Exp>().error())),
+  detail::enable_if_t<std::is_void<Ret>::value> * = nullptr>
+detail::decay_t<Exp> or_else_impl(Exp &&exp, F &&f) {
+  return exp.has_value()
+         ? std::forward<Exp>(exp)
+         : (detail::invoke(std::forward<F>(f), std::forward<Exp>(exp).error()),
+            std::forward<Exp>(exp));
+}
+#endif
+} // namespace detail
+
+template <class T, class E, class U, class F>
+constexpr bool operator==(const expected<T, E> &lhs,
+                          const expected<U, F> &rhs) {
+  return (lhs.has_value() != rhs.has_value())
+             ? false
+             : (!lhs.has_value() ? lhs.error() == rhs.error() : *lhs == *rhs);
+}
+template <class T, class E, class U, class F>
+constexpr bool operator!=(const expected<T, E> &lhs,
+                          const expected<U, F> &rhs) {
+  return (lhs.has_value() != rhs.has_value())
+             ? true
+             : (!lhs.has_value() ? lhs.error() != rhs.error() : *lhs != *rhs);
+}
+
+template <class T, class E, class U>
+constexpr bool operator==(const expected<T, E> &x, const U &v) {
+  return x.has_value() ? *x == v : false;
+}
+template <class T, class E, class U>
+constexpr bool operator==(const U &v, const expected<T, E> &x) {
+  return x.has_value() ? *x == v : false;
+}
+template <class T, class E, class U>
+constexpr bool operator!=(const expected<T, E> &x, const U &v) {
+  return x.has_value() ? *x != v : true;
+}
+template <class T, class E, class U>
+constexpr bool operator!=(const U &v, const expected<T, E> &x) {
+  return x.has_value() ? *x != v : true;
+}
+
+template <class T, class E>
+constexpr bool operator==(const expected<T, E> &x, const unexpected<E> &e) {
+  return x.has_value() ? false : x.error() == e.value();
+}
+template <class T, class E>
+constexpr bool operator==(const unexpected<E> &e, const expected<T, E> &x) {
+  return x.has_value() ? false : x.error() == e.value();
+}
+template <class T, class E>
+constexpr bool operator!=(const expected<T, E> &x, const unexpected<E> &e) {
+  return x.has_value() ? true : x.error() != e.value();
+}
+template <class T, class E>
+constexpr bool operator!=(const unexpected<E> &e, const expected<T, E> &x) {
+  return x.has_value() ? true : x.error() != e.value();
+}
+
+template <class T, class E,
+          detail::enable_if_t<(std::is_void<T>::value ||
+                               std::is_move_constructible<T>::value) &&
+                              detail::is_swappable<T>::value &&
+                              std::is_move_constructible<E>::value &&
+                              detail::is_swappable<E>::value> * = nullptr>
+void swap(expected<T, E> &lhs,
+          expected<T, E> &rhs) noexcept(noexcept(lhs.swap(rhs))) {
+  lhs.swap(rhs);
+}
+} // namespace tl
+
+#endif
diff --git a/Telegram/ThirdParty/expected/tests/assignment.cpp b/Telegram/ThirdParty/expected/tests/assignment.cpp
new file mode 100644
index 0000000..2d6bf6b
--- /dev/null
+++ b/Telegram/ThirdParty/expected/tests/assignment.cpp
@@ -0,0 +1,75 @@
+#include <catch2/catch.hpp>
+#include <tl/expected.hpp>
+
+TEST_CASE("Simple assignment", "[assignment.simple]") {
+  tl::expected<int, int> e1 = 42;
+  tl::expected<int, int> e2 = 17;
+  tl::expected<int, int> e3 = 21;
+  tl::expected<int, int> e4 = tl::make_unexpected(42);
+  tl::expected<int, int> e5 = tl::make_unexpected(17);
+  tl::expected<int, int> e6 = tl::make_unexpected(21);
+
+  e1 = e2;
+  REQUIRE(e1);
+  REQUIRE(*e1 == 17);
+  REQUIRE(e2);
+  REQUIRE(*e2 == 17);
+
+  e1 = std::move(e2);
+  REQUIRE(e1);
+  REQUIRE(*e1 == 17);
+  REQUIRE(e2);
+  REQUIRE(*e2 == 17);
+
+  e1 = 42;
+  REQUIRE(e1);
+  REQUIRE(*e1 == 42);
+
+  auto unex = tl::make_unexpected(12);
+  e1 = unex;
+  REQUIRE(!e1);
+  REQUIRE(e1.error() == 12);
+
+  e1 = tl::make_unexpected(42);
+  REQUIRE(!e1);
+  REQUIRE(e1.error() == 42);
+
+  e1 = e3;
+  REQUIRE(e1);
+  REQUIRE(*e1 == 21);
+
+  e4 = e5;
+  REQUIRE(!e4);
+  REQUIRE(e4.error() == 17);
+
+  e4 = std::move(e6);
+  REQUIRE(!e4);
+  REQUIRE(e4.error() == 21);
+
+  e4 = e1;
+  REQUIRE(e4);
+  REQUIRE(*e4 == 21);
+}
+
+TEST_CASE("Assignment deletion", "[assignment.deletion]") {
+  struct has_all {
+    has_all() = default;
+    has_all(const has_all &) = default;
+    has_all(has_all &&) noexcept = default;
+    has_all &operator=(const has_all &) = default;
+  };
+
+  tl::expected<has_all, has_all> e1 = {};
+  tl::expected<has_all, has_all> e2 = {};
+  e1 = e2;
+
+  struct except_move {
+    except_move() = default;
+    except_move(const except_move &) = default;
+    except_move(except_move &&) noexcept(false){};
+    except_move &operator=(const except_move &) = default;
+  };
+  tl::expected<except_move, except_move> e3 = {};
+  tl::expected<except_move, except_move> e4 = {};
+  // e3 = e4; should not compile
+}
diff --git a/Telegram/ThirdParty/expected/tests/bases.cpp b/Telegram/ThirdParty/expected/tests/bases.cpp
new file mode 100644
index 0000000..7189307
--- /dev/null
+++ b/Telegram/ThirdParty/expected/tests/bases.cpp
@@ -0,0 +1,191 @@
+#include <catch2/catch.hpp>
+#include <tl/expected.hpp>
+
+#include <string>
+
+// Old versions of GCC don't have the correct trait names. Could fix them up if needs be.
+#if (defined(__GNUC__) && __GNUC__ == 4 && __GNUC_MINOR__ <= 9 &&              \
+     !defined(__clang__))
+// nothing for now
+#else
+TEST_CASE("Triviality", "[bases.triviality]") {
+    REQUIRE(std::is_trivially_copy_constructible<tl::expected<int,int>>::value);
+    REQUIRE(std::is_trivially_copy_assignable<tl::expected<int,int>>::value);
+    REQUIRE(std::is_trivially_move_constructible<tl::expected<int,int>>::value);
+    REQUIRE(std::is_trivially_move_assignable<tl::expected<int,int>>::value);
+    REQUIRE(std::is_trivially_destructible<tl::expected<int,int>>::value);
+
+    REQUIRE(std::is_trivially_copy_constructible<tl::expected<void,int>>::value);
+    REQUIRE(std::is_trivially_move_constructible<tl::expected<void,int>>::value);
+    REQUIRE(std::is_trivially_destructible<tl::expected<void,int>>::value);
+
+
+    {
+        struct T {
+            T(const T&) = default;
+            T(T&&) = default;
+            T& operator=(const T&) = default;
+            T& operator=(T&&) = default;
+            ~T() = default;
+        };
+        REQUIRE(std::is_trivially_copy_constructible<tl::expected<T,int>>::value);
+        REQUIRE(std::is_trivially_copy_assignable<tl::expected<T,int>>::value);
+        REQUIRE(std::is_trivially_move_constructible<tl::expected<T,int>>::value);
+        REQUIRE(std::is_trivially_move_assignable<tl::expected<T,int>>::value);
+        REQUIRE(std::is_trivially_destructible<tl::expected<T,int>>::value);
+    }
+
+    {
+        struct T {
+            T(const T&){}
+            T(T&&) {};
+            T& operator=(const T&) {}
+            T& operator=(T&&) {};
+            ~T(){}
+        };
+        REQUIRE(!std::is_trivially_copy_constructible<tl::expected<T,int>>::value);
+        REQUIRE(!std::is_trivially_copy_assignable<tl::expected<T,int>>::value);
+        REQUIRE(!std::is_trivially_move_constructible<tl::expected<T,int>>::value);
+        REQUIRE(!std::is_trivially_move_assignable<tl::expected<T,int>>::value);
+        REQUIRE(!std::is_trivially_destructible<tl::expected<T,int>>::value);
+    }
+
+}
+
+TEST_CASE("Deletion", "[bases.deletion]") {
+    REQUIRE(std::is_copy_constructible<tl::expected<int,int>>::value);
+    REQUIRE(std::is_copy_assignable<tl::expected<int,int>>::value);
+    REQUIRE(std::is_move_constructible<tl::expected<int,int>>::value);
+    REQUIRE(std::is_move_assignable<tl::expected<int,int>>::value);
+    REQUIRE(std::is_destructible<tl::expected<int,int>>::value);
+
+    {
+        struct T {
+            T()=default;
+        };
+        REQUIRE(std::is_default_constructible<tl::expected<T,int>>::value);
+    }
+
+    {
+        struct T {
+            T(int){}
+        };
+        REQUIRE(!std::is_default_constructible<tl::expected<T,int>>::value);
+    }
+
+    {
+        struct T {
+            T(const T&) = default;
+            T(T&&) = default;
+            T& operator=(const T&) = default;
+            T& operator=(T&&) = default;
+            ~T() = default;
+        };
+        REQUIRE(std::is_copy_constructible<tl::expected<T,int>>::value);
+        REQUIRE(std::is_copy_assignable<tl::expected<T,int>>::value);
+        REQUIRE(std::is_move_constructible<tl::expected<T,int>>::value);
+        REQUIRE(std::is_move_assignable<tl::expected<T,int>>::value);
+        REQUIRE(std::is_destructible<tl::expected<T,int>>::value);
+    }
+
+    {
+        struct T {
+            T(const T&)=delete;
+            T(T&&)=delete;
+            T& operator=(const T&)=delete;
+            T& operator=(T&&)=delete;
+        };
+        REQUIRE(!std::is_copy_constructible<tl::expected<T,int>>::value);
+        REQUIRE(!std::is_copy_assignable<tl::expected<T,int>>::value);
+        REQUIRE(!std::is_move_constructible<tl::expected<T,int>>::value);
+        REQUIRE(!std::is_move_assignable<tl::expected<T,int>>::value);
+    }
+
+    {
+        struct T {
+            T(const T&)=delete;
+            T(T&&)=default;
+            T& operator=(const T&)=delete;
+            T& operator=(T&&)=default;
+        };
+        REQUIRE(!std::is_copy_constructible<tl::expected<T,int>>::value);
+        REQUIRE(!std::is_copy_assignable<tl::expected<T,int>>::value);
+        REQUIRE(std::is_move_constructible<tl::expected<T,int>>::value);
+        REQUIRE(std::is_move_assignable<tl::expected<T,int>>::value);
+    }
+
+    {
+        struct T {
+            T(const T&)=default;
+            T(T&&)=delete;
+            T& operator=(const T&)=default;
+            T& operator=(T&&)=delete;
+        };
+        REQUIRE(std::is_copy_constructible<tl::expected<T,int>>::value);
+        REQUIRE(std::is_copy_assignable<tl::expected<T,int>>::value);
+    }
+
+	{
+		tl::expected<int, int> e;
+		REQUIRE(std::is_default_constructible<decltype(e)>::value);
+		REQUIRE(std::is_copy_constructible<decltype(e)>::value);
+		REQUIRE(std::is_move_constructible<decltype(e)>::value);
+		REQUIRE(std::is_copy_assignable<decltype(e)>::value);
+		REQUIRE(std::is_move_assignable<decltype(e)>::value);
+		REQUIRE(TL_EXPECTED_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(decltype(e))::value);
+		REQUIRE(TL_EXPECTED_IS_TRIVIALLY_COPY_ASSIGNABLE(decltype(e))::value);
+#	if !defined(TL_EXPECTED_GCC49)
+		REQUIRE(std::is_trivially_move_constructible<decltype(e)>::value);
+		REQUIRE(std::is_trivially_move_assignable<decltype(e)>::value);
+#	endif
+	}
+
+	{
+		tl::expected<int, std::string> e;
+		REQUIRE(std::is_default_constructible<decltype(e)>::value);
+		REQUIRE(std::is_copy_constructible<decltype(e)>::value);
+		REQUIRE(std::is_move_constructible<decltype(e)>::value);
+		REQUIRE(std::is_copy_assignable<decltype(e)>::value);
+		REQUIRE(std::is_move_assignable<decltype(e)>::value);
+		REQUIRE(!TL_EXPECTED_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(decltype(e))::value);
+		REQUIRE(!TL_EXPECTED_IS_TRIVIALLY_COPY_ASSIGNABLE(decltype(e))::value);
+#	if !defined(TL_EXPECTED_GCC49)
+		REQUIRE(!std::is_trivially_move_constructible<decltype(e)>::value);
+		REQUIRE(!std::is_trivially_move_assignable<decltype(e)>::value);
+#	endif
+	}
+
+	{
+		tl::expected<std::string, int> e;
+		REQUIRE(std::is_default_constructible<decltype(e)>::value);
+		REQUIRE(std::is_copy_constructible<decltype(e)>::value);
+		REQUIRE(std::is_move_constructible<decltype(e)>::value);
+		REQUIRE(std::is_copy_assignable<decltype(e)>::value);
+		REQUIRE(std::is_move_assignable<decltype(e)>::value);
+		REQUIRE(!TL_EXPECTED_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(decltype(e))::value);
+		REQUIRE(!TL_EXPECTED_IS_TRIVIALLY_COPY_ASSIGNABLE(decltype(e))::value);
+#	if !defined(TL_EXPECTED_GCC49)
+		REQUIRE(!std::is_trivially_move_constructible<decltype(e)>::value);
+		REQUIRE(!std::is_trivially_move_assignable<decltype(e)>::value);
+#	endif
+	}
+
+	{
+		tl::expected<std::string, std::string> e;
+		REQUIRE(std::is_default_constructible<decltype(e)>::value);
+		REQUIRE(std::is_copy_constructible<decltype(e)>::value);
+		REQUIRE(std::is_move_constructible<decltype(e)>::value);
+		REQUIRE(std::is_copy_assignable<decltype(e)>::value);
+		REQUIRE(std::is_move_assignable<decltype(e)>::value);
+		REQUIRE(!TL_EXPECTED_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(decltype(e))::value);
+		REQUIRE(!TL_EXPECTED_IS_TRIVIALLY_COPY_ASSIGNABLE(decltype(e))::value);
+#	if !defined(TL_EXPECTED_GCC49)
+		REQUIRE(!std::is_trivially_move_constructible<decltype(e)>::value);
+		REQUIRE(!std::is_trivially_move_assignable<decltype(e)>::value);
+#	endif
+	}
+
+}
+
+
+#endif
diff --git a/Telegram/ThirdParty/expected/tests/constexpr.cpp b/Telegram/ThirdParty/expected/tests/constexpr.cpp
new file mode 100644
index 0000000..9046592
--- /dev/null
+++ b/Telegram/ThirdParty/expected/tests/constexpr.cpp
@@ -0,0 +1,6 @@
+#include <catch2/catch.hpp>
+#include <tl/expected.hpp>
+
+TEST_CASE("Constexpr", "[constexpr]") {
+    //TODO
+}
diff --git a/Telegram/ThirdParty/expected/tests/constructors.cpp b/Telegram/ThirdParty/expected/tests/constructors.cpp
new file mode 100644
index 0000000..df168ba
--- /dev/null
+++ b/Telegram/ThirdParty/expected/tests/constructors.cpp
@@ -0,0 +1,134 @@
+#include <catch2/catch.hpp>
+#include <tl/expected.hpp>
+
+#include <type_traits>
+#include <vector>
+#include <string>
+
+struct takes_init_and_variadic {
+    std::vector<int> v;
+    std::tuple<int, int> t;
+    template <class... Args>
+    takes_init_and_variadic(std::initializer_list<int> l, Args &&... args)
+        : v(l), t(std::forward<Args>(args)...) {}
+};
+
+TEST_CASE("Constructors", "[constructors]") {
+    {
+        tl::expected<int,int> e;
+        REQUIRE(e);
+        REQUIRE(e == 0);
+    }
+
+    {
+        tl::expected<int,int> e = tl::make_unexpected(0);
+        REQUIRE(!e);
+        REQUIRE(e.error() == 0);
+    }
+
+    {
+        tl::expected<int,int> e (tl::unexpect, 0);
+        REQUIRE(!e);
+        REQUIRE(e.error() == 0);
+    }
+
+    {
+        tl::expected<int,int> e (tl::in_place, 42);
+        REQUIRE(e);
+        REQUIRE(e == 42);
+    }
+
+    {
+        tl::expected<std::vector<int>,int> e (tl::in_place, {0,1});
+        REQUIRE(e);
+        REQUIRE((*e)[0] == 0);
+        REQUIRE((*e)[1] == 1);
+    }
+
+    {
+        tl::expected<std::tuple<int,int>,int> e (tl::in_place, 0, 1);
+        REQUIRE(e);
+        REQUIRE(std::get<0>(*e) == 0);
+        REQUIRE(std::get<1>(*e) == 1);
+    }
+
+    {
+        tl::expected<takes_init_and_variadic,int> e (tl::in_place, {0,1}, 2, 3);
+        REQUIRE(e);
+        REQUIRE(e->v[0] == 0);
+        REQUIRE(e->v[1] == 1);
+        REQUIRE(std::get<0>(e->t) == 2);
+        REQUIRE(std::get<1>(e->t) == 3);
+    }
+
+	{
+		tl::expected<int, int> e;
+		REQUIRE(std::is_default_constructible<decltype(e)>::value);
+		REQUIRE(std::is_copy_constructible<decltype(e)>::value);
+		REQUIRE(std::is_move_constructible<decltype(e)>::value);
+		REQUIRE(std::is_copy_assignable<decltype(e)>::value);
+		REQUIRE(std::is_move_assignable<decltype(e)>::value);
+		REQUIRE(TL_EXPECTED_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(decltype(e))::value);
+		REQUIRE(TL_EXPECTED_IS_TRIVIALLY_COPY_ASSIGNABLE(decltype(e))::value);
+#	if !defined(TL_EXPECTED_GCC49)
+		REQUIRE(std::is_trivially_move_constructible<decltype(e)>::value);
+		REQUIRE(std::is_trivially_move_assignable<decltype(e)>::value);
+#	endif
+	}
+
+	{
+		tl::expected<int, std::string> e;
+		REQUIRE(std::is_default_constructible<decltype(e)>::value);
+		REQUIRE(std::is_copy_constructible<decltype(e)>::value);
+		REQUIRE(std::is_move_constructible<decltype(e)>::value);
+		REQUIRE(std::is_copy_assignable<decltype(e)>::value);
+		REQUIRE(std::is_move_assignable<decltype(e)>::value);
+		REQUIRE(!TL_EXPECTED_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(decltype(e))::value);
+		REQUIRE(!TL_EXPECTED_IS_TRIVIALLY_COPY_ASSIGNABLE(decltype(e))::value);
+#	if !defined(TL_EXPECTED_GCC49)
+		REQUIRE(!std::is_trivially_move_constructible<decltype(e)>::value);
+		REQUIRE(!std::is_trivially_move_assignable<decltype(e)>::value);
+#	endif
+	}
+
+	{
+		tl::expected<std::string, int> e;
+		REQUIRE(std::is_default_constructible<decltype(e)>::value);
+		REQUIRE(std::is_copy_constructible<decltype(e)>::value);
+		REQUIRE(std::is_move_constructible<decltype(e)>::value);
+		REQUIRE(std::is_copy_assignable<decltype(e)>::value);
+		REQUIRE(std::is_move_assignable<decltype(e)>::value);
+		REQUIRE(!TL_EXPECTED_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(decltype(e))::value);
+		REQUIRE(!TL_EXPECTED_IS_TRIVIALLY_COPY_ASSIGNABLE(decltype(e))::value);
+#	if !defined(TL_EXPECTED_GCC49)
+		REQUIRE(!std::is_trivially_move_constructible<decltype(e)>::value);
+		REQUIRE(!std::is_trivially_move_assignable<decltype(e)>::value);
+#	endif
+	}
+
+	{
+		tl::expected<std::string, std::string> e;
+		REQUIRE(std::is_default_constructible<decltype(e)>::value);
+		REQUIRE(std::is_copy_constructible<decltype(e)>::value);
+		REQUIRE(std::is_move_constructible<decltype(e)>::value);
+		REQUIRE(std::is_copy_assignable<decltype(e)>::value);
+		REQUIRE(std::is_move_assignable<decltype(e)>::value);
+		REQUIRE(!TL_EXPECTED_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(decltype(e))::value);
+		REQUIRE(!TL_EXPECTED_IS_TRIVIALLY_COPY_ASSIGNABLE(decltype(e))::value);
+#	if !defined(TL_EXPECTED_GCC49)
+		REQUIRE(!std::is_trivially_move_constructible<decltype(e)>::value);
+		REQUIRE(!std::is_trivially_move_assignable<decltype(e)>::value);
+#	endif
+	}
+
+    {
+        tl::expected<void,int> e;
+        REQUIRE(e);
+    }
+
+    {
+        tl::expected<void,int> e (tl::unexpect, 42);
+        REQUIRE(!e);
+        REQUIRE(e.error() == 42);
+    }
+}
diff --git a/Telegram/ThirdParty/expected/tests/emplace.cpp b/Telegram/ThirdParty/expected/tests/emplace.cpp
new file mode 100644
index 0000000..9449079
--- /dev/null
+++ b/Telegram/ThirdParty/expected/tests/emplace.cpp
@@ -0,0 +1,50 @@
+#include <catch2/catch.hpp>
+#include <tl/expected.hpp>
+#include <memory>
+#include <vector>
+#include <tuple>
+
+namespace {
+struct takes_init_and_variadic {
+  std::vector<int> v;
+  std::tuple<int, int> t;
+  template <class... Args>
+  takes_init_and_variadic(std::initializer_list<int> l, Args &&... args)
+      : v(l), t(std::forward<Args>(args)...) {}
+};
+}
+
+TEST_CASE("Emplace", "[emplace]") {
+    {
+        tl::expected<std::unique_ptr<int>,int> e;
+        e.emplace(new int{42});
+        REQUIRE(e);
+        REQUIRE(**e == 42);
+    }
+
+    {
+        tl::expected<std::vector<int>,int> e;
+        e.emplace({0,1});
+        REQUIRE(e);
+        REQUIRE((*e)[0] == 0);
+        REQUIRE((*e)[1] == 1);
+    }
+
+    {
+        tl::expected<std::tuple<int,int>,int> e;
+        e.emplace(2,3);
+        REQUIRE(e);
+        REQUIRE(std::get<0>(*e) == 2);
+        REQUIRE(std::get<1>(*e) == 3);
+    }
+
+    {
+        tl::expected<takes_init_and_variadic,int> e = tl::make_unexpected(0);
+        e.emplace({0,1}, 2, 3);
+        REQUIRE(e);
+        REQUIRE(e->v[0] == 0);
+        REQUIRE(e->v[1] == 1);
+        REQUIRE(std::get<0>(e->t) == 2);
+        REQUIRE(std::get<1>(e->t) == 3);
+    }
+}
diff --git a/Telegram/ThirdParty/expected/tests/extensions.cpp b/Telegram/ThirdParty/expected/tests/extensions.cpp
new file mode 100644
index 0000000..9670f90
--- /dev/null
+++ b/Telegram/ThirdParty/expected/tests/extensions.cpp
@@ -0,0 +1,584 @@
+#include <catch2/catch.hpp>
+#include <tl/expected.hpp>
+
+#define TOKENPASTE(x, y) x##y
+#define TOKENPASTE2(x, y) TOKENPASTE(x, y)
+#define STATIC_REQUIRE(e)                                                      \
+  constexpr bool TOKENPASTE2(rqure, __LINE__) = e;                             \
+  REQUIRE(e);
+
+TEST_CASE("Map extensions", "[extensions.map]") {
+  auto mul2 = [](int a) { return a * 2; };
+  auto ret_void = [](int a) {};
+
+  {
+    tl::expected<int, int> e = 21;
+    auto ret = e.map(mul2);
+    REQUIRE(ret);
+    REQUIRE(*ret == 42);
+  }
+
+  {
+    const tl::expected<int, int> e = 21;
+    auto ret = e.map(mul2);
+    REQUIRE(ret);
+    REQUIRE(*ret == 42);
+  }
+
+  {
+    tl::expected<int, int> e = 21;
+    auto ret = std::move(e).map(mul2);
+    REQUIRE(ret);
+    REQUIRE(*ret == 42);
+  }
+
+  {
+    const tl::expected<int, int> e = 21;
+    auto ret = std::move(e).map(mul2);
+    REQUIRE(ret);
+    REQUIRE(*ret == 42);
+  }
+
+  {
+    tl::expected<int, int> e(tl::unexpect, 21);
+    auto ret = e.map(mul2);
+    REQUIRE(!ret);
+    REQUIRE(ret.error() == 21);
+  }
+
+  {
+    const tl::expected<int, int> e(tl::unexpect, 21);
+    auto ret = e.map(mul2);
+    REQUIRE(!ret);
+    REQUIRE(ret.error() == 21);
+  }
+
+  {
+    tl::expected<int, int> e(tl::unexpect, 21);
+    auto ret = std::move(e).map(mul2);
+    REQUIRE(!ret);
+    REQUIRE(ret.error() == 21);
+  }
+
+  {
+    const tl::expected<int, int> e(tl::unexpect, 21);
+    auto ret = std::move(e).map(mul2);
+    REQUIRE(!ret);
+    REQUIRE(ret.error() == 21);
+  }
+
+  {
+    tl::expected<int, int> e = 21;
+    auto ret = e.map(ret_void);
+    REQUIRE(ret);
+    STATIC_REQUIRE(
+        (std::is_same<decltype(ret), tl::expected<void, int>>::value));
+  }
+
+  {
+    const tl::expected<int, int> e = 21;
+    auto ret = e.map(ret_void);
+    REQUIRE(ret);
+    STATIC_REQUIRE(
+        (std::is_same<decltype(ret), tl::expected<void, int>>::value));
+  }
+
+  {
+    tl::expected<int, int> e = 21;
+    auto ret = std::move(e).map(ret_void);
+    REQUIRE(ret);
+    STATIC_REQUIRE(
+        (std::is_same<decltype(ret), tl::expected<void, int>>::value));
+  }
+
+  {
+    const tl::expected<int, int> e = 21;
+    auto ret = std::move(e).map(ret_void);
+    REQUIRE(ret);
+    STATIC_REQUIRE(
+        (std::is_same<decltype(ret), tl::expected<void, int>>::value));
+  }
+
+  {
+    tl::expected<int, int> e(tl::unexpect, 21);
+    auto ret = e.map(ret_void);
+    REQUIRE(!ret);
+    STATIC_REQUIRE(
+        (std::is_same<decltype(ret), tl::expected<void, int>>::value));
+  }
+
+  {
+    const tl::expected<int, int> e(tl::unexpect, 21);
+    auto ret = e.map(ret_void);
+    REQUIRE(!ret);
+    STATIC_REQUIRE(
+        (std::is_same<decltype(ret), tl::expected<void, int>>::value));
+  }
+
+  {
+    tl::expected<int, int> e(tl::unexpect, 21);
+    auto ret = std::move(e).map(ret_void);
+    REQUIRE(!ret);
+    STATIC_REQUIRE(
+        (std::is_same<decltype(ret), tl::expected<void, int>>::value));
+  }
+
+  {
+    const tl::expected<int, int> e(tl::unexpect, 21);
+    auto ret = std::move(e).map(ret_void);
+    REQUIRE(!ret);
+    STATIC_REQUIRE(
+        (std::is_same<decltype(ret), tl::expected<void, int>>::value));
+  }
+
+
+  // mapping functions which return references
+  {
+    tl::expected<int, int> e(42);
+    auto ret = e.map([](int& i) -> int& { return i; });
+    REQUIRE(ret);
+    REQUIRE(ret == 42);
+  }
+}
+
+TEST_CASE("Map error extensions", "[extensions.map_error]") {
+  auto mul2 = [](int a) { return a * 2; };
+  auto ret_void = [](int a) {};
+
+  {
+    tl::expected<int, int> e = 21;
+    auto ret = e.map_error(mul2);
+    REQUIRE(ret);
+    REQUIRE(*ret == 21);
+  }
+
+  {
+    const tl::expected<int, int> e = 21;
+    auto ret = e.map_error(mul2);
+    REQUIRE(ret);
+    REQUIRE(*ret == 21);
+  }
+
+  {
+    tl::expected<int, int> e = 21;
+    auto ret = std::move(e).map_error(mul2);
+    REQUIRE(ret);
+    REQUIRE(*ret == 21);
+  }
+
+  {
+    const tl::expected<int, int> e = 21;
+    auto ret = std::move(e).map_error(mul2);
+    REQUIRE(ret);
+    REQUIRE(*ret == 21);
+  }
+
+  {
+    tl::expected<int, int> e(tl::unexpect, 21);
+    auto ret = e.map_error(mul2);
+    REQUIRE(!ret);
+    REQUIRE(ret.error() == 42);
+  }
+
+  {
+    const tl::expected<int, int> e(tl::unexpect, 21);
+    auto ret = e.map_error(mul2);
+    REQUIRE(!ret);
+    REQUIRE(ret.error() == 42);
+  }
+
+  {
+    tl::expected<int, int> e(tl::unexpect, 21);
+    auto ret = std::move(e).map_error(mul2);
+    REQUIRE(!ret);
+    REQUIRE(ret.error() == 42);
+  }
+
+  {
+    const tl::expected<int, int> e(tl::unexpect, 21);
+    auto ret = std::move(e).map_error(mul2);
+    REQUIRE(!ret);
+    REQUIRE(ret.error() == 42);
+  }
+
+  {
+    tl::expected<int, int> e = 21;
+    auto ret = e.map_error(ret_void);
+    REQUIRE(ret);
+  }
+
+  {
+    const tl::expected<int, int> e = 21;
+    auto ret = e.map_error(ret_void);
+    REQUIRE(ret);
+  }
+
+  {
+    tl::expected<int, int> e = 21;
+    auto ret = std::move(e).map_error(ret_void);
+    REQUIRE(ret);
+  }
+
+  {
+    const tl::expected<int, int> e = 21;
+    auto ret = std::move(e).map_error(ret_void);
+    REQUIRE(ret);
+  }
+
+  {
+    tl::expected<int, int> e(tl::unexpect, 21);
+    auto ret = e.map_error(ret_void);
+    REQUIRE(!ret);
+  }
+
+  {
+    const tl::expected<int, int> e(tl::unexpect, 21);
+    auto ret = e.map_error(ret_void);
+    REQUIRE(!ret);
+  }
+
+  {
+    tl::expected<int, int> e(tl::unexpect, 21);
+    auto ret = std::move(e).map_error(ret_void);
+    REQUIRE(!ret);
+  }
+
+  {
+    const tl::expected<int, int> e(tl::unexpect, 21);
+    auto ret = std::move(e).map_error(ret_void);
+    REQUIRE(!ret);
+  }
+
+}
+
+TEST_CASE("And then extensions", "[extensions.and_then]") {
+  auto succeed = [](int a) { return tl::expected<int, int>(21 * 2); };
+  auto fail = [](int a) { return tl::expected<int, int>(tl::unexpect, 17); };
+
+  {
+    tl::expected<int, int> e = 21;
+    auto ret = e.and_then(succeed);
+    REQUIRE(ret);
+    REQUIRE(*ret == 42);
+  }
+
+  {
+    const tl::expected<int, int> e = 21;
+    auto ret = e.and_then(succeed);
+    REQUIRE(ret);
+    REQUIRE(*ret == 42);
+  }
+
+  {
+    tl::expected<int, int> e = 21;
+    auto ret = std::move(e).and_then(succeed);
+    REQUIRE(ret);
+    REQUIRE(*ret == 42);
+  }
+
+  {
+    const tl::expected<int, int> e = 21;
+    auto ret = std::move(e).and_then(succeed);
+    REQUIRE(ret);
+    REQUIRE(*ret == 42);
+  }
+
+  {
+    tl::expected<int, int> e = 21;
+    auto ret = e.and_then(fail);
+    REQUIRE(!ret);
+    REQUIRE(ret.error() == 17);
+  }
+
+  {
+    const tl::expected<int, int> e = 21;
+    auto ret = e.and_then(fail);
+    REQUIRE(!ret);
+    REQUIRE(ret.error() == 17);
+  }
+
+  {
+    tl::expected<int, int> e = 21;
+    auto ret = std::move(e).and_then(fail);
+    REQUIRE(!ret);
+    REQUIRE(ret.error() == 17);
+  }
+
+  {
+    const tl::expected<int, int> e = 21;
+    auto ret = std::move(e).and_then(fail);
+    REQUIRE(!ret);
+    REQUIRE(ret.error() == 17);
+  }
+
+  {
+    tl::expected<int, int> e(tl::unexpect, 21);
+    auto ret = e.and_then(succeed);
+    REQUIRE(!ret);
+    REQUIRE(ret.error() == 21);
+  }
+
+  {
+    const tl::expected<int, int> e(tl::unexpect, 21);
+    auto ret = e.and_then(succeed);
+    REQUIRE(!ret);
+    REQUIRE(ret.error() == 21);
+  }
+
+  {
+    tl::expected<int, int> e(tl::unexpect, 21);
+    auto ret = std::move(e).and_then(succeed);
+    REQUIRE(!ret);
+    REQUIRE(ret.error() == 21);
+  }
+
+  {
+    const tl::expected<int, int> e(tl::unexpect, 21);
+    auto ret = std::move(e).and_then(succeed);
+    REQUIRE(!ret);
+    REQUIRE(ret.error() == 21);
+  }
+
+  {
+    tl::expected<int, int> e(tl::unexpect, 21);
+    auto ret = e.and_then(fail);
+    REQUIRE(!ret);
+    REQUIRE(ret.error() == 21);
+  }
+
+  {
+    const tl::expected<int, int> e(tl::unexpect, 21);
+    auto ret = e.and_then(fail);
+    REQUIRE(!ret);
+    REQUIRE(ret.error() == 21);
+  }
+
+  {
+    tl::expected<int, int> e(tl::unexpect, 21);
+    auto ret = std::move(e).and_then(fail);
+    REQUIRE(!ret);
+    REQUIRE(ret.error() == 21);
+  }
+
+  {
+    const tl::expected<int, int> e(tl::unexpect, 21);
+    auto ret = std::move(e).and_then(fail);
+    REQUIRE(!ret);
+    REQUIRE(ret.error() == 21);
+  }
+}
+
+TEST_CASE("or_else", "[extensions.or_else]") {
+  using eptr = std::unique_ptr<int>;
+  auto succeed = [](int a) { return tl::expected<int, int>(21 * 2); };
+  auto succeedptr = [](eptr e) { return tl::expected<int,eptr>(21*2);};
+  auto fail =    [](int a) { return tl::expected<int,int>(tl::unexpect, 17);};
+  auto efail =   [](eptr e) { *e = 17;return tl::expected<int,eptr>(tl::unexpect, std::move(e));};
+  auto failptr = [](eptr e) { return tl::expected<int,eptr>(tl::unexpect, std::move(e));};
+  auto failvoid = [](int) {};
+  auto failvoidptr = [](const eptr&) { /* don't consume */};
+  auto consumeptr = [](eptr) {};
+  auto make_u_int = [](int n) { return std::unique_ptr<int>(new int(n));};
+
+  {
+    tl::expected<int, int> e = 21;
+    auto ret = e.or_else(succeed);
+    REQUIRE(ret);
+    REQUIRE(*ret == 21);
+  }
+
+  {
+    const tl::expected<int, int> e = 21;
+    auto ret = e.or_else(succeed);
+    REQUIRE(ret);
+    REQUIRE(*ret == 21);
+  }
+
+  {
+    tl::expected<int, int> e = 21;
+    auto ret = std::move(e).or_else(succeed);
+    REQUIRE(ret);
+    REQUIRE(*ret == 21);
+  }
+
+  {
+    tl::expected<int, eptr> e = 21;
+    auto ret = std::move(e).or_else(succeedptr);
+    REQUIRE(ret);
+    REQUIRE(*ret == 21);
+  }
+
+  {
+    const tl::expected<int, int> e = 21;
+    auto ret = std::move(e).or_else(succeed);
+    REQUIRE(ret);
+    REQUIRE(*ret == 21);
+  }
+
+  {
+    tl::expected<int, int> e = 21;
+    auto ret = e.or_else(fail);
+    REQUIRE(ret);
+    REQUIRE(*ret == 21);
+  }
+
+  {
+    const tl::expected<int, int> e = 21;
+    auto ret = e.or_else(fail);
+    REQUIRE(ret);
+    REQUIRE(*ret == 21);
+  }
+
+  {
+    tl::expected<int, int> e = 21;
+    auto ret = std::move(e).or_else(fail);
+    REQUIRE(ret);
+    REQUIRE(ret == 21);
+  }
+
+
+  {
+    tl::expected<int, eptr> e = 21;
+    auto ret = std::move(e).or_else(efail);
+    REQUIRE(ret);
+    REQUIRE(ret == 21);
+  }
+
+  {
+    const tl::expected<int, int> e = 21;
+    auto ret = std::move(e).or_else(fail);
+    REQUIRE(ret);
+    REQUIRE(*ret == 21);
+  }
+
+  {
+    tl::expected<int, int> e(tl::unexpect, 21);
+    auto ret = e.or_else(succeed);
+    REQUIRE(ret);
+    REQUIRE(*ret == 42);
+  }
+
+  {
+    const tl::expected<int, int> e(tl::unexpect, 21);
+    auto ret = e.or_else(succeed);
+    REQUIRE(ret);
+    REQUIRE(*ret == 42);
+  }
+
+  {
+    tl::expected<int, int> e(tl::unexpect, 21);
+    auto ret = std::move(e).or_else(succeed);
+    REQUIRE(ret);
+    REQUIRE(*ret == 42);
+  }
+
+  {
+    tl::expected<int, eptr> e(tl::unexpect, make_u_int(21));
+    auto ret = std::move(e).or_else(succeedptr);
+    REQUIRE(ret);
+    REQUIRE(*ret == 42);
+  }
+
+  {
+    const tl::expected<int, int> e(tl::unexpect, 21);
+    auto ret = std::move(e).or_else(succeed);
+    REQUIRE(ret);
+    REQUIRE(*ret == 42);
+  }
+
+  {
+    tl::expected<int, int> e(tl::unexpect, 21);
+    auto ret = e.or_else(fail);
+    REQUIRE(!ret);
+    REQUIRE(ret.error() == 17);
+  }
+
+  {
+    tl::expected<int, int> e(tl::unexpect, 21);
+    auto ret = e.or_else(failvoid);
+    REQUIRE(!ret);
+    REQUIRE(ret.error() == 21);
+  }
+
+  {
+    const tl::expected<int, int> e(tl::unexpect, 21);
+    auto ret = e.or_else(fail);
+    REQUIRE(!ret);
+    REQUIRE(ret.error() == 17);
+  }
+
+  {
+    const tl::expected<int, int> e(tl::unexpect, 21);
+    auto ret = e.or_else(failvoid);
+    REQUIRE(!ret);
+    REQUIRE(ret.error() == 21);
+  }
+
+  {
+    tl::expected<int, int> e(tl::unexpect, 21);
+    auto ret = std::move(e).or_else(fail);
+    REQUIRE(!ret);
+    REQUIRE(ret.error() == 17);
+  }
+
+  {
+    tl::expected<int, int> e(tl::unexpect, 21);
+    auto ret = std::move(e).or_else(failvoid);
+    REQUIRE(!ret);
+    REQUIRE(ret.error() == 21);
+  }
+
+  {
+    tl::expected<int, eptr> e(tl::unexpect, make_u_int(21));
+    auto ret = std::move(e).or_else(failvoidptr);
+    REQUIRE(!ret);
+    REQUIRE(*ret.error() == 21);
+  }
+
+  {
+    tl::expected<int, eptr> e(tl::unexpect, make_u_int(21));
+    auto ret = std::move(e).or_else(consumeptr);
+    REQUIRE(!ret);
+    REQUIRE(ret.error() == nullptr);
+  }
+
+  {
+    const tl::expected<int, int> e(tl::unexpect, 21);
+    auto ret = std::move(e).or_else(fail);
+    REQUIRE(!ret);
+    REQUIRE(ret.error() == 17);
+  }
+
+  {
+    const tl::expected<int, int> e(tl::unexpect, 21);
+    auto ret = std::move(e).or_else(failvoid);
+    REQUIRE(!ret);
+    REQUIRE(ret.error() == 21);
+  }
+
+}
+struct S {
+    int x;
+};
+
+struct F {
+    int x;
+};
+
+TEST_CASE("14", "[issue.14]") {
+    auto res = tl::expected<S,F>{tl::unexpect, F{}};
+
+    res.map_error([](F f) {
+
+    });
+}
+
+TEST_CASE("32", "[issue.32]") {
+    int i = 0;
+    tl::expected<void, int> a;
+    a.map([&i]{i = 42;});
+    REQUIRE(i == 42);
+
+    auto x = a.map([]{return 42;});
+    REQUIRE(*x == 42);
+}
diff --git a/Telegram/ThirdParty/expected/tests/issues.cpp b/Telegram/ThirdParty/expected/tests/issues.cpp
new file mode 100644
index 0000000..e9f99da
--- /dev/null
+++ b/Telegram/ThirdParty/expected/tests/issues.cpp
@@ -0,0 +1,138 @@
+#include <catch2/catch.hpp>
+#include <tl/expected.hpp>
+
+#include <string>
+
+using std::string;
+
+tl::expected<int, string> getInt3(int val) { return val; }
+
+tl::expected<int, string> getInt2(int val) { return val; }
+
+tl::expected<int, string> getInt1() { return getInt2(5).and_then(getInt3); }
+
+TEST_CASE("Issue 1", "[issues.1]") { getInt1(); }
+
+tl::expected<int, int> operation1() { return 42; }
+
+tl::expected<std::string, int> operation2(int const val) { return "Bananas"; }
+
+TEST_CASE("Issue 17", "[issues.17]") {
+  auto const intermediate_result = operation1();
+
+  intermediate_result.and_then(operation2);
+}
+
+struct a {};
+struct b : a {};
+
+auto doit() -> tl::expected<std::unique_ptr<b>, int> {
+    return tl::make_unexpected(0);
+}
+
+TEST_CASE("Issue 23", "[issues.23]") {
+    tl::expected<std::unique_ptr<a>, int> msg = doit();
+    REQUIRE(!msg.has_value());    
+}
+
+TEST_CASE("Issue 26", "[issues.26]") {
+  tl::expected<a, int> exp = tl::expected<b, int>(tl::unexpect, 0);
+  REQUIRE(!exp.has_value());
+}
+
+struct foo {
+  foo() = default;
+  foo(foo &) = delete;
+  foo(foo &&){};
+};
+
+TEST_CASE("Issue 29", "[issues.29]") {
+  std::vector<foo> v;
+  v.emplace_back();
+  tl::expected<std::vector<foo>, int> ov = std::move(v);
+  REQUIRE(ov->size() == 1);
+}
+
+tl::expected<int, std::string> error() {
+  return tl::make_unexpected(std::string("error1 "));
+}
+std::string maperror(std::string s) { return s + "maperror "; }
+
+TEST_CASE("Issue 30", "[issues.30]") {
+  error().map_error(maperror);
+}
+
+struct i31{
+  int i;
+};
+TEST_CASE("Issue 31", "[issues.31]") {
+    const tl::expected<i31, int> a = i31{42};
+    a->i;
+
+    tl::expected< void, std::string > result;
+    tl::expected< void, std::string > result2 = result;
+    result2 = result;
+}
+
+TEST_CASE("Issue 33", "[issues.33]") {
+    tl::expected<void, int> res {tl::unexpect, 0};
+    REQUIRE(!res);    
+    res = res.map_error([](int i) { return 42; });
+    REQUIRE(res.error() == 42);
+}
+
+
+tl::expected<void, std::string> voidWork() { return {}; }
+tl::expected<int, std::string> work2() { return 42; }
+void errorhandling(std::string){}
+
+TEST_CASE("Issue 34", "[issues.34]") {
+  tl::expected <int, std::string> result = voidWork ()
+      .and_then (work2);
+  result.map_error ([&] (std::string result) {errorhandling (result);});
+}
+
+struct non_copyable {
+	non_copyable(non_copyable&&) = default;
+	non_copyable(non_copyable const&) = delete;
+	non_copyable() = default;
+};
+
+TEST_CASE("Issue 42", "[issues.42]") {
+	tl::expected<non_copyable,int>{}.map([](non_copyable) {});
+}
+
+TEST_CASE("Issue 43", "[issues.43]") {
+	auto result = tl::expected<void, std::string>{};
+	result = tl::make_unexpected(std::string{ "foo" });
+}
+
+#if !(__GNUC__ <= 5)
+#include <memory>
+
+using MaybeDataPtr = tl::expected<int, std::unique_ptr<int>>;
+
+MaybeDataPtr test(int i) noexcept
+{
+  return std::move(i);
+}
+
+MaybeDataPtr test2(int i) noexcept
+{
+  return std::move(i);
+}
+
+TEST_CASE("Issue 49", "[issues.49]") {
+  auto m = test(10)
+    .and_then(test2);
+}
+#endif
+
+tl::expected<int, std::unique_ptr<std::string>> func()
+{
+  return 1;
+}
+
+TEST_CASE("Issue 61", "[issues.61]") {
+  REQUIRE(func().value() == 1);
+}
diff --git a/Telegram/ThirdParty/expected/tests/main.cpp b/Telegram/ThirdParty/expected/tests/main.cpp
new file mode 100644
index 0000000..4ed06df
--- /dev/null
+++ b/Telegram/ThirdParty/expected/tests/main.cpp
@@ -0,0 +1,2 @@
+#define CATCH_CONFIG_MAIN
+#include <catch2/catch.hpp>
diff --git a/Telegram/ThirdParty/expected/tests/noexcept.cpp b/Telegram/ThirdParty/expected/tests/noexcept.cpp
new file mode 100644
index 0000000..f5c688f
--- /dev/null
+++ b/Telegram/ThirdParty/expected/tests/noexcept.cpp
@@ -0,0 +1,6 @@
+#include <catch2/catch.hpp>
+#include <tl/expected.hpp>
+
+TEST_CASE("Noexcept", "[noexcept]") {
+    //TODO
+}
diff --git a/Telegram/ThirdParty/expected/tests/observers.cpp b/Telegram/ThirdParty/expected/tests/observers.cpp
new file mode 100644
index 0000000..5d8473c
--- /dev/null
+++ b/Telegram/ThirdParty/expected/tests/observers.cpp
@@ -0,0 +1,36 @@
+#include <catch2/catch.hpp>
+#include <tl/expected.hpp>
+
+struct move_detector {
+  move_detector() = default;
+  move_detector(move_detector &&rhs) { rhs.been_moved = true; }
+  bool been_moved = false;
+};
+
+TEST_CASE("Observers", "[observers]") {
+    tl::expected<int,int> o1 = 42;
+    tl::expected<int,int> o2 {tl::unexpect, 0};
+    const tl::expected<int,int> o3 = 42;
+
+  REQUIRE(*o1 == 42);
+  REQUIRE(*o1 == o1.value());
+  REQUIRE(o2.value_or(42) == 42);
+  REQUIRE(o2.error() == 0);
+  REQUIRE(o3.value() == 42);
+  auto success = std::is_same<decltype(o1.value()), int &>::value;
+  REQUIRE(success);
+  success = std::is_same<decltype(o3.value()), const int &>::value;
+  REQUIRE(success);
+  success = std::is_same<decltype(std::move(o1).value()), int &&>::value;
+  REQUIRE(success);
+
+  #ifndef TL_EXPECTED_NO_CONSTRR
+  success = std::is_same<decltype(std::move(o3).value()), const int &&>::value;
+  REQUIRE(success);
+  #endif
+
+  tl::expected<move_detector,int> o4{tl::in_place};
+  move_detector o5 = std::move(o4).value();
+  REQUIRE(o4->been_moved);
+  REQUIRE(!o5.been_moved);
+}
diff --git a/Telegram/ThirdParty/expected/tests/relops.cpp b/Telegram/ThirdParty/expected/tests/relops.cpp
new file mode 100644
index 0000000..a1f8a73
--- /dev/null
+++ b/Telegram/ThirdParty/expected/tests/relops.cpp
@@ -0,0 +1,6 @@
+#include <catch2/catch.hpp>
+#include <tl/expected.hpp>
+
+TEST_CASE("Relational operators", "[relops]") {
+    //TODO
+}
diff --git a/Telegram/ThirdParty/expected/tests/swap.cpp b/Telegram/ThirdParty/expected/tests/swap.cpp
new file mode 100644
index 0000000..b3423c4
--- /dev/null
+++ b/Telegram/ThirdParty/expected/tests/swap.cpp
@@ -0,0 +1,101 @@
+#include <catch2/catch.hpp>
+#include <tl/expected.hpp>
+
+struct no_throw {
+  no_throw(std::string i) : i(i) {}
+  std::string i;
+};
+struct canthrow_move {
+  canthrow_move(std::string i) : i(i) {}
+  canthrow_move(canthrow_move const &) = default;
+  canthrow_move(canthrow_move &&other) noexcept(false) : i(other.i) {}
+  canthrow_move &operator=(canthrow_move &&) = default;
+  std::string i;
+};
+
+bool should_throw = false;
+struct willthrow_move {
+  willthrow_move(std::string i) : i(i) {}
+  willthrow_move(willthrow_move const &) = default;
+  willthrow_move(willthrow_move &&other) : i(other.i) {
+    if (should_throw)
+      throw 0;
+  }
+  willthrow_move &operator=(willthrow_move &&) = default;
+  std::string i;
+};
+static_assert(tl::detail::is_swappable<no_throw>::value, "");
+
+template <class T1, class T2> void swap_test() {
+  std::string s1 = "abcdefghijklmnopqrstuvwxyz";
+  std::string s2 = "zyxwvutsrqponmlkjihgfedcba";
+
+  tl::expected<T1, T2> a{s1};
+  tl::expected<T1, T2> b{s2};
+  swap(a, b);
+  REQUIRE(a->i == s2);
+  REQUIRE(b->i == s1);
+
+  a = s1;
+  b = tl::unexpected<T2>(s2);
+  swap(a, b);
+  REQUIRE(a.error().i == s2);
+  REQUIRE(b->i == s1);
+
+  a = tl::unexpected<T2>(s1);
+  b = s2;
+  swap(a, b);
+  REQUIRE(a->i == s2);
+  REQUIRE(b.error().i == s1);
+
+  a = tl::unexpected<T2>(s1);
+  b = tl::unexpected<T2>(s2);
+  swap(a, b);
+  REQUIRE(a.error().i == s2);
+  REQUIRE(b.error().i == s1);
+
+  a = s1;
+  b = s2;
+  a.swap(b);
+  REQUIRE(a->i == s2);
+  REQUIRE(b->i == s1);
+
+  a = s1;
+  b = tl::unexpected<T2>(s2);
+  a.swap(b);
+  REQUIRE(a.error().i == s2);
+  REQUIRE(b->i == s1);
+
+  a = tl::unexpected<T2>(s1);
+  b = s2;
+  a.swap(b);
+  REQUIRE(a->i == s2);
+  REQUIRE(b.error().i == s1);
+
+  a = tl::unexpected<T2>(s1);
+  b = tl::unexpected<T2>(s2);
+  a.swap(b);
+  REQUIRE(a.error().i == s2);
+  REQUIRE(b.error().i == s1);
+}
+
+TEST_CASE("swap") {
+
+  swap_test<no_throw, no_throw>();
+  swap_test<no_throw, canthrow_move>();
+  swap_test<canthrow_move, no_throw>();
+
+  std::string s1 = "abcdefghijklmnopqrstuvwxyz";
+  std::string s2 = "zyxwvutsrqponmlkjihgfedcbaxxx";
+  tl::expected<no_throw, willthrow_move> a{s1};
+  tl::expected<no_throw, willthrow_move> b{tl::unexpect, s2};
+  should_throw = 1;
+
+  #ifdef _MSC_VER
+  //this seems to break catch on GCC and Clang
+  REQUIRE_THROWS(swap(a, b));
+  #endif
+
+  REQUIRE(a->i == s1);
+  REQUIRE(b.error().i == s2);
+}
diff --git a/Telegram/ThirdParty/expected/tests/test.cpp b/Telegram/ThirdParty/expected/tests/test.cpp
new file mode 100644
index 0000000..0338ccb
--- /dev/null
+++ b/Telegram/ThirdParty/expected/tests/test.cpp
@@ -0,0 +1,32 @@
+struct no_throw {
+  no_throw(std::string i) : i(i) {}
+  std::string i;
+};
+struct canthrow_move {
+  canthrow_move(std::string i) : i(i) {}
+  canthrow_move(canthrow_move const &) = default;
+  canthrow_move(canthrow_move &&other) noexcept(false) : i(other.i) {}
+  canthrow_move &operator=(canthrow_move &&) = default;
+  std::string i;
+};
+
+bool should_throw = false;
+struct willthrow_move {
+  willthrow_move(std::string i) : i(i) {}
+  willthrow_move(willthrow_move const &) = default;
+  willthrow_move(willthrow_move &&other) : i(other.i) {
+    if (should_throw)
+      throw 0;
+  }
+  willthrow_move &operator=(willthrow_move &&) = default;
+  std::string i;
+};
+
+int main() {
+  std::string s1 = "abcdefghijklmnopqrstuvwxyz";
+  std::string s2 = "zyxwvutsrqponmlkjihgfedcbaxxx";
+  tl::expected<no_throw, willthrow_move> a{s1};
+  tl::expected<no_throw, willthrow_move> b{tl::unexpect, s2};
+  should_throw = 1;
+  swap(a, b);
+}
\ No newline at end of file
Submodule Telegram/ThirdParty/libtgvoip 302d42fc2..303dcacc2:
diff --git a/Telegram/ThirdParty/libtgvoip/EchoCanceller.cpp b/Telegram/ThirdParty/libtgvoip/EchoCanceller.cpp
index d11f110..bd8b31b 100755
--- a/Telegram/ThirdParty/libtgvoip/EchoCanceller.cpp
+++ b/Telegram/ThirdParty/libtgvoip/EchoCanceller.cpp
@@ -96,6 +96,7 @@ EchoCanceller::~EchoCanceller(){
 #ifndef TGVOIP_NO_DSP
 	delete apm;
 	delete audioFrame;
+	delete farendBufferPool;
 #endif
 }
 
diff --git a/Telegram/ThirdParty/libtgvoip/NetworkSocket.cpp b/Telegram/ThirdParty/libtgvoip/NetworkSocket.cpp
index 4ee314e..940d401 100644
--- a/Telegram/ThirdParty/libtgvoip/NetworkSocket.cpp
+++ b/Telegram/ThirdParty/libtgvoip/NetworkSocket.cpp
@@ -364,8 +364,8 @@ bool NetworkSocketTCPObfuscated::IsFailed(){
 NetworkSocketSOCKS5Proxy::NetworkSocketSOCKS5Proxy(NetworkSocket *tcp, NetworkSocket *udp, std::string username, std::string password) : NetworkSocketWrapper(udp ? PROTO_UDP : PROTO_TCP){
 	this->tcp=tcp;
 	this->udp=udp;
-	this->username=username;
-	this->password=password;
+	this->username=std::move(username);
+	this->password=std::move(password);
 	connectedAddress=NULL;
 }
 
diff --git a/Telegram/ThirdParty/libtgvoip/OpusDecoder.cpp b/Telegram/ThirdParty/libtgvoip/OpusDecoder.cpp
index 0ecd63e..a1bcef2 100755
--- a/Telegram/ThirdParty/libtgvoip/OpusDecoder.cpp
+++ b/Telegram/ThirdParty/libtgvoip/OpusDecoder.cpp
@@ -10,7 +10,7 @@
 #include <assert.h>
 #include <math.h>
 #include <algorithm>
-#ifdef HAVE_CONFIG_H
+#if defined HAVE_CONFIG_H || defined TGVOIP_USE_INSTALLED_OPUS
 #include <opus/opus.h>
 #else
 #include "opus.h"
diff --git a/Telegram/ThirdParty/libtgvoip/OpusEncoder.cpp b/Telegram/ThirdParty/libtgvoip/OpusEncoder.cpp
index 8786bf5..8fb297f 100755
--- a/Telegram/ThirdParty/libtgvoip/OpusEncoder.cpp
+++ b/Telegram/ThirdParty/libtgvoip/OpusEncoder.cpp
@@ -9,7 +9,7 @@
 #include <algorithm>
 #include "logging.h"
 #include "VoIPServerConfig.h"
-#ifdef HAVE_CONFIG_H
+#if defined HAVE_CONFIG_H || defined TGVOIP_USE_INSTALLED_OPUS
 #include <opus/opus.h>
 #else
 #include "opus.h"
diff --git a/Telegram/ThirdParty/libtgvoip/VoIPController.cpp b/Telegram/ThirdParty/libtgvoip/VoIPController.cpp
old mode 100755
new mode 100644
index d9297ce..b7eecdb
--- a/Telegram/ThirdParty/libtgvoip/VoIPController.cpp
+++ b/Telegram/ThirdParty/libtgvoip/VoIPController.cpp
@@ -773,10 +773,10 @@ string VoIPController::GetCurrentAudioOutputID(){
 
 void VoIPController::SetProxy(int protocol, string address, uint16_t port, string username, string password){
 	proxyProtocol=protocol;
-	proxyAddress=address;
+	proxyAddress=std::move(address);
 	proxyPort=port;
-	proxyUsername=username;
-	proxyPassword=password;
+	proxyUsername=std::move(username);
+	proxyPassword=std::move(password);
 }
 
 int VoIPController::GetSignalBarsCount(){
@@ -894,7 +894,7 @@ void VoIPController::SetConfig(const Config& cfg){
 
 void VoIPController::SetPersistentState(vector<uint8_t> state){
 	using namespace json11;
-	
+
 	if(state.empty())
 		return;
 	string jsonErr;
@@ -915,7 +915,7 @@ void VoIPController::SetPersistentState(vector<uint8_t> state){
 
 vector<uint8_t> VoIPController::GetPersistentState(){
 	using namespace json11;
-	
+
 	Json::object obj=Json::object{
 		{"ver", 1},
 	};
@@ -1116,10 +1116,11 @@ void VoIPController::HandleAudioInput(unsigned char *data, size_t len, unsigned
 	}
 
 	unsentStreamPackets++;
+	size_t pktLength = pkt.GetLength();
 	PendingOutgoingPacket p{
 			/*.seq=*/GenerateOutSeq(),
 			/*.type=*/PKT_STREAM_DATA,
-			/*.len=*/pkt.GetLength(),
+			/*.len=*/pktLength,
 			/*.data=*/Buffer(move(pkt)),
 			/*.endpoint=*/0,
 	};
@@ -1142,10 +1143,11 @@ void VoIPController::HandleAudioInput(unsigned char *data, size_t len, unsigned
 			pkt.WriteBytes(*ecData);
 		}
 
+		pktLength = pkt.GetLength();
 		PendingOutgoingPacket p{
 				GenerateOutSeq(),
 				PKT_STREAM_EC,
-				pkt.GetLength(),
+				pktLength,
 				Buffer(move(pkt)),
 				0
 		};
@@ -1324,7 +1326,7 @@ void VoIPController::WritePacketHeader(uint32_t pseq, BufferOutputStream *s, uns
 		if(!currentExtras.empty()){
 			s->WriteByte(static_cast<unsigned char>(currentExtras.size()));
 			for(vector<UnacknowledgedExtraData>::iterator x=currentExtras.begin(); x!=currentExtras.end(); ++x){
-				LOGV("Writing extra into header: type %u, length %lu", x->type, x->data.Length());
+				LOGV("Writing extra into header: type %u, length %d", x->type, int(x->data.Length()));
 				assert(x->data.Length()<=254);
 				s->WriteByte(static_cast<unsigned char>(x->data.Length()+1));
 				s->WriteByte(x->type);
@@ -1406,7 +1408,7 @@ void VoIPController::WritePacketHeader(uint32_t pseq, BufferOutputStream *s, uns
 					s->WriteByte(XPFLAG_HAS_EXTRA);
 					s->WriteByte(static_cast<unsigned char>(currentExtras.size()));
 					for(vector<UnacknowledgedExtraData>::iterator x=currentExtras.begin(); x!=currentExtras.end(); ++x){
-						LOGV("Writing extra into header: type %u, length %lu", x->type, x->data.Length());
+						LOGV("Writing extra into header: type %u, length %d", x->type, int(x->data.Length()));
 						assert(x->data.Length()<=254);
 						s->WriteByte(static_cast<unsigned char>(x->data.Length()+1));
 						s->WriteByte(x->type);
@@ -1486,10 +1488,11 @@ void VoIPController::SendInit(){
 					out.WriteInt32(id);
 				}*/
 			}
+			size_t outLength = out.GetLength();
 			SendOrEnqueuePacket(PendingOutgoingPacket{
 					/*.seq=*/initSeq,
 					/*.type=*/PKT_INIT,
-					/*.len=*/out.GetLength(),
+					/*.len=*/outLength,
 					/*.data=*/Buffer(move(out)),
 					/*.endpoint=*/e.id
 			});
@@ -1518,14 +1521,14 @@ void VoIPController::InitUDPProxy(){
 		ResetUdpAvailability();
 		return;
 	}
-	
+
 	NetworkSocket* tcp=NetworkSocket::Create(PROTO_TCP);
 	tcp->Connect(resolvedProxyAddress, proxyPort);
-	
+
 	vector<NetworkSocket*> writeSockets;
 	vector<NetworkSocket*> readSockets;
 	vector<NetworkSocket*> errorSockets;
-	
+
 	while(!tcp->IsFailed() && !tcp->IsReadyToSend()){
 		writeSockets.push_back(tcp);
 		if(!NetworkSocket::Select(readSockets, writeSockets, errorSockets, selectCanceller)){
@@ -1579,12 +1582,12 @@ void VoIPController::RunRecvThread(){
 		udpPingTimeoutID=messageThread.Post(std::bind(&VoIPController::SendUdpPings, this), 0.0, 0.5);
 	}
 	while(runReceiver){
-		
+
 		if(proxyProtocol==PROXY_SOCKS5 && needReInitUdpProxy){
 			InitUDPProxy();
 			needReInitUdpProxy=false;
 		}
-		
+
 		packet.data=*buffer;
 		packet.length=buffer.Length();
 
@@ -1595,7 +1598,7 @@ void VoIPController::RunRecvThread(){
 		errorSockets.push_back(realUdpSocket);
 		if(!realUdpSocket->IsReadyToSend())
 			writeSockets.push_back(realUdpSocket);
-		
+
 		{
 			MutexGuard m(endpointsMutex);
 			for(pair<const int64_t, Endpoint>& _e:endpoints){
@@ -2132,7 +2135,7 @@ simpleAudioBlock random_id:long random_bytes:string raw_data:string = DecryptedA
 		}
 		for(vector<UnacknowledgedExtraData>::iterator x=currentExtras.begin();x!=currentExtras.end();){
 			if(x->firstContainingSeq!=0 && (lastRemoteAckSeq==x->firstContainingSeq || seqgt(lastRemoteAckSeq, x->firstContainingSeq))){
-				LOGV("Peer acknowledged extra type %u length %lu", x->type, x->data.Length());
+				LOGV("Peer acknowledged extra type %u length %d", x->type, int(x->data.Length()));
 				ProcessAcknowledgedOutgoingExtra(*x);
 				x=currentExtras.erase(x);
 				continue;
@@ -2310,10 +2313,11 @@ simpleAudioBlock random_id:long random_bytes:string raw_data:string = DecryptedA
 			out.WriteByte((unsigned char) ((*s)->enabled ? 1 : 0));
 		}
 		LOGI("Sending init ack");
+		size_t outLength = out.GetLength();
 		SendOrEnqueuePacket(PendingOutgoingPacket{
 				/*.seq=*/GenerateOutSeq(),
 				/*.type=*/PKT_INIT_ACK,
-				/*.len=*/out.GetLength(),
+				/*.len=*/outLength,
 				/*.data=*/Buffer(move(out)),
 				/*.endpoint=*/0
 		});
@@ -2517,10 +2521,11 @@ simpleAudioBlock random_id:long random_bytes:string raw_data:string = DecryptedA
 		}
 		BufferOutputStream pkt(128);
 		pkt.WriteInt32(pseq);
+		size_t pktLength = pkt.GetLength();
 		SendOrEnqueuePacket(PendingOutgoingPacket{
 				/*.seq=*/GenerateOutSeq(),
 				/*.type=*/PKT_PONG,
-				/*.len=*/pkt.GetLength(),
+				/*.len=*/pktLength,
 				/*.data=*/Buffer(move(pkt)),
 				/*.endpoint=*/srcEndpoint.id,
 		});
@@ -2775,7 +2780,7 @@ bool VoIPController::SendOrEnqueuePacket(PendingOutgoingPacket pkt, bool enqueue
 		abort();
 		return false;
 	}
-	
+
 
 	bool canSend;
 	if(endpoint->type!=Endpoint::Type::TCP_RELAY){
@@ -3031,7 +3036,7 @@ void VoIPController::AddTCPRelays(){
 			relays.push_back(tcpRelay);
 		}
 		for(Endpoint& e:relays){
-			endpoints[e.id]=move(e);
+			endpoints[e.id]=e;
 		}
 		didAddTcpRelays=true;
 	}
@@ -3182,7 +3187,7 @@ void VoIPController::SendPacketReliably(unsigned char type, unsigned char *data,
 
 void VoIPController::SendExtra(Buffer &data, unsigned char type){
 	MutexGuard m(queuedPacketsMutex);
-	LOGV("Sending extra type %u length %lu", type, data.Length());
+	LOGV("Sending extra type %u length %d", type, int(data.Length()));
 	for(vector<UnacknowledgedExtraData>::iterator x=currentExtras.begin();x!=currentExtras.end();++x){
 		if(x->type==type){
 			x->firstContainingSeq=0;
@@ -3437,16 +3442,17 @@ void VoIPController::SendVideoFrame(const Buffer &frame, uint32_t flags){
 			pkt.WriteBytes(frame, offset, len);
 
 			uint32_t seq=GenerateOutSeq();
+			size_t pktLength = pkt.GetLength();
 			PendingOutgoingPacket p{
 					/*.seq=*/seq,
 					/*.type=*/PKT_STREAM_DATA,
-					/*.len=*/pkt.GetLength(),
+					/*.len=*/pktLength,
 					/*.data=*/Buffer(move(pkt)),
 					/*.endpoint=*/0,
 			};
 			unsentStreamPackets++;
 			SendOrEnqueuePacket(move(p));
-			videoCongestionControl.ProcessPacketSent(static_cast<unsigned int>(pkt.GetLength()));
+			videoCongestionControl.ProcessPacketSent(static_cast<unsigned int>(pktLength));
 			sentFrame.unacknowledgedPackets.push_back(seq);
 		}
 		MutexGuard m(sentVideoFramesMutex);
@@ -3704,7 +3710,7 @@ void VoIPController::UpdateCongestion(){
 				wasExtraEC=true;
 			}
 		}
-		
+
 		if(avgSendLossCount>0.08){
 			extraEcLevel=4;
 		}else if(avgSendLossCount>0.05){
@@ -3973,7 +3979,7 @@ Endpoint::~Endpoint(){
 
 #pragma mark - AudioInputTester
 
-AudioInputTester::AudioInputTester(std::string deviceID) : deviceID(deviceID){
+AudioInputTester::AudioInputTester(std::string deviceID) : deviceID(std::move(deviceID)){
 	io=audio::AudioIO::Create(deviceID, "default");
 	if(io->Failed()){
 		LOGE("Audio IO failed");
diff --git a/Telegram/ThirdParty/libtgvoip/audio/Resampler.cpp b/Telegram/ThirdParty/libtgvoip/audio/Resampler.cpp
index 076d4ca..74583af 100644
--- a/Telegram/ThirdParty/libtgvoip/audio/Resampler.cpp
+++ b/Telegram/ThirdParty/libtgvoip/audio/Resampler.cpp
@@ -58,7 +58,7 @@ static const int16_t hann[960]={
 		0x7FDE, 0x7FE1, 0x7FE4, 0x7FE7, 0x7FEA, 0x7FED, 0x7FEF, 0x7FF1, 0x7FF3, 0x7FF5, 0x7FF7, 0x7FF9, 0x7FFA, 0x7FFB, 0x7FFC, 0x7FFD, 0x7FFE, 0x7FFE, 0x7FFF, 0x7FFF
 };
 
-#define MIN(a, b) (a<b ? a : b)
+#define MIN(a, b) (((a)<(b)) ? (a) : (b))
 
 size_t Resampler::Convert48To44(int16_t *from, int16_t *to, size_t fromLen, size_t toLen){
 	size_t outLen=fromLen*147/160;
diff --git a/Telegram/ThirdParty/libtgvoip/libtgvoip.gyp b/Telegram/ThirdParty/libtgvoip/libtgvoip.gyp
index 1d03579..d5a5adb 100644
--- a/Telegram/ThirdParty/libtgvoip/libtgvoip.gyp
+++ b/Telegram/ThirdParty/libtgvoip/libtgvoip.gyp
@@ -14,11 +14,9 @@
         'variables': {
           'tgvoip_src_loc': '.',
           'special_build_target%': '',
-          'linux_path_opus_include%': '<(DEPTH)/../../../Libraries/opus/include',
         },
         'include_dirs': [
           '<(tgvoip_src_loc)/webrtc_dsp',
-          '<(linux_path_opus_include)',
         ],
         'direct_dependent_settings': {
           'include_dirs': [
@@ -770,6 +768,7 @@
                   },
                   'include_dirs': [
                     '<(DEPTH)/../../../Libraries/openssl/include',
+                    '/usr/local/include',
                   ],
                   'direct_dependent_settings': {
                     'linkflags': [
@@ -786,6 +785,7 @@
                   },
                   'include_dirs': [
                     '<(DEPTH)/../../../Libraries/macos/openssl_1_1_1/include',
+                    '/usr/local/macos/include',
                   ],
                   'direct_dependent_settings': {
                     'linkflags': [
@@ -817,6 +817,9 @@
           [
             '"<(OS)" == "win"', {
               'msbuild_toolset': 'v142',
+              'include_dirs': [
+                '<(DEPTH)/../../../Libraries/opus/include',
+              ],
               'defines': [
                 'NOMINMAX',
                 '_USING_V110_SDK71_',
@@ -895,7 +898,11 @@
                   },
                 },
               },
-            },
+            }, {
+              'defines': [
+                'TGVOIP_USE_INSTALLED_OPUS',
+              ],
+            }
           ],
           [
             '"<(OS)" == "linux"', {
diff --git a/Telegram/ThirdParty/libtgvoip/libtgvoip_osx.xcodeproj/project.pbxproj b/Telegram/ThirdParty/libtgvoip/libtgvoip_osx.xcodeproj/project.pbxproj
index e5df12c..592428d 100644
--- a/Telegram/ThirdParty/libtgvoip/libtgvoip_osx.xcodeproj/project.pbxproj
+++ b/Telegram/ThirdParty/libtgvoip/libtgvoip_osx.xcodeproj/project.pbxproj
@@ -333,8 +333,6 @@
 		69DF157C2237DFE100C1F8ED /* SampleBufferDisplayLayerRenderer.mm in Sources */ = {isa = PBXBuildFile; fileRef = 69DF157A2237DFE100C1F8ED /* SampleBufferDisplayLayerRenderer.mm */; };
 		69DF157E2237DFE700C1F8ED /* SampleBufferDisplayLayerRenderer.h in Headers */ = {isa = PBXBuildFile; fileRef = 69DF157D2237DFE700C1F8ED /* SampleBufferDisplayLayerRenderer.h */; };
 		69DF15802237E96E00C1F8ED /* VideoToolbox.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 69DF157F2237E96E00C1F8ED /* VideoToolbox.framework */; };
-		69EBC7912136D220003CFE90 /* AudioInputAudioUnitOSX.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C2A87DDC1F4B6A61002D3F73 /* AudioInputAudioUnitOSX.cpp */; };
-		69EBC7922136D220003CFE90 /* AudioOutputAudioUnitOSX.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C2A87DDE1F4B6A61002D3F73 /* AudioOutputAudioUnitOSX.cpp */; };
 		69EBC7942136D277003CFE90 /* DarwinSpecific.mm in Sources */ = {isa = PBXBuildFile; fileRef = 69EBC7932136D277003CFE90 /* DarwinSpecific.mm */; };
 		C2A87DD81F4B6A33002D3F73 /* Resampler.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C2A87DD71F4B6A33002D3F73 /* Resampler.cpp */; };
 		C2A87DDF1F4B6A61002D3F73 /* AudioInputAudioUnit.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C2A87DDB1F4B6A61002D3F73 /* AudioInputAudioUnit.cpp */; };
@@ -2494,6 +2492,7 @@
 			developmentRegion = English;
 			hasScannedForEncodings = 0;
 			knownRegions = (
+				English,
 				en,
 			);
 			mainGroup = 69F8422C1E67540700C110F7;
@@ -2670,7 +2669,6 @@
 				691E05E921A4FD7600F838EF /* channel_buffer.cc in Sources */,
 				691E078721A4FD7700F838EF /* echo_audibility.cc in Sources */,
 				691E068921A4FD7600F838EF /* entropy_coding.c in Sources */,
-				69EBC7922136D220003CFE90 /* AudioOutputAudioUnitOSX.cpp in Sources */,
 				691E061821A4FD7600F838EF /* filter_ma_fast_q12.c in Sources */,
 				691E05D921A4FD7600F838EF /* raw_logging.cc in Sources */,
 				691E079A21A4FD7700F838EF /* suppression_gain_limiter.cc in Sources */,
@@ -2693,7 +2691,6 @@
 				691E07DB21A4FD7700F838EF /* block_mean_calculator.cc in Sources */,
 				692AB9041E6759DD00706ACC /* VoIPServerConfig.cpp in Sources */,
 				691E066A21A4FD7600F838EF /* lpc_shape_swb16_tables.c in Sources */,
-				69EBC7912136D220003CFE90 /* AudioInputAudioUnitOSX.cpp in Sources */,
 				691E071021A4FD7700F838EF /* wpd_node.cc in Sources */,
 				691E062621A4FD7600F838EF /* cross_correlation.c in Sources */,
 				691E07EE21A4FD7700F838EF /* platform_file.cc in Sources */,
@@ -3565,6 +3562,174 @@
 			};
 			name = ReleaseHockeyapp;
 		};
+		D045B56522E0C29A005B6623 /* HockeyappMacAlpha */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ALWAYS_SEARCH_USER_PATHS = NO;
+				CLANG_ANALYZER_NONNULL = YES;
+				CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
+				CLANG_CXX_LIBRARY = "libc++";
+				CLANG_ENABLE_MODULES = YES;
+				CLANG_ENABLE_OBJC_ARC = YES;
+				CLANG_WARN_BOOL_CONVERSION = YES;
+				CLANG_WARN_CONSTANT_CONVERSION = YES;
+				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
+				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
+				CLANG_WARN_EMPTY_BODY = YES;
+				CLANG_WARN_ENUM_CONVERSION = YES;
+				CLANG_WARN_INFINITE_RECURSION = YES;
+				CLANG_WARN_INT_CONVERSION = YES;
+				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
+				CLANG_WARN_SUSPICIOUS_MOVE = YES;
+				CLANG_WARN_UNREACHABLE_CODE = YES;
+				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
+				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
+				COPY_PHASE_STRIP = NO;
+				CURRENT_PROJECT_VERSION = 1;
+				DEBUG_INFORMATION_FORMAT = dwarf;
+				ENABLE_STRICT_OBJC_MSGSEND = YES;
+				ENABLE_TESTABILITY = YES;
+				GCC_C_LANGUAGE_STANDARD = gnu99;
+				GCC_DYNAMIC_NO_PIC = NO;
+				GCC_NO_COMMON_BLOCKS = YES;
+				GCC_OPTIMIZATION_LEVEL = 0;
+				GCC_PREPROCESSOR_DEFINITIONS = (
+					"DEBUG=1",
+					"$(inherited)",
+				);
+				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
+				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
+				GCC_WARN_UNDECLARED_SELECTOR = YES;
+				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
+				GCC_WARN_UNUSED_FUNCTION = YES;
+				GCC_WARN_UNUSED_VARIABLE = YES;
+				IPHONEOS_DEPLOYMENT_TARGET = 10.2;
+				MTL_ENABLE_DEBUG_INFO = YES;
+				ONLY_ACTIVE_ARCH = YES;
+				SDKROOT = iphoneos;
+				TARGETED_DEVICE_FAMILY = "1,2";
+				VERSIONING_SYSTEM = "apple-generic";
+				VERSION_INFO_PREFIX = "";
+			};
+			name = HockeyappMacAlpha;
+		};
+		D045B56622E0C29A005B6623 /* HockeyappMacAlpha */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				CLANG_CXX_LANGUAGE_STANDARD = "c++0x";
+				CLANG_CXX_LIBRARY = "libc++";
+				CODE_SIGN_IDENTITY = "";
+				DEFINES_MODULE = YES;
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				DYLIB_INSTALL_NAME_BASE = "@rpath";
+				HEADER_SEARCH_PATHS = (
+					"$(inherited)",
+					"../../thrid-party/opus/include/opus",
+					"../../third-party/opus/include/opus",
+					webrtc_dsp,
+					"../Telegram-Mac/third-party/opus/include/opus",
+					"../Telegram-Mac/thrid-party/opus/include/opus",
+				);
+				INFOPLIST_FILE = "$(SRCROOT)/Info.plist";
+				INSTALL_PATH = "$(LOCAL_LIBRARY_DIR)/Frameworks";
+				IPHONEOS_DEPLOYMENT_TARGET = 6.0;
+				LD_RUNPATH_SEARCH_PATHS = "$(inherited) @executable_path/Frameworks @loader_path/Frameworks";
+				LIBRARY_SEARCH_PATHS = "$(inherited)";
+				MACH_O_TYPE = staticlib;
+				MACOSX_DEPLOYMENT_TARGET = 10.7;
+				OTHER_CFLAGS = (
+					"-DTGVOIP_USE_CUSTOM_CRYPTO",
+					"-DWEBRTC_POSIX",
+					"-DWEBRTC_APM_DEBUG_DUMP=0",
+					"-DTGVOIP_USE_DESKTOP_DSP",
+					"-DWEBRTC_MAC",
+					"-DWEBRTC_NS_FLOAT",
+				);
+				PRODUCT_BUNDLE_IDENTIFIER = me.grishka.libtgvoip;
+				PRODUCT_NAME = "$(TARGET_NAME)";
+				SDKROOT = macosx;
+				SKIP_INSTALL = YES;
+			};
+			name = HockeyappMacAlpha;
+		};
+		D045B56722E0C29A005B6623 /* HockeyappMacAlpha */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ALWAYS_SEARCH_USER_PATHS = NO;
+				CLANG_ANALYZER_NONNULL = YES;
+				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
+				CLANG_CXX_LANGUAGE_STANDARD = "gnu++14";
+				CLANG_CXX_LIBRARY = "libc++";
+				CLANG_ENABLE_MODULES = YES;
+				CLANG_ENABLE_OBJC_ARC = YES;
+				CLANG_ENABLE_OBJC_WEAK = YES;
+				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
+				CLANG_WARN_BOOL_CONVERSION = YES;
+				CLANG_WARN_COMMA = YES;
+				CLANG_WARN_CONSTANT_CONVERSION = YES;
+				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
+				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
+				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
+				CLANG_WARN_EMPTY_BODY = YES;
+				CLANG_WARN_ENUM_CONVERSION = YES;
+				CLANG_WARN_INFINITE_RECURSION = YES;
+				CLANG_WARN_INT_CONVERSION = YES;
+				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
+				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
+				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
+				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
+				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
+				CLANG_WARN_STRICT_PROTOTYPES = YES;
+				CLANG_WARN_SUSPICIOUS_MOVE = YES;
+				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
+				CLANG_WARN_UNREACHABLE_CODE = YES;
+				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
+				CODE_SIGN_IDENTITY = "-";
+				CODE_SIGN_STYLE = Automatic;
+				COMBINE_HIDPI_IMAGES = YES;
+				COPY_PHASE_STRIP = NO;
+				DEBUG_INFORMATION_FORMAT = dwarf;
+				ENABLE_STRICT_OBJC_MSGSEND = YES;
+				ENABLE_TESTABILITY = YES;
+				GCC_C_LANGUAGE_STANDARD = gnu11;
+				GCC_DYNAMIC_NO_PIC = NO;
+				GCC_NO_COMMON_BLOCKS = YES;
+				GCC_OPTIMIZATION_LEVEL = 0;
+				GCC_PREPROCESSOR_DEFINITIONS = (
+					"DEBUG=1",
+					"$(inherited)",
+				);
+				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
+				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
+				GCC_WARN_UNDECLARED_SELECTOR = YES;
+				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
+				GCC_WARN_UNUSED_FUNCTION = YES;
+				GCC_WARN_UNUSED_VARIABLE = YES;
+				HEADER_SEARCH_PATHS = (
+					/usr/local/opt/openssl/include,
+					webrtc_dsp,
+				);
+				INFOPLIST_FILE = tests/Info.plist;
+				LD_RUNPATH_SEARCH_PATHS = "$(inherited) @executable_path/../Frameworks @loader_path/../Frameworks";
+				LIBRARY_SEARCH_PATHS = (
+					/usr/local/opt/openssl/lib,
+					/usr/local/lib,
+				);
+				MACOSX_DEPLOYMENT_TARGET = 10.13;
+				MTL_ENABLE_DEBUG_INFO = YES;
+				ONLY_ACTIVE_ARCH = YES;
+				OTHER_CFLAGS = "-DTGVOIP_USE_CALLBACK_AUDIO_IO";
+				OTHER_LDFLAGS = (
+					"-lopus",
+					"-lcrypto",
+				);
+				PRODUCT_BUNDLE_IDENTIFIER = me.grishka.libtgvoipTests;
+				PRODUCT_NAME = "$(TARGET_NAME)";
+				SDKROOT = macosx;
+			};
+			name = HockeyappMacAlpha;
+		};
 		D04D01C31E678C0D0086DDC0 /* DebugAppStore */ = {
 			isa = XCBuildConfiguration;
 			buildSettings = {
@@ -3750,6 +3915,7 @@
 			isa = XCConfigurationList;
 			buildConfigurations = (
 				697B6FCC2136DBA4004C8E54 /* DebugHockeyapp */,
+				D045B56722E0C29A005B6623 /* HockeyappMacAlpha */,
 				697B6FCD2136DBA4004C8E54 /* Debug Auto Test */,
 				697B6FCE2136DBA4004C8E54 /* DebugAppStore */,
 				697B6FCF2136DBA4004C8E54 /* ReleaseHockeyapp */,
@@ -3762,6 +3928,7 @@
 			isa = XCConfigurationList;
 			buildConfigurations = (
 				69F8423C1E67540700C110F7 /* DebugHockeyapp */,
+				D045B56522E0C29A005B6623 /* HockeyappMacAlpha */,
 				69EBC7982136D55A003CFE90 /* Debug Auto Test */,
 				D04D01C31E678C0D0086DDC0 /* DebugAppStore */,
 				69F8423D1E67540700C110F7 /* ReleaseHockeyapp */,
@@ -3774,6 +3941,7 @@
 			isa = XCConfigurationList;
 			buildConfigurations = (
 				69F8423F1E67540700C110F7 /* DebugHockeyapp */,
+				D045B56622E0C29A005B6623 /* HockeyappMacAlpha */,
 				69EBC7992136D55A003CFE90 /* Debug Auto Test */,
 				D04D01C41E678C0D0086DDC0 /* DebugAppStore */,
 				69F842401E67540700C110F7 /* ReleaseHockeyapp */,
diff --git a/Telegram/ThirdParty/libtgvoip/os/darwin/AudioUnitIO.h b/Telegram/ThirdParty/libtgvoip/os/darwin/AudioUnitIO.h
index 981a7e9..14351d8 100644
--- a/Telegram/ThirdParty/libtgvoip/os/darwin/AudioUnitIO.h
+++ b/Telegram/ThirdParty/libtgvoip/os/darwin/AudioUnitIO.h
@@ -39,7 +39,9 @@ class AudioOutputAudioUnit;
 		std::string currentInputDevice;
 		std::string currentOutputDevice;
 		bool duckingEnabled=true;
+#ifndef TGVOIP_NO_OSX_PRIVATE_API
 		bool actualDuckingEnabled=true;
+#endif // TGVOIP_NO_OSX_PRIVATE_API
 		AudioDeviceID currentOutputDeviceID;
 #endif
 		AudioComponentInstance unit;
diff --git a/Telegram/ThirdParty/libtgvoip/os/linux/AudioPulse.cpp b/Telegram/ThirdParty/libtgvoip/os/linux/AudioPulse.cpp
index 701d851..f02ece8 100644
--- a/Telegram/ThirdParty/libtgvoip/os/linux/AudioPulse.cpp
+++ b/Telegram/ThirdParty/libtgvoip/os/linux/AudioPulse.cpp
@@ -193,7 +193,7 @@ AudioPulse::AudioPulse(std::string inputDevice, std::string outputDevice){
 	isLocked=false;
 
 	output=new AudioOutputPulse(context, mainloop, outputDevice);
-	input=new AudioInputPulse(context, mainloop, outputDevice);
+	input=new AudioInputPulse(context, mainloop, inputDevice);
 }
 
 AudioPulse::~AudioPulse(){
diff --git a/Telegram/ThirdParty/libtgvoip/os/windows/NetworkSocketWinsock.cpp b/Telegram/ThirdParty/libtgvoip/os/windows/NetworkSocketWinsock.cpp
index 04e0d48..6f89f38 100644
--- a/Telegram/ThirdParty/libtgvoip/os/windows/NetworkSocketWinsock.cpp
+++ b/Telegram/ThirdParty/libtgvoip/os/windows/NetworkSocketWinsock.cpp
@@ -53,7 +53,7 @@ NetworkSocketWinsock::~NetworkSocketWinsock(){
 }
 
 void NetworkSocketWinsock::SetMaxPriority(){
-	
+
 }
 
 void NetworkSocketWinsock::Send(NetworkPacket *packet){
@@ -73,7 +73,7 @@ void NetworkSocketWinsock::Send(NetworkPacket *packet){
 					addrinfo *addr0;
 					int res=getaddrinfo("ipv4only.arpa", NULL, NULL, &addr0);
 					if(res!=0){
-						LOGW("Error updating NAT64 prefix: %d / %s", res, gai_strerror(res));
+						LOGW("Error updating NAT64 prefix: %d / %s", res, gai_strerrorA(res));
 					}else{
 						addrinfo *addrPtr;
 						unsigned char *addr170=NULL;
@@ -243,7 +243,7 @@ void NetworkSocketWinsock::Open(){
 			failed=true;
 			return;
 		}
-		
+
 		int res;
 		if(isAtLeastVista){
 			DWORD flag=0;
@@ -362,7 +362,7 @@ std::string NetworkSocketWinsock::GetLocalInterfaceInfo(IPv4Address *v4addr, IPv
 	IP_ADAPTER_ADDRESSES* addrs=(IP_ADAPTER_ADDRESSES*)malloc(15*1024);
 	ULONG size=15*1024;
 	ULONG flags=GAA_FLAG_SKIP_ANYCAST | GAA_FLAG_SKIP_MULTICAST | GAA_FLAG_SKIP_DNS_SERVER | GAA_FLAG_SKIP_FRIENDLY_NAME;
-	
+
 	ULONG res=GetAdaptersAddresses(AF_UNSPEC, flags, NULL, addrs, &size);
 	if(res==ERROR_BUFFER_OVERFLOW){
 		addrs=(IP_ADAPTER_ADDRESSES*)realloc(addrs, size);
@@ -565,7 +565,7 @@ IPv4Address *NetworkSocketWinsock::ResolveDomainName(std::string name){
 	IPv4Address* ret=NULL;
 	int res=getaddrinfo(name.c_str(), NULL, NULL, &addr0);
 	if(res!=0){
-		LOGW("Error updating NAT64 prefix: %d / %s", res, gai_strerror(res));
+		LOGW("Error updating NAT64 prefix: %d / %s", res, gai_strerrorA(res));
 	}else{
 		addrinfo* addrPtr;
 		for(addrPtr=addr0;addrPtr;addrPtr=addrPtr->ai_next){
diff --git a/Telegram/ThirdParty/libtgvoip/threading.h b/Telegram/ThirdParty/libtgvoip/threading.h
index 9dc2554..52a09ff 100755
--- a/Telegram/ThirdParty/libtgvoip/threading.h
+++ b/Telegram/ThirdParty/libtgvoip/threading.h
@@ -107,7 +107,9 @@ namespace tgvoip{
 		std::function<void()> entry;
 		pthread_t thread;
 		const char* name;
+#ifdef __APPLE__
 		bool maxPriority=false;
+#endif
 		bool valid=false;
 	};
 }
diff --git a/Telegram/build/build.bat b/Telegram/build/build.bat
index 88b5c4e92..1c0959e5e 100644
--- a/Telegram/build/build.bat
+++ b/Telegram/build/build.bat
@@ -48,11 +48,11 @@ echo.
 
 set "HomePath=%FullScriptPath%.."
 set "ResourcesPath=%HomePath%\Resources"
-set "SolutionPath=%HomePath%\.."
+set "SolutionPath=%HomePath%\..\out"
 set "UpdateFile=tupdate%AppVersion%"
 set "SetupFile=tsetup.%AppVersionStrFull%.exe"
 set "PortableFile=tportable.%AppVersionStrFull%.zip"
-set "ReleasePath=%HomePath%\..\out\Release"
+set "ReleasePath=%SolutionPath%\Release"
 set "DeployPath=%ReleasePath%\deploy\%AppVersionStrMajor%\%AppVersionStrFull%"
 set "SignPath=%HomePath%\..\..\DesktopPrivate\Sign.bat"
 set "BinaryName=Telegram"
@@ -105,26 +105,24 @@ if %AlphaVersion% neq 0 (
 
 cd "%HomePath%"
 
-call gyp\refresh.bat
+call configure.bat
 if %errorlevel% neq 0 goto error
 
 cd "%SolutionPath%"
-call ninja -C out/Release Telegram
+call cmake --build . --config Release --target Telegram
 if %errorlevel% neq 0 goto error
 
 echo.
 echo Version %AppVersionStrFull% build successfull. Preparing..
 echo.
 
-if not exist "%SolutionPath%\..\Libraries\breakpad\src\tools\windows\dump_syms\Release\dump_syms.exe" (
+if not exist "%SolutionPath%\..\..\Libraries\breakpad\src\tools\windows\dump_syms\Release\dump_syms.exe" (
   echo Utility dump_syms not found!
   exit /b 1
 )
 
 echo Dumping debug symbols..
-xcopy "%ReleasePath%\%BinaryName%.exe" "%ReleasePath%\%BinaryName%.exe.exe*"
-call "%SolutionPath%\..\Libraries\breakpad\src\tools\windows\dump_syms\Release\dump_syms.exe" "%ReleasePath%\%BinaryName%.exe.pdb" > "%ReleasePath%\%BinaryName%.exe.sym"
-del "%ReleasePath%\%BinaryName%.exe.exe"
+call "%SolutionPath%\..\..\Libraries\breakpad\src\tools\windows\dump_syms\Release\dump_syms.exe" "%ReleasePath%\%BinaryName%.pdb" > "%ReleasePath%\%BinaryName%.sym"
 echo Done!
 
 set "PATH=%PATH%;C:\Program Files\7-Zip;C:\Program Files (x86)\Inno Setup 5"
@@ -179,17 +177,17 @@ if %BuildUWP% equ 0 (
 
 for /f ^"usebackq^ eol^=^
 
-^ delims^=^" %%a in (%ReleasePath%\%BinaryName%.exe.sym) do (
+^ delims^=^" %%a in (%ReleasePath%\%BinaryName%.sym) do (
   set "SymbolsHashLine=%%a"
   goto symbolslinedone
 )
 :symbolslinedone
 FOR /F "tokens=1,2,3,4* delims= " %%i in ("%SymbolsHashLine%") do set "SymbolsHash=%%l"
 
-echo Copying %BinaryName%.exe.sym to %DropboxSymbolsPath%\%BinaryName%.exe.pdb\%SymbolsHash%
-if not exist %DropboxSymbolsPath%\%BinaryName%.exe.pdb mkdir %DropboxSymbolsPath%\%BinaryName%.exe.pdb
-if not exist %DropboxSymbolsPath%\%BinaryName%.exe.pdb\%SymbolsHash% mkdir %DropboxSymbolsPath%\%BinaryName%.exe.pdb\%SymbolsHash%
-move "%ReleasePath%\%BinaryName%.exe.sym" %DropboxSymbolsPath%\%BinaryName%.exe.pdb\%SymbolsHash%\
+echo Copying %BinaryName%.sym to %DropboxSymbolsPath%\%BinaryName%.pdb\%SymbolsHash%
+if not exist %DropboxSymbolsPath%\%BinaryName%.pdb mkdir %DropboxSymbolsPath%\%BinaryName%.pdb
+if not exist %DropboxSymbolsPath%\%BinaryName%.pdb\%SymbolsHash% mkdir %DropboxSymbolsPath%\%BinaryName%.pdb\%SymbolsHash%
+move "%ReleasePath%\%BinaryName%.sym" %DropboxSymbolsPath%\%BinaryName%.pdb\%SymbolsHash%\
 echo Done!
 
 if %BuildUWP% neq 0 (
@@ -225,8 +223,7 @@ if %BuildUWP% neq 0 (
   if not exist "%ReleasePath%\deploy\%AppVersionStrMajor%" mkdir "%ReleasePath%\deploy\%AppVersionStrMajor%"
   mkdir "%DeployPath%"
 
-  xcopy "%ReleasePath%\%BinaryName%.pdb" "%DeployPath%\"
-  move "%ReleasePath%\%BinaryName%.exe.pdb" "%DeployPath%\"
+  move "%ReleasePath%\%BinaryName%.pdb" "%DeployPath%\"
   move "%ReleasePath%\%BinaryName%.x86.appx" "%DeployPath%\"
   move "%ReleasePath%\%BinaryName%.x64.appx" "%DeployPath%\"
   move "%ReleasePath%\%BinaryName%.exe" "%DeployPath%\"
@@ -246,10 +243,8 @@ if %BuildUWP% neq 0 (
 
   move "%ReleasePath%\%BinaryName%.exe" "%DeployPath%\%BinaryName%\"
   move "%ReleasePath%\Updater.exe" "%DeployPath%\"
-  xcopy "%ReleasePath%\%BinaryName%.pdb" "%DeployPath%\"
-  xcopy "%ReleasePath%\Updater.pdb" "%DeployPath%\"
-  move "%ReleasePath%\%BinaryName%.exe.pdb" "%DeployPath%\"
-  move "%ReleasePath%\Updater.exe.pdb" "%DeployPath%\"
+  move "%ReleasePath%\%BinaryName%.pdb" "%DeployPath%\"
+  move "%ReleasePath%\Updater.pdb" "%DeployPath%\"
   if %AlphaVersion% equ 0 (
     move "%ReleasePath%\%SetupFile%" "%DeployPath%\"
   ) else (
@@ -280,10 +275,8 @@ if %BuildUWP% equ 0 (
     if not exist "%DeployPath%\%SetupFile%" goto error
   )
   if not exist "%DeployPath%\%BinaryName%.pdb" goto error
-  if not exist "%DeployPath%\%BinaryName%.exe.pdb" goto error
   if not exist "%DeployPath%\Updater.exe" goto error
   if not exist "%DeployPath%\Updater.pdb" goto error
-  if not exist "%DeployPath%\Updater.exe.pdb" goto error
   md "%FinalDeployPath%"
 
   xcopy "%DeployPath%\%UpdateFile%" "%FinalDeployPath%\" /Y
diff --git a/Telegram/build/build.sh b/Telegram/build/build.sh
index 325d473b2..da5439714 100755
--- a/Telegram/build/build.sh
+++ b/Telegram/build/build.sh
@@ -52,13 +52,15 @@ if [ "$BuildTarget" == "linux" ]; then
   echo "Building version $AppVersionStrFull for Linux 64bit.."
   UpdateFile="tlinuxupd$AppVersion"
   SetupFile="tsetup.$AppVersionStrFull.tar.xz"
-  ReleasePath="$HomePath/../out/Release"
+  ProjectPath="$HomePath/../out"
+  ReleasePath="$ProjectPath/Release"
   BinaryName="Telegram"
 elif [ "$BuildTarget" == "linux32" ]; then
   echo "Building version $AppVersionStrFull for Linux 32bit.."
   UpdateFile="tlinux32upd$AppVersion"
   SetupFile="tsetup32.$AppVersionStrFull.tar.xz"
-  ReleasePath="$HomePath/../out/Release"
+  ProjectPath="$HomePath/../out"
+  ReleasePath="$ProjectPath/Release"
   BinaryName="Telegram"
 elif [ "$BuildTarget" == "mac" ]; then
   echo "Building version $AppVersionStrFull for macOS 10.12+.."
@@ -67,13 +69,15 @@ elif [ "$BuildTarget" == "mac" ]; then
   fi
   UpdateFile="tmacupd$AppVersion"
   SetupFile="tsetup.$AppVersionStrFull.dmg"
-  ReleasePath="$HomePath/../out/Release"
+  ProjectPath="$HomePath/../out"
+  ReleasePath="$ProjectPath/Release"
   BinaryName="Telegram"
 elif [ "$BuildTarget" == "osx" ]; then
   echo "Building version $AppVersionStrFull for OS X 10.10 and 10.11.."
   UpdateFile="tosxupd$AppVersion"
   SetupFile="tsetup-osx.$AppVersionStrFull.dmg"
-  ReleasePath="$HomePath/../out/Release"
+  ProjectPath="$HomePath/../out"
+  ReleasePath="$ProjectPath/Release"
   BinaryName="Telegram"
 elif [ "$BuildTarget" == "macstore" ]; then
   if [ "$AlphaVersion" != "0" ]; then
@@ -81,7 +85,8 @@ elif [ "$BuildTarget" == "macstore" ]; then
   fi
 
   echo "Building version $AppVersionStrFull for Mac App Store.."
-  ReleasePath="$HomePath/../out/Release"
+  ProjectPath="$HomePath/../out"
+  ReleasePath="$ProjectPath/Release"
   BinaryName="Telegram Desktop"
 else
   Error "Invalid target!"
@@ -123,10 +128,12 @@ if [ "$BuildTarget" == "linux" ] || [ "$BuildTarget" == "linux32" ]; then
     Error "Backup folder not found!"
   fi
 
-  gyp/refresh.sh
+  ./configure.sh
 
+  cd $ProjectPath
+  cmake --build . --config Release --target Telegram -- -j8
   cd $ReleasePath
-  make -j4
+
   echo "$BinaryName build complete!"
 
   if [ ! -f "$ReleasePath/$BinaryName" ]; then
@@ -253,8 +260,11 @@ if [ "$BuildTarget" == "mac" ] || [ "$BuildTarget" == "osx" ] || [ "$BuildTarget
     Error "Backup path not found!"
   fi
 
-  gyp/refresh.sh
-  xcodebuild -project Telegram.xcodeproj -alltargets -configuration Release build
+  ./configure.sh
+
+  cd $ProjectPath
+  cmake --build . --config Release --target Telegram
+  cd $ReleasePath
 
   if [ ! -d "$ReleasePath/$BinaryName.app" ]; then
     Error "$BinaryName.app not found!"
diff --git a/Telegram/build/set_version.py b/Telegram/build/set_version.py
index 7a1039ad6..ec503b8bc 100644
--- a/Telegram/build/set_version.py
+++ b/Telegram/build/set_version.py
@@ -20,6 +20,7 @@ executePath = os.getcwd()
 scriptPath = os.path.dirname(os.path.realpath(__file__))
 
 inputVersion = ''
+versionOriginal = ''
 versionMajor = ''
 versionMinor = ''
 versionPatch = ''
@@ -29,6 +30,7 @@ for arg in sys.argv:
   match = re.match(r'^\s*(\d+)\.(\d+)(\.(\d+)(\.(\d+|beta))?)?\s*$', arg)
   if match:
     inputVersion = arg
+    versionOriginal = inputVersion
     versionMajor = match.group(1)
     versionMinor = match.group(2)
     versionPatch = match.group(4) if match.group(4) else '0'
@@ -117,6 +119,7 @@ replaceInFile(scriptPath + '/version', [
   [ r'(AppVersionStr\s+)\d[\d\.]*', r'\g<1>' + versionStr ],
   [ r'(BetaChannel\s+)\d', r'\g<1>' + ('1' if versionBeta else '0') ],
   [ r'(AlphaVersion\s+)\d+', r'\g<1>' + versionFullAlpha ],
+  [ r'(AppVersionOriginal\s+)\d[\d\.beta]*', r'\g<1>' + versionOriginal ],
 ])
 
 print('Patching core/version.h...')
diff --git a/Telegram/build/updates.py b/Telegram/build/updates.py
index 8ffd5e96b..e0f0db828 100644
--- a/Telegram/build/updates.py
+++ b/Telegram/build/updates.py
@@ -46,20 +46,21 @@ outputFolder = 'updates/' + today
 archive = 'tdesktop_macOS_' + today + '.zip'
 
 if building:
-    print('Building debug version for OS X 10.8+..')
+    print('Building debug version for OS X 10.12+..')
 
     if os.path.exists('../out/Debug/' + outputFolder):
         finish(1, 'Todays updates version exists.')
 
-    result = subprocess.call('gyp/refresh.sh', shell=True)
+    result = subprocess.call('./configure.sh', shell=True)
     if result != 0:
         finish(1, 'While calling GYP.')
 
-    result = subprocess.call('xcodebuild -project Telegram.xcodeproj -alltargets -configuration Debug build', shell=True)
+    os.chdir('../out')
+    result = subprocess.call('cmake --build . --config Debug --target Telegram', shell=True)
     if result != 0:
         finish(1, 'While building Telegram.')
 
-    os.chdir('../out/Debug')
+    os.chdir('Debug')
     if not os.path.exists('Telegram.app'):
         finish(1, 'Telegram.app not found.')
 
diff --git a/Telegram/build/version b/Telegram/build/version
index d4f9f3413..6c96cfb80 100644
--- a/Telegram/build/version
+++ b/Telegram/build/version
@@ -1,6 +1,7 @@
-AppVersion         1009001
+AppVersion         1009003
 AppVersionStrMajor 1.9
-AppVersionStrSmall 1.9.1
-AppVersionStr      1.9.1
-BetaChannel        1
+AppVersionStrSmall 1.9.3
+AppVersionStr      1.9.3
+BetaChannel        0
 AlphaVersion       0
+AppVersionOriginal 1.9.3
diff --git a/Telegram/cmake/generate_lang.cmake b/Telegram/cmake/generate_lang.cmake
new file mode 100644
index 000000000..0a13cd311
--- /dev/null
+++ b/Telegram/cmake/generate_lang.cmake
@@ -0,0 +1,32 @@
+# This file is part of Telegram Desktop,
+# the official desktop application for the Telegram messaging service.
+#
+# For license and copyright information please follow this link:
+# https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+
+function(generate_lang target_name lang_file)
+    set(gen_dst ${CMAKE_CURRENT_BINARY_DIR}/gen)
+    file(MAKE_DIRECTORY ${gen_dst})
+
+    set(gen_timestamp ${gen_dst}/lang_auto.timestamp)
+    set(gen_files
+        ${gen_dst}/lang_auto.cpp
+        ${gen_dst}/lang_auto.h
+    )
+
+    add_custom_command(
+    OUTPUT
+        ${gen_timestamp}
+    BYPRODUCTS
+        ${gen_files}
+    COMMAND
+        codegen_lang
+        -o${gen_dst}
+        ${lang_file}
+    COMMENT "Generating lang (${target_name})"
+    DEPENDS
+        codegen_lang
+        ${lang_file}
+    )
+    generate_target(${target_name} lang ${gen_timestamp} "${gen_files}" ${gen_dst})
+endfunction()
diff --git a/Telegram/cmake/generate_numbers.cmake b/Telegram/cmake/generate_numbers.cmake
new file mode 100644
index 000000000..d6028880c
--- /dev/null
+++ b/Telegram/cmake/generate_numbers.cmake
@@ -0,0 +1,32 @@
+# This file is part of Telegram Desktop,
+# the official desktop application for the Telegram messaging service.
+#
+# For license and copyright information please follow this link:
+# https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+
+function(generate_numbers target_name numbers_file)
+    set(gen_dst ${CMAKE_CURRENT_BINARY_DIR}/gen)
+    file(MAKE_DIRECTORY ${gen_dst})
+
+    set(gen_timestamp ${gen_dst}/numbers.timestamp)
+    set(gen_files
+        ${gen_dst}/numbers.cpp
+        ${gen_dst}/numbers.h
+    )
+
+    add_custom_command(
+    OUTPUT
+        ${gen_timestamp}
+    BYPRODUCTS
+        ${gen_files}
+    COMMAND
+        codegen_numbers
+        -o${gen_dst}
+        ${numbers_file}
+    COMMENT "Generating numbers (${target_name})"
+    DEPENDS
+        codegen_numbers
+        ${numbers_file}
+    )
+    generate_target(${target_name} numbers ${gen_timestamp} "${gen_files}" ${gen_dst})
+endfunction()
diff --git a/Telegram/cmake/generate_scheme.cmake b/Telegram/cmake/generate_scheme.cmake
new file mode 100644
index 000000000..75d3995e2
--- /dev/null
+++ b/Telegram/cmake/generate_scheme.cmake
@@ -0,0 +1,36 @@
+# This file is part of Telegram Desktop,
+# the official desktop application for the Telegram messaging service.
+#
+# For license and copyright information please follow this link:
+# https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+
+function(generate_scheme target_name script scheme_files)
+    set(gen_dst ${CMAKE_CURRENT_BINARY_DIR}/gen)
+    file(MAKE_DIRECTORY ${gen_dst})
+
+    set(gen_timestamp ${gen_dst}/scheme.timestamp)
+    set(gen_files
+        ${gen_dst}/scheme.cpp
+        ${gen_dst}/scheme.h
+        ${gen_dst}/scheme-dump_to_text.cpp
+        ${gen_dst}/scheme-dump_to_text.h
+    )
+
+    add_custom_command(
+    OUTPUT
+        ${gen_timestamp}
+    BYPRODUCTS
+        ${gen_files}
+    COMMAND
+        python
+        ${script}
+        -o${gen_dst}/scheme
+        ${scheme_files}
+    COMMENT "Generating scheme (${target_name})"
+    DEPENDS
+        ${script}
+        ${submodules_loc}/lib_tl/tl/generate_tl.py
+        ${scheme_files}
+    )
+    generate_target(${target_name} scheme ${gen_timestamp} "${gen_files}" ${gen_dst})
+endfunction()
diff --git a/Telegram/cmake/lib_export.cmake b/Telegram/cmake/lib_export.cmake
new file mode 100644
index 000000000..ef312a0a5
--- /dev/null
+++ b/Telegram/cmake/lib_export.cmake
@@ -0,0 +1,46 @@
+# This file is part of Telegram Desktop,
+# the official desktop application for the Telegram messaging service.
+#
+# For license and copyright information please follow this link:
+# https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+
+add_library(lib_export OBJECT)
+init_target(lib_export)
+add_library(tdesktop::lib_export ALIAS lib_export)
+
+target_precompile_headers(lib_export PRIVATE ${src_loc}/export/export_pch.h)
+nice_target_sources(lib_export ${src_loc}
+PRIVATE
+    export/export_api_wrap.cpp
+    export/export_api_wrap.h
+    export/export_controller.cpp
+    export/export_controller.h
+    export/export_settings.cpp
+    export/export_settings.h
+    export/data/export_data_types.cpp
+    export/data/export_data_types.h
+    export/output/export_output_abstract.cpp
+    export/output/export_output_abstract.h
+    export/output/export_output_file.cpp
+    export/output/export_output_file.h
+    export/output/export_output_html.cpp
+    export/output/export_output_html.h
+    export/output/export_output_json.cpp
+    export/output/export_output_json.h
+    export/output/export_output_result.h
+    export/output/export_output_stats.cpp
+    export/output/export_output_stats.h
+    export/output/export_output_text.cpp
+    export/output/export_output_text.h
+)
+
+target_include_directories(lib_export
+PUBLIC
+    ${src_loc}
+)
+
+target_link_libraries(lib_export
+PUBLIC
+    desktop-app::lib_base
+    tdesktop::lib_scheme
+)
diff --git a/Telegram/cmake/lib_ffmpeg.cmake b/Telegram/cmake/lib_ffmpeg.cmake
new file mode 100644
index 000000000..a9985392e
--- /dev/null
+++ b/Telegram/cmake/lib_ffmpeg.cmake
@@ -0,0 +1,30 @@
+# This file is part of Telegram Desktop,
+# the official desktop application for the Telegram messaging service.
+#
+# For license and copyright information please follow this link:
+# https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+
+add_library(lib_ffmpeg OBJECT)
+add_library(desktop-app::lib_ffmpeg ALIAS lib_ffmpeg)
+init_target(lib_ffmpeg)
+
+nice_target_sources(lib_ffmpeg ${src_loc}
+PRIVATE
+    ffmpeg/ffmpeg_utility.cpp
+    ffmpeg/ffmpeg_utility.h
+)
+
+target_include_directories(lib_ffmpeg
+PUBLIC
+    ${src_loc}
+)
+
+target_link_libraries(lib_ffmpeg
+PUBLIC
+    desktop-app::lib_base
+    desktop-app::external_ffmpeg
+)
+
+if (DESKTOP_APP_SPECIAL_TARGET)
+    target_compile_definitions(lib_ffmpeg PRIVATE LIB_FFMPEG_USE_QT_PRIVATE_API)
+endif()
diff --git a/Telegram/cmake/lib_mtproto.cmake b/Telegram/cmake/lib_mtproto.cmake
new file mode 100644
index 000000000..491be6ba0
--- /dev/null
+++ b/Telegram/cmake/lib_mtproto.cmake
@@ -0,0 +1,68 @@
+# This file is part of Telegram Desktop,
+# the official desktop application for the Telegram messaging service.
+#
+# For license and copyright information please follow this link:
+# https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+
+add_library(lib_mtproto OBJECT)
+init_target(lib_mtproto)
+add_library(tdesktop::lib_mtproto ALIAS lib_mtproto)
+
+target_precompile_headers(lib_mtproto PRIVATE ${src_loc}/stdafx.h)
+target_precompile_headers(lib_mtproto PRIVATE ${src_loc}/mtproto/mtproto_pch.h)
+nice_target_sources(lib_mtproto ${src_loc}
+PRIVATE
+    mtproto/details/mtproto_abstract_socket.cpp
+    mtproto/details/mtproto_abstract_socket.h
+    mtproto/details/mtproto_bound_key_creator.cpp
+    mtproto/details/mtproto_bound_key_creator.h
+    mtproto/details/mtproto_dc_key_binder.cpp
+    mtproto/details/mtproto_dc_key_binder.h
+    mtproto/details/mtproto_dc_key_creator.cpp
+    mtproto/details/mtproto_dc_key_creator.h
+    mtproto/details/mtproto_dcenter.cpp
+    mtproto/details/mtproto_dcenter.h
+    mtproto/details/mtproto_domain_resolver.cpp
+    mtproto/details/mtproto_domain_resolver.h
+    mtproto/details/mtproto_dump_to_text.cpp
+    mtproto/details/mtproto_dump_to_text.h
+    mtproto/details/mtproto_received_ids_manager.cpp
+    mtproto/details/mtproto_received_ids_manager.h
+    mtproto/details/mtproto_rsa_public_key.cpp
+    mtproto/details/mtproto_rsa_public_key.h
+    mtproto/details/mtproto_serialized_request.cpp
+    mtproto/details/mtproto_serialized_request.h
+    mtproto/details/mtproto_tcp_socket.cpp
+    mtproto/details/mtproto_tcp_socket.h
+    mtproto/details/mtproto_tls_socket.cpp
+    mtproto/details/mtproto_tls_socket.h
+    mtproto/mtproto_auth_key.cpp
+    mtproto/mtproto_auth_key.h
+    mtproto/mtproto_concurrent_sender.cpp
+    mtproto/mtproto_concurrent_sender.h
+    mtproto/mtproto_dh_utils.cpp
+    mtproto/mtproto_dh_utils.h
+    mtproto/mtproto_proxy_data.cpp
+    mtproto/mtproto_proxy_data.h
+    mtproto/mtproto_rpc_sender.cpp
+    mtproto/mtproto_rpc_sender.h
+)
+
+target_include_directories(lib_mtproto
+PUBLIC
+    ${src_loc}
+)
+
+target_link_libraries(lib_mtproto
+PUBLIC
+    tdesktop::lib_scheme
+PRIVATE
+    desktop-app::lib_ui
+    desktop-app::external_zlib
+)
+
+target_compile_definitions(lib_mtproto
+PRIVATE
+    TDESKTOP_API_ID=${TDESKTOP_API_ID}
+    TDESKTOP_API_HASH=${TDESKTOP_API_HASH}
+)
diff --git a/Telegram/cmake/lib_scheme.cmake b/Telegram/cmake/lib_scheme.cmake
new file mode 100644
index 000000000..81777adf4
--- /dev/null
+++ b/Telegram/cmake/lib_scheme.cmake
@@ -0,0 +1,35 @@
+# This file is part of Telegram Desktop,
+# the official desktop application for the Telegram messaging service.
+#
+# For license and copyright information please follow this link:
+# https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+
+add_library(lib_scheme OBJECT)
+init_target(lib_scheme)
+add_library(tdesktop::lib_scheme ALIAS lib_scheme)
+
+include(cmake/generate_scheme.cmake)
+
+set(scheme_files
+    ${res_loc}/tl/mtproto.tl
+    ${res_loc}/tl/api.tl
+)
+
+generate_scheme(lib_scheme ${src_loc}/codegen/scheme/codegen_scheme.py "${scheme_files}")
+
+nice_target_sources(lib_scheme ${res_loc}
+PRIVATE
+    tl/mtproto.tl
+    tl/api.tl
+)
+
+target_include_directories(lib_scheme
+PUBLIC
+    ${src_loc}
+)
+
+target_link_libraries(lib_scheme
+PUBLIC
+    desktop-app::lib_base
+    desktop-app::lib_tl
+)
diff --git a/Telegram/cmake/lib_tgvoip.cmake b/Telegram/cmake/lib_tgvoip.cmake
new file mode 100644
index 000000000..38fa632a4
--- /dev/null
+++ b/Telegram/cmake/lib_tgvoip.cmake
@@ -0,0 +1,784 @@
+# This file is part of Telegram Desktop,
+# the official desktop application for the Telegram messaging service.
+#
+# For license and copyright information please follow this link:
+# https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+
+add_library(lib_tgvoip STATIC)
+init_target(lib_tgvoip cxx_std_11)
+add_library(tdesktop::lib_tgvoip ALIAS lib_tgvoip)
+
+if (NOT APPLE)
+    # On macOS if you build libtgvoip with C++17 it uses std::optional
+    # instead of absl::optional and when it uses optional::value, the
+    # build fails, because optional::value is available starting with
+    # macOS 10.14+. This way we force using absl::optional.
+    target_compile_features(lib_tgvoip PUBLIC cxx_std_17)
+endif()
+
+set(tgvoip_loc ${third_party_loc}/libtgvoip)
+
+nice_target_sources(lib_tgvoip ${tgvoip_loc}
+PRIVATE
+    BlockingQueue.cpp
+    BlockingQueue.h
+    Buffers.cpp
+    Buffers.h
+    CongestionControl.cpp
+    CongestionControl.h
+    EchoCanceller.cpp
+    EchoCanceller.h
+    JitterBuffer.cpp
+    JitterBuffer.h
+    logging.cpp
+    logging.h
+    MediaStreamItf.cpp
+    MediaStreamItf.h
+    OpusDecoder.cpp
+    OpusDecoder.h
+    OpusEncoder.cpp
+    OpusEncoder.h
+    threading.h
+    VoIPController.cpp
+    VoIPGroupController.cpp
+    VoIPController.h
+    PrivateDefines.h
+    VoIPServerConfig.cpp
+    VoIPServerConfig.h
+    audio/AudioInput.cpp
+    audio/AudioInput.h
+    audio/AudioOutput.cpp
+    audio/AudioOutput.h
+    audio/Resampler.cpp
+    audio/Resampler.h
+    NetworkSocket.cpp
+    NetworkSocket.h
+    PacketReassembler.cpp
+    PacketReassembler.h
+    MessageThread.cpp
+    MessageThread.h
+    audio/AudioIO.cpp
+    audio/AudioIO.h
+    video/ScreamCongestionController.cpp
+    video/ScreamCongestionController.h
+    video/VideoSource.cpp
+    video/VideoSource.h
+    video/VideoRenderer.cpp
+    video/VideoRenderer.h
+    json11.cpp
+    json11.hpp
+
+    # Windows
+    os/windows/NetworkSocketWinsock.cpp
+    os/windows/NetworkSocketWinsock.h
+    os/windows/AudioInputWave.cpp
+    os/windows/AudioInputWave.h
+    os/windows/AudioOutputWave.cpp
+    os/windows/AudioOutputWave.h
+    os/windows/AudioOutputWASAPI.cpp
+    os/windows/AudioOutputWASAPI.h
+    os/windows/AudioInputWASAPI.cpp
+    os/windows/AudioInputWASAPI.h
+    os/windows/WindowsSpecific.cpp
+    os/windows/WindowsSpecific.h
+
+    # macOS
+    os/darwin/AudioInputAudioUnit.cpp
+    os/darwin/AudioInputAudioUnit.h
+    os/darwin/AudioOutputAudioUnit.cpp
+    os/darwin/AudioOutputAudioUnit.h
+    os/darwin/AudioInputAudioUnitOSX.cpp
+    os/darwin/AudioInputAudioUnitOSX.h
+    os/darwin/AudioOutputAudioUnitOSX.cpp
+    os/darwin/AudioOutputAudioUnitOSX.h
+    os/darwin/AudioUnitIO.cpp
+    os/darwin/AudioUnitIO.h
+    os/darwin/DarwinSpecific.mm
+    os/darwin/DarwinSpecific.h
+
+    # Linux
+    os/linux/AudioInputALSA.cpp
+    os/linux/AudioInputALSA.h
+    os/linux/AudioOutputALSA.cpp
+    os/linux/AudioOutputALSA.h
+    os/linux/AudioOutputPulse.cpp
+    os/linux/AudioOutputPulse.h
+    os/linux/AudioInputPulse.cpp
+    os/linux/AudioInputPulse.h
+    os/linux/AudioPulse.cpp
+    os/linux/AudioPulse.h
+
+    # POSIX
+    os/posix/NetworkSocketPosix.cpp
+    os/posix/NetworkSocketPosix.h
+
+    # WebRTC APM
+    webrtc_dsp/system_wrappers/include/field_trial.h
+    webrtc_dsp/system_wrappers/include/cpu_features_wrapper.h
+    webrtc_dsp/system_wrappers/include/asm_defines.h
+    webrtc_dsp/system_wrappers/include/metrics.h
+    webrtc_dsp/system_wrappers/include/compile_assert_c.h
+    webrtc_dsp/system_wrappers/source/field_trial.cc
+    webrtc_dsp/system_wrappers/source/metrics.cc
+    webrtc_dsp/system_wrappers/source/cpu_features.cc
+    webrtc_dsp/typedefs.h
+    webrtc_dsp/absl/strings/internal/memutil.h
+    webrtc_dsp/absl/strings/internal/memutil.cc
+    webrtc_dsp/absl/strings/string_view.cc
+    webrtc_dsp/absl/strings/ascii.h
+    webrtc_dsp/absl/strings/ascii.cc
+    webrtc_dsp/absl/strings/string_view.h
+    webrtc_dsp/absl/types/optional.h
+    webrtc_dsp/absl/types/bad_optional_access.h
+    webrtc_dsp/absl/types/bad_optional_access.cc
+    webrtc_dsp/absl/types/optional.cc
+    webrtc_dsp/absl/memory/memory.h
+    webrtc_dsp/absl/meta/type_traits.h
+    webrtc_dsp/absl/algorithm/algorithm.h
+    webrtc_dsp/absl/container/inlined_vector.h
+    webrtc_dsp/absl/base/policy_checks.h
+    webrtc_dsp/absl/base/port.h
+    webrtc_dsp/absl/base/config.h
+    webrtc_dsp/absl/base/internal/raw_logging.cc
+    webrtc_dsp/absl/base/internal/throw_delegate.cc
+    webrtc_dsp/absl/base/internal/invoke.h
+    webrtc_dsp/absl/base/internal/inline_variable.h
+    webrtc_dsp/absl/base/internal/atomic_hook.h
+    webrtc_dsp/absl/base/internal/identity.h
+    webrtc_dsp/absl/base/internal/raw_logging.h
+    webrtc_dsp/absl/base/internal/throw_delegate.h
+    webrtc_dsp/absl/base/attributes.h
+    webrtc_dsp/absl/base/macros.h
+    webrtc_dsp/absl/base/optimization.h
+    webrtc_dsp/absl/base/log_severity.h
+    webrtc_dsp/absl/utility/utility.h
+    webrtc_dsp/rtc_base/string_to_number.h
+    webrtc_dsp/rtc_base/constructormagic.h
+    webrtc_dsp/rtc_base/race_checker.cc
+    webrtc_dsp/rtc_base/strings/string_builder.h
+    webrtc_dsp/rtc_base/strings/string_builder.cc
+    webrtc_dsp/rtc_base/event_tracer.h
+    webrtc_dsp/rtc_base/stringencode.h
+    webrtc_dsp/rtc_base/memory/aligned_malloc.cc
+    webrtc_dsp/rtc_base/memory/aligned_malloc.h
+    webrtc_dsp/rtc_base/timeutils.cc
+    webrtc_dsp/rtc_base/event.h
+    webrtc_dsp/rtc_base/ignore_wundef.h
+    webrtc_dsp/rtc_base/stringutils.h
+    webrtc_dsp/rtc_base/arraysize.h
+    webrtc_dsp/rtc_base/platform_file.cc
+    webrtc_dsp/rtc_base/swap_queue.h
+    webrtc_dsp/rtc_base/string_to_number.cc
+    webrtc_dsp/rtc_base/trace_event.h
+    webrtc_dsp/rtc_base/checks.h
+    webrtc_dsp/rtc_base/deprecation.h
+    webrtc_dsp/rtc_base/thread_checker_impl.cc
+    webrtc_dsp/rtc_base/sanitizer.h
+    webrtc_dsp/rtc_base/scoped_ref_ptr.h
+    webrtc_dsp/rtc_base/logging.h
+    webrtc_dsp/rtc_base/logging_mac.h
+    webrtc_dsp/rtc_base/logging_mac.mm
+    webrtc_dsp/rtc_base/timeutils.h
+    webrtc_dsp/rtc_base/atomicops.h
+    webrtc_dsp/rtc_base/stringencode.cc
+    webrtc_dsp/rtc_base/stringutils.cc
+    webrtc_dsp/rtc_base/checks.cc
+    webrtc_dsp/rtc_base/numerics/safe_minmax.h
+    webrtc_dsp/rtc_base/numerics/safe_conversions.h
+    webrtc_dsp/rtc_base/numerics/safe_conversions_impl.h
+    webrtc_dsp/rtc_base/numerics/safe_compare.h
+    webrtc_dsp/rtc_base/system/unused.h
+    webrtc_dsp/rtc_base/system/inline.h
+    webrtc_dsp/rtc_base/system/ignore_warnings.h
+    webrtc_dsp/rtc_base/system/asm_defines.h
+    webrtc_dsp/rtc_base/system/rtc_export.h
+    webrtc_dsp/rtc_base/system/arch.h
+    webrtc_dsp/rtc_base/platform_thread.cc
+    webrtc_dsp/rtc_base/platform_thread.h
+    webrtc_dsp/rtc_base/platform_thread_types.h
+    webrtc_dsp/rtc_base/protobuf_utils.h
+    webrtc_dsp/rtc_base/thread_annotations.h
+    webrtc_dsp/rtc_base/gtest_prod_util.h
+    webrtc_dsp/rtc_base/function_view.h
+    webrtc_dsp/rtc_base/criticalsection.h
+    webrtc_dsp/rtc_base/criticalsection.cc
+    webrtc_dsp/rtc_base/platform_thread_types.cc
+    webrtc_dsp/rtc_base/refcount.h
+    webrtc_dsp/rtc_base/event.cc
+    webrtc_dsp/rtc_base/thread_checker_impl.h
+    webrtc_dsp/rtc_base/event_tracer.cc
+    webrtc_dsp/rtc_base/compile_assert_c.h
+    webrtc_dsp/rtc_base/logging_webrtc.cc
+    webrtc_dsp/rtc_base/type_traits.h
+    webrtc_dsp/rtc_base/platform_file.h
+    webrtc_dsp/rtc_base/refcounter.h
+    webrtc_dsp/rtc_base/logging_mac.h
+    webrtc_dsp/rtc_base/thread_checker.h
+    webrtc_dsp/rtc_base/race_checker.h
+    webrtc_dsp/rtc_base/refcountedobject.h
+    webrtc_dsp/third_party/rnnoise/src/rnn_vad_weights.cc
+    webrtc_dsp/third_party/rnnoise/src/rnn_activations.h
+    webrtc_dsp/third_party/rnnoise/src/kiss_fft.h
+    webrtc_dsp/third_party/rnnoise/src/kiss_fft.cc
+    webrtc_dsp/third_party/rnnoise/src/rnn_vad_weights.h
+    webrtc_dsp/api/audio/audio_frame.cc
+    webrtc_dsp/api/audio/echo_canceller3_config.h
+    webrtc_dsp/api/audio/echo_control.h
+    webrtc_dsp/api/audio/audio_frame.h
+    webrtc_dsp/api/audio/echo_canceller3_config.cc
+    webrtc_dsp/api/audio/echo_canceller3_factory.h
+    webrtc_dsp/api/audio/echo_canceller3_factory.cc
+    webrtc_dsp/api/array_view.h
+    webrtc_dsp/modules/third_party/fft/fft.h
+    webrtc_dsp/modules/third_party/fft/fft.c
+    webrtc_dsp/modules/audio_coding/codecs/isac/bandwidth_info.h
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/include/isac.h
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/pitch_estimator.c
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/lpc_shape_swb16_tables.c
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/pitch_gain_tables.c
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/arith_routines_logist.c
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/os_specific_inline.h
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/filterbanks.c
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/entropy_coding.h
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/isac_vad.h
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/settings.h
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/transform.c
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/lpc_shape_swb12_tables.h
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/arith_routines.h
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/crc.h
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/pitch_filter.c
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/encode_lpc_swb.c
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/filter_functions.c
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/decode.c
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/lattice.c
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/intialize.c
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/lpc_tables.c
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/lpc_gain_swb_tables.c
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/bandwidth_estimator.c
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/isac_float_type.h
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/pitch_lag_tables.h
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/encode.c
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/lpc_analysis.c
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/spectrum_ar_model_tables.h
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/arith_routines_hist.c
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/codec.h
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/pitch_gain_tables.h
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/lpc_shape_swb16_tables.h
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/pitch_estimator.h
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/entropy_coding.c
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/isac_vad.c
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/structs.h
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/filter_functions.h
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/encode_lpc_swb.h
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/pitch_filter.h
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/arith_routines.c
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/crc.c
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/lpc_shape_swb12_tables.c
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/lpc_analysis.h
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/decode_bwe.c
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/spectrum_ar_model_tables.c
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/bandwidth_estimator.h
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/pitch_lag_tables.c
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/isac.c
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/lpc_gain_swb_tables.h
+    webrtc_dsp/modules/audio_coding/codecs/isac/main/source/lpc_tables.h
+    webrtc_dsp/modules/audio_processing/rms_level.cc
+    webrtc_dsp/modules/audio_processing/echo_detector/moving_max.h
+    webrtc_dsp/modules/audio_processing/echo_detector/circular_buffer.h
+    webrtc_dsp/modules/audio_processing/echo_detector/normalized_covariance_estimator.h
+    webrtc_dsp/modules/audio_processing/echo_detector/normalized_covariance_estimator.cc
+    webrtc_dsp/modules/audio_processing/echo_detector/moving_max.cc
+    webrtc_dsp/modules/audio_processing/echo_detector/circular_buffer.cc
+    webrtc_dsp/modules/audio_processing/echo_detector/mean_variance_estimator.cc
+    webrtc_dsp/modules/audio_processing/echo_detector/mean_variance_estimator.h
+    webrtc_dsp/modules/audio_processing/gain_control_for_experimental_agc.h
+    webrtc_dsp/modules/audio_processing/splitting_filter.cc
+    webrtc_dsp/modules/audio_processing/gain_control_impl.cc
+    webrtc_dsp/modules/audio_processing/rms_level.h
+    webrtc_dsp/modules/audio_processing/ns/ns_core.h
+    webrtc_dsp/modules/audio_processing/ns/nsx_core.c
+    webrtc_dsp/modules/audio_processing/ns/noise_suppression_x.c
+    webrtc_dsp/modules/audio_processing/ns/nsx_core_c.c
+    webrtc_dsp/modules/audio_processing/ns/defines.h
+    webrtc_dsp/modules/audio_processing/ns/noise_suppression.h
+    webrtc_dsp/modules/audio_processing/ns/ns_core.c
+    webrtc_dsp/modules/audio_processing/ns/nsx_core.h
+    webrtc_dsp/modules/audio_processing/ns/windows_private.h
+    webrtc_dsp/modules/audio_processing/ns/noise_suppression_x.h
+    webrtc_dsp/modules/audio_processing/ns/noise_suppression.c
+    webrtc_dsp/modules/audio_processing/ns/nsx_defines.h
+    webrtc_dsp/modules/audio_processing/residual_echo_detector.h
+    webrtc_dsp/modules/audio_processing/audio_processing_impl.h
+    webrtc_dsp/modules/audio_processing/audio_buffer.cc
+    webrtc_dsp/modules/audio_processing/typing_detection.cc
+    webrtc_dsp/modules/audio_processing/render_queue_item_verifier.h
+    webrtc_dsp/modules/audio_processing/include/audio_generator.h
+    webrtc_dsp/modules/audio_processing/include/config.h
+    webrtc_dsp/modules/audio_processing/include/audio_frame_view.h
+    webrtc_dsp/modules/audio_processing/include/mock_audio_processing.h
+    webrtc_dsp/modules/audio_processing/include/gain_control.h
+    webrtc_dsp/modules/audio_processing/include/audio_generator_factory.h
+    webrtc_dsp/modules/audio_processing/include/audio_processing_statistics.cc
+    webrtc_dsp/modules/audio_processing/include/audio_generator_factory.cc
+    webrtc_dsp/modules/audio_processing/include/aec_dump.cc
+    webrtc_dsp/modules/audio_processing/include/aec_dump.h
+    webrtc_dsp/modules/audio_processing/include/audio_processing_statistics.h
+    webrtc_dsp/modules/audio_processing/include/audio_processing.h
+    webrtc_dsp/modules/audio_processing/include/audio_processing.cc
+    webrtc_dsp/modules/audio_processing/include/config.cc
+    webrtc_dsp/modules/audio_processing/agc2/interpolated_gain_curve.h
+    webrtc_dsp/modules/audio_processing/agc2/biquad_filter.h
+    webrtc_dsp/modules/audio_processing/agc2/interpolated_gain_curve.cc
+    webrtc_dsp/modules/audio_processing/agc2/agc2_common.cc
+    webrtc_dsp/modules/audio_processing/agc2/agc2_testing_common.h
+    webrtc_dsp/modules/audio_processing/agc2/adaptive_mode_level_estimator.h
+    webrtc_dsp/modules/audio_processing/agc2/gain_applier.cc
+    webrtc_dsp/modules/audio_processing/agc2/signal_classifier.h
+    webrtc_dsp/modules/audio_processing/agc2/adaptive_agc.cc
+    webrtc_dsp/modules/audio_processing/agc2/adaptive_digital_gain_applier.cc
+    webrtc_dsp/modules/audio_processing/agc2/limiter.cc
+    webrtc_dsp/modules/audio_processing/agc2/saturation_protector.cc
+    webrtc_dsp/modules/audio_processing/agc2/vector_float_frame.h
+    webrtc_dsp/modules/audio_processing/agc2/rnn_vad/spectral_features_internal.cc
+    webrtc_dsp/modules/audio_processing/agc2/rnn_vad/sequence_buffer.h
+    webrtc_dsp/modules/audio_processing/agc2/rnn_vad/rnn.h
+    webrtc_dsp/modules/audio_processing/agc2/rnn_vad/rnn.cc
+    webrtc_dsp/modules/audio_processing/agc2/rnn_vad/test_utils.h
+    webrtc_dsp/modules/audio_processing/agc2/rnn_vad/pitch_info.h
+    webrtc_dsp/modules/audio_processing/agc2/rnn_vad/lp_residual.h
+    webrtc_dsp/modules/audio_processing/agc2/rnn_vad/ring_buffer.h
+    webrtc_dsp/modules/audio_processing/agc2/rnn_vad/pitch_search_internal.cc
+    webrtc_dsp/modules/audio_processing/agc2/rnn_vad/symmetric_matrix_buffer.h
+    webrtc_dsp/modules/audio_processing/agc2/rnn_vad/spectral_features.h
+    webrtc_dsp/modules/audio_processing/agc2/rnn_vad/features_extraction.h
+    webrtc_dsp/modules/audio_processing/agc2/rnn_vad/common.h
+    webrtc_dsp/modules/audio_processing/agc2/rnn_vad/spectral_features_internal.h
+    webrtc_dsp/modules/audio_processing/agc2/rnn_vad/fft_util.h
+    webrtc_dsp/modules/audio_processing/agc2/rnn_vad/spectral_features.cc
+    webrtc_dsp/modules/audio_processing/agc2/rnn_vad/pitch_search_internal.h
+    webrtc_dsp/modules/audio_processing/agc2/rnn_vad/pitch_search.cc
+    webrtc_dsp/modules/audio_processing/agc2/rnn_vad/pitch_search.h
+    webrtc_dsp/modules/audio_processing/agc2/rnn_vad/features_extraction.cc
+    webrtc_dsp/modules/audio_processing/agc2/rnn_vad/fft_util.cc
+    webrtc_dsp/modules/audio_processing/agc2/rnn_vad/lp_residual.cc
+    webrtc_dsp/modules/audio_processing/agc2/fixed_gain_controller.h
+    webrtc_dsp/modules/audio_processing/agc2/adaptive_mode_level_estimator_agc.cc
+    webrtc_dsp/modules/audio_processing/agc2/vector_float_frame.cc
+    webrtc_dsp/modules/audio_processing/agc2/down_sampler.h
+    webrtc_dsp/modules/audio_processing/agc2/noise_level_estimator.cc
+    webrtc_dsp/modules/audio_processing/agc2/agc2_testing_common.cc
+    webrtc_dsp/modules/audio_processing/agc2/fixed_digital_level_estimator.cc
+    webrtc_dsp/modules/audio_processing/agc2/fixed_gain_controller.cc
+    webrtc_dsp/modules/audio_processing/agc2/saturation_protector.h
+    webrtc_dsp/modules/audio_processing/agc2/vad_with_level.cc
+    webrtc_dsp/modules/audio_processing/agc2/limiter_db_gain_curve.cc
+    webrtc_dsp/modules/audio_processing/agc2/agc2_common.h
+    webrtc_dsp/modules/audio_processing/agc2/adaptive_mode_level_estimator_agc.h
+    webrtc_dsp/modules/audio_processing/agc2/adaptive_digital_gain_applier.h
+    webrtc_dsp/modules/audio_processing/agc2/vad_with_level.h
+    webrtc_dsp/modules/audio_processing/agc2/limiter_db_gain_curve.h
+    webrtc_dsp/modules/audio_processing/agc2/fixed_digital_level_estimator.h
+    webrtc_dsp/modules/audio_processing/agc2/adaptive_agc.h
+    webrtc_dsp/modules/audio_processing/agc2/gain_applier.h
+    webrtc_dsp/modules/audio_processing/agc2/down_sampler.cc
+    webrtc_dsp/modules/audio_processing/agc2/noise_level_estimator.h
+    webrtc_dsp/modules/audio_processing/agc2/signal_classifier.cc
+    webrtc_dsp/modules/audio_processing/agc2/noise_spectrum_estimator.cc
+    webrtc_dsp/modules/audio_processing/agc2/compute_interpolated_gain_curve.cc
+    webrtc_dsp/modules/audio_processing/agc2/compute_interpolated_gain_curve.h
+    webrtc_dsp/modules/audio_processing/agc2/biquad_filter.cc
+    webrtc_dsp/modules/audio_processing/agc2/noise_spectrum_estimator.h
+    webrtc_dsp/modules/audio_processing/agc2/limiter.h
+    webrtc_dsp/modules/audio_processing/agc2/adaptive_mode_level_estimator.cc
+    webrtc_dsp/modules/audio_processing/transient/moving_moments.cc
+    webrtc_dsp/modules/audio_processing/transient/transient_detector.h
+    webrtc_dsp/modules/audio_processing/transient/wpd_tree.cc
+    webrtc_dsp/modules/audio_processing/transient/transient_suppressor.h
+    webrtc_dsp/modules/audio_processing/transient/daubechies_8_wavelet_coeffs.h
+    webrtc_dsp/modules/audio_processing/transient/common.h
+    webrtc_dsp/modules/audio_processing/transient/wpd_node.h
+    webrtc_dsp/modules/audio_processing/transient/moving_moments.h
+    webrtc_dsp/modules/audio_processing/transient/wpd_tree.h
+    webrtc_dsp/modules/audio_processing/transient/wpd_node.cc
+    webrtc_dsp/modules/audio_processing/transient/transient_suppressor.cc
+    webrtc_dsp/modules/audio_processing/transient/transient_detector.cc
+    webrtc_dsp/modules/audio_processing/transient/dyadic_decimator.h
+    webrtc_dsp/modules/audio_processing/low_cut_filter.cc
+    webrtc_dsp/modules/audio_processing/noise_suppression_impl.h
+    webrtc_dsp/modules/audio_processing/level_estimator_impl.cc
+    webrtc_dsp/modules/audio_processing/three_band_filter_bank.cc
+    webrtc_dsp/modules/audio_processing/aec/echo_cancellation.cc
+    webrtc_dsp/modules/audio_processing/aec/aec_resampler.h
+    webrtc_dsp/modules/audio_processing/aec/aec_resampler.cc
+    webrtc_dsp/modules/audio_processing/aec/echo_cancellation.h
+    webrtc_dsp/modules/audio_processing/aec/aec_core.cc
+    webrtc_dsp/modules/audio_processing/aec/aec_core.h
+    webrtc_dsp/modules/audio_processing/aec/aec_core_optimized_methods.h
+    webrtc_dsp/modules/audio_processing/aec/aec_core_sse2.cc
+    webrtc_dsp/modules/audio_processing/aec/aec_common.h
+    webrtc_dsp/modules/audio_processing/voice_detection_impl.h
+    webrtc_dsp/modules/audio_processing/voice_detection_impl.cc
+    webrtc_dsp/modules/audio_processing/echo_cancellation_impl.cc
+    webrtc_dsp/modules/audio_processing/gain_control_for_experimental_agc.cc
+    webrtc_dsp/modules/audio_processing/agc/agc.cc
+    webrtc_dsp/modules/audio_processing/agc/loudness_histogram.cc
+    webrtc_dsp/modules/audio_processing/agc/agc_manager_direct.cc
+    webrtc_dsp/modules/audio_processing/agc/legacy/analog_agc.h
+    webrtc_dsp/modules/audio_processing/agc/legacy/gain_control.h
+    webrtc_dsp/modules/audio_processing/agc/legacy/digital_agc.h
+    webrtc_dsp/modules/audio_processing/agc/legacy/analog_agc.c
+    webrtc_dsp/modules/audio_processing/agc/legacy/digital_agc.c
+    webrtc_dsp/modules/audio_processing/agc/utility.cc
+    webrtc_dsp/modules/audio_processing/agc/mock_agc.h
+    webrtc_dsp/modules/audio_processing/agc/loudness_histogram.h
+    webrtc_dsp/modules/audio_processing/agc/gain_map_internal.h
+    webrtc_dsp/modules/audio_processing/agc/utility.h
+    webrtc_dsp/modules/audio_processing/agc/agc_manager_direct.h
+    webrtc_dsp/modules/audio_processing/agc/agc.h
+    webrtc_dsp/modules/audio_processing/common.h
+    webrtc_dsp/modules/audio_processing/audio_processing_impl.cc
+    webrtc_dsp/modules/audio_processing/audio_buffer.h
+    webrtc_dsp/modules/audio_processing/echo_control_mobile_impl.h
+    webrtc_dsp/modules/audio_processing/splitting_filter.h
+    webrtc_dsp/modules/audio_processing/low_cut_filter.h
+    webrtc_dsp/modules/audio_processing/audio_generator/file_audio_generator.h
+    webrtc_dsp/modules/audio_processing/audio_generator/file_audio_generator.cc
+    webrtc_dsp/modules/audio_processing/gain_controller2.cc
+    webrtc_dsp/modules/audio_processing/three_band_filter_bank.h
+    webrtc_dsp/modules/audio_processing/residual_echo_detector.cc
+    webrtc_dsp/modules/audio_processing/echo_cancellation_impl.h
+    webrtc_dsp/modules/audio_processing/noise_suppression_impl.cc
+    webrtc_dsp/modules/audio_processing/level_estimator_impl.h
+    webrtc_dsp/modules/audio_processing/gain_controller2.h
+    webrtc_dsp/modules/audio_processing/aecm/aecm_core.h
+    webrtc_dsp/modules/audio_processing/aecm/aecm_defines.h
+    webrtc_dsp/modules/audio_processing/aecm/aecm_core.cc
+    webrtc_dsp/modules/audio_processing/aecm/aecm_core_c.cc
+    webrtc_dsp/modules/audio_processing/aecm/echo_control_mobile.h
+    webrtc_dsp/modules/audio_processing/aecm/echo_control_mobile.cc
+    webrtc_dsp/modules/audio_processing/aec3/render_reverb_model.cc
+    webrtc_dsp/modules/audio_processing/aec3/downsampled_render_buffer.h
+    webrtc_dsp/modules/audio_processing/aec3/subtractor_output_analyzer.h
+    webrtc_dsp/modules/audio_processing/aec3/reverb_model_fallback.cc
+    webrtc_dsp/modules/audio_processing/aec3/residual_echo_estimator.h
+    webrtc_dsp/modules/audio_processing/aec3/shadow_filter_update_gain.h
+    webrtc_dsp/modules/audio_processing/aec3/echo_remover_metrics.cc
+    webrtc_dsp/modules/audio_processing/aec3/matched_filter_lag_aggregator.cc
+    webrtc_dsp/modules/audio_processing/aec3/render_delay_buffer2.cc
+    webrtc_dsp/modules/audio_processing/aec3/aec_state.h
+    webrtc_dsp/modules/audio_processing/aec3/suppression_filter.h
+    webrtc_dsp/modules/audio_processing/aec3/echo_path_variability.cc
+    webrtc_dsp/modules/audio_processing/aec3/frame_blocker.cc
+    webrtc_dsp/modules/audio_processing/aec3/subtractor.cc
+    webrtc_dsp/modules/audio_processing/aec3/block_delay_buffer.h
+    webrtc_dsp/modules/audio_processing/aec3/adaptive_fir_filter.h
+    webrtc_dsp/modules/audio_processing/aec3/cascaded_biquad_filter.h
+    webrtc_dsp/modules/audio_processing/aec3/matched_filter.h
+    webrtc_dsp/modules/audio_processing/aec3/subtractor_output.h
+    webrtc_dsp/modules/audio_processing/aec3/render_signal_analyzer.h
+    webrtc_dsp/modules/audio_processing/aec3/aec3_fft.cc
+    webrtc_dsp/modules/audio_processing/aec3/aec3_fft.h
+    webrtc_dsp/modules/audio_processing/aec3/echo_remover_metrics.h
+    webrtc_dsp/modules/audio_processing/aec3/fullband_erle_estimator.cc
+    webrtc_dsp/modules/audio_processing/aec3/suppression_filter.cc
+    webrtc_dsp/modules/audio_processing/aec3/block_processor.cc
+    webrtc_dsp/modules/audio_processing/aec3/filter_analyzer.h
+    webrtc_dsp/modules/audio_processing/aec3/subtractor.h
+    webrtc_dsp/modules/audio_processing/aec3/echo_path_delay_estimator.h
+    webrtc_dsp/modules/audio_processing/aec3/subband_erle_estimator.cc
+    webrtc_dsp/modules/audio_processing/aec3/render_delay_controller_metrics.cc
+    webrtc_dsp/modules/audio_processing/aec3/render_delay_buffer.cc
+    webrtc_dsp/modules/audio_processing/aec3/block_processor_metrics.h
+    webrtc_dsp/modules/audio_processing/aec3/vector_buffer.cc
+    webrtc_dsp/modules/audio_processing/aec3/erl_estimator.cc
+    webrtc_dsp/modules/audio_processing/aec3/aec_state.cc
+    webrtc_dsp/modules/audio_processing/aec3/adaptive_fir_filter.cc
+    webrtc_dsp/modules/audio_processing/aec3/fft_data.h
+    webrtc_dsp/modules/audio_processing/aec3/render_delay_controller.cc
+    webrtc_dsp/modules/audio_processing/aec3/skew_estimator.cc
+    webrtc_dsp/modules/audio_processing/aec3/render_delay_controller_metrics.h
+    webrtc_dsp/modules/audio_processing/aec3/comfort_noise_generator.h
+    webrtc_dsp/modules/audio_processing/aec3/echo_path_delay_estimator.cc
+    webrtc_dsp/modules/audio_processing/aec3/erl_estimator.h
+    webrtc_dsp/modules/audio_processing/aec3/echo_remover.h
+    webrtc_dsp/modules/audio_processing/aec3/block_framer.cc
+    webrtc_dsp/modules/audio_processing/aec3/erle_estimator.cc
+    webrtc_dsp/modules/audio_processing/aec3/reverb_model.cc
+    webrtc_dsp/modules/audio_processing/aec3/cascaded_biquad_filter.cc
+    webrtc_dsp/modules/audio_processing/aec3/matrix_buffer.h
+    webrtc_dsp/modules/audio_processing/aec3/render_buffer.cc
+    webrtc_dsp/modules/audio_processing/aec3/reverb_model_estimator.h
+    webrtc_dsp/modules/audio_processing/aec3/subtractor_output.cc
+    webrtc_dsp/modules/audio_processing/aec3/stationarity_estimator.cc
+    webrtc_dsp/modules/audio_processing/aec3/render_signal_analyzer.cc
+    webrtc_dsp/modules/audio_processing/aec3/echo_path_variability.h
+    webrtc_dsp/modules/audio_processing/aec3/moving_average.h
+    webrtc_dsp/modules/audio_processing/aec3/render_reverb_model.h
+    webrtc_dsp/modules/audio_processing/aec3/subtractor_output_analyzer.cc
+    webrtc_dsp/modules/audio_processing/aec3/suppression_gain.cc
+    webrtc_dsp/modules/audio_processing/aec3/echo_audibility.cc
+    webrtc_dsp/modules/audio_processing/aec3/block_processor_metrics.cc
+    webrtc_dsp/modules/audio_processing/aec3/render_delay_controller.h
+    webrtc_dsp/modules/audio_processing/aec3/suppression_gain.h
+    webrtc_dsp/modules/audio_processing/aec3/moving_average.cc
+    webrtc_dsp/modules/audio_processing/aec3/erle_estimator.h
+    webrtc_dsp/modules/audio_processing/aec3/subband_erle_estimator.h
+    webrtc_dsp/modules/audio_processing/aec3/reverb_model_estimator.cc
+    webrtc_dsp/modules/audio_processing/aec3/aec3_common.cc
+    webrtc_dsp/modules/audio_processing/aec3/residual_echo_estimator.cc
+    webrtc_dsp/modules/audio_processing/aec3/block_processor.h
+    webrtc_dsp/modules/audio_processing/aec3/fullband_erle_estimator.h
+    webrtc_dsp/modules/audio_processing/aec3/matched_filter.cc
+    webrtc_dsp/modules/audio_processing/aec3/stationarity_estimator.h
+    webrtc_dsp/modules/audio_processing/aec3/echo_canceller3.h
+    webrtc_dsp/modules/audio_processing/aec3/skew_estimator.h
+    webrtc_dsp/modules/audio_processing/aec3/reverb_decay_estimator.cc
+    webrtc_dsp/modules/audio_processing/aec3/render_delay_controller2.cc
+    webrtc_dsp/modules/audio_processing/aec3/render_buffer.h
+    webrtc_dsp/modules/audio_processing/aec3/suppression_gain_limiter.cc
+    webrtc_dsp/modules/audio_processing/aec3/main_filter_update_gain.cc
+    webrtc_dsp/modules/audio_processing/aec3/echo_remover.cc
+    webrtc_dsp/modules/audio_processing/aec3/reverb_model_fallback.h
+    webrtc_dsp/modules/audio_processing/aec3/downsampled_render_buffer.cc
+    webrtc_dsp/modules/audio_processing/aec3/vector_buffer.h
+    webrtc_dsp/modules/audio_processing/aec3/matrix_buffer.cc
+    webrtc_dsp/modules/audio_processing/aec3/reverb_frequency_response.h
+    webrtc_dsp/modules/audio_processing/aec3/echo_audibility.h
+    webrtc_dsp/modules/audio_processing/aec3/fft_buffer.h
+    webrtc_dsp/modules/audio_processing/aec3/block_processor2.cc
+    webrtc_dsp/modules/audio_processing/aec3/echo_canceller3.cc
+    webrtc_dsp/modules/audio_processing/aec3/block_delay_buffer.cc
+    webrtc_dsp/modules/audio_processing/aec3/aec3_common.h
+    webrtc_dsp/modules/audio_processing/aec3/fft_buffer.cc
+    webrtc_dsp/modules/audio_processing/aec3/vector_math.h
+    webrtc_dsp/modules/audio_processing/aec3/decimator.h
+    webrtc_dsp/modules/audio_processing/aec3/frame_blocker.h
+    webrtc_dsp/modules/audio_processing/aec3/block_framer.h
+    webrtc_dsp/modules/audio_processing/aec3/suppression_gain_limiter.h
+    webrtc_dsp/modules/audio_processing/aec3/delay_estimate.h
+    webrtc_dsp/modules/audio_processing/aec3/comfort_noise_generator.cc
+    webrtc_dsp/modules/audio_processing/aec3/reverb_model.h
+    webrtc_dsp/modules/audio_processing/aec3/main_filter_update_gain.h
+    webrtc_dsp/modules/audio_processing/aec3/matched_filter_lag_aggregator.h
+    webrtc_dsp/modules/audio_processing/aec3/shadow_filter_update_gain.cc
+    webrtc_dsp/modules/audio_processing/aec3/filter_analyzer.cc
+    webrtc_dsp/modules/audio_processing/aec3/reverb_decay_estimator.h
+    webrtc_dsp/modules/audio_processing/aec3/reverb_frequency_response.cc
+    webrtc_dsp/modules/audio_processing/aec3/decimator.cc
+    webrtc_dsp/modules/audio_processing/aec3/render_delay_buffer.h
+    webrtc_dsp/modules/audio_processing/echo_control_mobile_impl.cc
+    webrtc_dsp/modules/audio_processing/gain_control_impl.h
+    webrtc_dsp/modules/audio_processing/typing_detection.h
+    webrtc_dsp/modules/audio_processing/logging/apm_data_dumper.cc
+    webrtc_dsp/modules/audio_processing/logging/apm_data_dumper.h
+    webrtc_dsp/modules/audio_processing/vad/voice_activity_detector.cc
+    webrtc_dsp/modules/audio_processing/vad/standalone_vad.cc
+    webrtc_dsp/modules/audio_processing/vad/vad_audio_proc_internal.h
+    webrtc_dsp/modules/audio_processing/vad/pitch_internal.cc
+    webrtc_dsp/modules/audio_processing/vad/vad_circular_buffer.cc
+    webrtc_dsp/modules/audio_processing/vad/vad_circular_buffer.h
+    webrtc_dsp/modules/audio_processing/vad/pitch_based_vad.h
+    webrtc_dsp/modules/audio_processing/vad/vad_audio_proc.cc
+    webrtc_dsp/modules/audio_processing/vad/pole_zero_filter.cc
+    webrtc_dsp/modules/audio_processing/vad/pole_zero_filter.h
+    webrtc_dsp/modules/audio_processing/vad/pitch_based_vad.cc
+    webrtc_dsp/modules/audio_processing/vad/gmm.h
+    webrtc_dsp/modules/audio_processing/vad/common.h
+    webrtc_dsp/modules/audio_processing/vad/vad_audio_proc.h
+    webrtc_dsp/modules/audio_processing/vad/voice_gmm_tables.h
+    webrtc_dsp/modules/audio_processing/vad/noise_gmm_tables.h
+    webrtc_dsp/modules/audio_processing/vad/pitch_internal.h
+    webrtc_dsp/modules/audio_processing/vad/gmm.cc
+    webrtc_dsp/modules/audio_processing/vad/standalone_vad.h
+    webrtc_dsp/modules/audio_processing/vad/voice_activity_detector.h
+    webrtc_dsp/modules/audio_processing/utility/delay_estimator_internal.h
+    webrtc_dsp/modules/audio_processing/utility/ooura_fft.cc
+    webrtc_dsp/modules/audio_processing/utility/ooura_fft.h
+    webrtc_dsp/modules/audio_processing/utility/delay_estimator_wrapper.cc
+    webrtc_dsp/modules/audio_processing/utility/ooura_fft_sse2.cc
+    webrtc_dsp/modules/audio_processing/utility/delay_estimator.cc
+    webrtc_dsp/modules/audio_processing/utility/block_mean_calculator.h
+    webrtc_dsp/modules/audio_processing/utility/block_mean_calculator.cc
+    webrtc_dsp/modules/audio_processing/utility/delay_estimator.h
+    webrtc_dsp/modules/audio_processing/utility/ooura_fft_tables_common.h
+    webrtc_dsp/modules/audio_processing/utility/delay_estimator_wrapper.h
+    webrtc_dsp/common_audio/mocks/mock_smoothing_filter.h
+    webrtc_dsp/common_audio/wav_file.h
+    webrtc_dsp/common_audio/window_generator.cc
+    webrtc_dsp/common_audio/channel_buffer.cc
+    webrtc_dsp/common_audio/fir_filter_factory.cc
+    webrtc_dsp/common_audio/sparse_fir_filter.h
+    webrtc_dsp/common_audio/fir_filter_sse.h
+    webrtc_dsp/common_audio/window_generator.h
+    webrtc_dsp/common_audio/ring_buffer.h
+    webrtc_dsp/common_audio/fir_filter.h
+    webrtc_dsp/common_audio/include/audio_util.h
+    webrtc_dsp/common_audio/wav_header.cc
+    webrtc_dsp/common_audio/real_fourier_ooura.cc
+    webrtc_dsp/common_audio/audio_util.cc
+    webrtc_dsp/common_audio/real_fourier_ooura.h
+    webrtc_dsp/common_audio/fir_filter_sse.cc
+    webrtc_dsp/common_audio/smoothing_filter.h
+    webrtc_dsp/common_audio/resampler/push_sinc_resampler.cc
+    webrtc_dsp/common_audio/resampler/sinc_resampler.h
+    webrtc_dsp/common_audio/resampler/resampler.cc
+    webrtc_dsp/common_audio/resampler/sinc_resampler_sse.cc
+    webrtc_dsp/common_audio/resampler/include/push_resampler.h
+    webrtc_dsp/common_audio/resampler/include/resampler.h
+    webrtc_dsp/common_audio/resampler/push_sinc_resampler.h
+    webrtc_dsp/common_audio/resampler/push_resampler.cc
+    webrtc_dsp/common_audio/resampler/sinusoidal_linear_chirp_source.h
+    webrtc_dsp/common_audio/resampler/sinc_resampler.cc
+    webrtc_dsp/common_audio/resampler/sinusoidal_linear_chirp_source.cc
+    webrtc_dsp/common_audio/fir_filter_factory.h
+    webrtc_dsp/common_audio/audio_converter.h
+    webrtc_dsp/common_audio/wav_file.cc
+    webrtc_dsp/common_audio/third_party/spl_sqrt_floor/spl_sqrt_floor.c
+    webrtc_dsp/common_audio/third_party/spl_sqrt_floor/spl_sqrt_floor.h
+    webrtc_dsp/common_audio/third_party/fft4g/fft4g.c
+    webrtc_dsp/common_audio/third_party/fft4g/fft4g.h
+    webrtc_dsp/common_audio/audio_converter.cc
+    webrtc_dsp/common_audio/real_fourier.cc
+    webrtc_dsp/common_audio/channel_buffer.h
+    webrtc_dsp/common_audio/real_fourier.h
+    webrtc_dsp/common_audio/sparse_fir_filter.cc
+    webrtc_dsp/common_audio/smoothing_filter.cc
+    webrtc_dsp/common_audio/fir_filter_c.cc
+    webrtc_dsp/common_audio/ring_buffer.c
+    webrtc_dsp/common_audio/fir_filter_c.h
+    webrtc_dsp/common_audio/signal_processing/complex_fft_tables.h
+    webrtc_dsp/common_audio/signal_processing/complex_fft.c
+    webrtc_dsp/common_audio/signal_processing/filter_ma_fast_q12.c
+    webrtc_dsp/common_audio/signal_processing/levinson_durbin.c
+    webrtc_dsp/common_audio/signal_processing/dot_product_with_scale.cc
+    webrtc_dsp/common_audio/signal_processing/auto_corr_to_refl_coef.c
+    webrtc_dsp/common_audio/signal_processing/resample_by_2_internal.c
+    webrtc_dsp/common_audio/signal_processing/energy.c
+    webrtc_dsp/common_audio/signal_processing/sqrt_of_one_minus_x_squared.c
+    webrtc_dsp/common_audio/signal_processing/downsample_fast.c
+    webrtc_dsp/common_audio/signal_processing/splitting_filter1.c
+    webrtc_dsp/common_audio/signal_processing/filter_ar_fast_q12.c
+    webrtc_dsp/common_audio/signal_processing/spl_init.c
+    webrtc_dsp/common_audio/signal_processing/lpc_to_refl_coef.c
+    webrtc_dsp/common_audio/signal_processing/cross_correlation.c
+    webrtc_dsp/common_audio/signal_processing/include/signal_processing_library.h
+    webrtc_dsp/common_audio/signal_processing/include/real_fft.h
+    webrtc_dsp/common_audio/signal_processing/include/spl_inl.h
+    webrtc_dsp/common_audio/signal_processing/division_operations.c
+    webrtc_dsp/common_audio/signal_processing/auto_correlation.c
+    webrtc_dsp/common_audio/signal_processing/get_scaling_square.c
+    webrtc_dsp/common_audio/signal_processing/dot_product_with_scale.h
+    webrtc_dsp/common_audio/signal_processing/resample_by_2_internal.h
+    webrtc_dsp/common_audio/signal_processing/resample.c
+    webrtc_dsp/common_audio/signal_processing/min_max_operations.c
+    webrtc_dsp/common_audio/signal_processing/refl_coef_to_lpc.c
+    webrtc_dsp/common_audio/signal_processing/filter_ar.c
+    webrtc_dsp/common_audio/signal_processing/vector_scaling_operations.c
+    webrtc_dsp/common_audio/signal_processing/resample_fractional.c
+    webrtc_dsp/common_audio/signal_processing/real_fft.c
+    webrtc_dsp/common_audio/signal_processing/ilbc_specific_functions.c
+    webrtc_dsp/common_audio/signal_processing/complex_bit_reverse.c
+    webrtc_dsp/common_audio/signal_processing/randomization_functions.c
+    webrtc_dsp/common_audio/signal_processing/copy_set_operations.c
+    webrtc_dsp/common_audio/signal_processing/resample_by_2.c
+    webrtc_dsp/common_audio/signal_processing/get_hanning_window.c
+    webrtc_dsp/common_audio/signal_processing/resample_48khz.c
+    webrtc_dsp/common_audio/signal_processing/spl_inl.c
+    webrtc_dsp/common_audio/signal_processing/spl_sqrt.c
+    webrtc_dsp/common_audio/wav_header.h
+    webrtc_dsp/common_audio/vad/vad_sp.c
+    webrtc_dsp/common_audio/vad/vad.cc
+    webrtc_dsp/common_audio/vad/webrtc_vad.c
+    webrtc_dsp/common_audio/vad/vad_core.h
+    webrtc_dsp/common_audio/vad/include/vad.h
+    webrtc_dsp/common_audio/vad/include/webrtc_vad.h
+    webrtc_dsp/common_audio/vad/vad_gmm.h
+    webrtc_dsp/common_audio/vad/vad_filterbank.c
+    webrtc_dsp/common_audio/vad/vad_core.c
+    webrtc_dsp/common_audio/vad/vad_sp.h
+    webrtc_dsp/common_audio/vad/vad_filterbank.h
+    webrtc_dsp/common_audio/vad/vad_gmm.c 
+
+    # ARM/NEON sources
+    # TODO check if there's a good way to make these compile with ARM ports of TDesktop
+    # webrtc_dsp/modules/audio_processing/ns/nsx_core_neon.c
+    # webrtc_dsp/modules/audio_processing/aec/aec_core_neon.cc
+    # webrtc_dsp/modules/audio_processing/aecm/aecm_core_neon.cc
+    # webrtc_dsp/modules/audio_processing/utility/ooura_fft_tables_neon_sse2.h
+    # webrtc_dsp/modules/audio_processing/utility/ooura_fft_neon.cc
+    # webrtc_dsp/common_audio/fir_filter_neon.cc
+    # webrtc_dsp/common_audio/resampler/sinc_resampler_neon.cc
+    # webrtc_dsp/common_audio/third_party/spl_sqrt_floor/spl_sqrt_floor_arm.S
+    # webrtc_dsp/common_audio/fir_filter_neon.h
+    # webrtc_dsp/common_audio/signal_processing/downsample_fast_neon.c
+    # webrtc_dsp/common_audio/signal_processing/complex_bit_reverse_arm.S
+    # webrtc_dsp/common_audio/signal_processing/include/spl_inl_armv7.h
+    # webrtc_dsp/common_audio/signal_processing/min_max_operations_neon.c
+    # webrtc_dsp/common_audio/signal_processing/cross_correlation_neon.c
+    # webrtc_dsp/common_audio/signal_processing/filter_ar_fast_q12_armv7.S
+)
+
+target_compile_definitions(lib_tgvoip
+PUBLIC
+    WEBRTC_APM_DEBUG_DUMP=0
+    TGVOIP_USE_DESKTOP_DSP
+    WEBRTC_NS_FLOAT
+)
+
+if (WIN32)
+    target_compile_options(lib_tgvoip
+    PRIVATE
+        /wd4005
+        /wd4244 # conversion from 'int' to 'float', possible loss of data (several in webrtc)
+    )
+    target_compile_definitions(lib_tgvoip
+    PUBLIC
+        WEBRTC_WIN
+    )
+elseif (APPLE)
+    target_compile_definitions(lib_tgvoip
+    PUBLIC
+        WEBRTC_POSIX
+        WEBRTC_MAC
+        TARGET_OS_OSX
+        TARGET_OSX
+    )
+    if (build_macstore)
+        target_compile_definitions(lib_tgvoip
+        PUBLIC
+            TGVOIP_NO_OSX_PRIVATE_API
+        )
+    endif()
+else()
+    target_compile_options(lib_tgvoip
+    PRIVATE
+        -Wno-unknown-pragmas
+        -Wno-error=sequence-point
+        -Wno-error=unused-result
+    )
+    if (build_linux32)
+        target_compile_options(lib_tgvoip PRIVATE -msse2)
+    endif()
+    target_compile_definitions(lib_tgvoip
+    PUBLIC
+        WEBRTC_POSIX
+        WEBRTC_LINUX
+    )
+endif()
+
+if (NOT WIN32)
+    target_compile_definitions(lib_tgvoip PRIVATE TGVOIP_USE_INSTALLED_OPUS)
+endif()
+
+target_include_directories(lib_tgvoip
+PUBLIC
+    ${tgvoip_loc}
+PRIVATE
+    ${tgvoip_loc}/webrtc_dsp
+)
+
+target_link_libraries(lib_tgvoip
+PRIVATE
+    desktop-app::external_openssl
+    desktop-app::external_opus
+)
diff --git a/Telegram/cmake/telegram_options.cmake b/Telegram/cmake/telegram_options.cmake
new file mode 100644
index 000000000..cb721e590
--- /dev/null
+++ b/Telegram/cmake/telegram_options.cmake
@@ -0,0 +1,84 @@
+# This file is part of Telegram Desktop,
+# the official desktop application for the Telegram messaging service.
+#
+# For license and copyright information please follow this link:
+# https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+
+option(TDESKTOP_FORCE_GTK_FILE_DIALOG "Force using GTK file dialog (Linux only)." OFF)
+option(TDESKTOP_DISABLE_REGISTER_CUSTOM_SCHEME "Disable automatic 'tg://' URL scheme handler registration." OFF)
+option(TDESKTOP_DISABLE_NETWORK_PROXY "Disable all code for working through Socks5 or MTProxy." OFF)
+option(TDESKTOP_DISABLE_DESKTOP_FILE_GENERATION "Disable automatic '.desktop' file generation (Linux only)." OFF)
+option(TDESKTOP_DISABLE_GTK_INTEGRATION "Disable all code for GTK integration (Linux only)." OFF)
+option(TDESKTOP_API_TEST "Use test API credentials." OFF)
+set(TDESKTOP_API_ID "0" CACHE STRING "Provide 'api_id' for the Telegram API access.")
+set(TDESKTOP_API_HASH "" CACHE STRING "Provide 'api_hash' for the Telegram API access.")
+
+if (TDESKTOP_API_TEST)
+    set(TDESKTOP_API_ID 17349)
+    set(TDESKTOP_API_HASH 344583e45741c457fe1862106095a5eb)
+endif()
+
+if (TDESKTOP_API_ID STREQUAL "0" OR TDESKTOP_API_HASH STREQUAL "")
+    message(FATAL_ERROR 
+    " \n"
+    " PROVIDE: -D TDESKTOP_API_ID=[API_ID] -D TDESKTOP_API_HASH=[API_HASH]\n"
+    " \n"
+    " > To build your version of Telegram Desktop you're required to provide\n"
+    " > your own 'api_id' and 'api_hash' for the Telegram API access.\n"
+    " >\n"
+    " > How to obtain your 'api_id' and 'api_hash' is described here:\n"
+    " > https://core.telegram.org/api/obtaining_api_id\n"
+    " >\n"
+    " > If you're building the application not for deployment,\n"
+    " > but only for test purposes you can use TEST ONLY credentials,\n"
+    " > which are very limited by the Telegram API server:\n"
+    " >\n"
+    " > api_id: 17349\n"
+    " > api_hash: 344583e45741c457fe1862106095a5eb\n"
+    " >\n"
+    " > Your users will start getting internal server errors on login\n"
+    " > if you deploy an app using those 'api_id' and 'api_hash'.\n"
+    " ")
+endif()
+
+if (NOT DESKTOP_APP_SPECIAL_TARGET STREQUAL "")
+    set(TDESKTOP_FORCE_GTK_FILE_DIALOG ON)
+endif()
+
+if (TDESKTOP_FORCE_GTK_FILE_DIALOG AND TDESKTOP_DISABLE_GTK_INTEGRATION)
+    message(FATAL_ERROR "Option TDESKTOP_FORCE_GTK_FILE_DIALOG conflicts with option TDESKTOP_DISABLE_GTK_INTEGRATION.")
+endif()
+
+if (DESKTOP_APP_DISABLE_SPELLCHECK)
+    target_compile_definitions(Telegram PRIVATE TDESKTOP_DISABLE_SPELLCHECK)
+else()
+    target_link_libraries(Telegram PRIVATE desktop-app::lib_spellcheck)
+endif()
+
+if (disable_autoupdate)
+    target_compile_definitions(Telegram PRIVATE TDESKTOP_DISABLE_AUTOUPDATE)
+endif()
+
+if (DESKTOP_APP_SPECIAL_TARGET)
+    target_compile_definitions(Telegram PRIVATE TDESKTOP_ALLOW_CLOSED_ALPHA)
+endif()
+
+if (TDESKTOP_FORCE_GTK_FILE_DIALOG)
+    target_compile_definitions(Telegram PRIVATE TDESKTOP_FORCE_GTK_FILE_DIALOG)
+endif()
+
+if (TDESKTOP_DISABLE_REGISTER_CUSTOM_SCHEME)
+    target_compile_definitions(Telegram PRIVATE TDESKTOP_DISABLE_REGISTER_CUSTOM_SCHEME)
+endif()
+
+if (TDESKTOP_DISABLE_NETWORK_PROXY)
+    target_compile_definitions(Telegram PRIVATE TDESKTOP_DISABLE_NETWORK_PROXY)
+endif()
+
+if (TDESKTOP_DISABLE_DESKTOP_FILE_GENERATION)
+    target_compile_definitions(Telegram PRIVATE TDESKTOP_DISABLE_DESKTOP_FILE_GENERATION)
+endif()
+
+if (TDESKTOP_DISABLE_GTK_INTEGRATION)
+    target_compile_definitions(Telegram PRIVATE TDESKTOP_DISABLE_GTK_INTEGRATION)
+endif()
Submodule Telegram/codegen f1202034e..ee55a0b69:
diff --git a/Telegram/codegen/CMakeLists.txt b/Telegram/codegen/CMakeLists.txt
new file mode 100644
index 0000000..59c0ce8
--- /dev/null
+++ b/Telegram/codegen/CMakeLists.txt
@@ -0,0 +1,5 @@
+add_subdirectory(codegen/common)
+add_subdirectory(codegen/emoji)
+add_subdirectory(codegen/lang)
+add_subdirectory(codegen/numbers)
+add_subdirectory(codegen/style)
diff --git a/Telegram/codegen/codegen/common/CMakeLists.txt b/Telegram/codegen/codegen/common/CMakeLists.txt
new file mode 100644
index 0000000..ca53ac5
--- /dev/null
+++ b/Telegram/codegen/codegen/common/CMakeLists.txt
@@ -0,0 +1,31 @@
+add_library(codegen_common OBJECT)
+add_library(desktop-app::codegen_common ALIAS codegen_common)
+init_target(codegen_common "(codegen)")
+
+get_filename_component(src_loc ../.. REALPATH)
+
+nice_target_sources(codegen_common ${src_loc}
+PRIVATE
+    codegen/common/basic_tokenized_file.cpp
+    codegen/common/basic_tokenized_file.h
+    codegen/common/checked_utf8_string.cpp
+    codegen/common/checked_utf8_string.h
+    codegen/common/clean_file.cpp
+    codegen/common/clean_file.h
+    codegen/common/clean_file_reader.h
+    codegen/common/const_utf8_string.h
+    codegen/common/cpp_file.cpp
+    codegen/common/cpp_file.h
+    codegen/common/logging.cpp
+    codegen/common/logging.h
+)
+
+target_include_directories(codegen_common
+PUBLIC
+    ${src_loc}
+)
+
+target_link_libraries(codegen_common
+PUBLIC
+    desktop-app::external_qt
+)
diff --git a/Telegram/codegen/codegen/common/cpp_file.cpp b/Telegram/codegen/codegen/common/cpp_file.cpp
index f443663..3f5cee0 100644
--- a/Telegram/codegen/codegen/common/cpp_file.cpp
+++ b/Telegram/codegen/codegen/common/cpp_file.cpp
@@ -105,5 +105,10 @@ bool CppFile::finalize() {
 	return true;
 }
 
+bool TouchTimestamp(const QString &basepath) {
+	auto file = QFile(basepath + ".timestamp");
+	return file.open(QIODevice::WriteOnly) && (file.write("1", 1) == 1);
+}
+
 } // namespace common
-} // namespace codegen
\ No newline at end of file
+} // namespace codegen
diff --git a/Telegram/codegen/codegen/common/cpp_file.h b/Telegram/codegen/codegen/common/cpp_file.h
index e6d66a8..31068de 100644
--- a/Telegram/codegen/codegen/common/cpp_file.h
+++ b/Telegram/codegen/codegen/common/cpp_file.h
@@ -52,5 +52,7 @@ private:
 
 };
 
+bool TouchTimestamp(const QString &basepath);
+
 } // namespace common
 } // namespace codegen
diff --git a/Telegram/codegen/codegen/emoji/CMakeLists.txt b/Telegram/codegen/codegen/emoji/CMakeLists.txt
new file mode 100644
index 0000000..058e860
--- /dev/null
+++ b/Telegram/codegen/codegen/emoji/CMakeLists.txt
@@ -0,0 +1,28 @@
+add_executable(codegen_emoji)
+init_target(codegen_emoji "(codegen)")
+
+get_filename_component(src_loc ../.. REALPATH)
+
+nice_target_sources(codegen_emoji ${src_loc}
+PRIVATE
+    codegen/emoji/data.cpp
+    codegen/emoji/data.h
+    codegen/emoji/generator.cpp
+    codegen/emoji/generator.h
+    codegen/emoji/main.cpp
+    codegen/emoji/options.cpp
+    codegen/emoji/options.h
+    codegen/emoji/replaces.cpp
+    codegen/emoji/replaces.h
+)
+
+target_include_directories(codegen_emoji
+PUBLIC
+    ${src_loc}
+)
+
+target_link_libraries(codegen_emoji
+PUBLIC
+    desktop-app::codegen_common
+    desktop-app::external_qt
+)
diff --git a/Telegram/codegen/codegen/emoji/generator.cpp b/Telegram/codegen/codegen/emoji/generator.cpp
index c0ee43f..b5c3940 100644
--- a/Telegram/codegen/codegen/emoji/generator.cpp
+++ b/Telegram/codegen/codegen/emoji/generator.cpp
@@ -181,16 +181,11 @@ int Generator::generate() {
 	}
 #endif // SUPPORT_IMAGE_GENERATION
 
-	if (!writeSource()) {
-		return -1;
-	}
-	if (!writeHeader()) {
-		return -1;
-	}
-	if (!writeSuggestionsSource()) {
-		return -1;
-	}
-	if (!writeSuggestionsHeader()) {
+	if (!writeSource()
+		|| !writeHeader()
+		|| !writeSuggestionsSource()
+		|| !writeSuggestionsHeader()
+		|| !common::TouchTimestamp(outputPath_)) {
 		return -1;
 	}
 
diff --git a/Telegram/codegen/codegen/lang/CMakeLists.txt b/Telegram/codegen/codegen/lang/CMakeLists.txt
new file mode 100644
index 0000000..d179abe
--- /dev/null
+++ b/Telegram/codegen/codegen/lang/CMakeLists.txt
@@ -0,0 +1,28 @@
+add_executable(codegen_lang)
+init_target(codegen_lang "(codegen)")
+
+get_filename_component(src_loc ../.. REALPATH)
+
+nice_target_sources(codegen_lang ${src_loc}
+PRIVATE
+    codegen/lang/generator.cpp
+    codegen/lang/generator.h
+    codegen/lang/main.cpp
+    codegen/lang/options.cpp
+    codegen/lang/options.h
+    codegen/lang/parsed_file.cpp
+    codegen/lang/parsed_file.h
+    codegen/lang/processor.cpp
+    codegen/lang/processor.h
+)
+
+target_include_directories(codegen_lang
+PUBLIC
+    ${src_loc}
+)
+
+target_link_libraries(codegen_lang
+PUBLIC
+    desktop-app::codegen_common
+    desktop-app::external_qt
+)
diff --git a/Telegram/codegen/codegen/lang/processor.cpp b/Telegram/codegen/codegen/lang/processor.cpp
index 0015fa0..3c4ced2 100644
--- a/Telegram/codegen/codegen/lang/processor.cpp
+++ b/Telegram/codegen/codegen/lang/processor.cpp
@@ -55,10 +55,9 @@ bool Processor::write(const LangPack &langpack) const {
 	};
 
 	Generator generator(langpack, dstFilePath, project);
-	if (!generator.writeHeader()) {
-		return false;
-	}
-	if (!generator.writeSource()) {
+	if (!generator.writeHeader()
+		|| !generator.writeSource()
+		|| !common::TouchTimestamp(dstFilePath)) {
 		return false;
 	}
 	return true;
diff --git a/Telegram/codegen/codegen/numbers/CMakeLists.txt b/Telegram/codegen/codegen/numbers/CMakeLists.txt
new file mode 100644
index 0000000..54a0498
--- /dev/null
+++ b/Telegram/codegen/codegen/numbers/CMakeLists.txt
@@ -0,0 +1,28 @@
+add_executable(codegen_numbers)
+init_target(codegen_numbers "(codegen)")
+
+get_filename_component(src_loc ../.. REALPATH)
+
+nice_target_sources(codegen_numbers ${src_loc}
+PRIVATE
+    codegen/numbers/generator.cpp
+    codegen/numbers/generator.h
+    codegen/numbers/main.cpp
+    codegen/numbers/options.cpp
+    codegen/numbers/options.h
+    codegen/numbers/parsed_file.cpp
+    codegen/numbers/parsed_file.h
+    codegen/numbers/processor.cpp
+    codegen/numbers/processor.h
+)
+
+target_include_directories(codegen_numbers
+PUBLIC
+    ${src_loc}
+)
+
+target_link_libraries(codegen_numbers
+PUBLIC
+    desktop-app::codegen_common
+    desktop-app::external_qt
+)
diff --git a/Telegram/codegen/codegen/numbers/processor.cpp b/Telegram/codegen/codegen/numbers/processor.cpp
index a7eb796..37fbed9 100644
--- a/Telegram/codegen/codegen/numbers/processor.cpp
+++ b/Telegram/codegen/codegen/numbers/processor.cpp
@@ -55,10 +55,9 @@ bool Processor::write(const Rules &rules) const {
 	};
 
 	Generator generator(rules, dstFilePath, project);
-	if (!generator.writeHeader()) {
-		return false;
-	}
-	if (!generator.writeSource()) {
+	if (!generator.writeHeader()
+		|| !generator.writeSource()
+		|| !common::TouchTimestamp(dstFilePath)) {
 		return false;
 	}
 
diff --git a/Telegram/codegen/codegen/style/CMakeLists.txt b/Telegram/codegen/codegen/style/CMakeLists.txt
new file mode 100644
index 0000000..5324a6c
--- /dev/null
+++ b/Telegram/codegen/codegen/style/CMakeLists.txt
@@ -0,0 +1,33 @@
+add_executable(codegen_style)
+init_target(codegen_style "(codegen)")
+
+get_filename_component(src_loc ../.. REALPATH)
+
+nice_target_sources(codegen_style ${src_loc}
+PRIVATE
+    codegen/style/generator.cpp
+    codegen/style/generator.h
+    codegen/style/main.cpp
+    codegen/style/module.cpp
+    codegen/style/module.h
+    codegen/style/options.cpp
+    codegen/style/options.h
+    codegen/style/parsed_file.cpp
+    codegen/style/parsed_file.h
+    codegen/style/processor.cpp
+    codegen/style/processor.h
+    codegen/style/structure_types.cpp
+    codegen/style/structure_types.h
+)
+
+target_include_directories(codegen_style
+PUBLIC
+    ${src_loc}
+)
+
+target_link_libraries(codegen_style
+PUBLIC
+    desktop-app::codegen_common
+    desktop-app::lib_base
+    desktop-app::lib_crl
+)
diff --git a/Telegram/codegen/codegen/style/generator.cpp b/Telegram/codegen/codegen/style/generator.cpp
index 8c41d69..45ea810 100644
--- a/Telegram/codegen/codegen/style/generator.cpp
+++ b/Telegram/codegen/codegen/style/generator.cpp
@@ -388,7 +388,7 @@ bool Generator::writeHeaderRequiredIncludes() {
 		return true;
 	}
 	for (const auto base : includes) {
-		header_->include(base + ".h");
+		header_->include("styles/" + base + ".h");
 	}
 	header_->newline();
 	return true;
@@ -678,8 +678,8 @@ bool Generator::writeIncludesInSource() {
 		return true;
 	};
 	auto result = module_.enumIncludes(collector);
-	for (auto base : includes) {
-		source_->include(base + ".h");
+	for (const auto &base : includes) {
+		source_->include("styles/" + base + ".h");
 	}
 	source_->newline();
 	return result;
diff --git a/Telegram/codegen/codegen/style/main.cpp b/Telegram/codegen/codegen/style/main.cpp
index e9a1b08..ea736fd 100644
--- a/Telegram/codegen/codegen/style/main.cpp
+++ b/Telegram/codegen/codegen/style/main.cpp
@@ -13,7 +13,7 @@ int main(int argc, char *argv[]) {
 	QCoreApplication app(argc, argv);
 
 	auto options = codegen::style::parseOptions();
-	if (options.inputPath.isEmpty()) {
+	if (options.inputPaths.isEmpty()) {
 		return -1;
 	}
 
diff --git a/Telegram/codegen/codegen/style/module.cpp b/Telegram/codegen/codegen/style/module.cpp
index 606f91e..898eb67 100644
--- a/Telegram/codegen/codegen/style/module.cpp
+++ b/Telegram/codegen/codegen/style/module.cpp
@@ -20,7 +20,7 @@ QString fullNameKey(const FullName &name) {
 Module::Module(const QString &fullpath) : fullpath_(fullpath) {
 }
 
-void Module::addIncluded(std::unique_ptr<Module> &&value) {
+void Module::addIncluded(std::shared_ptr<const Module> value) {
 	included_.push_back(std::move(value));
 }
 
diff --git a/Telegram/codegen/codegen/style/module.h b/Telegram/codegen/codegen/style/module.h
index 0eca52a..0fbcee2 100644
--- a/Telegram/codegen/codegen/style/module.h
+++ b/Telegram/codegen/codegen/style/module.h
@@ -25,7 +25,7 @@ public:
 		return fullpath_;
 	}
 
-	void addIncluded(std::unique_ptr<Module> &&value);
+	void addIncluded(std::shared_ptr<const Module> value);
 
 	bool hasIncludes() const {
 		return !included_.empty();
@@ -85,7 +85,7 @@ public:
 
 private:
 	QString fullpath_;
-	std::vector<std::unique_ptr<Module>> included_;
+	std::vector<std::shared_ptr<const Module>> included_;
 	QList<Struct> structs_;
 	QList<Variable> variables_;
 	QMap<QString, int> structsByName_;
diff --git a/Telegram/codegen/codegen/style/options.cpp b/Telegram/codegen/codegen/style/options.cpp
index c3992cb..ceff51e 100644
--- a/Telegram/codegen/codegen/style/options.cpp
+++ b/Telegram/codegen/codegen/style/options.cpp
@@ -53,6 +53,17 @@ Options parseOptions() {
 		} else if (arg.startsWith("-o")) {
 			result.outputPath = arg.mid(2);
 
+		// Timestamp path
+		} else if (arg == "-t") {
+			if (++i == count) {
+				logError(kErrorOutputPathExpected, "Command Line") << "timestamp path expected after -t";
+				return Options();
+			} else {
+				result.timestampPath = args.at(i);
+			}
+		} else if (arg.startsWith("-t")) {
+			result.timestampPath = arg.mid(2);
+
 		// Working path
 		} else if (arg == "-w") {
 			if (++i == count) {
@@ -66,19 +77,19 @@ Options parseOptions() {
 
 		// Input path
 		} else {
-			if (result.inputPath.isEmpty()) {
-				result.inputPath = arg;
-			} else {
-				logError(kErrorSingleInputPathExpected, "Command Line") << "only one input path expected";
-				return Options();
-			}
+			result.inputPaths.push_back(arg);
 		}
 	}
-	if (result.inputPath.isEmpty()) {
+	if (result.timestampPath.isEmpty()) {
+		logError(kErrorInputPathExpected, "Command Line") << "timestamp path expected";
+		return Options();
+	}
+	if (result.inputPaths.isEmpty()) {
 		logError(kErrorInputPathExpected, "Command Line") << "input path expected";
 		return Options();
 	}
-	result.isPalette = (QFileInfo(result.inputPath).suffix() == "palette");
+	result.isPalette = (result.inputPaths.size() == 1)
+		&& (QFileInfo(result.inputPaths.front()).suffix() == "palette");
 	return result;
 }
 
diff --git a/Telegram/codegen/codegen/style/options.h b/Telegram/codegen/codegen/style/options.h
index 5c97941..385dce0 100644
--- a/Telegram/codegen/codegen/style/options.h
+++ b/Telegram/codegen/codegen/style/options.h
@@ -15,7 +15,8 @@ namespace style {
 struct Options {
 	QStringList includePaths = { "." };
 	QString outputPath = ".";
-	QString inputPath;
+	QString timestampPath;
+	QStringList inputPaths;
 	bool isPalette = false;
 };
 
diff --git a/Telegram/codegen/codegen/style/parsed_file.cpp b/Telegram/codegen/codegen/style/parsed_file.cpp
index ea5486e..a21a532 100644
--- a/Telegram/codegen/codegen/style/parsed_file.cpp
+++ b/Telegram/codegen/codegen/style/parsed_file.cpp
@@ -33,14 +33,14 @@ constexpr int kErrorIconDuplicate      = 807;
 constexpr int kErrorBadIconModifier    = 808;
 constexpr int kErrorCyclicDependency   = 809;
 
-QString findInputFile(const Options &options) {
+QString findInputFile(const Options &options, int index) {
 	for (const auto &dir : options.includePaths) {
-		QString tryPath = QDir(dir).absolutePath() + '/' + options.inputPath;
+		QString tryPath = QDir(dir).absolutePath() + '/' + options.inputPaths[index];
 		if (QFileInfo(tryPath).exists()) {
 			return tryPath;
 		}
 	}
-	return options.inputPath;
+	return options.inputPaths[index];
 }
 
 QString tokenValue(const BasicToken &token) {
@@ -146,9 +146,12 @@ Modifier GetModifier(const QString &name) {
 }
 
 ParsedFile::ParsedFile(
+	std::map<QString, std::shared_ptr<const structure::Module>> &includeCache,
 	const Options &options,
+	int index,
 	std::vector<QString> includeStack)
-: filePath_(findInputFile(options))
+: includeCache_(includeCache)
+, filePath_(findInputFile(options, index))
 , file_(filePath_)
 , options_(options)
 , includeStack_(includeStack) {
@@ -206,19 +209,29 @@ common::LogStream ParsedFile::logErrorTypeMismatch() {
 	return logError(kErrorTypeMismatch) << "type mismatch: ";
 }
 
-ParsedFile::ModulePtr ParsedFile::readIncluded() {
+std::shared_ptr<const structure::Module> ParsedFile::readIncluded() {
 	if (auto usingFile = assertNextToken(BasicType::String)) {
 		if (assertNextToken(BasicType::Semicolon)) {
+			const auto includedName = tokenValue(usingFile);
+			const auto i = includeCache_.find(includedName);
+			if (i != includeCache_.end()) {
+				return i->second;
+			}
 			auto includeStack = includeStack_;
 			includeStack.push_back(filePath_);
 			ParsedFile included(
-				includedOptions(tokenValue(usingFile)),
+				includeCache_,
+				includedOptions(includedName),
+				0,
 				includeStack);
-			if (included.read()) {
-				return included.getResult();
-			} else {
+			if (!included.read()) {
 				logError(kErrorInIncluded) << "error while parsing '" << tokenValue(usingFile).toStdString() << "'";
+				return nullptr;
 			}
+			return includeCache_.emplace(
+				includedName,
+				included.getResult()
+			).first->second;
 		}
 	}
 	return nullptr;
@@ -843,7 +856,7 @@ BasicToken ParsedFile::assertNextToken(BasicToken::Type type) {
 
 Options ParsedFile::includedOptions(const QString &filepath) {
 	auto result = options_;
-	result.inputPath = filepath;
+	result.inputPaths = QStringList() << filepath;
 	result.includePaths[0] = QFileInfo(filePath_).dir().absolutePath();
 	result.isPalette = (QFileInfo(filepath).suffix() == "palette");
 	return result;
diff --git a/Telegram/codegen/codegen/style/parsed_file.h b/Telegram/codegen/codegen/style/parsed_file.h
index 9b17760..66402bb 100644
--- a/Telegram/codegen/codegen/style/parsed_file.h
+++ b/Telegram/codegen/codegen/style/parsed_file.h
@@ -23,16 +23,17 @@ Modifier GetModifier(const QString &name);
 // Parses an input file to the internal struct.
 class ParsedFile {
 public:
-	explicit ParsedFile(
+	ParsedFile(
+		std::map<QString, std::shared_ptr<const structure::Module>> &includeCache,
 		const Options &options,
+		int index = 0,
 		std::vector<QString> includeStack = {});
 	ParsedFile(const ParsedFile &other) = delete;
 	ParsedFile &operator=(const ParsedFile &other) = delete;
 
 	bool read();
 
-	using ModulePtr = std::unique_ptr<structure::Module>;
-	ModulePtr getResult() {
+	std::unique_ptr<const structure::Module> getResult() {
 		return std::move(module_);
 	}
 
@@ -59,7 +60,7 @@ private:
 	}
 
 	// Helper methods for context-dependent reading.
-	ModulePtr readIncluded();
+	std::shared_ptr<const structure::Module> readIncluded();
 	structure::Struct readStruct(const QString &name);
 	structure::Variable readVariable(const QString &name);
 
@@ -104,11 +105,13 @@ private:
 	// Compose context-dependent full name.
 	structure::FullName composeFullName(const QString &name);
 
+	std::map<QString, std::shared_ptr<const structure::Module>> includeCache_;
+
 	QString filePath_;
 	common::BasicTokenizedFile file_;
 	Options options_;
 	bool failed_ = false;
-	ModulePtr module_;
+	std::unique_ptr<structure::Module> module_;
 
 	std::vector<QString> includeStack_;
 
diff --git a/Telegram/codegen/codegen/style/processor.cpp b/Telegram/codegen/codegen/style/processor.cpp
index 4279ee4..325f66c 100644
--- a/Telegram/codegen/codegen/style/processor.cpp
+++ b/Telegram/codegen/codegen/style/processor.cpp
@@ -25,20 +25,25 @@ QString destFileBaseName(const structure::Module &module) {
 } // namespace
 
 Processor::Processor(const Options &options)
-: parser_(std::make_unique<ParsedFile>(options))
-, options_(options) {
+: options_(options) {
 }
 
 int Processor::launch() {
-	if (!parser_->read()) {
-		return -1;
-	}
+	auto cache = std::map<QString, std::shared_ptr<const structure::Module>>();
+	for (auto i = 0; i != options_.inputPaths.size(); ++i) {
+		auto parser = ParsedFile(cache, options_, i);
+		if (!parser.read()) {
+			return -1;
+		}
 
-	auto module = parser_->getResult();
-	if (!write(*module)) {
+		const auto module = parser.getResult();
+		if (!write(*module)) {
+			return -1;
+		}
+	}
+	if (!common::TouchTimestamp(options_.timestampPath)) {
 		return -1;
 	}
-
 	return 0;
 }
 
@@ -60,10 +65,7 @@ bool Processor::write(const structure::Module &module) const {
 	};
 
 	Generator generator(module, dstFilePath, project, options_.isPalette);
-	if (!generator.writeHeader()) {
-		return false;
-	}
-	if (!generator.writeSource()) {
+	if (!generator.writeHeader() || !generator.writeSource()) {
 		return false;
 	}
 	return true;
diff --git a/Telegram/codegen/codegen/style/processor.h b/Telegram/codegen/codegen/style/processor.h
index c66a718..dd781d6 100644
--- a/Telegram/codegen/codegen/style/processor.h
+++ b/Telegram/codegen/codegen/style/processor.h
@@ -33,7 +33,6 @@ public:
 private:
 	bool write(const structure::Module &module) const;
 
-	std::unique_ptr<ParsedFile> parser_;
 	const Options &options_;
 
 };
diff --git a/Telegram/configure.bat b/Telegram/configure.bat
new file mode 100644
index 000000000..3e38d6ee5
--- /dev/null
+++ b/Telegram/configure.bat
@@ -0,0 +1,12 @@
+@echo OFF
+
+set "FullScriptPath=%~dp0"
+
+python %FullScriptPath%configure.py %*
+if %errorlevel% neq 0 goto error
+
+exit /b
+
+:error
+echo FAILED
+exit /b 1
diff --git a/Telegram/configure.py b/Telegram/configure.py
new file mode 100644
index 000000000..f54118584
--- /dev/null
+++ b/Telegram/configure.py
@@ -0,0 +1,60 @@
+'''
+This file is part of Telegram Desktop,
+the official desktop application for the Telegram messaging service.
+
+For license and copyright information please follow this link:
+https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+'''
+import sys, os, re
+
+sys.dont_write_bytecode = True
+scriptPath = os.path.dirname(os.path.realpath(__file__))
+sys.path.append(scriptPath + '/../cmake')
+import run_cmake
+
+executePath = os.getcwd()
+def finish(code):
+    global executePath
+    os.chdir(executePath)
+    sys.exit(code)
+
+def error(message):
+    print('[ERROR] ' + message)
+    finish(1)
+
+if sys.platform == 'win32' and not 'COMSPEC' in os.environ:
+    error('COMSPEC environment variable is not set.')
+
+executePath = os.getcwd()
+scriptPath = os.path.dirname(os.path.realpath(__file__))
+scriptName = os.path.basename(scriptPath)
+
+arguments = sys.argv[1:]
+
+officialTarget = ''
+officialTargetFile = scriptPath + '/build/target'
+if os.path.isfile(officialTargetFile):
+    with open(officialTargetFile, 'r') as f:
+        for line in f:
+            officialTarget = line.strip()
+
+if officialTarget != '':
+    officialApiIdFile = scriptPath + '/../../DesktopPrivate/custom_api_id.h'
+    if not os.path.isfile(officialApiIdFile):
+        print("[ERROR] DesktopPrivate/custom_api_id.h not found.")
+        finish(1)
+    with open(officialApiIdFile, 'r') as f:
+        for line in f:
+            apiIdMatch = re.search(r'ApiId\s+=\s+(\d+)', line)
+            apiHashMatch = re.search(r'ApiHash\s+=\s+"([a-fA-F\d]+)"', line)
+            if apiIdMatch:
+                arguments.append('-DTDESKTOP_API_ID=' + apiIdMatch.group(1))
+            elif apiHashMatch:
+                arguments.append('-DTDESKTOP_API_HASH=' + apiHashMatch.group(1))
+    finish(run_cmake.run(scriptName, arguments))
+
+if 'linux' in sys.platform:
+    debugCode = run_cmake.run(scriptName, arguments, "Debug")
+    finish(debugCode if debugCode else run_cmake.run(scriptName, arguments, "Release"))
+else:
+    finish(run_cmake.run(scriptName, arguments))
diff --git a/Telegram/configure.sh b/Telegram/configure.sh
new file mode 100755
index 000000000..0f87909a1
--- /dev/null
+++ b/Telegram/configure.sh
@@ -0,0 +1,10 @@
+#!/usr/bin/env bash
+set -e
+
+pushd `dirname $0` > /dev/null
+FullScriptPath=`pwd`
+popd > /dev/null
+
+python $FullScriptPath/configure.py "$@"
+
+exit
diff --git a/Telegram/gyp/Telegram.gyp b/Telegram/gyp/Telegram.gyp
index b141322a9..cc113bdd4 100644
--- a/Telegram/gyp/Telegram.gyp
+++ b/Telegram/gyp/Telegram.gyp
@@ -75,6 +75,7 @@
       '<(submodules_loc)/codegen/codegen.gyp:codegen_style',
       '<(submodules_loc)/lib_base/lib_base.gyp:lib_base',
       '<(submodules_loc)/lib_ui/lib_ui.gyp:lib_ui',
+      '<(submodules_loc)/lib_qr/lib_qr.gyp:lib_qr',
       '<(third_party_loc)/libtgvoip/libtgvoip.gyp:libtgvoip',
       '<(submodules_loc)/lib_lottie/lib_lottie.gyp:lib_lottie',
       'tests/tests.gyp:tests',
@@ -99,7 +100,6 @@
       '<(SHARED_INTERMEDIATE_DIR)',
       '<(libs_loc)/breakpad/src',
       '<(libs_loc)/lzma/C',
-      '<(libs_loc)/zlib',
       '<(libs_loc)/openal-soft/include',
       '<(libs_loc)/opus/include',
       '<(minizip_loc)',
@@ -130,7 +130,7 @@
       ],
     }], [ '"<(special_build_target)" != ""', {
       'defines': [
-        'TDESKTOP_OFFICIAL_TARGET=<(special_build_target)',
+        'TDESKTOP_ALLOW_CLOSED_ALPHA',
         'TDESKTOP_FORCE_GTK_FILE_DIALOG',
       ],
       'dependencies': [
Submodule Telegram/gyp/helpers 1b346350e..5b000acfb:
diff --git a/Telegram/gyp/helpers/common/linux.gypi b/Telegram/gyp/helpers/common/linux.gypi
index 12b91b0..5ec145d 100644
--- a/Telegram/gyp/helpers/common/linux.gypi
+++ b/Telegram/gyp/helpers/common/linux.gypi
@@ -32,7 +32,6 @@
         'linux_path_va%': '/usr/local',
         'linux_path_vdpau%': '/usr/local',
         'linux_path_breakpad%': '/usr/local',
-        'linux_path_opus_include%': '<(libs_loc)/opus/include',
         'linux_path_range%': '/usr/local',
       },
       'include_dirs': [
@@ -40,7 +39,6 @@
         '<(linux_path_ffmpeg)/include',
         '<(linux_path_openal)/include',
         '<(linux_path_breakpad)/include/breakpad',
-        '<(linux_path_opus_include)',
         '<(linux_path_range)/include',
       ],
       'library_dirs': [
@@ -70,7 +68,7 @@
               'sources': [ '__Wrong_Special_Build_Target_<(special_build_target)_' ],
             }],
           ],
-        }], [ '"<!(uname -p)" == "x86_64"', {
+        }], [ '"<!(uname -m)" == "x86_64"', {
           # 32 bit version can't be linked with debug info or LTO,
           # virtual memory exhausted :(
           'cflags_c': [ '-g' ],
diff --git a/Telegram/gyp/lib_ffmpeg.gyp b/Telegram/gyp/lib_ffmpeg.gyp
index 306da12f6..87359f865 100644
--- a/Telegram/gyp/lib_ffmpeg.gyp
+++ b/Telegram/gyp/lib_ffmpeg.gyp
@@ -42,7 +42,7 @@
     ],
     'conditions': [[ '"<(special_build_target)" != ""', {
       'defines': [
-        'TDESKTOP_OFFICIAL_TARGET=<(special_build_target)',
+        'LIB_FFMPEG_USE_QT_PRIVATE_API',
       ],
     }]],
   }],
diff --git a/Telegram/gyp/lib_mtproto.gyp b/Telegram/gyp/lib_mtproto.gyp
index 5344f6e10..5ca1ad191 100644
--- a/Telegram/gyp/lib_mtproto.gyp
+++ b/Telegram/gyp/lib_mtproto.gyp
@@ -19,8 +19,8 @@
     'variables': {
       'src_loc': '../SourceFiles',
       'res_loc': '../Resources',
-      'pch_source': '<(src_loc)/mtproto/mtp_pch.cpp',
-      'pch_header': '<(src_loc)/mtproto/mtp_pch.h',
+      'pch_source': '<(src_loc)/mtproto/mtproto_pch.cpp',
+      'pch_header': '<(src_loc)/mtproto/mtproto_pch.h',
     },
     'defines': [
     ],
@@ -34,12 +34,40 @@
       '<(src_loc)',
     ],
     'sources': [
-      '<(src_loc)/mtproto/mtp_abstract_socket.cpp',
-      '<(src_loc)/mtproto/mtp_abstract_socket.h',
-      '<(src_loc)/mtproto/mtp_tcp_socket.cpp',
-      '<(src_loc)/mtproto/mtp_tcp_socket.h',
-      '<(src_loc)/mtproto/mtp_tls_socket.cpp',
-      '<(src_loc)/mtproto/mtp_tls_socket.h',
+      '<(src_loc)/mtproto/details/mtproto_abstract_socket.cpp',
+      '<(src_loc)/mtproto/details/mtproto_abstract_socket.h',
+      '<(src_loc)/mtproto/details/mtproto_bound_key_creator.cpp',
+      '<(src_loc)/mtproto/details/mtproto_bound_key_creator.h',
+      '<(src_loc)/mtproto/details/mtproto_dc_key_binder.cpp',
+      '<(src_loc)/mtproto/details/mtproto_dc_key_binder.h',
+      '<(src_loc)/mtproto/details/mtproto_dc_key_creator.cpp',
+      '<(src_loc)/mtproto/details/mtproto_dc_key_creator.h',
+      '<(src_loc)/mtproto/details/mtproto_dcenter.cpp',
+      '<(src_loc)/mtproto/details/mtproto_dcenter.h',
+      '<(src_loc)/mtproto/details/mtproto_domain_resolver.cpp',
+      '<(src_loc)/mtproto/details/mtproto_domain_resolver.h',
+      '<(src_loc)/mtproto/details/mtproto_dump_to_text.cpp',
+      '<(src_loc)/mtproto/details/mtproto_dump_to_text.h',
+      '<(src_loc)/mtproto/details/mtproto_received_ids_manager.cpp',
+      '<(src_loc)/mtproto/details/mtproto_received_ids_manager.h',
+      '<(src_loc)/mtproto/details/mtproto_rsa_public_key.cpp',
+      '<(src_loc)/mtproto/details/mtproto_rsa_public_key.h',
+      '<(src_loc)/mtproto/details/mtproto_serialized_request.cpp',
+      '<(src_loc)/mtproto/details/mtproto_serialized_request.h',
+      '<(src_loc)/mtproto/details/mtproto_tcp_socket.cpp',
+      '<(src_loc)/mtproto/details/mtproto_tcp_socket.h',
+      '<(src_loc)/mtproto/details/mtproto_tls_socket.cpp',
+      '<(src_loc)/mtproto/details/mtproto_tls_socket.h',
+      '<(src_loc)/mtproto/mtproto_auth_key.cpp',
+      '<(src_loc)/mtproto/mtproto_auth_key.h',
+      '<(src_loc)/mtproto/mtproto_concurrent_sender.cpp',
+      '<(src_loc)/mtproto/mtproto_concurrent_sender.h',
+      '<(src_loc)/mtproto/mtproto_dh_utils.cpp',
+      '<(src_loc)/mtproto/mtproto_dh_utils.h',
+      '<(src_loc)/mtproto/mtproto_proxy_data.cpp',
+      '<(src_loc)/mtproto/mtproto_proxy_data.h',
+      '<(src_loc)/mtproto/mtproto_rpc_sender.cpp',
+      '<(src_loc)/mtproto/mtproto_rpc_sender.h',
     ],
   }],
 }
diff --git a/Telegram/gyp/lib_scheme.gyp b/Telegram/gyp/lib_scheme.gyp
index 265c27a3f..2975bc30f 100644
--- a/Telegram/gyp/lib_scheme.gyp
+++ b/Telegram/gyp/lib_scheme.gyp
@@ -50,6 +50,8 @@
       'outputs': [
         '<(SHARED_INTERMEDIATE_DIR)/scheme.cpp',
         '<(SHARED_INTERMEDIATE_DIR)/scheme.h',
+        '<(SHARED_INTERMEDIATE_DIR)/scheme-dump_to_text.cpp',
+        '<(SHARED_INTERMEDIATE_DIR)/scheme-dump_to_text.h',
       ],
       'action': [
         'python', '<(src_loc)/codegen/scheme/codegen_scheme.py',
diff --git a/Telegram/gyp/telegram/linux.gypi b/Telegram/gyp/telegram/linux.gypi
index ba6bc45e8..59f6acc93 100644
--- a/Telegram/gyp/telegram/linux.gypi
+++ b/Telegram/gyp/telegram/linux.gypi
@@ -71,15 +71,18 @@
       },
     },
     'conditions': [
-      [ '"<!(uname -p)" != "x86_64"', {
+      [ '"<!(uname -m)" != "x86_64"', {
         'ldflags': [
           '-Wl,-wrap,__divmoddi4',
         ],
+      }, {
+        'ldflags': [
+          '-Wl,-wrap,__divmodti4',
+        ],
       }], ['not_need_gtk!="True"', {
         'cflags_cc': [
           '<!(pkg-config 2> /dev/null --cflags gtk+-2.0)',
           '<!(pkg-config 2> /dev/null --cflags glib-2.0)',
-          '<!(pkg-config 2> /dev/null --cflags dee-1.0)',
         ],
       }], ['<!(pkg-config ayatana-appindicator3-0.1; echo $?) == 0', {
         'cflags_cc': [ '<!(pkg-config --cflags ayatana-appindicator3-0.1)' ],
diff --git a/Telegram/gyp/telegram/sources.txt b/Telegram/gyp/telegram/sources.txt
index e3ccb66db..05d4936e5 100644
--- a/Telegram/gyp/telegram/sources.txt
+++ b/Telegram/gyp/telegram/sources.txt
@@ -438,18 +438,22 @@
 <(src_loc)/inline_bots/inline_bot_send_data.h
 <(src_loc)/inline_bots/inline_results_widget.cpp
 <(src_loc)/inline_bots/inline_results_widget.h
-<(src_loc)/intro/introwidget.cpp
-<(src_loc)/intro/introwidget.h
-<(src_loc)/intro/introcode.cpp
-<(src_loc)/intro/introcode.h
-<(src_loc)/intro/introphone.cpp
-<(src_loc)/intro/introphone.h
-<(src_loc)/intro/intropwdcheck.cpp
-<(src_loc)/intro/intropwdcheck.h
-<(src_loc)/intro/introsignup.cpp
-<(src_loc)/intro/introsignup.h
-<(src_loc)/intro/introstart.cpp
-<(src_loc)/intro/introstart.h
+<(src_loc)/intro/intro_code.cpp
+<(src_loc)/intro/intro_code.h
+<(src_loc)/intro/intro_password_check.cpp
+<(src_loc)/intro/intro_password_check.h
+<(src_loc)/intro/intro_phone.cpp
+<(src_loc)/intro/intro_phone.h
+<(src_loc)/intro/intro_qr.cpp
+<(src_loc)/intro/intro_qr.h
+<(src_loc)/intro/intro_signup.cpp
+<(src_loc)/intro/intro_signup.h
+<(src_loc)/intro/intro_start.cpp
+<(src_loc)/intro/intro_start.h
+<(src_loc)/intro/intro_step.cpp
+<(src_loc)/intro/intro_step.h
+<(src_loc)/intro/intro_widget.cpp
+<(src_loc)/intro/intro_widget.h
 <(src_loc)/lang/lang_cloud_manager.cpp
 <(src_loc)/lang/lang_cloud_manager.h
 <(src_loc)/lang/lang_file_parser.cpp
@@ -514,6 +518,8 @@
 <(src_loc)/media/streaming/media_streaming_audio_track.cpp
 <(src_loc)/media/streaming/media_streaming_audio_track.h
 <(src_loc)/media/streaming/media_streaming_common.h
+<(src_loc)/media/streaming/media_streaming_document.cpp
+<(src_loc)/media/streaming/media_streaming_document.h
 <(src_loc)/media/streaming/media_streaming_file.cpp
 <(src_loc)/media/streaming/media_streaming_file.h
 <(src_loc)/media/streaming/media_streaming_file_delegate.h
@@ -539,14 +545,8 @@
 <(src_loc)/media/view/media_view_group_thumbs.h
 <(src_loc)/media/view/media_view_overlay_widget.cpp
 <(src_loc)/media/view/media_view_overlay_widget.h
-<(src_loc)/mtproto/auth_key.cpp
-<(src_loc)/mtproto/auth_key.h
-<(src_loc)/mtproto/concurrent_sender.cpp
-<(src_loc)/mtproto/concurrent_sender.h
 <(src_loc)/mtproto/config_loader.cpp
 <(src_loc)/mtproto/config_loader.h
-<(src_loc)/mtproto/connection.cpp
-<(src_loc)/mtproto/connection.h
 <(src_loc)/mtproto/connection_abstract.cpp
 <(src_loc)/mtproto/connection_abstract.h
 <(src_loc)/mtproto/connection_http.cpp
@@ -555,10 +555,7 @@
 <(src_loc)/mtproto/connection_resolving.h
 <(src_loc)/mtproto/connection_tcp.cpp
 <(src_loc)/mtproto/connection_tcp.h
-<(src_loc)/mtproto/core_types.cpp
 <(src_loc)/mtproto/core_types.h
-<(src_loc)/mtproto/dcenter.cpp
-<(src_loc)/mtproto/dcenter.h
 <(src_loc)/mtproto/dc_options.cpp
 <(src_loc)/mtproto/dc_options.h
 <(src_loc)/mtproto/dedicated_file_loader.cpp
@@ -567,13 +564,11 @@
 <(src_loc)/mtproto/facade.h
 <(src_loc)/mtproto/mtp_instance.cpp
 <(src_loc)/mtproto/mtp_instance.h
-<(src_loc)/mtproto/rsa_public_key.cpp
-<(src_loc)/mtproto/rsa_public_key.h
-<(src_loc)/mtproto/rpc_sender.cpp
-<(src_loc)/mtproto/rpc_sender.h
 <(src_loc)/mtproto/sender.h
 <(src_loc)/mtproto/session.cpp
 <(src_loc)/mtproto/session.h
+<(src_loc)/mtproto/session_private.cpp
+<(src_loc)/mtproto/session_private.h
 <(src_loc)/mtproto/special_config_request.cpp
 <(src_loc)/mtproto/special_config_request.h
 <(src_loc)/mtproto/type_utils.h
@@ -605,8 +600,6 @@
 <(src_loc)/platform/linux/linux_desktop_environment.h
 <(src_loc)/platform/linux/linux_gdk_helper.cpp
 <(src_loc)/platform/linux/linux_gdk_helper.h
-<(src_loc)/platform/linux/linux_libnotify.cpp
-<(src_loc)/platform/linux/linux_libnotify.h
 <(src_loc)/platform/linux/linux_libs.cpp
 <(src_loc)/platform/linux/linux_libs.h
 <(src_loc)/platform/linux/file_utilities_linux.cpp
@@ -698,8 +691,14 @@
 <(src_loc)/settings/settings_privacy_controllers.h
 <(src_loc)/settings/settings_privacy_security.cpp
 <(src_loc)/settings/settings_privacy_security.h
+<(src_loc)/storage/download_manager_mtproto.cpp
+<(src_loc)/storage/download_manager_mtproto.h
 <(src_loc)/storage/file_download.cpp
 <(src_loc)/storage/file_download.h
+<(src_loc)/storage/file_download_mtproto.cpp
+<(src_loc)/storage/file_download_mtproto.h
+<(src_loc)/storage/file_download_web.cpp
+<(src_loc)/storage/file_download_web.h
 <(src_loc)/storage/file_upload.cpp
 <(src_loc)/storage/file_upload.h
 <(src_loc)/storage/localimageloader.cpp
diff --git a/Telegram/gyp/utils.gyp b/Telegram/gyp/utils.gyp
index 7d5dafaba..3669236f0 100644
--- a/Telegram/gyp/utils.gyp
+++ b/Telegram/gyp/utils.gyp
@@ -22,7 +22,7 @@
       '<(src_loc)',
     ],
     'sources': [
-      '<(src_loc)/_other/updater.cpp',
+      '<(src_loc)/_other/updater_win.cpp',
       '<(src_loc)/_other/updater.h',
       '<(src_loc)/_other/updater_linux.cpp',
       '<(src_loc)/_other/updater_osx.m',
@@ -49,7 +49,7 @@
       }],
       [ '"<(build_win)" != "1"', {
         'sources!': [
-          '<(src_loc)/_other/updater.cpp',
+          '<(src_loc)/_other/updater_win.cpp',
         ],
       }],
     ],
Submodule Telegram/lib_base a94ad7f81..78690f858:
diff --git a/Telegram/lib_base/CMakeLists.txt b/Telegram/lib_base/CMakeLists.txt
new file mode 100644
index 0000000..68473e8
--- /dev/null
+++ b/Telegram/lib_base/CMakeLists.txt
@@ -0,0 +1,165 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+add_library(lib_base OBJECT)
+add_library(desktop-app::lib_base ALIAS lib_base)
+init_target(lib_base)
+
+add_library(lib_base_crash_report_writer OBJECT)
+add_library(desktop-app::lib_base_crash_report_writer ALIAS lib_base_crash_report_writer)
+init_target(lib_base_crash_report_writer)
+
+get_filename_component(src_loc . REALPATH)
+
+target_precompile_headers(lib_base PRIVATE ${src_loc}/base/base_pch.h)
+nice_target_sources(lib_base ${src_loc}
+PRIVATE
+    base/platform/linux/base_file_utilities_linux.cpp
+    base/platform/linux/base_file_utilities_linux.h
+    base/platform/linux/base_info_linux.cpp
+    base/platform/linux/base_info_linux.h
+    base/platform/linux/base_last_input_linux.cpp
+    base/platform/linux/base_last_input_linux.h
+    base/platform/linux/base_layout_switch_linux.cpp
+    base/platform/linux/base_layout_switch_linux.h
+    base/platform/linux/base_process_linux.cpp
+    base/platform/linux/base_process_linux.h
+    base/platform/linux/base_url_scheme_linux.cpp
+    base/platform/linux/base_url_scheme_linux.h
+    base/platform/mac/base_file_utilities_mac.h
+    base/platform/mac/base_file_utilities_mac.mm
+    base/platform/mac/base_info_mac.h
+    base/platform/mac/base_info_mac.mm
+    base/platform/mac/base_last_input_mac.h
+    base/platform/mac/base_last_input_mac.mm
+    base/platform/mac/base_layout_switch_mac.h
+    base/platform/mac/base_layout_switch_mac.mm
+    base/platform/mac/base_process_mac.h
+    base/platform/mac/base_process_mac.mm
+    base/platform/mac/base_url_scheme_mac.h
+    base/platform/mac/base_url_scheme_mac.mm
+    base/platform/mac/base_utilities_mac.h
+    base/platform/mac/base_utilities_mac.mm
+    base/platform/win/base_file_utilities_win.cpp
+    base/platform/win/base_file_utilities_win.h
+    base/platform/win/base_info_win.cpp
+    base/platform/win/base_info_win.h
+    base/platform/win/base_last_input_win.cpp
+    base/platform/win/base_last_input_win.h
+    base/platform/win/base_layout_switch_win.cpp
+    base/platform/win/base_layout_switch_win.h
+    base/platform/win/base_process_win.cpp
+    base/platform/win/base_process_win.h
+    base/platform/win/base_url_scheme_win.cpp
+    base/platform/win/base_url_scheme_win.h
+    base/platform/win/base_windows_h.h
+    base/platform/base_platform_info.h
+    base/platform/base_platform_last_input.h
+    base/platform/base_platform_layout_switch.h
+    base/platform/base_platform_file_utilities.h
+    base/platform/base_platform_process.h
+    base/platform/base_platform_url_scheme.h
+    base/algorithm.h
+    base/assertion.cpp
+    base/assertion.h
+    base/basic_types.h
+    base/binary_guard.h
+    base/build_config.h
+    base/bytes.h
+    base/call_delayed.cpp
+    base/call_delayed.h
+    base/crc32hash.cpp
+    base/crc32hash.h
+    base/concurrent_timer.cpp
+    base/concurrent_timer.h
+    base/flags.h
+    base/enum_mask.h
+    base/expected.h
+    base/event_filter.cpp
+    base/event_filter.h
+    base/base_file_utilities.cpp
+    base/base_file_utilities.h
+    base/file_lock.h
+    base/file_lock_win.cpp
+    base/file_lock_posix.cpp
+    base/flat_map.h
+    base/flat_set.h
+    base/functors.h
+    base/index_based_iterator.h
+    base/integration.cpp
+    base/integration.h
+    base/invoke_queued.h
+    base/last_used_cache.h
+    base/last_user_input.cpp
+    base/last_user_input.h
+    base/match_method.h
+    base/object_ptr.h
+    base/observer.cpp
+    base/observer.h
+    base/ordered_set.h
+    base/openssl_help.h
+    base/optional.h
+    base/overload.h
+    base/parse_helper.cpp
+    base/parse_helper.h
+    base/qthelp_regex.h
+    base/qthelp_url.cpp
+    base/qthelp_url.h
+    base/qt_connection.h
+    base/qt_signal_producer.h
+    base/runtime_composer.cpp
+    base/runtime_composer.h
+    base/single_instance.cpp
+    base/single_instance.h
+    base/thread_safe_wrap.h
+    base/timer.cpp
+    base/timer.h
+    base/timer_rpl.h
+    base/type_traits.h
+    base/unique_any.h
+    base/unique_function.h
+    base/unique_qptr.h
+    base/unixtime.cpp
+    base/unixtime.h
+    base/value_ordering.h
+    base/variant.h
+    base/virtual_method.h
+    base/weak_ptr.h
+    base/zlib_help.h
+)
+
+target_include_directories(lib_base
+PUBLIC
+    ${src_loc}
+)
+
+target_link_libraries(lib_base
+PUBLIC
+    desktop-app::lib_rpl
+    desktop-app::lib_crl
+    desktop-app::external_qt
+    desktop-app::external_openssl
+    desktop-app::external_crash_reports
+    desktop-app::external_variant
+    desktop-app::external_ranges
+    desktop-app::external_gsl
+    desktop-app::external_expected
+)
+
+if (DESKTOP_APP_USE_GLIBC_WRAPS)
+    target_link_libraries(lib_base PUBLIC desktop-app::linux_glibc_wraps)
+endif()
+
+target_precompile_headers(lib_base_crash_report_writer PRIVATE ${src_loc}/base/base_pch.h)
+nice_target_sources(lib_base_crash_report_writer ${src_loc}
+PRIVATE
+    base/crash_report_header.cpp
+    base/crash_report_header.h
+    base/crash_report_writer.cpp
+    base/crash_report_writer.h
+)
+
+target_link_libraries(lib_base_crash_report_writer PUBLIC desktop-app::lib_base)
diff --git a/Telegram/lib_base/base/assertion.h b/Telegram/lib_base/base/assertion.h
index cfb6b74..c336dfe 100644
--- a/Telegram/lib_base/base/assertion.h
+++ b/Telegram/lib_base/base/assertion.h
@@ -11,7 +11,8 @@
 // Ensures/Expects.
 #include <gsl/gsl_assert>
 
-namespace base::assertion {
+namespace base {
+namespace assertion {
 
 void log(const char *message, const char *file, int line);
 
@@ -40,7 +41,8 @@ constexpr const char* extract_basename(const char* path, size_t size) {
 	return path + size;
 }
 
-} // namespace base::assertion
+} // namespace assertion
+} // namespace base
 
 #if defined(__clang__) || defined(__GNUC__)
 #define AssertUnlikelyHelper(x) __builtin_expect(!!(x), 0)
diff --git a/Telegram/lib_base/base/crash_report_writer.cpp b/Telegram/lib_base/base/crash_report_writer.cpp
index 6460319..963a720 100644
--- a/Telegram/lib_base/base/crash_report_writer.cpp
+++ b/Telegram/lib_base/base/crash_report_writer.cpp
@@ -200,7 +200,7 @@ void SignalHandler(int signum) {
 	_write(ReportFileNo, ReportHeaderBytes(), ReportHeaderLength());
 	_close(ReportFileNo);
 #else // Q_OS_WIN
-	write(ReportFileNo, ReportHeaderBytes(), ReportHeaderLength());
+	[[maybe_unused]] auto result_ = write(ReportFileNo, ReportHeaderBytes(), ReportHeaderLength());
 	close(ReportFileNo);
 #endif // Q_OS_WIN
 	ReportFileNo = -1;
@@ -209,11 +209,14 @@ void SignalHandler(int signum) {
 	if (BreakpadDumpId) {
 		FinalReportPath.append(BreakpadDumpId);
 		FinalReportPath.append(L".txt");
-		const auto handle = _wopen(
+		auto handle = int();
+		const auto errcode = _wsopen_s(
+			&handle,
 			FinalReportPath.c_str(),
 			_O_WRONLY | _O_CREAT | _O_TRUNC | _O_BINARY,
+			_SH_DENYWR,
 			_S_IWRITE);
-		if (handle >= 0) {
+		if (!errcode) {
 			_write(handle, ReportHeaderBytes(), ReportHeaderLength());
 			_close(handle);
 		}
@@ -231,7 +234,7 @@ void SignalHandler(int signum) {
 			O_WRONLY | O_CREAT | O_TRUNC,
 			S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
 		if (handle >= 0) {
-			write(handle, ReportHeaderBytes(), ReportHeaderLength());
+			[[maybe_unused]] auto result_ = write(handle, ReportHeaderBytes(), ReportHeaderLength());
 			close(handle);
 		}
 	}
diff --git a/Telegram/lib_base/base/expected.h b/Telegram/lib_base/base/expected.h
new file mode 100644
index 0000000..382be4a
--- /dev/null
+++ b/Telegram/lib_base/base/expected.h
@@ -0,0 +1,17 @@
+// This file is part of Desktop App Toolkit,
+// a set of libraries for developing nice desktop applications.
+//
+// For license and copyright information please follow this link:
+// https://github.com/desktop-app/legal/blob/master/LEGAL
+//
+#pragma once
+
+#include <tl/expected.hpp>
+
+namespace base {
+
+using ::tl::expected;
+using ::tl::unexpected;
+using ::tl::make_unexpected;
+
+} // namespace base
diff --git a/Telegram/lib_base/base/flat_map.h b/Telegram/lib_base/base/flat_map.h
index 42c4899..388b7d2 100644
--- a/Telegram/lib_base/base/flat_map.h
+++ b/Telegram/lib_base/base/flat_map.h
@@ -840,7 +840,7 @@ public:
 		}
 		auto result = std::move(it->second);
 		this->erase(it);
-		return std::move(result);
+		return result;
 	}
 
 private:
diff --git a/Telegram/lib_base/base/openssl_help.h b/Telegram/lib_base/base/openssl_help.h
index 9346426..c25b820 100644
--- a/Telegram/lib_base/base/openssl_help.h
+++ b/Telegram/lib_base/base/openssl_help.h
@@ -19,6 +19,9 @@ extern "C" {
 #include <openssl/crypto.h>
 #include <openssl/evp.h>
 #include <openssl/hmac.h>
+#include <openssl/rsa.h>
+#include <openssl/pem.h>
+#include <openssl/err.h>
 } // extern "C"
 
 #ifdef small
@@ -412,13 +415,25 @@ inline void ShaUpdate(Context context, Method method, Arg &&arg, Args &&...args)
 }
 
 template <size_type Size, typename Method>
-inline bytes::vector Sha(Method method, bytes::const_span data) {
-	auto result = bytes::vector(Size);
+inline void Sha(
+		bytes::span dst,
+		Method method,
+		bytes::const_span data) {
+	Expects(dst.size() >= Size);
+
 	method(
 		reinterpret_cast<const unsigned char*>(data.data()),
 		data.size(),
-		reinterpret_cast<unsigned char*>(result.data()));
-	return result;
+		reinterpret_cast<unsigned char*>(dst.data()));
+}
+
+template <size_type Size, typename Method>
+[[nodiscard]] inline bytes::vector Sha(
+		Method method,
+		bytes::const_span data) {
+	auto bytes = bytes::vector(Size);
+	Sha<Size>(bytes, method, data);
+	return bytes;
 }
 
 template <
@@ -429,25 +444,25 @@ template <
 	typename Finalize,
 	typename ...Args,
 	typename = std::enable_if_t<(sizeof...(Args) > 1)>>
-bytes::vector Sha(
+[[nodiscard]] bytes::vector Sha(
 		Context context,
 		Init init,
 		Update update,
 		Finalize finalize,
 		Args &&...args) {
-	auto result = bytes::vector(Size);
+	auto bytes = bytes::vector(Size);
 
 	init(&context);
 	ShaUpdate(&context, update, args...);
-	finalize(reinterpret_cast<unsigned char*>(result.data()), &context);
+	finalize(reinterpret_cast<unsigned char*>(bytes.data()), &context);
 
-	return result;
+	return bytes;
 }
 
 template <
 	size_type Size,
 	typename Evp>
-bytes::vector Pbkdf2(
+[[nodiscard]] bytes::vector Pbkdf2(
 		bytes::const_span password,
 		bytes::const_span salt,
 		int iterations,
@@ -471,14 +486,18 @@ constexpr auto kSha1Size = size_type(SHA_DIGEST_LENGTH);
 constexpr auto kSha256Size = size_type(SHA256_DIGEST_LENGTH);
 constexpr auto kSha512Size = size_type(SHA512_DIGEST_LENGTH);
 
-inline bytes::vector Sha1(bytes::const_span data) {
+[[nodiscard]] inline bytes::vector Sha1(bytes::const_span data) {
 	return details::Sha<kSha1Size>(SHA1, data);
 }
 
+inline void Sha1To(bytes::span dst, bytes::const_span data) {
+	details::Sha<kSha1Size>(dst, SHA1, data);
+}
+
 template <
 	typename ...Args,
 	typename = std::enable_if_t<(sizeof...(Args) > 1)>>
-inline bytes::vector Sha1(Args &&...args) {
+[[nodiscard]] inline bytes::vector Sha1(Args &&...args) {
 	return details::Sha<kSha1Size>(
 		SHA_CTX(),
 		SHA1_Init,
@@ -487,14 +506,18 @@ inline bytes::vector Sha1(Args &&...args) {
 		args...);
 }
 
-inline bytes::vector Sha256(bytes::const_span data) {
+[[nodiscard]] inline bytes::vector Sha256(bytes::const_span data) {
 	return details::Sha<kSha256Size>(SHA256, data);
 }
 
+inline void Sha256To(bytes::span dst, bytes::const_span data) {
+	details::Sha<kSha256Size>(dst, SHA256, data);
+}
+
 template <
 	typename ...Args,
 	typename = std::enable_if_t<(sizeof...(Args) > 1)>>
-inline bytes::vector Sha256(Args &&...args) {
+[[nodiscard]] inline bytes::vector Sha256(Args &&...args) {
 	return details::Sha<kSha256Size>(
 		SHA256_CTX(),
 		SHA256_Init,
@@ -503,14 +526,18 @@ inline bytes::vector Sha256(Args &&...args) {
 		args...);
 }
 
-inline bytes::vector Sha512(bytes::const_span data) {
+[[nodiscard]] inline bytes::vector Sha512(bytes::const_span data) {
 	return details::Sha<kSha512Size>(SHA512, data);
 }
 
+inline void Sha512To(bytes::span dst, bytes::const_span data) {
+	details::Sha<kSha512Size>(dst, SHA512, data);
+}
+
 template <
 	typename ...Args,
 	typename = std::enable_if_t<(sizeof...(Args) > 1)>>
-inline bytes::vector Sha512(Args &&...args) {
+[[nodiscard]] inline bytes::vector Sha512(Args &&...args) {
 	return details::Sha<kSha512Size>(
 		SHA512_CTX(),
 		SHA512_Init,
@@ -570,9 +597,11 @@ inline bytes::vector HmacSha256(
 namespace bytes {
 
 inline void set_random(span destination) {
-	RAND_bytes(
-		reinterpret_cast<unsigned char*>(destination.data()),
-		destination.size());
+	if (!destination.empty()) {
+		RAND_bytes(
+			reinterpret_cast<unsigned char*>(destination.data()),
+			destination.size());
+	}
 }
 
 } // namespace bytes
diff --git a/Telegram/lib_base/base/variant.h b/Telegram/lib_base/base/variant.h
index ac83b3e..f011c9d 100644
--- a/Telegram/lib_base/base/variant.h
+++ b/Telegram/lib_base/base/variant.h
@@ -35,8 +35,7 @@ inline bool operator!=(std::nullopt_t, std::nullopt_t) {
 // We use base::variant<> alias and base::get_if() helper while we don't have std::variant<>.
 namespace base {
 
-template <typename... Types>
-using variant = mapbox::util::variant<Types...>;
+using ::mapbox::util::variant;
 
 template <typename T, typename... Types>
 inline T *get_if(variant<Types...> *v) {
diff --git a/Telegram/lib_base/gyp/sources.txt b/Telegram/lib_base/gyp/sources.txt
index bd5293d..10bd4f4 100644
--- a/Telegram/lib_base/gyp/sources.txt
+++ b/Telegram/lib_base/gyp/sources.txt
@@ -64,6 +64,7 @@
 <(src_loc)/base/enum_mask.h
 <(src_loc)/base/event_filter.cpp
 <(src_loc)/base/event_filter.h
+<(src_loc)/base/expected.h
 <(src_loc)/base/base_file_utilities.cpp
 <(src_loc)/base/base_file_utilities.h
 <(src_loc)/base/flat_map.h
diff --git a/Telegram/lib_base/lib_base.gyp b/Telegram/lib_base/lib_base.gyp
index 4aa591e..3278b66 100644
--- a/Telegram/lib_base/lib_base.gyp
+++ b/Telegram/lib_base/lib_base.gyp
@@ -37,17 +37,23 @@
       '<(libs_loc)/breakpad/src',
       '<(libs_loc)/crashpad',
       '<(libs_loc)/crashpad/third_party/mini_chromium/mini_chromium',
+      '<(libs_loc)/zlib',
+      '<(third_party_loc)/minizip',
       '<(submodules_loc)/lib_rpl',
       '<(third_party_loc)/GSL/include',
       '<(third_party_loc)/variant/include',
+      '<(third_party_loc)/expected/include',
     ],
     'direct_dependent_settings': {
       'include_dirs': [
         '<(src_loc)',
         '<(libs_loc)/range-v3/include',
+        '<(libs_loc)/zlib',
+        '<(third_party_loc)/minizip',
         '<(submodules_loc)/lib_rpl',
         '<(third_party_loc)/GSL/include',
         '<(third_party_loc)/variant/include',
+        '<(third_party_loc)/expected/include',
       ],
     },
     'sources': [
Submodule Telegram/lib_crl 440d088d5..5a740bf0b:
diff --git a/Telegram/lib_crl/CMakeLists.txt b/Telegram/lib_crl/CMakeLists.txt
new file mode 100644
index 0000000..d241fb6
--- /dev/null
+++ b/Telegram/lib_crl/CMakeLists.txt
@@ -0,0 +1,67 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+add_library(lib_crl OBJECT)
+add_library(desktop-app::lib_crl ALIAS lib_crl)
+init_target(lib_crl)
+
+get_filename_component(src_loc . REALPATH)
+
+nice_target_sources(lib_crl ${src_loc}
+PRIVATE
+    crl/common/crl_common_config.h
+    crl/common/crl_common_guards.h
+    crl/common/crl_common_list.cpp
+    crl/common/crl_common_list.h
+    crl/common/crl_common_on_main.cpp
+    crl/common/crl_common_on_main.h
+    crl/common/crl_common_on_main_guarded.h
+    crl/common/crl_common_queue.cpp
+    crl/common/crl_common_queue.h
+    crl/common/crl_common_sync.h
+    crl/common/crl_common_utils.h
+    crl/dispatch/crl_dispatch_async.cpp
+    crl/dispatch/crl_dispatch_async.h
+    crl/dispatch/crl_dispatch_on_main.h
+    crl/dispatch/crl_dispatch_queue.cpp
+    crl/dispatch/crl_dispatch_queue.h
+    crl/dispatch/crl_dispatch_semaphore.cpp
+    crl/dispatch/crl_dispatch_semaphore.h
+    crl/mac/crl_mac_time.cpp
+    crl/linux/crl_linux_time.cpp
+    crl/qt/crl_qt_async.cpp
+    crl/qt/crl_qt_async.h
+    crl/qt/crl_qt_guards.h
+    crl/qt/crl_qt_semaphore.cpp
+    crl/qt/crl_qt_semaphore.h
+    crl/winapi/crl_winapi_async.cpp
+    crl/winapi/crl_winapi_async.h
+    crl/winapi/crl_winapi_dll.h
+    crl/winapi/crl_winapi_list.cpp
+    crl/winapi/crl_winapi_list.h
+    crl/winapi/crl_winapi_semaphore.cpp
+    crl/winapi/crl_winapi_semaphore.h
+    crl/winapi/crl_winapi_time.cpp
+    crl/winapi/crl_winapi_windows_h.h
+    crl/crl.h
+    crl/crl_async.h
+    crl/crl_object_on_queue.h
+    crl/crl_on_main.h
+    crl/crl_queue.h
+    crl/crl_semaphore.h
+    crl/crl_time.cpp
+    crl/crl_time.h
+)
+
+target_include_directories(lib_crl
+PUBLIC
+    ${src_loc}
+)
+
+target_link_libraries(lib_crl
+PUBLIC
+    desktop-app::external_qt
+)
diff --git a/Telegram/lib_crl/crl/common/crl_common_on_main_guarded.h b/Telegram/lib_crl/crl/common/crl_common_on_main_guarded.h
index f1314f8..f6bf6eb 100644
--- a/Telegram/lib_crl/crl/common/crl_common_on_main_guarded.h
+++ b/Telegram/lib_crl/crl/common/crl_common_on_main_guarded.h
@@ -11,14 +11,13 @@
 #include <memory>
 #include <type_traits>
 
-namespace crl::details {
+namespace crl {
+namespace details {
 
 template <typename T>
 constexpr std::size_t dependent_zero = 0;
 
-} // namespace crl::details
-
-namespace crl {
+} // namespace details
 
 template <typename T, typename Enable = void>
 struct guard_traits;
Submodule Telegram/lib_lottie 6debd5de4..a0a0269ff:
diff --git a/Telegram/lib_lottie/CMakeLists.txt b/Telegram/lib_lottie/CMakeLists.txt
new file mode 100644
index 0000000..036f550
--- /dev/null
+++ b/Telegram/lib_lottie/CMakeLists.txt
@@ -0,0 +1,50 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+add_library(lib_lottie OBJECT)
+add_library(desktop-app::lib_lottie ALIAS lib_lottie)
+init_target(lib_lottie)
+
+get_filename_component(src_loc . REALPATH)
+
+nice_target_sources(lib_lottie ${src_loc}
+PRIVATE
+    lottie/lottie_animation.cpp
+    lottie/lottie_animation.h
+    lottie/lottie_cache.cpp
+    lottie/lottie_cache.h
+    lottie/lottie_common.cpp
+    lottie/lottie_common.h
+    lottie/lottie_frame_renderer.cpp
+    lottie/lottie_frame_renderer.h
+    lottie/lottie_multi_player.cpp
+    lottie/lottie_multi_player.h
+    lottie/lottie_player.h
+    lottie/lottie_single_player.cpp
+    lottie/lottie_single_player.h
+)
+
+if (DESKTOP_APP_LOTTIE_USE_CACHE)
+    target_compile_definitions(lib_lottie PUBLIC LOTTIE_USE_CACHE)
+    target_link_libraries(lib_lottie
+    PUBLIC
+        desktop-app::lib_ffmpeg
+        desktop-app::external_lz4
+    )
+endif()
+
+target_include_directories(lib_lottie
+PUBLIC
+    ${src_loc}
+)
+
+target_link_libraries(lib_lottie
+PUBLIC
+    desktop-app::lib_ui
+    desktop-app::external_rlottie
+PRIVATE
+    desktop-app::external_zlib
+)
diff --git a/Telegram/lib_lottie/lottie/lottie_single_player.cpp b/Telegram/lib_lottie/lottie/lottie_single_player.cpp
index f023e30..369cb28 100644
--- a/Telegram/lib_lottie/lottie/lottie_single_player.cpp
+++ b/Telegram/lib_lottie/lottie/lottie_single_player.cpp
@@ -136,13 +136,16 @@ void SinglePlayer::checkNextFrameRender() {
 		}
 	} else {
 		_timer.cancel();
+		renderFrame(now);
+	}
+}
 
-		_state->markFrameDisplayed(now);
-		_state->addTimelineDelay(now - _nextFrameTime);
+void SinglePlayer::renderFrame(crl::time now) {
+	_state->markFrameDisplayed(now);
+	_state->addTimelineDelay(now - _nextFrameTime);
 
-		_nextFrameTime = kFrameDisplayTimeAlreadyDone;
-		_updates.fire({ DisplayFrameRequest() });
-	}
+	_nextFrameTime = kFrameDisplayTimeAlreadyDone;
+	_updates.fire({ DisplayFrameRequest() });
 }
 
 void SinglePlayer::updateFrameRequest(
diff --git a/Telegram/lib_lottie/lottie/lottie_single_player.h b/Telegram/lib_lottie/lottie/lottie_single_player.h
index 24dd31e..9e9826f 100644
--- a/Telegram/lib_lottie/lottie/lottie_single_player.h
+++ b/Telegram/lib_lottie/lottie/lottie_single_player.h
@@ -66,6 +66,7 @@ public:
 private:
 	void checkNextFrameAvailability();
 	void checkNextFrameRender();
+	void renderFrame(crl::time now);
 
 	base::Timer _timer;
 	const std::shared_ptr<FrameRenderer> _renderer;
Submodule Telegram/lib_qr 000000000...9877397db (new submodule)
diff --git a/Telegram/lib_qr/CMakeLists.txt b/Telegram/lib_qr/CMakeLists.txt
new file mode 100644
index 0000000..bdecb0a
--- /dev/null
+++ b/Telegram/lib_qr/CMakeLists.txt
@@ -0,0 +1,28 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+add_library(lib_qr OBJECT)
+add_library(desktop-app::lib_qr ALIAS lib_qr)
+init_target(lib_qr)
+
+get_filename_component(src_loc . REALPATH)
+
+nice_target_sources(lib_qr ${src_loc}
+PRIVATE
+    qr/qr_generate.cpp
+    qr/qr_generate.h
+)
+
+target_include_directories(lib_qr
+PUBLIC
+    ${src_loc}
+)
+
+target_link_libraries(lib_qr
+PUBLIC
+    desktop-app::lib_base
+    desktop-app::external_qr_code_generator
+)
diff --git a/Telegram/lib_qr/lib_qr.gyp b/Telegram/lib_qr/lib_qr.gyp
new file mode 100644
index 0000000..0943f58
--- /dev/null
+++ b/Telegram/lib_qr/lib_qr.gyp
@@ -0,0 +1,51 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+{
+  'includes': [
+    '../gyp/helpers/common/common.gypi',
+  ],
+  'targets': [{
+    'target_name': 'lib_qr',
+    'includes': [
+      '../gyp/helpers/common/library.gypi',
+      '../gyp/helpers/modules/qt.gypi',
+    ],
+    'variables': {
+      'src_loc': '.',
+      'qr_loc': '<(third_party_loc)/QR',
+      'qr_src': '<(qr_loc)/cpp',
+    },
+    'dependencies': [
+      '<(submodules_loc)/lib_base/lib_base.gyp:lib_base',
+    ],
+    'export_dependent_settings': [
+      '<(submodules_loc)/lib_base/lib_base.gyp:lib_base',
+    ],
+    'defines': [
+    ],
+    'include_dirs': [
+      '<(src_loc)',
+      '<(qr_src)',
+    ],
+    'direct_dependent_settings': {
+      'include_dirs': [
+        '<(src_loc)',
+      ],
+    },
+    'sources': [
+      '<(src_loc)/qr/qr_generate.cpp',
+      '<(src_loc)/qr/qr_generate.h',
+
+      '<(qr_src)/BitBuffer.cpp',
+      '<(qr_src)/BitBuffer.hpp',
+      '<(qr_src)/QrCode.cpp',
+      '<(qr_src)/QrCode.hpp',
+      '<(qr_src)/QrSegment.cpp',
+      '<(qr_src)/QrSegment.hpp',
+    ],
+  }],
+}
diff --git a/Telegram/lib_qr/qr/qr_generate.cpp b/Telegram/lib_qr/qr/qr_generate.cpp
new file mode 100644
index 0000000..6027b86
--- /dev/null
+++ b/Telegram/lib_qr/qr/qr_generate.cpp
@@ -0,0 +1,242 @@
+// This file is part of Desktop App Toolkit,
+// a set of libraries for developing nice desktop applications.
+//
+// For license and copyright information please follow this link:
+// https://github.com/desktop-app/legal/blob/master/LEGAL
+//
+#include "qr/qr_generate.h"
+
+#include "base/assertion.h"
+
+#include "QrCode.hpp"
+#include <QtGui/QPainter>
+#include <string>
+
+namespace Qr {
+namespace {
+
+using namespace qrcodegen;
+
+[[nodiscard]] int ReplaceElements(const Data &data) {
+	const auto elements = [&] {
+		switch (data.redundancy) {
+		case Redundancy::Low: return data.size / 5;
+		case Redundancy::Medium: return data.size / 4;
+		case Redundancy::Quartile: return data.size / 3;
+		case Redundancy::High: return data.size / 2;
+		}
+		Unexpected("Redundancy value in Qr::ReplaceElements.");
+	}();
+	const auto close = (data.redundancy != Redundancy::Quartile);
+	const auto shift = (data.size - elements) % 2;
+	return elements + (close ? -1 : 1) * shift;
+}
+
+[[nodiscard]] QrCode::Ecc RedundancyToEcc(Redundancy redundancy) {
+	switch (redundancy) {
+	case Redundancy::Low: return QrCode::Ecc::LOW;
+	case Redundancy::Medium: return QrCode::Ecc::MEDIUM;
+	case Redundancy::Quartile: return QrCode::Ecc::QUARTILE;
+	case Redundancy::High: return QrCode::Ecc::HIGH;
+	}
+	Unexpected("Redundancy value in Qr::RedundancyToEcc.");
+}
+
+} // namespace
+
+Data Encode(const QString &text, Redundancy redundancy) {
+	Expects(!text.isEmpty());
+
+	auto result = Data();
+	result.redundancy = redundancy;
+	const auto utf8 = text.toStdString();
+	const auto qr = QrCode::encodeText(
+		utf8.c_str(),
+		RedundancyToEcc(redundancy));
+	result.size = qr.getSize();
+	Assert(result.size > 0);
+
+	result.values.reserve(result.size * result.size);
+	for (auto row = 0; row != result.size; ++row) {
+		for (auto column = 0; column != result.size; ++column) {
+			result.values.push_back(qr.getModule(row, column));
+		}
+	}
+	return result;
+}
+
+void PrepareForRound(QPainter &p) {
+	p.setRenderHints(QPainter::Antialiasing
+		| QPainter::SmoothPixmapTransform
+		| QPainter::TextAntialiasing
+		| QPainter::HighQualityAntialiasing);
+	p.setPen(Qt::NoPen);
+}
+
+QImage GenerateSingle(int size, QColor bg, QColor color) {
+	auto result = QImage(size, size, QImage::Format_ARGB32_Premultiplied);
+	result.fill(bg);
+	{
+		auto p = QPainter(&result);
+		p.setCompositionMode(QPainter::CompositionMode_Source);
+		PrepareForRound(p);
+		p.setBrush(color);
+		p.drawRoundedRect(
+			QRect{ 0, 0, size, size },
+			size / 2.,
+			size / 2.);
+	}
+	return result;
+}
+
+int ReplaceSize(const Data &data, int pixel) {
+	return ReplaceElements(data) * pixel;
+}
+
+QImage Generate(const Data &data, int pixel, QColor fg) {
+	Expects(data.size > 0);
+	Expects(data.values.size() == data.size * data.size);
+
+	const auto bg = Qt::transparent;
+	const auto replaceElements = ReplaceElements(data);
+	const auto replaceFrom = (data.size - replaceElements) / 2;
+	const auto replaceTill = (data.size - replaceFrom);
+	const auto black = GenerateSingle(pixel, bg, fg);
+	const auto white = GenerateSingle(pixel, fg, bg);
+	const auto value = [&](int row, int column) {
+		return (row >= 0)
+			&& (row < data.size)
+			&& (column >= 0)
+			&& (column < data.size)
+			&& (row < replaceFrom
+				|| row >= replaceTill
+				|| column < replaceFrom
+				|| column >= replaceTill)
+			&& data.values[row * data.size + column];
+	};
+	const auto blackFull = [&](int row, int column) {
+		return (value(row - 1, column) && value(row + 1, column))
+			|| (value(row, column - 1) && value(row, column + 1));
+	};
+	const auto whiteCorner = [&](int row, int column, int dx, int dy) {
+		return !value(row + dy, column)
+			|| !value(row, column + dx)
+			|| !value(row + dy, column + dx);
+	};
+	const auto whiteFull = [&](int row, int column) {
+		return whiteCorner(row, column, -1, -1)
+			&& whiteCorner(row, column, 1, -1)
+			&& whiteCorner(row, column, 1, 1)
+			&& whiteCorner(row, column, -1, 1);
+	};
+	auto result = QImage(
+		data.size * pixel,
+		data.size * pixel,
+		QImage::Format_ARGB32_Premultiplied);
+	result.fill(bg);
+	{
+		auto p = QPainter(&result);
+		p.setCompositionMode(QPainter::CompositionMode_Source);
+		const auto skip = pixel - pixel / 2;
+		const auto brect = [&](int x, int y, int width, int height) {
+			p.fillRect(x, y, width, height, fg);
+		};
+		const auto wrect = [&](int x, int y, int width, int height) {
+			p.fillRect(x, y, width, height, bg);
+		};
+		const auto large = [&](int x, int y) {
+			p.setBrush(fg);
+			p.drawRoundedRect(
+				QRect{ x, y, pixel * 7, pixel * 7 },
+				pixel * 2.,
+				pixel * 2.);
+			p.setBrush(bg);
+			p.drawRoundedRect(
+				QRect{ x + pixel, y + pixel, pixel * 5, pixel * 5 },
+				pixel * 1.5,
+				pixel * 1.5);
+			p.setBrush(fg);
+			p.drawRoundedRect(
+				QRect{ x + pixel * 2, y + pixel * 2, pixel * 3, pixel * 3 },
+				pixel,
+				pixel);
+
+		};
+		for (auto row = 0; row != data.size; ++row) {
+			for (auto column = 0; column != data.size; ++column) {
+				if ((row < 7 && (column < 7 || column >= data.size - 7))
+					|| (column < 7 && (row < 7 || row >= data.size - 7))) {
+					continue;
+				}
+				const auto x = column * pixel;
+				const auto y = row * pixel;
+				const auto index = row * data.size + column;
+				if (value(row, column)) {
+					if (blackFull(row, column)) {
+						brect(x, y, pixel, pixel);
+					} else {
+						p.drawImage(x, y, black);
+						if (value(row - 1, column)) {
+							brect(x, y, pixel, pixel / 2);
+						} else if (value(row + 1, column)) {
+							brect(x, y + skip, pixel, pixel / 2);
+						}
+						if (value(row, column - 1)) {
+							brect(x, y, pixel / 2, pixel);
+						} else if (value(row, column + 1)) {
+							brect(x + skip, y, pixel / 2, pixel);
+						}
+					}
+				} else if (whiteFull(row, column)) {
+					wrect(x, y, pixel, pixel);
+				} else {
+					p.drawImage(x, y, white);
+					if (whiteCorner(row, column, -1, -1)
+						&& whiteCorner(row, column, 1, -1)) {
+						wrect(x, y, pixel, pixel / 2);
+					} else if (whiteCorner(row, column, -1, 1)
+						&& whiteCorner(row, column, 1, 1)) {
+						wrect(x, y + skip, pixel, pixel / 2);
+					}
+					if (whiteCorner(row, column, -1, -1)
+						&& whiteCorner(row, column, -1, 1)) {
+						wrect(x, y, pixel / 2, pixel);
+					} else if (whiteCorner(row, column, 1, -1)
+						&& whiteCorner(row, column, 1, 1)) {
+						wrect(x + skip, y, pixel / 2, pixel);
+					}
+					if (whiteCorner(row, column, -1, -1)) {
+						wrect(x, y, pixel / 2, pixel / 2);
+					}
+					if (whiteCorner(row, column, 1, -1)) {
+						wrect(x + skip, y, pixel / 2, pixel / 2);
+					}
+					if (whiteCorner(row, column, 1, 1)) {
+						wrect(x + skip, y + skip, pixel / 2, pixel / 2);
+					}
+					if (whiteCorner(row, column, -1, 1)) {
+						wrect(x, y + skip, pixel / 2, pixel / 2);
+					}
+				}
+			}
+		}
+
+		PrepareForRound(p);
+		large(0, 0);
+		large((data.size - 7) * pixel, 0);
+		large(0, (data.size - 7) * pixel);
+	}
+	return result;
+}
+
+QImage ReplaceCenter(QImage qr, const QImage &center) {
+	{
+		auto p = QPainter(&qr);
+		const auto x = (qr.width() - center.width()) / 2;
+		const auto y = (qr.height() - center.height()) / 2;
+		p.drawImage(x, y, center);
+	}
+	return qr;
+}
+
+} // namespace Qr
diff --git a/Telegram/lib_qr/qr/qr_generate.h b/Telegram/lib_qr/qr/qr_generate.h
new file mode 100644
index 0000000..09ab7e0
--- /dev/null
+++ b/Telegram/lib_qr/qr/qr_generate.h
@@ -0,0 +1,42 @@
+// This file is part of Desktop App Toolkit,
+// a set of libraries for developing nice desktop applications.
+//
+// For license and copyright information please follow this link:
+// https://github.com/desktop-app/legal/blob/master/LEGAL
+//
+#pragma once
+
+#include <QtGui/QImage>
+#include <QtGui/QColor>
+#include <QtCore/QString>
+
+#include <vector>
+
+namespace Qr {
+
+enum class Redundancy {
+	Low,
+	Medium,
+	Quartile,
+	High,
+
+	Default = Medium
+};
+
+struct Data {
+	int size = 0;
+	Redundancy redundancy = Redundancy::Default;
+	std::vector<bool> values; // size x size
+};
+
+[[nodiscard]] Data Encode(
+	const QString &text,
+	Redundancy redundancy = Redundancy::Default);
+[[nodiscard]] QImage Generate(
+	const Data &data,
+	int pixel,
+	QColor fg = Qt::black);
+[[nodiscard]] int ReplaceSize(const Data &data, int pixel);
+[[nodiscard]] QImage ReplaceCenter(QImage qr, const QImage &center);
+
+} // namespace Qr
Submodule Telegram/lib_rpl 01323035b..bd850834f:
diff --git a/Telegram/lib_rpl/CMakeLists.txt b/Telegram/lib_rpl/CMakeLists.txt
new file mode 100644
index 0000000..051ade3
--- /dev/null
+++ b/Telegram/lib_rpl/CMakeLists.txt
@@ -0,0 +1,53 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+add_library(lib_rpl INTERFACE)
+add_library(desktop-app::lib_rpl ALIAS lib_rpl)
+
+get_filename_component(src_loc "." REALPATH)
+
+nice_target_sources(lib_rpl ${src_loc}
+INTERFACE
+    rpl/details/callable.h
+    rpl/details/superset_type.h
+    rpl/details/type_list.h
+    rpl/after_next.h
+    rpl/before_next.h
+    rpl/combine.h
+    rpl/combine_previous.h
+    rpl/complete.h
+    rpl/conditional.h
+    rpl/consumer.h
+    rpl/deferred.h
+    rpl/distinct_until_changed.h
+    rpl/event_stream.h
+    rpl/fail.h
+    rpl/filter.h
+    rpl/flatten_latest.h
+    rpl/lifetime.h
+    rpl/map.h
+    rpl/mappers.h
+    rpl/merge.h
+    rpl/never.h
+    rpl/producer.h
+    rpl/range.h
+    rpl/rpl.h
+    rpl/skip.h
+    rpl/take.h
+    rpl/then.h
+    rpl/type_erased.h
+    rpl/variable.h
+)
+
+target_include_directories(lib_rpl
+INTERFACE
+    ${src_loc}
+)
+
+target_link_libraries(lib_rpl
+INTERFACE
+    desktop-app::external_gsl
+)
Submodule Telegram/lib_spellcheck 0269666de..3ed9533de:
diff --git a/Telegram/lib_spellcheck/CMakeLists.txt b/Telegram/lib_spellcheck/CMakeLists.txt
new file mode 100644
index 0000000..282e732
--- /dev/null
+++ b/Telegram/lib_spellcheck/CMakeLists.txt
@@ -0,0 +1,47 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+add_library(lib_spellcheck OBJECT)
+add_library(desktop-app::lib_spellcheck ALIAS lib_spellcheck)
+init_target(lib_spellcheck)
+
+get_filename_component(src_loc . REALPATH)
+
+target_precompile_headers(lib_spellcheck PRIVATE ${src_loc}/spellcheck/spellcheck_pch.h)
+nice_target_sources(lib_spellcheck ${src_loc}
+PRIVATE
+    spellcheck/platform/platform_spellcheck.h
+    spellcheck/platform/linux/linux_enchant.cpp
+    spellcheck/platform/linux/linux_enchant.h
+    spellcheck/platform/linux/spellcheck_linux.cpp
+    spellcheck/platform/linux/spellcheck_linux.h
+    spellcheck/platform/mac/spellcheck_mac.h
+    spellcheck/platform/mac/spellcheck_mac.mm
+    spellcheck/platform/win/spellcheck_win.cpp
+    spellcheck/platform/win/spellcheck_win.h
+    spellcheck/spellcheck_utils.cpp
+    spellcheck/spellcheck_utils.h
+    spellcheck/spellcheck_types.h
+    spellcheck/spelling_highlighter.cpp
+    spellcheck/spelling_highlighter.h
+)
+
+target_include_directories(lib_spellcheck
+PUBLIC
+    ${src_loc}
+)
+
+target_link_libraries(lib_spellcheck
+PUBLIC
+    desktop-app::lib_ui
+)
+
+if (LINUX)
+    find_package(PkgConfig REQUIRED)
+
+    pkg_search_module(ENCHANT REQUIRED enchant-2 enchant)
+    target_include_directories(lib_spellcheck PRIVATE ${ENCHANT_INCLUDE_DIRS})
+endif()
diff --git a/Telegram/lib_spellcheck/gyp/sources.txt b/Telegram/lib_spellcheck/gyp/sources.txt
index 2819f5f..9552f2f 100644
--- a/Telegram/lib_spellcheck/gyp/sources.txt
+++ b/Telegram/lib_spellcheck/gyp/sources.txt
@@ -1,4 +1,6 @@
 <(src_loc)/spellcheck/platform/platform_spellcheck.h
+<(src_loc)/spellcheck/platform/linux/linux_enchant.cpp
+<(src_loc)/spellcheck/platform/linux/linux_enchant.h
 <(src_loc)/spellcheck/platform/linux/spellcheck_linux.cpp
 <(src_loc)/spellcheck/platform/linux/spellcheck_linux.h
 <(src_loc)/spellcheck/platform/mac/spellcheck_mac.h
diff --git a/Telegram/lib_spellcheck/lib_spellcheck.gyp b/Telegram/lib_spellcheck/lib_spellcheck.gyp
index 89ac698..77fef3a 100644
--- a/Telegram/lib_spellcheck/lib_spellcheck.gyp
+++ b/Telegram/lib_spellcheck/lib_spellcheck.gyp
@@ -64,6 +64,10 @@
       'include_dirs': [
         '/usr/local/macold/include/c++/v1',
       ],
+    }], [ 'build_linux', {
+      'cflags_cc': [
+        '<!(pkg-config --silence-errors --cflags enchant-2 || pkg-config --cflags enchant)',
+      ],
     }]],
   }],
 }
\ No newline at end of file
diff --git a/Telegram/lib_spellcheck/spellcheck/platform/linux/linux_enchant.cpp b/Telegram/lib_spellcheck/spellcheck/platform/linux/linux_enchant.cpp
new file mode 100644
index 0000000..3074802
--- /dev/null
+++ b/Telegram/lib_spellcheck/spellcheck/platform/linux/linux_enchant.cpp
@@ -0,0 +1,254 @@
+/* enchant
+ * Copyright (C) 2003 Dom Lachowicz
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ *
+ * In addition, as a special exception, Dom Lachowicz
+ * gives permission to link the code of this program with
+ * non-LGPL Spelling Provider libraries (eg: a MSFT Office
+ * spell checker backend) and distribute linked combinations including
+ * the two.  You must obey the GNU Lesser General Public License in all
+ * respects for all of the code used other than said providers.  If you modify
+ * this file, you may extend this exception to your version of the
+ * file, but you are not obligated to do so.  If you do not wish to
+ * do so, delete this exception statement from your version.
+ *
+ * Nicholas Guriev (email: guriev-ns@ya.ru) split the full <enchant++.h> header
+ * into two files, linux_enchant.h and linux_enchant.cpp, to use within Desktop
+ * App Toolkit. He also implemented explicit linking with dlopen/dlsym to avoid
+ * rigid dependency on the Enchant library at runtime.
+ */
+
+#include <enchant.h>
+#include <dlfcn.h>
+#include "spellcheck/platform/linux/linux_enchant.h"
+
+namespace {
+
+struct {
+	//decltype (enchant_broker_describe) * broker_describe;
+	//decltype (enchant_broker_dict_exists) * broker_dict_exists;
+	decltype (enchant_broker_free) * broker_free;
+	decltype (enchant_broker_free_dict) * broker_free_dict;
+	decltype (enchant_broker_get_error) * broker_get_error;
+	decltype (enchant_broker_init) * broker_init;
+	decltype (enchant_broker_list_dicts) * broker_list_dicts;
+	decltype (enchant_broker_request_dict) * broker_request_dict;
+	//decltype (enchant_broker_request_pwl_dict) * broker_request_pwl_dict;
+	//decltype (enchant_broker_set_ordering) * broker_set_ordering;
+	decltype (enchant_dict_add) * dict_add;
+	decltype (enchant_dict_add_to_session) * dict_add_to_session;
+	decltype (enchant_dict_check) * dict_check;
+	decltype (enchant_dict_describe) * dict_describe;
+	decltype (enchant_dict_free_string_list) * dict_free_string_list;
+	decltype (enchant_dict_get_error) * dict_get_error;
+	decltype (enchant_dict_is_added) * dict_is_added;
+	//decltype (enchant_dict_is_removed) * dict_is_removed;
+	decltype (enchant_dict_remove) * dict_remove;
+	decltype (enchant_dict_remove_from_session) * dict_remove_from_session;
+	//decltype (enchant_dict_store_replacement) * dict_store_replacement;
+	decltype (enchant_dict_suggest) * dict_suggest;
+} f_enchant;
+
+} // anonymous namespace
+
+enchant::Exception::Exception (const char * ex)
+	: std::exception (), m_ex ("") {
+	if (ex)
+		m_ex = ex;
+}
+
+enchant::Exception::~Exception () = default;
+
+const char * enchant::Exception::what () const noexcept {
+	return m_ex.c_str();
+}
+
+enchant::Dict::Dict (EnchantDict * dict, EnchantBroker * broker)
+	: m_dict (dict), m_broker (broker) {
+	f_enchant.dict_describe (m_dict, s_describe_fn, this);
+}
+
+enchant::Dict::~Dict () {
+	f_enchant.broker_free_dict (m_broker, m_dict);
+}
+
+bool enchant::Dict::check (const std::string & utf8word) {
+	int val;
+
+	val = f_enchant.dict_check (m_dict, utf8word.c_str(), utf8word.size());
+	if (val == 0)
+		return true;
+	else if (val > 0)
+		return false;
+	else {
+		throw enchant::Exception (f_enchant.dict_get_error (m_dict));
+	}
+
+	return false; // never reached
+}
+
+void enchant::Dict::suggest (const std::string & utf8word,
+			     std::vector<std::string> & out_suggestions) {
+	size_t n_suggs;
+	char ** suggs;
+
+	out_suggestions.clear ();
+
+	suggs = f_enchant.dict_suggest (m_dict, utf8word.c_str(),
+					utf8word.size(), &n_suggs);
+
+	if (suggs && n_suggs) {
+		out_suggestions.reserve(n_suggs);
+
+		for (size_t i = 0; i < n_suggs; i++) {
+			out_suggestions.push_back (suggs[i]);
+		}
+
+		f_enchant.dict_free_string_list (m_dict, suggs);
+	}
+}
+
+void enchant::Dict::add (const std::string & utf8word) {
+	f_enchant.dict_add (m_dict, utf8word.c_str(), utf8word.size());
+}
+
+void enchant::Dict::add_to_session (const std::string & utf8word) {
+	f_enchant.dict_add_to_session (m_dict, utf8word.c_str(), utf8word.size());
+}
+
+bool enchant::Dict::is_added (const std::string & utf8word) {
+	return f_enchant.dict_is_added (m_dict, utf8word.c_str(),
+					utf8word.size());
+}
+
+void enchant::Dict::remove (const std::string & utf8word) {
+	f_enchant.dict_remove (m_dict, utf8word.c_str(), utf8word.size());
+}
+
+void enchant::Dict::remove_from_session (const std::string & utf8word) {
+	f_enchant.dict_remove_from_session (m_dict, utf8word.c_str(),
+					    utf8word.size());
+}
+
+//bool enchant::Dict::is_removed (const std::string & utf8word) {
+//	return f_enchant.dict_is_removed (m_dict, utf8word.c_str(),
+//					  utf8word.size());
+//}
+
+//void enchant::Dict::store_replacement (const std::string & utf8bad,
+//				       const std::string & utf8good) {
+//	f_enchant.dict_store_replacement (m_dict,
+//					  utf8bad.c_str(), utf8bad.size(),
+//					  utf8good.c_str(), utf8good.size());
+//}
+
+enchant::Broker::Broker ()
+	: m_broker (f_enchant.broker_init ())
+	{
+	}
+
+enchant::Broker::~Broker () {
+	f_enchant.broker_free (m_broker);
+}
+
+enchant::Dict * enchant::Broker::request_dict (const std::string & lang) {
+	EnchantDict * dict = f_enchant.broker_request_dict (m_broker, lang.c_str());
+
+	if (!dict) {
+		throw enchant::Exception (f_enchant.broker_get_error (m_broker));
+		return 0; // never reached
+	}
+
+	return new Dict (dict, m_broker);
+}
+
+//enchant::Dict * enchant::Broker::request_pwl_dict (const std::string & pwl) {
+//	EnchantDict * dict = f_enchant.broker_request_pwl_dict (m_broker, pwl.c_str());
+//
+//	if (!dict) {
+//		throw enchant::Exception (f_enchant.broker_get_error (m_broker));
+//		return 0; // never reached
+//	}
+//
+//	return new Dict (dict, m_broker);
+//}
+
+//bool enchant::Broker::dict_exists (const std::string & lang) {
+//	if (f_enchant.broker_dict_exists (m_broker, lang.c_str()))
+//		return true;
+//	return false;
+//}
+
+//void enchant::Broker::set_ordering (const std::string & tag, const std::string & ordering) {
+//	f_enchant.broker_set_ordering (m_broker, tag.c_str(), ordering.c_str());
+//}
+
+//void enchant::Broker::describe (EnchantBrokerDescribeFn fn, void * user_data) {
+//	f_enchant.broker_describe (m_broker, fn, user_data);
+//}
+
+void enchant::Broker::list_dicts (EnchantDictDescribeFn fn, void * user_data) {
+	f_enchant.broker_list_dicts (m_broker, fn, user_data);
+}
+
+#define GET_SYMBOL_enchant(func_name) do { \
+	typedef decltype (enchant_ ## func_name) * Fp; \
+	f_enchant.func_name = reinterpret_cast<Fp> ( dlsym (handle, "enchant_" # func_name)); \
+	if (!f_enchant.func_name) { \
+		return false; \
+	} \
+} while(0)
+
+bool enchant::loader::do_explicit_linking () {
+	static enum { NotLoadedYet, LoadSuccessful, LoadFailed = -1 } load_status;
+	if (load_status == NotLoadedYet) {
+		load_status = LoadFailed;
+		void * handle = dlopen ("libenchant.so.1", RTLD_NOW)
+				?: dlopen ("libenchant-2.so.2", RTLD_NOW)
+				?: dlopen ("libenchant.so.2", RTLD_NOW);
+		if (!handle) {
+			// logs ?
+			return false;
+		}
+		//GET_SYMBOL_enchant (broker_describe);
+		//GET_SYMBOL_enchant (broker_dict_exists);
+		GET_SYMBOL_enchant (broker_free);
+		GET_SYMBOL_enchant (broker_free_dict);
+		GET_SYMBOL_enchant (broker_get_error);
+		GET_SYMBOL_enchant (broker_init);
+		GET_SYMBOL_enchant (broker_list_dicts);
+		GET_SYMBOL_enchant (broker_request_dict);
+		//GET_SYMBOL_enchant (broker_request_pwl_dict);
+		//GET_SYMBOL_enchant (broker_set_ordering);
+		GET_SYMBOL_enchant (dict_add);
+		GET_SYMBOL_enchant (dict_add_to_session);
+		GET_SYMBOL_enchant (dict_check);
+		GET_SYMBOL_enchant (dict_describe);
+		GET_SYMBOL_enchant (dict_free_string_list);
+		GET_SYMBOL_enchant (dict_get_error);
+		GET_SYMBOL_enchant (dict_is_added);
+		//GET_SYMBOL_enchant (dict_is_removed);
+		GET_SYMBOL_enchant (dict_remove);
+		GET_SYMBOL_enchant (dict_remove_from_session);
+		//GET_SYMBOL_enchant (dict_store_replacement);
+		GET_SYMBOL_enchant (dict_suggest);
+		load_status = LoadSuccessful;
+	}
+	return load_status == LoadSuccessful;
+}
+
+// vi: ts=8 sw=8
diff --git a/Telegram/lib_spellcheck/spellcheck/platform/linux/linux_enchant.h b/Telegram/lib_spellcheck/spellcheck/platform/linux/linux_enchant.h
new file mode 100644
index 0000000..cd67c02
--- /dev/null
+++ b/Telegram/lib_spellcheck/spellcheck/platform/linux/linux_enchant.h
@@ -0,0 +1,201 @@
+/* enchant
+ * Copyright (C) 2003 Dom Lachowicz
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ *
+ * In addition, as a special exception, Dom Lachowicz
+ * gives permission to link the code of this program with
+ * non-LGPL Spelling Provider libraries (eg: a MSFT Office
+ * spell checker backend) and distribute linked combinations including
+ * the two.  You must obey the GNU Lesser General Public License in all
+ * respects for all of the code used other than said providers.  If you modify
+ * this file, you may extend this exception to your version of the
+ * file, but you are not obligated to do so.  If you do not wish to
+ * do so, delete this exception statement from your version.
+ *
+ * Nicholas Guriev (email: guriev-ns@ya.ru) split the full <enchant++.h> header
+ * into two files, linux_enchant.h and linux_enchant.cpp, to use within Desktop
+ * App Toolkit. He also implemented explicit linking with dlopen/dlsym to avoid
+ * rigid dependency on the Enchant library at runtime.
+ */
+
+#pragma once
+
+#include <string>
+#include <vector>
+#include <exception>
+
+#ifndef ENCHANT_H
+typedef struct str_enchant_broker EnchantBroker;
+typedef struct str_enchant_dict   EnchantDict;
+
+/**
+ * EnchantBrokerDescribeFn
+ * @provider_name: The provider's identifier, such as "ispell" or "aspell" in UTF8 encoding
+ * @provider_desc: A description of the provider, such as "Aspell 0.53" in UTF8 encoding
+ * @provider_dll_file: The provider's DLL filename in Glib file encoding (UTF8 on Windows)
+ * @user_data: Supplied user data, or %null if you don't care
+ *
+ * Callback used to enumerate and describe Enchant's various providers
+ */
+typedef void (*EnchantBrokerDescribeFn) (const char * const provider_name,
+					 const char * const provider_desc,
+					 const char * const provider_dll_file,
+					 void * user_data);
+
+/**
+ * EnchantDictDescribeFn
+ * @lang_tag: The dictionary's language tag (eg: en_US, de_AT, ...)
+ * @provider_name: The provider's name (eg: Aspell) in UTF8 encoding
+ * @provider_desc: The provider's description (eg: Aspell 0.50.3) in UTF8 encoding
+ * @provider_file: The DLL/SO where this dict's provider was loaded from in Glib file encoding (UTF8 on Windows)
+ * @user_data: Supplied user data, or %null if you don't care
+ *
+ * Callback used to describe an individual dictionary
+ */
+typedef void (*EnchantDictDescribeFn) (const char * const lang_tag,
+				       const char * const provider_name,
+				       const char * const provider_desc,
+				       const char * const provider_file,
+				       void * user_data);
+#endif  // !ENCHANT_H
+
+namespace enchant
+{
+	class Broker;
+
+	class Exception : public std::exception
+		{
+		public:
+			explicit Exception (const char * ex);
+			virtual ~Exception () noexcept;
+			virtual const char * what () const noexcept;
+
+		private:
+			std::string m_ex;
+		}; // class enchant::Exception
+
+	class Dict
+		{
+			friend class enchant::Broker;
+
+		public:
+
+			~Dict ();
+
+			bool check (const std::string & utf8word);
+			void suggest (const std::string & utf8word,
+				      std::vector<std::string> & out_suggestions);
+
+			std::vector<std::string> suggest (const std::string & utf8word) {
+				std::vector<std::string> result;
+				suggest (utf8word, result);
+				return result;
+			}
+
+			void add (const std::string & utf8word);
+			void add_to_session (const std::string & utf8word);
+			bool is_added (const std::string & utf8word);
+			void remove (const std::string & utf8word);
+			void remove_from_session (const std::string & utf8word);
+			bool is_removed (const std::string & utf8word);
+			void store_replacement (const std::string & utf8bad,
+						const std::string & utf8good);
+
+			const std::string & get_lang () const {
+				return m_lang;
+			}
+
+			const std::string & get_provider_name () const {
+				return m_provider_name;
+			}
+
+			const std::string & get_provider_desc () const {
+				return m_provider_desc;
+			}
+
+			const std::string & get_provider_file () const {
+				return m_provider_file;
+			}
+
+		private:
+
+			// space reserved for API/ABI expansion
+			void * _private[5];
+
+			static void s_describe_fn (const char * const lang,
+						   const char * const provider_name,
+						   const char * const provider_desc,
+						   const char * const provider_file,
+						   void * user_data) {
+				enchant::Dict * dict = static_cast<enchant::Dict *> (user_data);
+
+				dict->m_lang = lang;
+				dict->m_provider_name = provider_name;
+				dict->m_provider_desc = provider_desc;
+				dict->m_provider_file = provider_file;
+			}
+
+			Dict (EnchantDict * dict, EnchantBroker * broker);
+
+			// private, unimplemented
+			Dict () = delete;
+			Dict (const Dict & rhs) = delete;
+			Dict& operator=(const Dict & rhs) = delete;
+
+			EnchantDict * m_dict;
+			EnchantBroker * m_broker;
+
+			std::string m_lang;
+			std::string m_provider_name;
+			std::string m_provider_desc;
+			std::string m_provider_file;
+		}; // class enchant::Dict
+
+	class Broker
+		{
+
+		public:
+
+			Broker ();
+			~Broker ();
+
+			Dict * request_dict (const std::string & lang);
+			Dict * request_pwl_dict (const std::string & pwl);
+			bool dict_exists (const std::string & lang);
+			void set_ordering (const std::string & tag, const std::string & ordering);
+			void describe (EnchantBrokerDescribeFn fn, void * user_data = nullptr);
+			void list_dicts (EnchantDictDescribeFn fn, void * user_data = nullptr);
+
+		private:
+
+			// space reserved for API/ABI expansion
+			void * _private[5];
+
+			// not implemented
+			Broker (const Broker & rhs) = delete;
+			Broker& operator=(const Broker & rhs) = delete;
+
+			EnchantBroker * m_broker;
+		}; // class enchant::Broker
+
+	namespace loader {
+		bool do_explicit_linking ();
+	} // loader subnamespace
+
+} // enchant namespace
+
+// vi: ts=8 sw=8
diff --git a/Telegram/lib_spellcheck/spellcheck/platform/linux/spellcheck_linux.cpp b/Telegram/lib_spellcheck/spellcheck/platform/linux/spellcheck_linux.cpp
index 42654e5..a465cc6 100644
--- a/Telegram/lib_spellcheck/spellcheck/platform/linux/spellcheck_linux.cpp
+++ b/Telegram/lib_spellcheck/spellcheck/platform/linux/spellcheck_linux.cpp
@@ -1,38 +1,188 @@
 // This file is part of Desktop App Toolkit,
 // a set of libraries for developing nice desktop applications.
 //
-// For license and copyright information please follow this link:
-// https://github.com/desktop-app/legal/blob/master/LEGAL
-//
+// Author: Nicholas Guriev <guriev-ns@ya.ru>, public domain, 2019
+// License: CC0, https://creativecommons.org/publicdomain/zero/1.0/legalcode
+
+#include <set>
+#include <QLocale>
+
+#include "spellcheck/spellcheck_utils.h"
+#include "spellcheck/platform/linux/linux_enchant.h"
+
 #include "spellcheck/platform/linux/spellcheck_linux.h"
+#include "base/integration.h"
 
 namespace Platform::Spellchecker {
+namespace {
+
+class EnchantSpellChecker {
+public:
+	bool isAvailable();
+	auto knownLanguages();
+	bool checkSpelling(const QString &word);
+	auto findSuggestions(const QString &word);
+	void addWord(const QString &wordToAdd);
+	void ignoreWord(const QString &word);
+	void removeWord(const QString &word);
+	bool isWordInDictionary(const QString &word);
+	static EnchantSpellChecker *instance();
+
+private:
+	EnchantSpellChecker();
+	EnchantSpellChecker(const EnchantSpellChecker&) = delete;
+	EnchantSpellChecker& operator =(const EnchantSpellChecker&) = delete;
+
+	std::unique_ptr<enchant::Broker> _brokerHandle;
+	std::vector<std::unique_ptr<enchant::Dict>> _validators;
+};
+
+EnchantSpellChecker::EnchantSpellChecker() {
+	if (!enchant::loader::do_explicit_linking()) return;
+
+	std::set<std::string> langs;
+	_brokerHandle = std::make_unique<enchant::Broker>();
+	_brokerHandle->list_dicts([](
+			const char *language,
+			const char *provider,
+			const char *description,
+			const char *filename,
+			void *our_payload) {
+		static_cast<decltype(langs)*>(our_payload)->insert(language);
+	}, &langs);
+	using DictPtr = std::unique_ptr<enchant::Dict>;
+	_validators.reserve(langs.size());
+	try {
+		std::string langTag = QLocale::system().name().toStdString();
+		_validators.push_back(DictPtr(_brokerHandle->request_dict(langTag)));
+		langs.erase(langTag);
+	} catch (const enchant::Exception &e) {
+		// no first dictionary found
+	}
+	for (const std::string &language : langs) {
+		try {
+			_validators.push_back(DictPtr(_brokerHandle->request_dict(language)));
+		} catch (const enchant::Exception &e) {
+			base::Integration::Instance().logMessage(QString("Catch after request_dict: ") + e.what());
+		}
+	}
+}
+
+EnchantSpellChecker *EnchantSpellChecker::instance() {
+	static EnchantSpellChecker capsule;
+	return &capsule;
+}
+
+bool EnchantSpellChecker::isAvailable() {
+	return !_validators.empty();
+}
+
+auto EnchantSpellChecker::knownLanguages() {
+	return _validators | ranges::views::transform([](const auto &validator) {
+		return QString(validator->get_lang().c_str());
+	}) | ranges::to_vector;
+}
+
+bool EnchantSpellChecker::checkSpelling(const QString &word) {
+	auto w = word.toStdString();
+	return ranges::any_of(_validators, [&](const auto &validator) {
+		try {
+			return validator->check(w);
+		} catch (const enchant::Exception &e) {
+			base::Integration::Instance().logMessage(QString("Catch after check '") + word + "': " + e.what());
+			return true;
+		}
+	}) || _validators.empty();
+}
+
+auto EnchantSpellChecker::findSuggestions(const QString &word) {
+	auto w = word.toStdString();
+	std::vector<QString> result;
+	for (const auto &validator : _validators) {
+		for (const auto &replacement : validator->suggest(w)) {
+			if (!replacement.empty()) {
+				result.push_back(replacement.c_str());
+			}
+			if (result.size() >= Platform::Spellchecker::kMaxSuggestions) {
+				break;
+			}
+		}
+		if (!result.empty()) {
+			break;
+		}
+	}
+	return result;
+}
+
+void EnchantSpellChecker::addWord(const QString &wordToAdd) {
+	auto word = wordToAdd.toStdString();
+	auto &&first = _validators.at(0);
+	first->add(word);
+	first->add_to_session(word);
+}
+
+void EnchantSpellChecker::ignoreWord(const QString &word) {
+	_validators.at(0)->add_to_session(word.toStdString());
+}
+
+void EnchantSpellChecker::removeWord(const QString &word) {
+	auto w = word.toStdString();
+	for (const auto &validator : _validators) {
+		validator->remove_from_session(w);
+		validator->remove(w);
+	}
+}
+
+bool EnchantSpellChecker::isWordInDictionary(const QString &word) {
+	auto w = word.toStdString();
+	return ranges::any_of(_validators, [&w](const auto &validator) {
+		return validator->is_added(w);
+	});
+}
+
+} // namespace
+
+void Init() {
+}
+
+bool IsAvailable() {
+	return EnchantSpellChecker::instance()->isAvailable();
+}
+
+void KnownLanguages(std::vector<QString> *langCodes) {
+	*langCodes = EnchantSpellChecker::instance()->knownLanguages();
+}
 
 bool CheckSpelling(const QString &wordToCheck) {
-	return true;
+	return EnchantSpellChecker::instance()->checkSpelling(wordToCheck);
 }
 
 void FillSuggestionList(
-	const QString &wrongWord,
-	std::vector<QString> *optionalSuggestions) {
+		const QString &wrongWord,
+		std::vector<QString> *variants) {
+	*variants = EnchantSpellChecker::instance()->findSuggestions(wrongWord);
 }
 
 void AddWord(const QString &word) {
+	EnchantSpellChecker::instance()->addWord(word);
 }
 
 void RemoveWord(const QString &word) {
+	EnchantSpellChecker::instance()->removeWord(word);
 }
 
 void IgnoreWord(const QString &word) {
+	EnchantSpellChecker::instance()->ignoreWord(word);
 }
 
 bool IsWordInDictionary(const QString &wordToCheck) {
-	return false;
+	return EnchantSpellChecker::instance()->isWordInDictionary(wordToCheck);
 }
 
 void CheckSpellingText(
-	const QString &text,
-	MisspelledWords *misspelledWordRanges) {
+		const QString &text,
+		MisspelledWords *misspelledWords) {
+	*misspelledWords = ::Spellchecker::RangesFromText(text, CheckSpelling);
 }
 
 } // namespace Platform::Spellchecker
diff --git a/Telegram/lib_spellcheck/spellcheck/platform/mac/spellcheck_mac.mm b/Telegram/lib_spellcheck/spellcheck/platform/mac/spellcheck_mac.mm
index 945e1d2..d045aaa 100644
--- a/Telegram/lib_spellcheck/spellcheck/platform/mac/spellcheck_mac.mm
+++ b/Telegram/lib_spellcheck/spellcheck/platform/mac/spellcheck_mac.mm
@@ -32,10 +32,33 @@ NSSpellChecker *SharedSpellChecker() {
 	}
 }
 
+inline auto SystemLanguages() {
+	static auto languages = std::vector<QString>();
+	if (!languages.size()) {
+		const auto uiLanguages = QLocale::system().uiLanguages();
+		languages = (
+			uiLanguages
+		) | ranges::view::transform([&](const auto &lang) {
+			return lang.left(std::max(lang.indexOf('_'), lang.indexOf('-')));
+		}) | ranges::views::unique | ranges::to_vector;
+	}
+	return languages;
+}
+
 } // namespace
 
 namespace Platform::Spellchecker {
 
+void Init() {
+}
+
+bool IsAvailable() {
+	return true;
+}
+
+void KnownLanguages(std::vector<QString> *langCodes) {
+	*langCodes = SystemLanguages();
+}
 
 bool CheckSpelling(const QString &wordToCheck) {
 	const auto wordLength = wordToCheck.length();
@@ -57,7 +80,7 @@ bool CheckSpelling(const QString &wordToCheck) {
 // There's no need to check the language on the Mac.
 void CheckSpellingText(
 	const QString &text,
-	MisspelledWords *misspelledWordRanges) {
+	MisspelledWords *misspelledWords) {
 // Probably never gonna be defined.
 #ifdef SPELLCHECKER_MAC_AUTO_CHECK_TEXT
 
@@ -71,12 +94,12 @@ void CheckSpellingText(
 			orthography:nil
 			wordCount:nil];
 
-	misspelledWordRanges->reserve(spellRanges.count);
+	misspelledWords->reserve(spellRanges.count);
 	for (NSTextCheckingResult *result in spellRanges) {
 		if (result.resultType != NSTextCheckingTypeSpelling) {
 			continue;
 		}
-		misspelledWordRanges->push_back({
+		misspelledWords->push_back({
 			result.range.location,
 			result.range.length});
 	}
@@ -88,18 +111,7 @@ void CheckSpellingText(
 // But at the same time "testtttyy" will be marked as misspelled word.
 
 // So we have to manually split the text into words and check them separately.
-	const auto words = ::Spellchecker::RangesFromText(text, [&](auto &word) {
-		return CheckSpelling(std::move(word));
-	});
-
-	if (words.empty()) {
-		return;
-	}
-
-	misspelledWordRanges->insert(
-		misspelledWordRanges->end(),
-		words.begin(),
-		words.end());
+	*misspelledWords = ::Spellchecker::RangesFromText(text, CheckSpelling);
 
 #endif
 }
@@ -118,22 +130,14 @@ void FillSuggestionList(
 	};
 
 	auto wordCounter = 0;
-	const auto wordScript = ::Spellchecker::WordScript(wrongWord.midRef(0));
+	const auto wordScript = ::Spellchecker::WordScript(&wrongWord);
 	optionalSuggestions->reserve(kMaxSuggestions);
-	auto hasEnglish = false;
 
 	// for (NSString *lang in [SharedSpellChecker() availableLanguages]) {
-	for (const auto &lang : QLocale::system().uiLanguages()) {
-		const auto isEn = lang.startsWith("en");
-		if (hasEnglish && isEn) {
-			continue;
-		} else {
-			hasEnglish = isEn;
-		}
+	for (const auto &lang : SystemLanguages()) {
 		if (wordScript != ::Spellchecker::LocaleToScriptCode(lang)) {
 			continue;
 		}
-
 		for (NSString *guess in guesses(Q2NSString(lang))) {
 			optionalSuggestions->push_back(NS2QString(guess));
 			if (++wordCounter >= kMaxSuggestions) {
diff --git a/Telegram/lib_spellcheck/spellcheck/platform/platform_spellcheck.h b/Telegram/lib_spellcheck/spellcheck/platform/platform_spellcheck.h
index 5efd3aa..6ad7201 100644
--- a/Telegram/lib_spellcheck/spellcheck/platform/platform_spellcheck.h
+++ b/Telegram/lib_spellcheck/spellcheck/platform/platform_spellcheck.h
@@ -12,9 +12,12 @@ namespace Platform::Spellchecker {
 
 constexpr auto kMaxSuggestions = 5;
 
+[[nodiscard]] bool IsAvailable();
 [[nodiscard]] bool CheckSpelling(const QString &wordToCheck);
 [[nodiscard]] bool IsWordInDictionary(const QString &wordToCheck);
 
+void Init();
+void KnownLanguages(std::vector<QString> *langCodes);
 void FillSuggestionList(
 	const QString &wrongWord,
 	std::vector<QString> *optionalSuggestions);
@@ -25,7 +28,7 @@ void IgnoreWord(const QString &word);
 
 void CheckSpellingText(
 	const QString &text,
-	MisspelledWords *misspelledWordRanges);
+	MisspelledWords *misspelledWords);
 
 } // namespace Platform::Spellchecker
 
diff --git a/Telegram/lib_spellcheck/spellcheck/platform/win/spellcheck_win.cpp b/Telegram/lib_spellcheck/spellcheck/platform/win/spellcheck_win.cpp
index ba55639..1844b2e 100644
--- a/Telegram/lib_spellcheck/spellcheck/platform/win/spellcheck_win.cpp
+++ b/Telegram/lib_spellcheck/spellcheck/platform/win/spellcheck_win.cpp
@@ -9,56 +9,65 @@
 #include <wrl/client.h>
 #include <spellcheck.h>
 
+#include <QtCore/QDir>
 #include <QtCore/QLocale>
+#include <QVector>
 
 #include "base/platform/base_platform_info.h"
 
 using namespace Microsoft::WRL;
 
-namespace Platform {
-namespace Spellchecker {
-
+namespace Platform::Spellchecker {
 
 namespace {
 
-inline LPCWSTR Q2WString(QString string) {
+inline LPCWSTR Q2WString(QStringView string) {
 	return (LPCWSTR)string.utf16();
 }
 
+inline auto SystemLanguages() {
+	const auto appdata = qEnvironmentVariable("appdata");
+	const auto dir = QDir(appdata + QString("\\Microsoft\\Spelling"));
+	return (dir.exists()
+		? dir.entryList(QDir::Dirs | QDir::NoDotAndDotDot)
+		: QLocale::system().uiLanguages()).toVector().toStdVector();
+}
+
 // WindowsSpellChecker class is used to store all the COM objects and
 // control their lifetime. The class also provides wrappers for
 // ISpellCheckerFactory and ISpellChecker APIs. All COM calls are on the
 // background thread.
 class WindowsSpellChecker {
-
 public:
-
 	WindowsSpellChecker();
-	void createFactory();
-	void createSpellChecker(const QString& lang);
-
-	bool isLanguageSupported(const QString& lang);
 
-	void addWord(const QString& word);
-	void removeWord(const QString& word);
-	void ignoreWord(const QString& word);
-	bool checkSpelling(const QString& word);
+	void addWord(LPCWSTR word);
+	void removeWord(LPCWSTR word);
+	void ignoreWord(LPCWSTR word);
+	bool checkSpelling(LPCWSTR word);
 	void fillSuggestionList(
-		const QString &wrongWord,
+		LPCWSTR wrongWord,
 		std::vector<QString> *optionalSuggestions);
 	void checkSpellingText(
-		const QString &text,
+		LPCWSTR text,
 		MisspelledWords *misspelledWordRanges);
+	std::vector<QString> systemLanguages();
 
 private:
+	void createFactory();
+	bool isLanguageSupported(const LPCWSTR& lang);
+	void createSpellCheckers();
 
+	std::vector<QString> _systemLanguages;
 	ComPtr<ISpellCheckerFactory> _spellcheckerFactory;
 	std::map<QString, ComPtr<ISpellChecker>> _spellcheckerMap;
 
 };
 
 WindowsSpellChecker::WindowsSpellChecker() {
+	_systemLanguages = SystemLanguages();
 	createFactory();
+	createSpellCheckers();
 }
 
 void WindowsSpellChecker::createFactory() {
@@ -69,45 +78,48 @@ void WindowsSpellChecker::createFactory() {
 	}
 }
 
-void WindowsSpellChecker::createSpellChecker(const QString& lang) {
+void WindowsSpellChecker::createSpellCheckers() {
 	if (!_spellcheckerFactory) {
 		return;
 	}
-	if (_spellcheckerMap.find(lang) != _spellcheckerMap.end()) {
-		return;
-	}
-
-	if (isLanguageSupported(lang)) {
+	for (const auto &lang : _systemLanguages) {
+		const auto wlang = Q2WString(lang);
+		if (!isLanguageSupported(wlang)) {
+			continue;
+		}
+		if (_spellcheckerMap.find(lang) != _spellcheckerMap.end()) {
+			continue;
+		}
 		ComPtr<ISpellChecker> spellchecker;
 		HRESULT hr = _spellcheckerFactory->CreateSpellChecker(
-		Q2WString(lang), &spellchecker);
+			wlang,
+			&spellchecker);
 		if (SUCCEEDED(hr)) {
-			_spellcheckerMap.insert({lang, spellchecker});
+			_spellcheckerMap.insert({ lang, spellchecker });
 		}
 	}
 }
 
-bool WindowsSpellChecker::isLanguageSupported(const QString& lang) {
+bool WindowsSpellChecker::isLanguageSupported(const LPCWSTR& lang) {
 	if (!_spellcheckerFactory) {
 		return false;
 	}
 
 	BOOL isSupported = (BOOL)false;
-	HRESULT hr = _spellcheckerFactory->IsSupported(
-		Q2WString(lang),
-		&isSupported);
+	HRESULT hr = _spellcheckerFactory->IsSupported(lang, &isSupported);
 	return SUCCEEDED(hr) && isSupported;
 }
 
 void WindowsSpellChecker::fillSuggestionList(
-	const QString &wrongWord,
+	LPCWSTR wrongWord,
 	std::vector<QString> *optionalSuggestions) {
 	auto i = 0;
 	for (const auto &[_, spellchecker] : _spellcheckerMap) {
 		ComPtr<IEnumString> suggestions;
-		HRESULT hr = spellchecker->Suggest(
-			Q2WString(wrongWord),
-			&suggestions);
+		HRESULT hr = spellchecker->Suggest(wrongWord, &suggestions);
+		if (hr != S_OK) {
+			continue;
+		}
 
 		while (true) {
 			wchar_t* suggestion = nullptr;
@@ -117,22 +129,21 @@ void WindowsSpellChecker::fillSuggestionList(
 			}
 			const auto guess =
 				QString::fromWCharArray(suggestion, wcslen(suggestion));
+			CoTaskMemFree(suggestion);
 			if (!guess.isEmpty()) {
 				optionalSuggestions->push_back(guess);
 				if (++i >= kMaxSuggestions) {
 					return;
 				}
 			}
-			CoTaskMemFree(suggestion);
 		}
 	}
-
 }
 
-bool WindowsSpellChecker::checkSpelling(const QString& word) {
+bool WindowsSpellChecker::checkSpelling(LPCWSTR word) {
 	for (const auto &[_, spellchecker] : _spellcheckerMap) {
 		ComPtr<IEnumSpellingError> spellingErrors;
-		HRESULT hr = spellchecker->Check(Q2WString(word), &spellingErrors);
+		HRESULT hr = spellchecker->Check(word, &spellingErrors);
 
 		if (SUCCEEDED(hr) && spellingErrors) {
 			ComPtr<ISpellingError> spellingError;
@@ -155,7 +166,7 @@ bool WindowsSpellChecker::checkSpelling(const QString& word) {
 }
 
 void WindowsSpellChecker::checkSpellingText(
-	const QString &text,
+	LPCWSTR text,
 	MisspelledWords *misspelledWordRanges) {
 
 	// The spellchecker marks words not from its own language as misspelled.
@@ -172,7 +183,7 @@ void WindowsSpellChecker::checkSpellingText(
 		ComPtr<IEnumSpellingError> spellingErrors;
 
 		HRESULT hr = spellchecker->ComprehensiveCheck(
-			Q2WString(text),
+			text,
 			&spellingErrors);
 		if (!(SUCCEEDED(hr) && spellingErrors)) {
 			continue;
@@ -193,13 +204,10 @@ void WindowsSpellChecker::checkSpellingText(
 				&& isActionGood(action))) {
 				continue;
 			}
-			const auto word = std::make_pair(
-				(int) startIndex,
-				(int) errorLength);
+			const auto word = std::pair((int) startIndex, (int) errorLength);
 			if (misspelledWords.empty()
-				|| ranges::find_if(misspelledWords, [&](auto &range) {
-					return (word == range);
-				}) != misspelledWords.end()) {
+				|| (ranges::find(misspelledWords, word)
+					!= misspelledWords.end())) {
 				tempMisspelled.push_back(std::move(word));
 			}
 		}
@@ -211,75 +219,88 @@ void WindowsSpellChecker::checkSpellingText(
 		}
 		misspelledWords = std::move(tempMisspelled);
 	}
-	misspelledWordRanges->insert(
-		misspelledWordRanges->end(),
-		misspelledWords.begin(),
-		misspelledWords.end());
+	*misspelledWordRanges = misspelledWords;
 }
 
-void WindowsSpellChecker::addWord(const QString& word) {
+void WindowsSpellChecker::addWord(LPCWSTR word) {
 	for (const auto &[_, spellchecker] : _spellcheckerMap) {
-		spellchecker->Add(Q2WString(word));
+		spellchecker->Add(word);
 	}
 }
 
-void WindowsSpellChecker::removeWord(const QString& word) {
+void WindowsSpellChecker::removeWord(LPCWSTR word) {
 	for (const auto &[_, spellchecker] : _spellcheckerMap) {
 		ComPtr<ISpellChecker2> spellchecker2;
 		spellchecker->QueryInterface(IID_PPV_ARGS(&spellchecker2));
 		if (spellchecker2) {
-			spellchecker2->Remove(Q2WString(word));
+			spellchecker2->Remove(word);
 		}
 	}
 }
 
-void WindowsSpellChecker::ignoreWord(const QString& word) {
+void WindowsSpellChecker::ignoreWord(LPCWSTR word) {
 	for (const auto &[_, spellchecker] : _spellcheckerMap) {
-		spellchecker->Ignore(Q2WString(word));
+		spellchecker->Ignore(word);
 	}
 }
 
+std::vector<QString> WindowsSpellChecker::systemLanguages() {
+	return _systemLanguages;
+}
+
 ////// End of WindowsSpellChecker class.
 
 std::unique_ptr<WindowsSpellChecker>& SharedSpellChecker() {
-	static auto isLanguageSetUp = false;
 	static auto spellchecker = std::make_unique<WindowsSpellChecker>();
-	if (!isLanguageSetUp) {
-		for (const auto lang : QLocale::system().uiLanguages()) {
-			spellchecker->createSpellChecker(lang);
-		}
-		isLanguageSetUp = true;
-	}
 	return spellchecker;
 }
 
 } // namespace
 
+// TODO: Add a better work with the Threading Models.
+// All COM objects should be created asynchronously
+// if we want to work with them asynchronously.
+// Some calls can be made in the main thread before spellchecking
+// (e.g. KnownLanguages), so we have to init it asynchronously first.
+void Init() {
+	crl::async(SharedSpellChecker);
+}
+
+bool IsAvailable() {
+	return IsWindows8OrGreater();
+}
+
+void KnownLanguages(std::vector<QString> *langCodes) {
+	*langCodes = SharedSpellChecker()->systemLanguages();
+}
+
 bool CheckSpelling(const QString &wordToCheck) {
 	// Windows 7 does not support spellchecking.
 	// https://docs.microsoft.com/en-us/windows/win32/api/spellcheck/nn-spellcheck-ispellchecker
 	if (!IsWindows8OrGreater()) {
 		return true;
 	}
-	return SharedSpellChecker()->checkSpelling(wordToCheck);
+	return SharedSpellChecker()->checkSpelling(Q2WString(wordToCheck));
 }
 
 void FillSuggestionList(
 	const QString &wrongWord,
 	std::vector<QString> *optionalSuggestions) {
-	SharedSpellChecker()->fillSuggestionList(wrongWord, optionalSuggestions);
+	SharedSpellChecker()->fillSuggestionList(
+		Q2WString(wrongWord),
+		optionalSuggestions);
 }
 
 void AddWord(const QString &word) {
-	SharedSpellChecker()->addWord(word);
+	SharedSpellChecker()->addWord(Q2WString(word));
 }
 
 void RemoveWord(const QString &word) {
-	SharedSpellChecker()->removeWord(word);
+	SharedSpellChecker()->removeWord(Q2WString(word));
 }
 
 void IgnoreWord(const QString &word) {
-	SharedSpellChecker()->ignoreWord(word);
+	SharedSpellChecker()->ignoreWord(Q2WString(word));
 }
 
 bool IsWordInDictionary(const QString &wordToCheck) {
@@ -289,10 +310,11 @@ bool IsWordInDictionary(const QString &wordToCheck) {
 
 void CheckSpellingText(
 	const QString &text,
-	MisspelledWords *misspelledWordRanges) {
-	SharedSpellChecker()->checkSpellingText(text, misspelledWordRanges);
+	MisspelledWords *misspelledWords) {
+	SharedSpellChecker()->checkSpellingText(
+		Q2WString(text),
+		misspelledWords);
 }
 
 
-} // namespace Spellchecker
-} // namespace Platform
+} // namespace Platform::Spellchecker
diff --git a/Telegram/lib_spellcheck/spellcheck/platform/win/spellcheck_win.h b/Telegram/lib_spellcheck/spellcheck/platform/win/spellcheck_win.h
index a21cb48..49d672c 100644
--- a/Telegram/lib_spellcheck/spellcheck/platform/win/spellcheck_win.h
+++ b/Telegram/lib_spellcheck/spellcheck/platform/win/spellcheck_win.h
@@ -8,8 +8,6 @@
 
 #include "spellcheck/platform/platform_spellcheck.h"
 
-namespace Platform {
-namespace Spellchecker {
+namespace Platform::Spellchecker {
 
-} // namespace Spellchecker
-} // namespace Platform
+} // namespace Platform::Spellchecker
diff --git a/Telegram/lib_spellcheck/spellcheck/spellcheck_types.h b/Telegram/lib_spellcheck/spellcheck/spellcheck_types.h
index 7fd67a7..55c7516 100644
--- a/Telegram/lib_spellcheck/spellcheck/spellcheck_types.h
+++ b/Telegram/lib_spellcheck/spellcheck/spellcheck_types.h
@@ -8,3 +8,7 @@
 
 using MisspelledWord = std::pair<int, int>;
 using MisspelledWords = std::vector<MisspelledWord>;
+
+#if QT_VERSION < QT_VERSION_CHECK(5, 10, 0)
+using QStringView = const QString&;
+#endif
diff --git a/Telegram/lib_spellcheck/spellcheck/spellcheck_utils.cpp b/Telegram/lib_spellcheck/spellcheck/spellcheck_utils.cpp
index 6a2ffdd..21cc158 100644
--- a/Telegram/lib_spellcheck/spellcheck/spellcheck_utils.cpp
+++ b/Telegram/lib_spellcheck/spellcheck/spellcheck_utils.cpp
@@ -5,8 +5,8 @@
 // https://github.com/desktop-app/legal/blob/master/LEGAL
 //
 #include "spellcheck/spellcheck_utils.h"
+#include "spellcheck/platform/platform_spellcheck.h"
 
-#include <QtCore/QLocale>
 #include <QtCore/QStringList>
 #include <QTextBoundaryFinder>
 
@@ -21,11 +21,16 @@ struct SubtagScript {
 // https://chromium.googlesource.com/chromium/src/+/refs/heads/master/third_party/blink/renderer/platform/text/locale_to_script_mapping.cc
 
 constexpr auto kAcuteAccentChars = {
-	QChar(769),	QChar(833),	QChar(180),
+	QChar(769),	QChar(833),	// QChar(180),
 	QChar(714),	QChar(779),	QChar(733),
 	QChar(758),	QChar(791),	QChar(719),
 };
 
+constexpr auto kUnspellcheckableScripts = {
+	QChar::Script_Katakana,
+	QChar::Script_Han,
+};
+
 constexpr SubtagScript kLocaleScriptList[] = {
 	{"aa", QChar::Script_Latin},     {"ab", QChar::Script_Cyrillic},
 	{"ady", QChar::Script_Cyrillic}, {"aeb", QChar::Script_Arabic},
@@ -189,11 +194,18 @@ inline auto IsAcuteAccentChar(const QChar &c) {
 	return ranges::find(kAcuteAccentChars, c) != end(kAcuteAccentChars);
 }
 
+inline auto IsSpellcheckableScripts(const QChar::Script &s) {
+	return ranges::find(kUnspellcheckableScripts, s)
+		== end(kUnspellcheckableScripts);
+}
+
 } // namespace
 
 QChar::Script LocaleToScriptCode(const QString &locale) {
+	const auto subtag = locale.left(
+		std::max(locale.indexOf('_'), locale.indexOf('-')));
 	for (const auto &kv : kLocaleScriptList) {
-		if (locale.split('-')[0] == kv.subtag) {
+		if (subtag == kv.subtag) {
 			return kv.script;
 		}
 	}
@@ -205,17 +217,25 @@ QChar::Script WordScript(const QStringRef &word) {
 	const auto firstLetter = ranges::find_if(word, [&](QChar c) {
 		return c.isLetter();
 	});
-	if (firstLetter == word.end()) {
-		return QChar::Script_Common;
-	}
-	return firstLetter->script();
+	return firstLetter == word.end()
+		? QChar::Script_Common
+		: firstLetter->script();
 }
 
 bool IsWordSkippable(const QStringRef &word) {
 	static auto systemScripts = std::vector<QChar::Script>();
 	if (!systemScripts.size()) {
-		for (const auto &lang : QLocale::system().uiLanguages()) {
-			systemScripts.push_back(LocaleToScriptCode(lang));
+		std::vector<QString> languages;
+		Platform::Spellchecker::KnownLanguages(&languages);
+		systemScripts = (
+			languages
+		) | ranges::views::transform(
+			LocaleToScriptCode
+		) | ranges::views::unique | ranges::views::filter(
+			IsSpellcheckableScripts
+		) | ranges::to_vector;
+		if (systemScripts.empty()) {
+			systemScripts = { QChar::Script_Common };
 		}
 	}
 	const auto wordScript = WordScript(word);
@@ -246,8 +266,8 @@ MisspelledWords RangesFromText(
 	};
 
 	while (finder.position() < text.length()) {
-		if (!(finder.boundaryReasons().testFlag(
-				QTextBoundaryFinder::StartOfItem))) {
+		if (!finder.boundaryReasons().testFlag(
+				QTextBoundaryFinder::StartOfItem)) {
 			if (isEnd()) {
 				break;
 			}
@@ -263,17 +283,15 @@ MisspelledWords RangesFromText(
 		if (length < 1) {
 			continue;
 		}
-		ranges.push_back(std::make_pair(start, length));
+		if (!filterCallback(text.mid(start, length))) {
+			ranges.push_back(std::make_pair(start, length));
+		}
 
 		if (isEnd()) {
 			break;
 		}
 	}
-	return ranges::view::all(
-		ranges
-	) | ranges::view::filter([&](const auto &range) {
-		return !filterCallback(text.mid(range.first, range.second));
-	}) | ranges::to_vector;
+	return ranges;
 }
 
 } // namespace Spellchecker
diff --git a/Telegram/lib_spellcheck/spellcheck/spelling_highlighter.cpp b/Telegram/lib_spellcheck/spellcheck/spelling_highlighter.cpp
index ca5d078..40645f9 100644
--- a/Telegram/lib_spellcheck/spellcheck/spelling_highlighter.cpp
+++ b/Telegram/lib_spellcheck/spellcheck/spelling_highlighter.cpp
@@ -10,6 +10,7 @@
 #include "spellcheck/spellcheck_utils.h"
 #include "styles/palette.h"
 #include "ui/text/text_entity.h"
+#include "ui/text/text_utilities.h"
 #include "ui/ui_utility.h"
 
 namespace ph {
@@ -33,6 +34,14 @@ const auto kUnspellcheckableTags = {
 
 constexpr auto kColdSpellcheckingTimeout = crl::time(1000);
 
+constexpr auto kMaxDeadKeys = 1;
+
+constexpr auto kSkippableFlags = 0
+	| TextParseLinks
+	| TextParseMentions
+	| TextParseHashtags
+	| TextParseBotCommands;
+
 const auto kKeysToCheck = {
 	Qt::Key_Up,
 	Qt::Key_Down,
@@ -69,6 +78,10 @@ inline bool IntersectsWordRanges(
 	return !(l1 > r2 || l2 > r1);
 }
 
+inline bool IntersectsWordRanges(const EntityInText &e,	int pos2, int len2) {
+	return IntersectsWordRanges({ e.offset(), e.length() }, pos2, len2);
+}
+
 inline bool IsTagUnspellcheckable(const QString &tag) {
 	if (tag.isEmpty()) {
 		return false;
@@ -92,17 +105,17 @@ inline bool IsTagUnspellcheckable(const QString &tag) {
 	return false;
 }
 
-inline bool IsMentionText(QStringView text, int position) {
-	if (position < 1) {
-		return false;
-	}
-	// If there is the '@' in front of the word, it's probably a mention.
-	// const auto beforeAt = (position == 1)
-	// 	? QChar()
-	// 	: text[position - 2];
+inline auto FindEntities(const QString &text) {
+	return TextUtilities::ParseEntities(text, kSkippableFlags).entities;
+}
 
-	return (text[position - 1] == '@');
-		// && !(beforeAt.isLetterOrNumber() || beforeAt == '_'));
+inline auto IntersectsAnyOfEntities(
+	int pos,
+	int len,
+	EntitiesInText entities) {
+	return !entities.empty() && ranges::any_of(entities, [&](const auto &e) {
+		return IntersectsWordRanges(e, pos, len);
+	});
 }
 
 inline QChar AddedSymbol(QStringView text, int position, int added) {
@@ -112,6 +125,33 @@ inline QChar AddedSymbol(QStringView text, int position, int added) {
 	return text.at(position);
 }
 
+inline MisspelledWord CorrectAccentValues(
+	const QString &oldText,
+	const QString &newText) {
+	auto diff = std::vector<int>();
+	const auto sizeOfDiff = newText.size() - oldText.size();
+	if (sizeOfDiff <= 0 || sizeOfDiff > kMaxDeadKeys) {
+		return MisspelledWord();
+	}
+	for (auto i = 0; i < oldText.size(); i++) {
+		if (oldText.at(i) != newText.at(i + diff.size())) {
+			diff.push_back(i);
+			if (diff.size() > kMaxDeadKeys) {
+				return MisspelledWord();
+			}
+		}
+	}
+	if (diff.size() == 0) {
+		return MisspelledWord(oldText.size(), sizeOfDiff);
+	}
+	return MisspelledWord(diff.front(), diff.size() > 1 ? diff.back() : 1);
+}
+
+inline MisspelledWord RangeFromCursorSelection(const QTextCursor &cursor) {
+	const auto start = cursor.selectionStart();
+	return MisspelledWord(start, cursor.selectionEnd() - start);
+}
+
 } // namespace
 
 SpellingHighlighter::SpellingHighlighter(
@@ -122,6 +162,9 @@ SpellingHighlighter::SpellingHighlighter(
 , _coldSpellcheckingTimer([=] { checkChangedText(); })
 , _field(field)
 , _textEdit(field->rawTextEdit()) {
+#ifdef Q_OS_WIN
+	Platform::Spellchecker::Init();
+#endif
 
 	_textEdit->installEventFilter(this);
 	_textEdit->viewport()->installEventFilter(this);
@@ -138,21 +181,89 @@ SpellingHighlighter::SpellingHighlighter(
 		contentsChange(pos, removed, added);
 	}, _lifetime);
 
+	_field->markdownTagApplies(
+	) | rpl::start_with_next([=](auto markdownTag) {
+		if (!IsTagUnspellcheckable(markdownTag.tag)) {
+			return;
+		}
+		_cachedRanges = ranges::view::all(
+			_cachedRanges
+		) | ranges::view::filter([&](const auto &range) {
+			return !IntersectsWordRanges(
+				range,
+				markdownTag.internalStart,
+				markdownTag.internalLength);
+		}) | ranges::to_vector;
+		rehighlight();
+	}, _lifetime);
+
 	std::move(
 		enabled
 	) | rpl::start_with_next([=](bool value) {
 		setEnabled(value);
 	}, _lifetime);
 
+	updateDocumentText();
 	checkCurrentText();
 }
 
 void SpellingHighlighter::contentsChange(int pos, int removed, int added) {
-	if (documentText().isEmpty()) {
+	if (document()->isEmpty()) {
+		updateDocumentText();
 		_cachedRanges.clear();
 		return;
 	}
 
+	{
+		const auto oldText = documentText().mid(
+			pos,
+			documentText().indexOf(QChar::ParagraphSeparator, pos));
+		updateDocumentText();
+
+		const auto b = findBlock(pos);
+		const auto bLen = (document()->blockCount() > 1)
+			? b.length()
+			: b.text().size();
+
+		// This is a workaround for typing accents.
+		// For example, when the user press the dead key (e.g. ` or ´),
+		// Qt sends wrong values. E.g. if a text length is 100,
+		// then values will be 0, 100, 100.
+		// This invokes to re-check the entire text.
+		// The Mac's accent menu has a pretty similar behavior.
+		if ((b.position() == pos) && (bLen == added)) {
+			const auto newText = b.text();
+			const auto diff = added - removed;
+			// The plain text of the document cannot contain dead keys.
+			if (!diff) {
+				if (!oldText.compare(newText, Qt::CaseSensitive)) {
+					const auto c = RangeFromCursorSelection(
+						_textEdit->textCursor());
+					// If the cursor has a selection for the entire text,
+					// we probably just changed its formatting.
+					// So if we find the unspellcheckable tag,
+					// we can clear cached ranges of misspelled words.
+					if (!c.first && c.second == bLen) {
+						if (hasUnspellcheckableTag(pos, added)) {
+							_cachedRanges.clear();
+							rehighlight();
+						} else {
+							checkCurrentText();
+						}
+					}
+					return;
+				}
+			} else if (diff > 0 && diff <= kMaxDeadKeys) {
+				const auto [p, l] = CorrectAccentValues(oldText, newText);
+				if (l) {
+					pos = p + b.position();
+					added = l;
+					removed = 0;
+				}
+			}
+		}
+	}
+
 	const auto shift = [&](auto chars) {
 		ranges::for_each(_cachedRanges, [&](auto &range) {
 			if (range.first >= pos + removed) {
@@ -192,7 +303,10 @@ void SpellingHighlighter::contentsChange(int pos, int removed, int added) {
 		shift(-removed);
 	}
 
-	rehighlight();
+	// Normally we should to invoke rehighlighting to immediately apply
+	// shifting of ranges. But we don't have to do this because the call of
+	// contentsChange() is performed before the application's call of
+	// highlightBlock().
 
 	_addedSymbols += added;
 	_removedSymbols += removed;
@@ -240,66 +354,40 @@ void SpellingHighlighter::checkChangedText() {
 	}
 
 	const auto wordUnderCursor = getWordUnderPosition(pos);
+	// If the length of the word is 0, there is no sense in checking it.
+	if (!wordUnderCursor.second) {
+		return;
+	}
+
 	const auto wordInCacheIt = [=] {
 		return ranges::find_if(_cachedRanges, [&](auto &&w) {
 			return w.first >= wordUnderCursor.first;
 		});
 	};
 
-	const auto checkAndAddWordUnderCursos = [&] {
-		const auto weak = Ui::MakeWeak(this);
-		auto w = documentText().mid(
-			wordUnderCursor.first,
-			wordUnderCursor.second);
-		if (IsWordSkippable(&w)) {
-			return;
-		}
-		crl::async([=,
-			w = std::move(w),
-			wordUnderCursor = std::move(wordUnderCursor)]() mutable {
-			if (Platform::Spellchecker::CheckSpelling(std::move(w))) {
-				return;
-			}
-
-			crl::on_main(weak, [=,
-					wordUnderCursor = std::move(wordUnderCursor)]() mutable {
-				ranges::insert(
-					_cachedRanges,
-					ranges::find_if(_cachedRanges, [&](auto &&w) {
-						return w.first >= wordUnderCursor.first;
-					}),
-					std::move(wordUnderCursor));
-				rehighlight();
-			});
-		});
-	};
-
 	if (added > 0) {
 		const auto lastWordNewSelection = getWordUnderPosition(pos + added);
 
 		// This is the same word.
 		if (wordUnderCursor == lastWordNewSelection) {
-			checkAndAddWordUnderCursos();
-			rehighlight();
+			checkSingleWord(wordUnderCursor);
 			return;
 		}
 
 		const auto beginNewSelection = wordUnderCursor.first;
 		const auto endNewSelection = EndOfWord(lastWordNewSelection);
 
-		const auto addedText = documentText().mid(
+		invokeCheckText(
 			beginNewSelection,
-			endNewSelection - beginNewSelection);
-
-		invokeCheckText(std::move(addedText), [=](const MisspelledWords &r) {
-			ranges::insert(_cachedRanges, wordInCacheIt(), std::move(r));
-		}, beginNewSelection);
+			endNewSelection - beginNewSelection,
+			[=](const MisspelledWords &r) {
+				ranges::insert(_cachedRanges, wordInCacheIt(), std::move(r));
+		});
 		return;
 	}
 
 	if (removed > 0) {
-		checkAndAddWordUnderCursos();
-		rehighlight();
+		checkSingleWord(wordUnderCursor);
 	}
 }
 
@@ -310,32 +398,50 @@ MisspelledWords SpellingHighlighter::filterSkippableWords(
 		return MisspelledWords();
 	}
 	return ranges | ranges::view::filter([&](const auto &range) {
-		return !IsWordSkippable(text.midRef(
-			range.first,
-			range.second));
+		return !isSkippableWord(range);
 	}) | ranges::to_vector;
 }
 
+bool SpellingHighlighter::isSkippableWord(const MisspelledWord &range) {
+	return isSkippableWord(range.first, range.second);
+}
+
+bool SpellingHighlighter::isSkippableWord(int position, int length) {
+	if (hasUnspellcheckableTag(position, length)) {
+		return true;
+	}
+	const auto ref = documentText().midRef(position, length);
+	if (ref.isNull()) {
+		return true;
+	}
+	return IsWordSkippable(ref);
+}
+
 void SpellingHighlighter::checkCurrentText() {
-	if (const auto text = documentText(); !text.isEmpty()) {
-		invokeCheckText(text, [&](const MisspelledWords &ranges) {
-			_cachedRanges = std::move(ranges);
-		});
+	if (document()->isEmpty()) {
+		_cachedRanges.clear();
+		return;
 	}
+	invokeCheckText(0, size(), [&](const MisspelledWords &ranges) {
+		_cachedRanges = std::move(ranges);
+	});
 }
 
 void SpellingHighlighter::invokeCheckText(
-	const QString &text,
-	Fn<void(const MisspelledWords &ranges)> callback,
-	int rangesOffset) {
+	int textPosition,
+	int textLength,
+	Fn<void(const MisspelledWords &ranges)> callback) {
 
+	const auto rangesOffset = textPosition;
+	const auto text = partDocumentText(textPosition, textLength);
 	const auto weak = Ui::MakeWeak(this);
+	_countOfCheckingTextAsync++;
 	crl::async([=,
 		text = std::move(text),
 		callback = std::move(callback)]() mutable {
 		MisspelledWords misspelledWordRanges;
 		Platform::Spellchecker::CheckSpellingText(
-			std::move(text),
+			text,
 			&misspelledWordRanges);
 		if (rangesOffset) {
 			ranges::for_each(misspelledWordRanges, [&](auto &&range) {
@@ -343,33 +449,99 @@ void SpellingHighlighter::invokeCheckText(
 			});
 		}
 		crl::on_main(weak, [=,
+				text = std::move(text),
 				ranges = std::move(misspelledWordRanges),
 				callback = std::move(callback)]() mutable {
-			const auto filtered = filterSkippableWords(ranges);
+			_countOfCheckingTextAsync--;
+			// Checking a large part of text can take an unknown amount of
+			// time. So we have to compare the text before and after async
+			// work.
+			// If the text has changed during async and we have more async,
+			// we don't perform further refreshing of cache and underlines.
+			// But if it was the last async, we should invoke a new one.
+			if (compareDocumentText(text, textPosition, textLength)) {
+				if (!_countOfCheckingTextAsync) {
+					checkCurrentText();
+				}
+				return;
+			}
+			auto filtered = filterSkippableWords(ranges);
+
+			// When we finish checking the text, the user can
+			// supplement the last word and there may be a situation where
+			// a part of the last word may not be underlined correctly.
+			// Example:
+			// 1. We insert a text with an incomplete last word.
+			// "Time in a bottl".
+			// 2. We don't wait for the check to be finished
+			// and end the last word with the letter "e".
+			// 3. invokeCheckText() will mark the last word "bottl" as
+			// misspelled.
+			// 4. checkSingleWord() will mark the "bottle" as correct and
+			// leave it as it is.
+			// 5. The first five letters of the "bottle" will be underlined
+			// and the sixth will not be underlined.
+			// We can fix it with a check of completeness of the last word.
+			if (filtered.size()) {
+				const auto lastWord = filtered.back();
+				if (const auto endOfText = textPosition + textLength;
+					EndOfWord(lastWord) == endOfText) {
+					const auto word = getWordUnderPosition(endOfText);
+					if (EndOfWord(word) != endOfText) {
+						filtered.pop_back();
+						checkSingleWord(word);
+					}
+				}
+			}
+
 			callback(std::move(filtered));
-			rehighlight();
+			for (const auto &b : blocksFromRange(textPosition, textLength)) {
+				rehighlightBlock(b);
+			}
 		});
 	});
 }
 
-bool SpellingHighlighter::checkSingleWord(const MisspelledWord &range) {
-	const auto w = documentText().mid(range.first, range.second);
-	return IsWordSkippable(&w)
-		|| Platform::Spellchecker::CheckSpelling(std::move(w));
+void SpellingHighlighter::checkSingleWord(const MisspelledWord &singleWord) {
+	const auto weak = Ui::MakeWeak(this);
+	auto w = partDocumentText(singleWord.first, singleWord.second);
+	if (isSkippableWord(singleWord)) {
+		return;
+	}
+	crl::async([=,
+		w = std::move(w),
+		singleWord = std::move(singleWord)]() mutable {
+		if (Platform::Spellchecker::CheckSpelling(std::move(w))) {
+			return;
+		}
+
+		crl::on_main(weak, [=,
+				singleWord = std::move(singleWord)]() mutable {
+			const auto posOfWord = singleWord.first;
+			ranges::insert(
+				_cachedRanges,
+				ranges::find_if(_cachedRanges, [&](auto &&w) {
+					return w.first >= posOfWord;
+				}),
+				singleWord);
+			rehighlightBlock(findBlock(posOfWord));
+		});
+	});
 }
 
 bool SpellingHighlighter::hasUnspellcheckableTag(int begin, int length) {
 	// This method is called only in the context of separate words,
 	// so it is not supposed that the word can be in more than one block.
-	const auto block = document()->findBlock(begin);
-	const auto end = begin + length;
+	const auto block = findBlock(begin);
+	length = std::min(block.position() + block.length() - begin, length);
 	for (auto it = block.begin(); !(it.atEnd()); ++it) {
 		const auto fragment = it.fragment();
 		if (!fragment.isValid()) {
 			continue;
 		}
-		const auto pos = fragment.position();
-		if (pos < begin || pos > end) {
+		const auto frPos = fragment.position();
+		const auto frLen = fragment.length();
+		if (!IntersectsWordRanges({frPos, frLen}, begin, length)) {
 			continue;
 		}
 		const auto format = fragment.charFormat();
@@ -386,36 +558,30 @@ bool SpellingHighlighter::hasUnspellcheckableTag(int begin, int length) {
 }
 
 MisspelledWord SpellingHighlighter::getWordUnderPosition(int position) {
-	_cursor.setPosition(std::min(position, documentText().size() - 1));
+	_cursor.setPosition(std::min(position, size()));
 	_cursor.select(QTextCursor::WordUnderCursor);
-	const auto start = _cursor.selectionStart();
-	return std::make_pair(start, _cursor.selectionEnd() - start);
+	return RangeFromCursorSelection(_cursor);
 }
 
 void SpellingHighlighter::highlightBlock(const QString &text) {
-	if (_cachedRanges.empty() || !_enabled) {
+	if (_cachedRanges.empty() || !_enabled || text.isEmpty()) {
 		return;
 	}
-	const auto block = currentBlock();
-	// Skip the all words outside the current block.
-	auto &&rangesOfBlock = (
+	const auto entities = FindEntities(text);
+	const auto bPos = currentBlock().position();
+	const auto bLen = currentBlock().length();
+	ranges::for_each((
 		_cachedRanges
+	// Skip the all words outside the current block.
 	) | ranges::view::filter([&](const auto &range) {
-		return IntersectsWordRanges(range, block.position(), block.length());
-	});
-
-	for (const auto &[position, length] : rangesOfBlock) {
-		const auto endOfBlock = text.length() + block.position();
-		const auto l = std::min(endOfBlock - position, length);
-		if (hasUnspellcheckableTag(position, l)) {
-			continue;
-		}
-		if (IsMentionText(text, position - block.position())) {
-			continue;
+		return IntersectsWordRanges(range, bPos, bLen);
+	}), [&](const auto &range) {
+		const auto posInBlock = range.first - bPos;
+		if (IntersectsAnyOfEntities(posInBlock, range.second, entities)) {
+			return;
 		}
-
-		setFormat(position - block.position(), length, _misspelledFormat);
-	}
+		setFormat(posInBlock, range.second, _misspelledFormat);
+	});
 
 	setCurrentBlockState(0);
 }
@@ -470,12 +636,57 @@ void SpellingHighlighter::setEnabled(bool enabled) {
 		checkCurrentText();
 	} else {
 		_cachedRanges.clear();
+		rehighlight();
 	}
-	rehighlight();
 }
 
 QString SpellingHighlighter::documentText() {
-	return _field->getLastText();
+	return _lastPlainText;
+}
+
+void SpellingHighlighter::updateDocumentText() {
+	_lastPlainText = document()->toRawText();
+}
+
+QString SpellingHighlighter::partDocumentText(int pos, int length) {
+	return _lastPlainText.mid(pos, length);
+}
+
+int SpellingHighlighter::size() {
+	return document()->characterCount() - 1;
+}
+
+QTextBlock SpellingHighlighter::findBlock(int pos) {
+	return document()->findBlock(pos);
+}
+
+std::vector<QTextBlock> SpellingHighlighter::blocksFromRange(
+	int pos,
+	int length) {
+
+	auto b = findBlock(pos);
+	auto blocks = std::vector<QTextBlock>{b};
+	const auto end = pos + length;
+	while (!b.contains(end) && (b != document()->end())) {
+		if ((b = b.next()).isValid()) {
+			blocks.push_back(b);
+		}
+	}
+	return blocks;
+}
+
+int SpellingHighlighter::compareDocumentText(
+	const QString &text,
+	int textPos,
+	int textLen) {
+	if (_lastPlainText.size() < textPos + textLen) {
+		return -1;
+	}
+	const auto p = _lastPlainText.midRef(textPos, textLen);
+	if (p.isNull()) {
+		return -1;
+	}
+	return text.compare(p, Qt::CaseSensitive);
 }
 
 void SpellingHighlighter::addSpellcheckerActions(
@@ -483,13 +694,26 @@ void SpellingHighlighter::addSpellcheckerActions(
 		QTextCursor cursorForPosition,
 		Fn<void()> showMenuCallback) {
 
+	cursorForPosition.select(QTextCursor::WordUnderCursor);
+	// There is no reason to call async work if the word is skippable.
+	{
+		const auto &[p, l] = RangeFromCursorSelection(cursorForPosition);
+		const auto e = FindEntities(findBlock(p).text());
+		if (!l
+			|| isSkippableWord(p, l)
+			|| IntersectsAnyOfEntities(p, l, e)) {
+			showMenuCallback();
+			return;
+		}
+	}
+	const auto word = cursorForPosition.selectedText();
+
 	const auto fillMenu = [=,
 		showMenuCallback = std::move(showMenuCallback),
 		menu = std::move(menu)](
 			const auto isCorrect,
 			const auto suggestions,
 			const auto newTextCursor) {
-		const auto word = newTextCursor.selectedText();
 		if (isCorrect) {
 			if (Platform::Spellchecker::IsWordInDictionary(word)) {
 				menu->addSeparator();
@@ -541,13 +765,10 @@ void SpellingHighlighter::addSpellcheckerActions(
 	const auto weak = Ui::MakeWeak(this);
 	crl::async([=,
 		newTextCursor = std::move(cursorForPosition),
-		fillMenu = std::move(fillMenu)]() mutable {
-
-		newTextCursor.select(QTextCursor::WordUnderCursor);
-		const auto word = newTextCursor.selectedText();
+		fillMenu = std::move(fillMenu),
+		word = std::move(word)]() mutable {
 
-		const auto isCorrect = IsWordSkippable(&word)
-			|| Platform::Spellchecker::CheckSpelling(word);
+		const auto isCorrect = Platform::Spellchecker::CheckSpelling(word);
 		std::vector<QString> suggestions;
 		if (!isCorrect) {
 			Platform::Spellchecker::FillSuggestionList(word, &suggestions);
diff --git a/Telegram/lib_spellcheck/spellcheck/spelling_highlighter.h b/Telegram/lib_spellcheck/spellcheck/spelling_highlighter.h
index 33ef2b2..9825a8a 100644
--- a/Telegram/lib_spellcheck/spellcheck/spelling_highlighter.h
+++ b/Telegram/lib_spellcheck/spellcheck/spelling_highlighter.h
@@ -14,6 +14,7 @@
 #include "ui/widgets/input_fields.h"
 
 #include <QtGui/QSyntaxHighlighter>
+#include <QtGui/QTextBlock>
 #include <QtWidgets/QMenu>
 #include <QtWidgets/QTextEdit>
 
@@ -76,22 +77,37 @@ private:
 	void checkText(const QString &text);
 
 	void invokeCheckText(
-		const QString &text,
-		Fn<void(const MisspelledWords &ranges)> callback,
-		int rangesOffset = 0);
+		int textPosition,
+		int textLength,
+		Fn<void(const MisspelledWords &ranges)> callback);
 
 	void checkChangedText();
-	bool checkSingleWord(const MisspelledWord &range);
+	void checkSingleWord(const MisspelledWord &singleWord);
 	MisspelledWords filterSkippableWords(MisspelledWords &ranges);
+	bool isSkippableWord(const MisspelledWord &range);
+	bool isSkippableWord(int position, int length);
 
 	bool hasUnspellcheckableTag(int begin, int length);
 	MisspelledWord getWordUnderPosition(int position);
+
 	QString documentText();
+	void updateDocumentText();
+	QString partDocumentText(int pos, int length);
+	int compareDocumentText(const QString &text, int textPos, int textLen);
+	QString _lastPlainText;
+
+	std::vector<QTextBlock> blocksFromRange(int pos, int length);
+
+	int size();
+	QTextBlock findBlock(int pos);
+
+	int _countOfCheckingTextAsync = 0;
 
 	QTextCharFormat _misspelledFormat;
 	QTextCursor _cursor;
 
 	MisspelledWords _cachedRanges;
+	EntitiesInText _cachedSkippableEntities;
 
 	int _addedSymbols = 0;
 	int _removedSymbols = 0;
Submodule Telegram/lib_storage 000000000...cb56ad46c (new submodule)
diff --git a/Telegram/lib_storage/CMakeLists.txt b/Telegram/lib_storage/CMakeLists.txt
new file mode 100644
index 0000000..b5a2576
--- /dev/null
+++ b/Telegram/lib_storage/CMakeLists.txt
@@ -0,0 +1,52 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+add_library(lib_storage OBJECT)
+add_library(desktop-app::lib_storage ALIAS lib_storage)
+init_target(lib_storage)
+
+get_filename_component(src_loc . REALPATH)
+
+target_precompile_headers(lib_storage PRIVATE ${src_loc}/storage/storage_pch.h)
+nice_target_sources(lib_storage ${src_loc}
+PRIVATE
+    storage/storage_clear_legacy.cpp
+    storage/storage_clear_legacy_posix.cpp
+    storage/storage_clear_legacy_win.cpp
+    storage/storage_clear_legacy.h
+    storage/storage_databases.cpp
+    storage/storage_databases.h
+    storage/storage_encrypted_file.cpp
+    storage/storage_encrypted_file.h
+    storage/storage_encryption.cpp
+    storage/storage_encryption.h
+    storage/cache/storage_cache_binlog_reader.cpp
+    storage/cache/storage_cache_binlog_reader.h
+    storage/cache/storage_cache_cleaner.cpp
+    storage/cache/storage_cache_cleaner.h
+    storage/cache/storage_cache_compactor.cpp
+    storage/cache/storage_cache_compactor.h
+    storage/cache/storage_cache_database.cpp
+    storage/cache/storage_cache_database.h
+    storage/cache/storage_cache_database_object.cpp
+    storage/cache/storage_cache_database_object.h
+    storage/cache/storage_cache_types.cpp
+    storage/cache/storage_cache_types.h
+    storage/storage_clear_legacy_posix.cpp
+    storage/storage_clear_legacy_win.cpp
+)
+
+target_include_directories(lib_storage
+PUBLIC
+    ${src_loc}
+)
+
+target_link_libraries(lib_storage
+PUBLIC
+    desktop-app::lib_base
+PRIVATE
+    desktop-app::external_xxhash
+)
diff --git a/Telegram/lib_storage/lib_storage.gyp b/Telegram/lib_storage/lib_storage.gyp
new file mode 100644
index 0000000..278acca
--- /dev/null
+++ b/Telegram/lib_storage/lib_storage.gyp
@@ -0,0 +1,81 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+{
+  'includes': [
+    '../gyp/helpers/common/common.gypi',
+  ],
+  'targets': [{
+    'target_name': 'lib_storage',
+    'includes': [
+      '../gyp/helpers/common/library.gypi',
+      '../gyp/helpers/modules/openssl.gypi',
+      '../gyp/helpers/modules/qt.gypi',
+      '../gyp/helpers/modules/pch.gypi',
+    ],
+    'variables': {
+      'src_loc': '.',
+      'pch_source': '<(src_loc)/storage/storage_pch.cpp',
+      'pch_header': '<(src_loc)/storage/storage_pch.h',
+    },
+    'defines': [
+      'XXH_INLINE_ALL',
+    ],
+    'dependencies': [
+      '<(submodules_loc)/lib_base/lib_base.gyp:lib_base',
+    ],
+    'export_dependent_settings': [
+      '<(submodules_loc)/lib_base/lib_base.gyp:lib_base',
+    ],
+    'include_dirs': [
+      '<(src_loc)',
+      '<(submodules_loc)/ThirdParty/xxHash',
+    ],
+    'direct_dependent_settings': {
+      'include_dirs': [
+        '<(src_loc)',
+      ],
+	  'conditions': [[ 'build_win', {
+	    'libraries': [
+		  '-lRstrtmgr',
+		],
+	  }]],
+	},
+    'sources': [
+      '<(src_loc)/storage/storage_clear_legacy.cpp',
+      '<(src_loc)/storage/storage_clear_legacy_posix.cpp',
+      '<(src_loc)/storage/storage_clear_legacy_win.cpp',
+      '<(src_loc)/storage/storage_clear_legacy.h',
+      '<(src_loc)/storage/storage_databases.cpp',
+      '<(src_loc)/storage/storage_databases.h',
+      '<(src_loc)/storage/storage_encrypted_file.cpp',
+      '<(src_loc)/storage/storage_encrypted_file.h',
+      '<(src_loc)/storage/storage_encryption.cpp',
+      '<(src_loc)/storage/storage_encryption.h',
+      '<(src_loc)/storage/cache/storage_cache_binlog_reader.cpp',
+      '<(src_loc)/storage/cache/storage_cache_binlog_reader.h',
+      '<(src_loc)/storage/cache/storage_cache_cleaner.cpp',
+      '<(src_loc)/storage/cache/storage_cache_cleaner.h',
+      '<(src_loc)/storage/cache/storage_cache_compactor.cpp',
+      '<(src_loc)/storage/cache/storage_cache_compactor.h',
+      '<(src_loc)/storage/cache/storage_cache_database.cpp',
+      '<(src_loc)/storage/cache/storage_cache_database.h',
+      '<(src_loc)/storage/cache/storage_cache_database_object.cpp',
+      '<(src_loc)/storage/cache/storage_cache_database_object.h',
+      '<(src_loc)/storage/cache/storage_cache_types.cpp',
+      '<(src_loc)/storage/cache/storage_cache_types.h',
+    ],
+    'conditions': [[ 'build_win', {
+      'sources!': [
+        '<(src_loc)/storage/storage_clear_legacy_posix.cpp',
+      ],
+    }, {
+      'sources!': [
+        '<(src_loc)/storage/storage_clear_legacy_win.cpp',
+      ],
+    }]],
+  }],
+}
diff --git a/Telegram/lib_storage/storage/cache/storage_cache_binlog_reader.cpp b/Telegram/lib_storage/storage/cache/storage_cache_binlog_reader.cpp
new file mode 100644
index 0000000..1586b7c
--- /dev/null
+++ b/Telegram/lib_storage/storage/cache/storage_cache_binlog_reader.cpp
@@ -0,0 +1,110 @@
+// This file is part of Desktop App Toolkit,
+// a set of libraries for developing nice desktop applications.
+//
+// For license and copyright information please follow this link:
+// https://github.com/desktop-app/legal/blob/master/LEGAL
+//
+#include "storage/cache/storage_cache_binlog_reader.h"
+
+namespace Storage {
+namespace Cache {
+namespace details {
+
+BinlogWrapper::BinlogWrapper(
+	File &binlog,
+	const Settings &settings,
+	int64 till)
+: _binlog(binlog)
+, _settings(settings)
+, _till(till ? till : _binlog.size())
+, _data(_settings.readBlockSize)
+, _full(_data) {
+}
+
+bool BinlogWrapper::finished() const {
+	return _finished;
+}
+
+bool BinlogWrapper::failed() const {
+	return _failed;
+}
+
+std::optional<BasicHeader> BinlogWrapper::ReadHeader(
+		File &binlog,
+		const Settings &settings) {
+	auto result = BasicHeader();
+	if (binlog.offset() != 0) {
+		return {};
+	} else if (binlog.read(bytes::object_as_span(&result)) != sizeof(result)) {
+		return {};
+	} else if (result.getFormat() != Format::Format_0) {
+		return {};
+	} else if (settings.trackEstimatedTime
+		!= !!(result.flags & result.kTrackEstimatedTime)) {
+		return {};
+	}
+	return result;
+}
+
+bool BinlogWrapper::readPart() {
+	if (_finished) {
+		return false;
+	}
+	const auto no = [&] {
+		finish();
+		return false;
+	};
+	const auto offset = _binlog.offset();
+	const auto left = (_till - offset);
+	if (!left) {
+		return no();
+	}
+
+	if (!_part.empty() && _full.data() != _part.data()) {
+		bytes::move(_full, _part);
+		_part = _full.subspan(0, _part.size());
+	}
+	const auto amount = std::min(
+		left,
+		int64(_full.size() - _part.size()));
+	Assert(amount > 0);
+	const auto readBytes = _binlog.read(
+		_full.subspan(_part.size(), amount));
+	if (!readBytes) {
+		return no();
+	}
+	_part = _full.subspan(0, _part.size() + readBytes);
+	return true;
+}
+
+bytes::const_span BinlogWrapper::readRecord(ReadRecordSize readRecordSize) {
+	if (_finished) {
+		return {};
+	}
+	const auto size = readRecordSize(*this, _part);
+	if (size == kRecordSizeUnknown || size > _part.size()) {
+		return {};
+	} else if (size == kRecordSizeInvalid) {
+		finish();
+		_finished = _failed = true;
+		return {};
+	}
+	Assert(size >= 0);
+	const auto result = _part.subspan(0, size);
+	_part = _part.subspan(size);
+	return result;
+}
+
+void BinlogWrapper::finish(size_type rollback) {
+	Expects(rollback >= 0);
+
+	if (rollback > 0) {
+		_failed = true;
+	}
+	rollback += _part.size();
+	_binlog.seek(_binlog.offset() - rollback);
+}
+
+} // namespace details
+} // namespace Cache
+} // namespace Storage
diff --git a/Telegram/lib_storage/storage/cache/storage_cache_binlog_reader.h b/Telegram/lib_storage/storage/cache/storage_cache_binlog_reader.h
new file mode 100644
index 0000000..b6ab7fb
--- /dev/null
+++ b/Telegram/lib_storage/storage/cache/storage_cache_binlog_reader.h
@@ -0,0 +1,264 @@
+// This file is part of Desktop App Toolkit,
+// a set of libraries for developing nice desktop applications.
+//
+// For license and copyright information please follow this link:
+// https://github.com/desktop-app/legal/blob/master/LEGAL
+//
+#pragma once
+
+#include "storage/cache/storage_cache_types.h"
+#include "storage/storage_encrypted_file.h"
+#include "base/bytes.h"
+#include "base/match_method.h"
+
+namespace Storage {
+namespace Cache {
+namespace details {
+
+template <typename ...Records>
+class BinlogReader;
+
+class BinlogWrapper {
+public:
+	BinlogWrapper(File &binlog, const Settings &settings, int64 till = 0);
+
+	bool finished() const;
+	bool failed() const;
+
+	static std::optional<BasicHeader> ReadHeader(
+		File &binlog,
+		const Settings &settings);
+
+private:
+	template <typename ...Records>
+	friend class BinlogReader;
+
+	bool readPart();
+	void finish(size_type rollback = 0);
+
+	using ReadRecordSize = size_type (*)(
+		const BinlogWrapper &that,
+		bytes::const_span data);
+	bytes::const_span readRecord(ReadRecordSize readRecordSize);
+
+	File &_binlog;
+	Settings _settings;
+
+	int64 _till = 0;
+	bytes::vector _data;
+	bytes::span _full;
+	bytes::span _part;
+	bool _finished = false;
+	bool _failed = false;
+
+};
+
+template <typename ...Records>
+class BinlogReader {
+public:
+	explicit BinlogReader(BinlogWrapper &wrapper);
+
+	template <typename ...Handlers>
+	bool readTillEnd(Handlers &&...handlers);
+
+private:
+	static size_type ReadRecordSize(
+		const BinlogWrapper &that,
+		bytes::const_span data);
+
+	template <typename ...Handlers>
+	bool handleRecord(bytes::const_span data, Handlers &&...handlers) const;
+
+	BinlogWrapper &_wrapper;
+
+};
+
+template <typename Record>
+struct MultiRecord {
+	using true_t = char;
+	using false_t = true_t(&)[2];
+	static_assert(sizeof(true_t) != sizeof(false_t));
+
+	static false_t Check(...);
+	template <typename Test, typename = typename Test::Part>
+	static true_t Check(const Test&);
+
+	static constexpr bool Is = (sizeof(Check(std::declval<Record>()))
+		== sizeof(true_t));
+};
+
+template <typename ...Records>
+struct BinlogReaderRecursive {
+	static void CheckSettings(const Settings &settings) {
+	}
+
+	static size_type ReadRecordSize(
+			RecordType type,
+			bytes::const_span data,
+			size_type partsLimit) {
+		return kRecordSizeInvalid;
+	}
+
+	template <typename ...Handlers>
+	static bool HandleRecord(
+			RecordType type,
+			bytes::const_span data,
+			Handlers &&...handlers) {
+		Unexpected("Bad type in BinlogReaderRecursive::HandleRecord.");
+	}
+};
+
+template <typename Record, typename ...Other>
+struct BinlogReaderRecursive<Record, Other...> {
+	static void CheckSettings(const Settings &settings);
+
+	static size_type ReadRecordSize(
+		RecordType type,
+		bytes::const_span data,
+		size_type partsLimit);
+
+	template <typename ...Handlers>
+	static bool HandleRecord(
+		RecordType type,
+		bytes::const_span data,
+		Handlers &&...handlers);
+};
+
+template <typename Record, typename ...Other>
+inline void BinlogReaderRecursive<Record, Other...>::CheckSettings(
+		const Settings &settings) {
+	static_assert(GoodForEncryption<Record>);
+	if constexpr (MultiRecord<Record>::Is) {
+		using Head = Record;
+		using Part = typename Record::Part;
+		static_assert(GoodForEncryption<Part>);
+		Assert(settings.readBlockSize
+			>= (sizeof(Head)
+				+ settings.maxBundledRecords * sizeof(Part)));
+	} else {
+		Assert(settings.readBlockSize >= sizeof(Record));
+	}
+}
+
+template <typename Record, typename ...Other>
+inline size_type BinlogReaderRecursive<Record, Other...>::ReadRecordSize(
+		RecordType type,
+		bytes::const_span data,
+		size_type partsLimit) {
+	if (type != Record::kType) {
+		return BinlogReaderRecursive<Other...>::ReadRecordSize(
+			type,
+			data,
+			partsLimit);
+	}
+	if constexpr (MultiRecord<Record>::Is) {
+		using Head = Record;
+		using Part = typename Record::Part;
+
+		if (data.size() < sizeof(Head)) {
+			return kRecordSizeUnknown;
+		}
+		const auto head = reinterpret_cast<const Head*>(data.data());
+		const auto count = head->validateCount();
+		return (count >= 0 && count <= partsLimit)
+				? (sizeof(Head) + count * sizeof(Part))
+				: kRecordSizeInvalid;
+	} else {
+		return sizeof(Record);
+	}
+}
+
+template <typename Record, typename ...Other>
+template <typename ...Handlers>
+inline bool BinlogReaderRecursive<Record, Other...>::HandleRecord(
+		RecordType type,
+		bytes::const_span data,
+		Handlers &&...handlers) {
+	if (type != Record::kType) {
+		return BinlogReaderRecursive<Other...>::HandleRecord(
+			type,
+			data,
+			std::forward<Handlers>(handlers)...);
+	}
+	if constexpr (MultiRecord<Record>::Is) {
+		using Head = Record;
+		using Part = typename Record::Part;
+
+		Assert(data.size() >= sizeof(Head));
+		const auto bytes = data.data();
+		const auto head = reinterpret_cast<const Head*>(bytes);
+		const auto count = head->validateCount();
+		Assert(data.size() == sizeof(Head) + count * sizeof(Part));
+		const auto parts = gsl::make_span(
+			reinterpret_cast<const Part*>(bytes + sizeof(Head)),
+			count);
+		auto from = std::begin(parts);
+		const auto till = std::end(parts);
+		const auto element = [&] {
+			return (from == till) ? nullptr : &*from++;
+		};
+		return base::match_method2(
+			*head,
+			element,
+			std::forward<Handlers>(handlers)...);
+	} else {
+		Assert(data.size() == sizeof(Record));
+		return base::match_method(
+			*reinterpret_cast<const Record*>(data.data()),
+			std::forward<Handlers>(handlers)...);
+	}
+}
+
+template <typename ...Records>
+BinlogReader<Records...>::BinlogReader(BinlogWrapper &wrapper)
+: _wrapper(wrapper) {
+	BinlogReaderRecursive<Records...>::CheckSettings(_wrapper._settings);
+}
+
+template <typename ...Records>
+template <typename ...Handlers>
+bool BinlogReader<Records...>::readTillEnd(Handlers &&...handlers) {
+	if (!_wrapper.readPart()) {
+		return true;
+	}
+	const auto readRecord = [&] {
+		return _wrapper.readRecord(&BinlogReader::ReadRecordSize);
+	};
+	for (auto bytes = readRecord(); !bytes.empty(); bytes = readRecord()) {
+		if (!handleRecord(bytes, std::forward<Handlers>(handlers)...)) {
+			_wrapper.finish(bytes.size());
+			return true;
+		}
+	}
+	return false;
+}
+
+template <typename ...Records>
+size_type BinlogReader<Records...>::ReadRecordSize(
+		const BinlogWrapper &that,
+		bytes::const_span data) {
+	if (data.empty()) {
+		return kRecordSizeUnknown;
+	}
+	return BinlogReaderRecursive<Records...>::ReadRecordSize(
+		static_cast<RecordType>(data[0]),
+		data,
+		that._settings.maxBundledRecords);
+}
+
+template <typename ...Records>
+template <typename ...Handlers>
+bool BinlogReader<Records...>::handleRecord(
+		bytes::const_span data,
+		Handlers &&...handlers) const {
+	Expects(!data.empty());
+
+	return BinlogReaderRecursive<Records...>::HandleRecord(
+		static_cast<RecordType>(data[0]),
+		data,
+		std::forward<Handlers>(handlers)...);
+}
+
+} // namespace details
+} // namespace Cache
+} // namespace Storage
diff --git a/Telegram/lib_storage/storage/cache/storage_cache_cleaner.cpp b/Telegram/lib_storage/storage/cache/storage_cache_cleaner.cpp
new file mode 100644
index 0000000..63f27e4
--- /dev/null
+++ b/Telegram/lib_storage/storage/cache/storage_cache_cleaner.cpp
@@ -0,0 +1,110 @@
+// This file is part of Desktop App Toolkit,
+// a set of libraries for developing nice desktop applications.
+//
+// For license and copyright information please follow this link:
+// https://github.com/desktop-app/legal/blob/master/LEGAL
+//
+#include "storage/cache/storage_cache_cleaner.h"
+
+#include <crl/crl.h>
+#include <QtCore/QDir>
+#include <QtCore/QFile>
+#include <unordered_map>
+#include <set>
+
+namespace Storage {
+namespace Cache {
+namespace details {
+
+class CleanerObject {
+public:
+	CleanerObject(
+		crl::weak_on_queue<CleanerObject> weak,
+		const QString &base,
+		base::binary_guard &&guard,
+		FnMut<void(Error)> done);
+
+private:
+	void start();
+	void scheduleNext();
+	void cleanNext();
+	void done();
+
+	crl::weak_on_queue<CleanerObject> _weak;
+	QString _base, _errorPath;
+	std::vector<QString> _queue;
+	base::binary_guard _guard;
+	FnMut<void(Error)> _done;
+
+};
+
+CleanerObject::CleanerObject(
+	crl::weak_on_queue<CleanerObject> weak,
+	const QString &base,
+	base::binary_guard &&guard,
+	FnMut<void(Error)> done)
+: _weak(std::move(weak))
+, _base(base)
+, _guard(std::move(guard))
+, _done(std::move(done)) {
+	start();
+}
+
+void CleanerObject::start() {
+	const auto entries = QDir(_base).entryList(
+		QDir::Dirs | QDir::NoDotAndDotDot);
+	for (const auto entry : entries) {
+		_queue.push_back(entry);
+	}
+	if (const auto version = ReadVersionValue(_base)) {
+		_queue.erase(
+			ranges::remove(_queue, QString::number(*version)),
+			end(_queue));
+		scheduleNext();
+	} else {
+		_errorPath = VersionFilePath(_base);
+		done();
+	}
+}
+
+void CleanerObject::scheduleNext() {
+	if (_queue.empty()) {
+		done();
+		return;
+	}
+	_weak.with([](CleanerObject &that) {
+		if (that._guard) {
+			that.cleanNext();
+		}
+	});
+}
+
+void CleanerObject::cleanNext() {
+	const auto path = _base + _queue.back();
+	_queue.pop_back();
+	if (!QDir(path).removeRecursively()) {
+		_errorPath = path;
+	}
+	scheduleNext();
+}
+
+void CleanerObject::done() {
+	if (_done) {
+		_done(_errorPath.isEmpty()
+			? Error::NoError()
+			: Error{ Error::Type::IO, _errorPath });
+	}
+}
+
+Cleaner::Cleaner(
+	const QString &base,
+	base::binary_guard &&guard,
+	FnMut<void(Error)> done)
+: _wrapped(base, std::move(guard), std::move(done)) {
+}
+
+Cleaner::~Cleaner() = default;
+
+} // namespace details
+} // namespace Cache
+} // namespace Storage
diff --git a/Telegram/lib_storage/storage/cache/storage_cache_cleaner.h b/Telegram/lib_storage/storage/cache/storage_cache_cleaner.h
new file mode 100644
index 0000000..6f65670
--- /dev/null
+++ b/Telegram/lib_storage/storage/cache/storage_cache_cleaner.h
@@ -0,0 +1,35 @@
+// This file is part of Desktop App Toolkit,
+// a set of libraries for developing nice desktop applications.
+//
+// For license and copyright information please follow this link:
+// https://github.com/desktop-app/legal/blob/master/LEGAL
+//
+#pragma once
+
+#include "storage/cache/storage_cache_types.h"
+#include "base/binary_guard.h"
+
+namespace Storage {
+namespace Cache {
+namespace details {
+
+class CleanerObject;
+
+class Cleaner {
+public:
+	Cleaner(
+		const QString &base,
+		base::binary_guard &&guard,
+		FnMut<void(Error)> done);
+
+	~Cleaner();
+
+private:
+	using Implementation = details::CleanerObject;
+	crl::object_on_queue<Implementation> _wrapped;
+
+};
+
+} // namespace details
+} // namespace Cache
+} // namespace Storage
diff --git a/Telegram/lib_storage/storage/cache/storage_cache_compactor.cpp b/Telegram/lib_storage/storage/cache/storage_cache_compactor.cpp
new file mode 100644
index 0000000..f98f9eb
--- /dev/null
+++ b/Telegram/lib_storage/storage/cache/storage_cache_compactor.cpp
@@ -0,0 +1,433 @@
+// This file is part of Desktop App Toolkit,
+// a set of libraries for developing nice desktop applications.
+//
+// For license and copyright information please follow this link:
+// https://github.com/desktop-app/legal/blob/master/LEGAL
+//
+#include "storage/cache/storage_cache_compactor.h"
+
+#include "storage/cache/storage_cache_database_object.h"
+#include "storage/cache/storage_cache_binlog_reader.h"
+#include <unordered_set>
+
+namespace Storage {
+namespace Cache {
+namespace details {
+
+class CompactorObject {
+public:
+	using Info = Compactor::Info;
+
+	CompactorObject(
+		crl::weak_on_queue<CompactorObject> weak,
+		crl::weak_on_queue<DatabaseObject> database,
+		base::binary_guard guard,
+		const QString &base,
+		const Settings &settings,
+		EncryptionKey &&key,
+		const Info &info);
+
+private:
+	using Entry = DatabaseObject::Entry;
+	using Raw = DatabaseObject::Raw;
+	using RawSpan = gsl::span<const Raw>;
+	static QString CompactFilename();
+
+	void start();
+	QString binlogPath() const;
+	QString compactPath() const;
+	bool openBinlog();
+	bool readHeader();
+	bool openCompact();
+	void parseChunk();
+	void fail();
+	void done(int64 till);
+	void finish();
+	void finalize();
+
+	std::vector<Key> readChunk();
+	bool readBlock(std::vector<Key> &result);
+	void processValues(const std::vector<Raw> &values);
+
+	template <typename MultiRecord>
+	void initList();
+	RawSpan fillList(RawSpan values);
+	template <typename RecordStore>
+	RawSpan fillList(std::vector<RecordStore> &list, RawSpan values);
+	template <typename RecordStore>
+	void addListRecord(
+		std::vector<RecordStore> &list,
+		const Raw &raw);
+	bool writeList();
+	template <typename MultiRecord>
+	bool writeMultiStore();
+
+	crl::weak_on_queue<CompactorObject> _weak;
+	crl::weak_on_queue<DatabaseObject> _database;
+	base::binary_guard _guard;
+	QString _base;
+	Settings _settings;
+	EncryptionKey _key;
+	BasicHeader _header;
+	Info _info;
+	File _binlog;
+	File _compact;
+	BinlogWrapper _wrapper;
+	size_type _partSize = 0;
+	std::unordered_set<Key> _written;
+	base::variant<
+		std::vector<MultiStore::Part>,
+		std::vector<MultiStoreWithTime::Part>> _list;
+
+};
+
+CompactorObject::CompactorObject(
+	crl::weak_on_queue<CompactorObject> weak,
+	crl::weak_on_queue<DatabaseObject> database,
+	base::binary_guard guard,
+	const QString &base,
+	const Settings &settings,
+	EncryptionKey &&key,
+	const Info &info)
+: _weak(std::move(weak))
+, _database(std::move(database))
+, _guard(std::move(guard))
+, _base(base)
+, _settings(settings)
+, _key(std::move(key))
+, _info(info)
+, _wrapper(_binlog, _settings, _info.till)
+, _partSize(_settings.maxBundledRecords) { // Perhaps a better estimate?
+	Expects(_settings.compactChunkSize > 0);
+
+	_written.reserve(_info.keysCount);
+	start();
+}
+
+template <typename MultiRecord>
+void CompactorObject::initList() {
+	using Part = typename MultiRecord::Part;
+	auto list = std::vector<Part>();
+	list.reserve(_partSize);
+	_list = std::move(list);
+}
+
+void CompactorObject::start() {
+	if (!openBinlog() || !readHeader() || !openCompact()) {
+		fail();
+	}
+	if (_settings.trackEstimatedTime) {
+		initList<MultiStoreWithTime>();
+	} else {
+		initList<MultiStore>();
+	}
+	parseChunk();
+}
+
+QString CompactorObject::CompactFilename() {
+	return QStringLiteral("binlog-temp");
+}
+
+QString CompactorObject::binlogPath() const {
+	return _base + DatabaseObject::BinlogFilename();
+}
+
+QString CompactorObject::compactPath() const {
+	return _base + CompactFilename();
+}
+
+bool CompactorObject::openBinlog() {
+	const auto path = binlogPath();
+	const auto result = _binlog.open(path, File::Mode::Read, _key);
+	return (result == File::Result::Success)
+		&& (_binlog.size() >= _info.till);
+}
+
+bool CompactorObject::readHeader() {
+	const auto header = BinlogWrapper::ReadHeader(_binlog, _settings);
+	if (!header) {
+		return false;
+	}
+	_header = *header;
+	return true;
+}
+
+bool CompactorObject::openCompact() {
+	const auto path = compactPath();
+	const auto result = _compact.open(path, File::Mode::Write, _key);
+	if (result != File::Result::Success) {
+		return false;
+	} else if (!_compact.write(bytes::object_as_span(&_header))) {
+		return false;
+	}
+	return true;
+}
+
+void CompactorObject::fail() {
+	_compact.close();
+	QFile(compactPath()).remove();
+	_database.with([](DatabaseObject &database) {
+		database.compactorFail();
+	});
+}
+
+void CompactorObject::done(int64 till) {
+	const auto path = compactPath();
+	_database.with([=, good = std::move(_guard)](DatabaseObject &database) {
+		if (good) {
+			database.compactorDone(path, till);
+		}
+	});
+}
+
+void CompactorObject::finish() {
+	if (writeList()) {
+		finalize();
+	} else {
+		fail();
+	}
+}
+
+void CompactorObject::finalize() {
+	_binlog.close();
+	_compact.close();
+
+	auto lastCatchUp = 0;
+	auto from = _info.till;
+	while (true) {
+		const auto till = CatchUp(
+			compactPath(),
+			binlogPath(),
+			_key,
+			from,
+			_settings.readBlockSize);
+		if (!till) {
+			fail();
+			return;
+		} else if (till == from
+			|| (lastCatchUp > 0 && (till - from) >= lastCatchUp)) {
+			done(till);
+			return;
+		}
+		lastCatchUp = (till - from);
+		from = till;
+	}
+}
+
+bool CompactorObject::writeList() {
+	if (_list.is<std::vector<MultiStore::Part>>()) {
+		return writeMultiStore<MultiStore>();
+	} else if (_list.is<std::vector<MultiStoreWithTime::Part>>()) {
+		return writeMultiStore<MultiStoreWithTime>();
+	} else {
+		Unexpected("List type in CompactorObject::writeList.");
+	}
+}
+
+template <typename MultiRecord>
+bool CompactorObject::writeMultiStore() {
+	using Part = typename MultiRecord::Part;
+	Assert(_list.is<std::vector<Part>>());
+	auto &list = _list.get_unchecked<std::vector<Part>>();
+	if (list.empty()) {
+		return true;
+	}
+	const auto guard = gsl::finally([&] { list.clear(); });
+	const auto size = list.size();
+	auto header = MultiRecord(size);
+	if (_compact.write(bytes::object_as_span(&header))
+		&& _compact.write(bytes::make_span(list))) {
+		_compact.flush();
+		return true;
+	}
+	return false;
+}
+
+std::vector<Key> CompactorObject::readChunk() {
+	const auto limit = _settings.compactChunkSize;
+	auto result = std::vector<Key>();
+	while (result.size() < limit) {
+		if (!readBlock(result)) {
+			break;
+		}
+	}
+	return result;
+}
+
+bool CompactorObject::readBlock(std::vector<Key> &result) {
+	const auto push = [&](const Store &store) {
+		result.push_back(store.key);
+		return true;
+	};
+	const auto pushMulti = [&](const auto &element) {
+		while (const auto record = element()) {
+			push(*record);
+		}
+		return true;
+	};
+	if (_settings.trackEstimatedTime) {
+		BinlogReader<
+			StoreWithTime,
+			MultiStoreWithTime,
+			MultiRemove,
+			MultiAccess> reader(_wrapper);
+		return !reader.readTillEnd([&](const StoreWithTime &record) {
+			return push(record);
+		}, [&](const MultiStoreWithTime &header, const auto &element) {
+			return pushMulti(element);
+		}, [&](const MultiRemove &header, const auto &element) {
+			return true;
+		}, [&](const MultiAccess &header, const auto &element) {
+			return true;
+		});
+	} else {
+		BinlogReader<
+			Store,
+			MultiStore,
+			MultiRemove> reader(_wrapper);
+		return !reader.readTillEnd([&](const Store &record) {
+			return push(record);
+		}, [&](const MultiStore &header, const auto &element) {
+			return pushMulti(element);
+		}, [&](const MultiRemove &header, const auto &element) {
+			return true;
+		});
+	}
+}
+
+void CompactorObject::parseChunk() {
+	auto keys = readChunk();
+	if (_wrapper.failed()) {
+		fail();
+		return;
+	} else if (keys.empty()) {
+		finish();
+		return;
+	}
+	_database.with([
+		weak = _weak,
+		keys = std::move(keys)
+	](DatabaseObject &database) {
+		auto result = database.getManyRaw(keys);
+		weak.with([result = std::move(result)](CompactorObject &that) {
+			that.processValues(result);
+		});
+	});
+}
+
+void CompactorObject::processValues(
+		const std::vector<std::pair<Key, Entry>> &values) {
+	auto left = gsl::make_span(values);
+	while (true) {
+		left = fillList(left);
+		if (left.empty()) {
+			break;
+		} else if (!writeList()) {
+			fail();
+			return;
+		}
+	}
+	parseChunk();
+}
+
+auto CompactorObject::fillList(RawSpan values) -> RawSpan {
+	return _list.match([&](auto &list) {
+		return fillList(list, values);
+	});
+}
+
+template <typename RecordStore>
+auto CompactorObject::fillList(
+	std::vector<RecordStore> &list,
+	RawSpan values
+) -> RawSpan {
+	const auto b = std::begin(values);
+	const auto e = std::end(values);
+	auto i = b;
+	while (i != e && list.size() != _partSize) {
+		addListRecord(list, *i++);
+	}
+	return values.subspan(i - b);
+}
+
+template <typename RecordStore>
+void CompactorObject::addListRecord(
+		std::vector<RecordStore> &list,
+		const Raw &raw) {
+	if (!_written.emplace(raw.first).second) {
+		return;
+	}
+	auto record = RecordStore();
+	record.key = raw.first;
+	record.setSize(raw.second.size);
+	record.checksum = raw.second.checksum;
+	record.tag = raw.second.tag;
+	record.place = raw.second.place;
+	if constexpr (std::is_same_v<RecordStore, StoreWithTime>) {
+		record.time.setRelative(raw.second.useTime);
+		record.time.system = _info.systemTime;
+	}
+	list.push_back(record);
+}
+
+Compactor::Compactor(
+	crl::weak_on_queue<DatabaseObject> database,
+	base::binary_guard guard,
+	const QString &base,
+	const Settings &settings,
+	EncryptionKey &&key,
+	const Info &info)
+: _wrapped(
+	std::move(database),
+	std::move(guard),
+	base,
+	settings,
+	std::move(key),
+	info) {
+}
+
+Compactor::~Compactor() = default;
+
+int64 CatchUp(
+		const QString &compactPath,
+		const QString &binlogPath,
+		const EncryptionKey &key,
+		int64 from,
+		size_type block) {
+	File binlog, compact;
+	const auto result1 = binlog.open(binlogPath, File::Mode::Read, key);
+	if (result1 != File::Result::Success) {
+		return 0;
+	}
+	const auto till = binlog.size();
+	if (till == from) {
+		return till;
+	} else if (till < from || !binlog.seek(from)) {
+		return 0;
+	}
+	const auto result2 = compact.open(
+		compactPath,
+		File::Mode::ReadAppend,
+		key);
+	if (result2 != File::Result::Success || !compact.seek(compact.size())) {
+		return 0;
+	}
+	auto buffer = bytes::vector(block);
+	auto bytes = bytes::make_span(buffer);
+	do {
+		const auto left = (till - from);
+		const auto limit = std::min(size_type(left), block);
+		const auto read = binlog.read(bytes.subspan(0, limit));
+		if (!read || read > limit) {
+			return 0;
+		} else if (!compact.write(bytes.subspan(0, read))) {
+			return 0;
+		}
+		from += read;
+	} while (from != till);
+	return till;
+}
+
+} // namespace details
+} // namespace Cache
+} // namespace Storage
diff --git a/Telegram/lib_storage/storage/cache/storage_cache_compactor.h b/Telegram/lib_storage/storage/cache/storage_cache_compactor.h
new file mode 100644
index 0000000..97ce1e6
--- /dev/null
+++ b/Telegram/lib_storage/storage/cache/storage_cache_compactor.h
@@ -0,0 +1,54 @@
+// This file is part of Desktop App Toolkit,
+// a set of libraries for developing nice desktop applications.
+//
+// For license and copyright information please follow this link:
+// https://github.com/desktop-app/legal/blob/master/LEGAL
+//
+#pragma once
+
+#include "storage/cache/storage_cache_types.h"
+#include <crl/crl_object_on_queue.h>
+#include <base/binary_guard.h>
+
+namespace Storage {
+class EncryptionKey;
+namespace Cache {
+namespace details {
+
+class CompactorObject;
+class DatabaseObject;
+
+class Compactor {
+public:
+	struct Info {
+		int64 till = 0;
+		uint32 systemTime = 0;
+		size_type keysCount = 0;
+	};
+
+	Compactor(
+		crl::weak_on_queue<DatabaseObject> database,
+		base::binary_guard guard,
+		const QString &base,
+		const Settings &settings,
+		EncryptionKey &&key,
+		const Info &info);
+
+	~Compactor();
+
+private:
+	using Implementation = CompactorObject;
+	crl::object_on_queue<Implementation> _wrapped;
+
+};
+
+int64 CatchUp(
+	const QString &compactPath,
+	const QString &binlogPath,
+	const EncryptionKey &key,
+	int64 from,
+	size_type block);
+
+} // namespace details
+} // namespace Cache
+} // namespace Storage
diff --git a/Telegram/lib_storage/storage/cache/storage_cache_database.cpp b/Telegram/lib_storage/storage/cache/storage_cache_database.cpp
new file mode 100644
index 0000000..894b3cd
--- /dev/null
+++ b/Telegram/lib_storage/storage/cache/storage_cache_database.cpp
@@ -0,0 +1,202 @@
+// This file is part of Desktop App Toolkit,
+// a set of libraries for developing nice desktop applications.
+//
+// For license and copyright information please follow this link:
+// https://github.com/desktop-app/legal/blob/master/LEGAL
+//
+#include "storage/cache/storage_cache_database.h"
+
+#include "storage/cache/storage_cache_database_object.h"
+
+namespace Storage {
+namespace Cache {
+
+Database::Database(const QString &path, const Settings &settings)
+: _wrapped(path, settings) {
+}
+
+void Database::reconfigure(const Settings &settings) {
+	_wrapped.with([settings](Implementation &unwrapped) mutable {
+		unwrapped.reconfigure(settings);
+	});
+}
+
+void Database::updateSettings(const SettingsUpdate &update) {
+	_wrapped.with([update](Implementation &unwrapped) mutable {
+		unwrapped.updateSettings(update);
+	});
+}
+
+void Database::open(EncryptionKey &&key, FnMut<void(Error)> &&done) {
+	_wrapped.with([
+		key = std::move(key),
+		done = std::move(done)
+	](Implementation &unwrapped) mutable {
+		unwrapped.open(std::move(key), std::move(done));
+	});
+}
+
+void Database::close(FnMut<void()> &&done) {
+	_wrapped.with([
+		done = std::move(done)
+	](Implementation &unwrapped) mutable {
+		unwrapped.close(std::move(done));
+	});
+}
+
+void Database::waitForCleaner(FnMut<void()> &&done) {
+	_wrapped.with([
+		done = std::move(done)
+	](Implementation &unwrapped) mutable {
+		unwrapped.waitForCleaner(std::move(done));
+	});
+}
+
+void Database::put(
+		const Key &key,
+		QByteArray &&value,
+		FnMut<void(Error)> &&done) {
+	return put(key, TaggedValue(std::move(value), 0), std::move(done));
+}
+
+void Database::get(const Key &key, FnMut<void(QByteArray&&)> &&done) {
+	if (done) {
+		auto untag = [done = std::move(done)](TaggedValue &&value) mutable {
+			done(std::move(value.bytes));
+		};
+		getWithTag(key, std::move(untag));
+	} else {
+		getWithTag(key, nullptr);
+	}
+}
+
+void Database::remove(const Key &key, FnMut<void(Error)> &&done) {
+	_wrapped.with([
+		key,
+		done = std::move(done)
+	](Implementation &unwrapped) mutable {
+		unwrapped.remove(key, std::move(done));
+	});
+}
+
+void Database::putIfEmpty(
+		const Key &key,
+		QByteArray &&value,
+		FnMut<void(Error)> &&done) {
+	return putIfEmpty(
+		key,
+		TaggedValue(std::move(value), 0),
+		std::move(done));
+}
+
+void Database::copyIfEmpty(
+		const Key &from,
+		const Key &to,
+		FnMut<void(Error)> &&done) {
+	_wrapped.with([
+		from,
+		to,
+		done = std::move(done)
+	](Implementation &unwrapped) mutable {
+		unwrapped.copyIfEmpty(from, to, std::move(done));
+	});
+}
+
+void Database::moveIfEmpty(
+		const Key &from,
+		const Key &to,
+		FnMut<void(Error)> &&done) {
+	_wrapped.with([
+		from,
+		to,
+		done = std::move(done)
+	](Implementation &unwrapped) mutable {
+		unwrapped.moveIfEmpty(from, to, std::move(done));
+	});
+}
+
+void Database::put(
+		const Key &key,
+		TaggedValue &&value,
+		FnMut<void(Error)> &&done) {
+	_wrapped.with([
+		key,
+		value = std::move(value),
+		done = std::move(done)
+	](Implementation &unwrapped) mutable {
+		unwrapped.put(key, std::move(value), std::move(done));
+	});
+}
+
+void Database::putIfEmpty(
+		const Key &key,
+		TaggedValue &&value,
+		FnMut<void(Error)> &&done) {
+	_wrapped.with([
+		key,
+		value = std::move(value),
+		done = std::move(done)
+	](Implementation &unwrapped) mutable {
+		unwrapped.putIfEmpty(key, std::move(value), std::move(done));
+	});
+}
+
+void Database::getWithTag(
+		const Key &key,
+		FnMut<void(TaggedValue&&)> &&done) {
+	_wrapped.with([
+		key,
+		done = std::move(done)
+	](Implementation &unwrapped) mutable {
+		unwrapped.get(key, std::move(done));
+	});
+}
+
+void Database::getWithSizes(
+		const Key &key,
+		std::vector<Key> &&keys,
+		FnMut<void(QByteArray&&, std::vector<int>&&)> &&done) {
+	_wrapped.with([
+		key,
+		keys = std::move(keys),
+		done = std::move(done)
+	](Implementation &unwrapped) mutable {
+		unwrapped.getWithSizes(key, std::move(keys), std::move(done));
+	});
+}
+
+auto Database::statsOnMain() const -> rpl::producer<Stats> {
+	return _wrapped.producer_on_main([](const Implementation &unwrapped) {
+		return unwrapped.stats();
+	});
+}
+
+void Database::clear(FnMut<void(Error)> &&done) {
+	_wrapped.with([
+		done = std::move(done)
+	](Implementation &unwrapped) mutable {
+		unwrapped.clear(std::move(done));
+	});
+}
+
+void Database::clearByTag(uint8 tag, FnMut<void(Error)> &&done) {
+	_wrapped.with([
+		tag,
+		done = std::move(done)
+	](Implementation &unwrapped) mutable {
+		unwrapped.clearByTag(tag, std::move(done));
+	});
+}
+
+void Database::sync() {
+	auto semaphore = crl::semaphore();
+	_wrapped.with([&](Implementation &) {
+		semaphore.release();
+	});
+	semaphore.acquire();
+}
+
+Database::~Database() = default;
+
+} // namespace Cache
+} // namespace Storage
diff --git a/Telegram/lib_storage/storage/cache/storage_cache_database.h b/Telegram/lib_storage/storage/cache/storage_cache_database.h
new file mode 100644
index 0000000..19a1413
--- /dev/null
+++ b/Telegram/lib_storage/storage/cache/storage_cache_database.h
@@ -0,0 +1,90 @@
+// This file is part of Desktop App Toolkit,
+// a set of libraries for developing nice desktop applications.
+//
+// For license and copyright information please follow this link:
+// https://github.com/desktop-app/legal/blob/master/LEGAL
+//
+#pragma once
+
+#include "storage/cache/storage_cache_types.h"
+#include "base/basic_types.h"
+#include <crl/crl_object_on_queue.h>
+#include <crl/crl_time.h>
+#include <rpl/producer.h>
+#include <QtCore/QString>
+
+namespace Storage {
+class EncryptionKey;
+namespace Cache {
+namespace details {
+class DatabaseObject;
+} // namespace details
+
+class Database {
+public:
+	using Settings = details::Settings;
+	using SettingsUpdate = details::SettingsUpdate;
+	Database(const QString &path, const Settings &settings);
+
+	void reconfigure(const Settings &settings);
+	void updateSettings(const SettingsUpdate &update);
+
+	void open(EncryptionKey &&key, FnMut<void(Error)> &&done = nullptr);
+	void close(FnMut<void()> &&done = nullptr);
+
+	void put(
+		const Key &key,
+		QByteArray &&value,
+		FnMut<void(Error)> &&done = nullptr);
+	void get(const Key &key, FnMut<void(QByteArray&&)> &&done);
+	void remove(const Key &key, FnMut<void(Error)> &&done = nullptr);
+
+	void putIfEmpty(
+		const Key &key,
+		QByteArray &&value,
+		FnMut<void(Error)> &&done = nullptr);
+	void copyIfEmpty(
+		const Key &from,
+		const Key &to,
+		FnMut<void(Error)> &&done = nullptr);
+	void moveIfEmpty(
+		const Key &from,
+		const Key &to,
+		FnMut<void(Error)> &&done = nullptr);
+
+	using TaggedValue = details::TaggedValue;
+	void put(
+		const Key &key,
+		TaggedValue &&value,
+		FnMut<void(Error)> &&done = nullptr);
+	void putIfEmpty(
+		const Key &key,
+		TaggedValue &&value,
+		FnMut<void(Error)> &&done = nullptr);
+	void getWithTag(const Key &key, FnMut<void(TaggedValue&&)> &&done);
+
+	void getWithSizes(
+		const Key &key,
+		std::vector<Key> &&keys,
+		FnMut<void(QByteArray&&, std::vector<int>&&)> &&done);
+
+	using Stats = details::Stats;
+	using TaggedSummary = details::TaggedSummary;
+	rpl::producer<Stats> statsOnMain() const;
+
+	void clear(FnMut<void(Error)> &&done = nullptr);
+	void clearByTag(uint8 tag, FnMut<void(Error)> &&done = nullptr);
+	void waitForCleaner(FnMut<void()> &&done = nullptr);
+
+	void sync();
+
+	~Database();
+
+private:
+	using Implementation = details::DatabaseObject;
+	crl::object_on_queue<Implementation> _wrapped;
+
+};
+
+} // namespace Cache
+} // namespace Storage
diff --git a/Telegram/lib_storage/storage/cache/storage_cache_database_object.cpp b/Telegram/lib_storage/storage/cache/storage_cache_database_object.cpp
new file mode 100644
index 0000000..b5772a6
--- /dev/null
+++ b/Telegram/lib_storage/storage/cache/storage_cache_database_object.cpp
@@ -0,0 +1,1360 @@
+// This file is part of Desktop App Toolkit,
+// a set of libraries for developing nice desktop applications.
+//
+// For license and copyright information please follow this link:
+// https://github.com/desktop-app/legal/blob/master/LEGAL
+//
+#include "storage/cache/storage_cache_database_object.h"
+
+#include "storage/cache/storage_cache_cleaner.h"
+#include "storage/cache/storage_cache_compactor.h"
+#include "storage/cache/storage_cache_binlog_reader.h"
+#include "storage/storage_encryption.h"
+#include "storage/storage_encrypted_file.h"
+#include "base/flat_map.h"
+#include "base/algorithm.h"
+#include <crl/crl.h>
+#include <xxhash.h>
+#include <QtCore/QDir>
+#include <unordered_map>
+#include <set>
+
+namespace Storage {
+namespace Cache {
+namespace details {
+namespace {
+
+constexpr auto kMaxDelayAfterFailure = 24 * 60 * 60 * crl::time(1000);
+
+uint32 CountChecksum(bytes::const_span data) {
+	const auto seed = uint32(0);
+	return XXH32(data.data(), data.size(), seed);
+}
+
+QString PlaceFromId(PlaceId place) {
+	auto result = QString();
+	result.reserve(15);
+	const auto pushDigit = [&](uint8 digit) {
+		const auto hex = (digit < 0x0A)
+			? char('0' + digit)
+			: char('A' + (digit - 0x0A));
+		result.push_back(hex);
+	};
+	const auto push = [&](uint8 value) {
+		pushDigit(value & 0x0F);
+		pushDigit(value >> 4);
+	};
+	for (auto i = 0; i != place.size(); ++i) {
+		push(place[i]);
+		if (!i) {
+			result.push_back('/');
+		}
+	}
+	return result;
+}
+
+int32 GetUnixtime() {
+	return std::max(int32(time(nullptr)), 1);
+}
+
+} // namespace
+
+DatabaseObject::Entry::Entry(
+	PlaceId place,
+	uint8 tag,
+	uint32 checksum,
+	size_type size,
+	uint64 useTime)
+: useTime(useTime)
+, size(size)
+, checksum(checksum)
+, place(place)
+, tag(tag) {
+}
+
+DatabaseObject::DatabaseObject(
+	crl::weak_on_queue<DatabaseObject> weak,
+	const QString &path,
+	const Settings &settings)
+: _weak(std::move(weak))
+, _base(ComputeBasePath(path))
+, _settings(settings)
+, _writeBundlesTimer(_weak, [=] { writeBundles(); checkCompactor(); })
+, _pruneTimer(_weak, [=] { prune(); }) {
+	checkSettings();
+}
+
+void DatabaseObject::reconfigure(const Settings &settings) {
+	Expects(_key.empty());
+
+	_settings = settings;
+	checkSettings();
+}
+
+void DatabaseObject::updateSettings(const SettingsUpdate &update) {
+	_settings.totalSizeLimit = update.totalSizeLimit;
+	_settings.totalTimeLimit = update.totalTimeLimit;
+	checkSettings();
+
+	optimize();
+}
+
+void DatabaseObject::checkSettings() {
+	Expects(_settings.staleRemoveChunk > 0);
+	Expects(_settings.maxDataSize > 0
+		&& _settings.maxDataSize < kDataSizeLimit);
+	Expects(_settings.maxBundledRecords > 0
+		&& _settings.maxBundledRecords < kBundledRecordsLimit);
+	Expects(!_settings.totalTimeLimit
+		|| _settings.totalTimeLimit > 0);
+	Expects(!_settings.totalSizeLimit
+		|| _settings.totalSizeLimit > _settings.maxDataSize);
+}
+
+template <typename Callback, typename ...Args>
+void DatabaseObject::invokeCallback(
+		Callback &&callback,
+		Args &&...args) const {
+	if (callback) {
+		callback(std::move(args)...);
+	}
+}
+
+Error DatabaseObject::ioError(const QString &path) const {
+	return { Error::Type::IO, path };
+}
+
+void DatabaseObject::open(EncryptionKey &&key, FnMut<void(Error)> &&done) {
+	close(nullptr);
+
+	const auto error = openSomeBinlog(std::move(key));
+	if (error.type != Error::Type::None) {
+		close(nullptr);
+	}
+	invokeCallback(done, error);
+}
+
+Error DatabaseObject::openSomeBinlog(EncryptionKey &&key) {
+	const auto version = readVersion();
+	const auto result = openBinlog(version, File::Mode::ReadAppend, key);
+	switch (result) {
+	case File::Result::Success: return Error::NoError();
+	case File::Result::Failed: return openNewBinlog(key);
+	case File::Result::LockFailed:
+		return Error{ Error::Type::LockFailed, binlogPath(version) };
+	case File::Result::WrongKey:
+		return _settings.clearOnWrongKey
+			? openNewBinlog(key)
+			: Error{ Error::Type::WrongKey, binlogPath(version) };
+	}
+	Unexpected("Result from DatabaseObject::openBinlog.");
+}
+
+Error DatabaseObject::openNewBinlog(EncryptionKey &key) {
+	const auto available = findAvailableVersion();
+	if (!writeVersion(available)) {
+		return ioError(versionPath());
+	}
+	const auto open = openBinlog(available, File::Mode::Write, key);
+	if (open != File::Result::Success) {
+		return ioError(binlogPath(available));
+	}
+	return Error::NoError();
+}
+
+QString DatabaseObject::computePath(Version version) const {
+	return _base + QString::number(version) + '/';
+}
+
+QString DatabaseObject::BinlogFilename() {
+	return QStringLiteral("binlog");
+}
+
+QString DatabaseObject::CompactReadyFilename() {
+	return QStringLiteral("binlog-ready");
+}
+
+QString DatabaseObject::binlogPath(Version version) const {
+	return computePath(version) + BinlogFilename();
+}
+
+QString DatabaseObject::binlogPath() const {
+	return _path + BinlogFilename();
+}
+
+QString DatabaseObject::compactReadyPath(Version version) const {
+	return computePath(version) + CompactReadyFilename();
+}
+
+QString DatabaseObject::compactReadyPath() const {
+	return _path + CompactReadyFilename();
+}
+
+File::Result DatabaseObject::openBinlog(
+		Version version,
+		File::Mode mode,
+		EncryptionKey &key) {
+	const auto ready = compactReadyPath(version);
+	const auto path = binlogPath(version);
+	if (QFile(ready).exists() && !File::Move(ready, path)) {
+		return File::Result::Failed;
+	}
+	const auto result = _binlog.open(path, mode, key);
+	if (result != File::Result::Success) {
+		return result;
+	}
+	const auto headerRequired = (mode == File::Mode::Read)
+		|| (mode == File::Mode::ReadAppend && _binlog.size() > 0);
+	const auto headerResult = headerRequired ? readHeader() : writeHeader();
+	if (!headerResult) {
+		return File::Result::Failed;
+	}
+	_path = computePath(version);
+	_key = std::move(key);
+	createCleaner();
+	readBinlog();
+	return File::Result::Success;
+}
+
+bool DatabaseObject::readHeader() {
+	if (const auto header = BinlogWrapper::ReadHeader(_binlog, _settings)) {
+		_time.setRelative((_time.system = header->systemTime));
+		return true;
+	}
+	return false;
+}
+
+bool DatabaseObject::writeHeader() {
+	auto header = BasicHeader();
+	const auto now = _settings.trackEstimatedTime ? GetUnixtime() : 0;
+	_time.setRelative((_time.system = header.systemTime = now));
+	if (_settings.trackEstimatedTime) {
+		header.flags |= header.kTrackEstimatedTime;
+	}
+	return _binlog.write(bytes::object_as_span(&header));
+}
+
+template <typename Reader, typename ...Handlers>
+void DatabaseObject::readBinlogHelper(
+		Reader &reader,
+		Handlers &&...handlers) {
+	while (true) {
+		const auto done = reader.readTillEnd(
+			std::forward<Handlers>(handlers)...);
+		if (done) {
+			break;
+		}
+	}
+}
+
+void DatabaseObject::readBinlog() {
+	BinlogWrapper wrapper(_binlog, _settings);
+	if (_settings.trackEstimatedTime) {
+		BinlogReader<
+			StoreWithTime,
+			MultiStoreWithTime,
+			MultiRemove,
+			MultiAccess> reader(wrapper);
+		readBinlogHelper(reader, [&](const StoreWithTime &record) {
+			return processRecordStore(
+				&record,
+				std::is_class<StoreWithTime>{});
+		}, [&](const MultiStoreWithTime &header, const auto &element) {
+			return processRecordMultiStore(header, element);
+		}, [&](const MultiRemove &header, const auto &element) {
+			return processRecordMultiRemove(header, element);
+		}, [&](const MultiAccess &header, const auto &element) {
+			return processRecordMultiAccess(header, element);
+		});
+	} else {
+		BinlogReader<
+			Store,
+			MultiStore,
+			MultiRemove> reader(wrapper);
+		readBinlogHelper(reader, [&](const Store &record) {
+			return processRecordStore(&record, std::is_class<Store>{});
+		}, [&](const MultiStore &header, const auto &element) {
+			return processRecordMultiStore(header, element);
+		}, [&](const MultiRemove &header, const auto &element) {
+			return processRecordMultiRemove(header, element);
+		});
+	}
+	adjustRelativeTime();
+	optimize();
+}
+
+uint64 DatabaseObject::countRelativeTime() const {
+	const auto now = GetUnixtime();
+	const auto delta = std::max(int64(now) - int64(_time.system), 0LL);
+	return _time.getRelative() + delta;
+}
+
+uint64 DatabaseObject::pruneBeforeTime() const {
+	const auto relative = countRelativeTime();
+	return (_settings.totalTimeLimit && relative > _settings.totalTimeLimit)
+		? (relative - _settings.totalTimeLimit)
+		: 0ULL;
+}
+
+void DatabaseObject::optimize() {
+	if (!startDelayedPruning()) {
+		checkCompactor();
+	}
+}
+
+bool DatabaseObject::startDelayedPruning() {
+	if (!_settings.trackEstimatedTime || _map.empty()) {
+		return false;
+	}
+	const auto before = pruneBeforeTime();
+	const auto pruning = [&] {
+		if (_settings.totalSizeLimit > 0
+			&& _totalSize > _settings.totalSizeLimit) {
+			return true;
+		} else if ((!_minimalEntryTime && !_map.empty())
+			|| _minimalEntryTime <= before) {
+			return true;
+		}
+		return false;
+	}();
+	if (pruning) {
+		if (!_pruneTimer.isActive()
+			|| _pruneTimer.remainingTime() > _settings.pruneTimeout) {
+			_pruneTimer.callOnce(_settings.pruneTimeout);
+		}
+		return true;
+	} else if (_minimalEntryTime != 0) {
+		Assert(_minimalEntryTime > before);
+		const auto seconds = int64(_minimalEntryTime - before);
+		if (!_pruneTimer.isActive()) {
+			_pruneTimer.callOnce(std::min(
+				crl::time(seconds * 1000),
+				_settings.maxPruneCheckTimeout));
+		}
+	}
+	return false;
+}
+
+void DatabaseObject::prune() {
+	if (!_stale.empty()) {
+		return;
+	}
+	auto stale = base::flat_set<Key>();
+	auto staleTotalSize = int64();
+	collectTimeStale(stale, staleTotalSize);
+	collectSizeStale(stale, staleTotalSize);
+	if (stale.size() <= _settings.staleRemoveChunk) {
+		clearStaleNow(stale);
+	} else {
+		_stale = ranges::view::all(stale) | ranges::to_vector;
+		startStaleClear();
+	}
+}
+
+void DatabaseObject::startStaleClear() {
+	// Report "Clearing..." status.
+	pushStats();
+	clearStaleChunk();
+}
+
+void DatabaseObject::clearStaleNow(const base::flat_set<Key> &stale) {
+	if (stale.empty()) {
+		return;
+	}
+
+	// Report "Clearing..." status.
+	_stale.push_back(stale.front());
+	pushStats();
+
+	for (const auto &key : stale) {
+		remove(key, nullptr);
+	}
+
+	// Report correct status async.
+	_stale.clear();
+	optimize();
+}
+
+void DatabaseObject::clearStaleChunkDelayed() {
+	if (_clearingStale) {
+		return;
+	}
+	_clearingStale = true;
+	_weak.with([](DatabaseObject &that) {
+		if (base::take(that._clearingStale)) {
+			that.clearStaleChunk();
+		}
+	});
+}
+
+void DatabaseObject::clearStaleChunk() {
+	if (_stale.empty()) {
+		return;
+	}
+	const auto stale = gsl::make_span(_stale);
+	const auto count = size_type(stale.size());
+	const auto clear = std::min(count, _settings.staleRemoveChunk);
+	for (const auto &key : stale.subspan(count - clear)) {
+		remove(key, nullptr);
+	}
+	_stale.resize(count - clear);
+	if (_stale.empty()) {
+		base::take(_stale);
+		optimize();
+	} else {
+		clearStaleChunkDelayed();
+	}
+}
+
+void DatabaseObject::collectTimeStale(
+		base::flat_set<Key> &stale,
+		int64 &staleTotalSize) {
+	if (!_settings.totalTimeLimit) {
+		return;
+	}
+	const auto before = pruneBeforeTime();
+	if (!_minimalEntryTime || _minimalEntryTime > before) {
+		return;
+	}
+	_minimalEntryTime = 0;
+	_entriesWithMinimalTimeCount = 0;
+	for (const auto &[key, entry] : _map) {
+		if (entry.useTime <= before) {
+			stale.emplace(key);
+			staleTotalSize += entry.size;
+		} else if (!_minimalEntryTime
+			|| _minimalEntryTime > entry.useTime) {
+			_minimalEntryTime = entry.useTime;
+			_entriesWithMinimalTimeCount = 1;
+		} else if (_minimalEntryTime == entry.useTime) {
+			++_entriesWithMinimalTimeCount;
+		}
+	}
+}
+
+void DatabaseObject::collectSizeStale(
+		base::flat_set<Key> &stale,
+		int64 &staleTotalSize) {
+	const auto removeSize = (_settings.totalSizeLimit > 0)
+		? (_totalSize - staleTotalSize - _settings.totalSizeLimit)
+		: 0;
+	if (removeSize <= 0) {
+		return;
+	}
+
+	using Bucket = std::pair<const Key, Entry>;
+	auto oldest = base::flat_multi_map<
+		int64,
+		const Bucket*,
+		std::greater<>>();
+	auto oldestTotalSize = int64();
+
+	const auto canRemoveFirst = [&](const Entry &adding) {
+		const auto totalSizeAfterAdd = oldestTotalSize + adding.size;
+		const auto &first = oldest.begin()->second->second;
+		return (adding.useTime <= first.useTime
+			&& (totalSizeAfterAdd - removeSize >= first.size));
+	};
+
+	for (const auto &bucket : _map) {
+		const auto &entry = bucket.second;
+		if (stale.contains(bucket.first)) {
+			continue;
+		}
+		const auto add = (oldestTotalSize < removeSize)
+			? true
+			: (entry.useTime < oldest.begin()->second->second.useTime);
+		if (!add) {
+			continue;
+		}
+		while (!oldest.empty() && canRemoveFirst(entry)) {
+			oldestTotalSize -= oldest.begin()->second->second.size;
+			oldest.erase(oldest.begin());
+		}
+		oldestTotalSize += entry.size;
+		oldest.emplace(entry.useTime, &bucket);
+	}
+
+	for (const auto &pair : oldest) {
+		stale.emplace(pair.second->first);
+	}
+	staleTotalSize += oldestTotalSize;
+}
+
+void DatabaseObject::adjustRelativeTime() {
+	if (!_settings.trackEstimatedTime) {
+		return;
+	}
+	const auto now = GetUnixtime();
+	if (now < _time.system) {
+		writeMultiAccessBlock();
+	}
+}
+
+template <typename Record, typename Postprocess>
+bool DatabaseObject::processRecordStoreGeneric(
+		const Record *record,
+		Postprocess &&postprocess) {
+	const auto size = record->getSize();
+	if (size <= 0 || size > _settings.maxDataSize) {
+		return false;
+	}
+	auto entry = Entry(
+		record->place,
+		record->tag,
+		record->checksum,
+		size,
+		_time.getRelative());
+	if (!postprocess(entry, record)) {
+		return false;
+	}
+	setMapEntry(record->key, std::move(entry));
+	return true;
+}
+
+bool DatabaseObject::processRecordStore(
+		const Store *record,
+		std::is_class<Store>) {
+	const auto postprocess = [](auto&&...) { return true; };
+	return processRecordStoreGeneric(record, postprocess);
+}
+
+bool DatabaseObject::processRecordStore(
+		const StoreWithTime *record,
+		std::is_class<StoreWithTime>) {
+	const auto postprocess = [&](
+			Entry &entry,
+			not_null<const StoreWithTime*> record) {
+		applyTimePoint(record->time);
+		entry.useTime = record->time.getRelative();
+		return true;
+	};
+	return processRecordStoreGeneric(record, postprocess);
+}
+
+template <typename Record, typename GetElement>
+bool DatabaseObject::processRecordMultiStore(
+		const Record &header,
+		const GetElement &element) {
+	while (const auto entry = element()) {
+		if (!processRecordStore(
+				entry,
+				std::is_class<typename Record::Part>{})) {
+			return false;
+		}
+	}
+	return true;
+}
+
+template <typename GetElement>
+bool DatabaseObject::processRecordMultiRemove(
+		const MultiRemove &header,
+		const GetElement &element) {
+	_binlogExcessLength += sizeof(header);
+	while (const auto entry = element()) {
+		_binlogExcessLength += sizeof(*entry);
+		if (const auto i = _map.find(*entry); i != end(_map)) {
+			eraseMapEntry(i);
+		}
+	}
+	return true;
+}
+
+template <typename GetElement>
+bool DatabaseObject::processRecordMultiAccess(
+		const MultiAccess &header,
+		const GetElement &element) {
+	Expects(_settings.trackEstimatedTime);
+
+	applyTimePoint(header.time);
+	const auto relative = header.time.getRelative();
+
+	_binlogExcessLength += sizeof(header);
+	while (const auto entry = element()) {
+		_binlogExcessLength += sizeof(*entry);
+		if (const auto i = _map.find(*entry); i != end(_map)) {
+			i->second.useTime = relative;
+		}
+	}
+	return true;
+}
+
+void DatabaseObject::setMapEntry(const Key &key, Entry &&entry) {
+	auto &already = _map[key];
+	updateStats(already, entry);
+	if (already.size != 0) {
+		_binlogExcessLength += _settings.trackEstimatedTime
+			? sizeof(StoreWithTime)
+			: sizeof(Store);
+	}
+	if (entry.useTime != 0
+		&& (entry.useTime < _minimalEntryTime || !_minimalEntryTime)) {
+		_minimalEntryTime = entry.useTime;
+		_entriesWithMinimalTimeCount = 1;
+	} else if (_minimalEntryTime != 0 && already.useTime != entry.useTime) {
+		if (entry.useTime == _minimalEntryTime) {
+			Assert(_entriesWithMinimalTimeCount > 0);
+			++_entriesWithMinimalTimeCount;
+		} else if (already.useTime == _minimalEntryTime) {
+			Assert(_entriesWithMinimalTimeCount > 0);
+			if (!--_entriesWithMinimalTimeCount) {
+				_minimalEntryTime = 0;
+			}
+		}
+	}
+	already = std::move(entry);
+}
+
+void DatabaseObject::updateStats(const Entry &was, const Entry &now) {
+	_totalSize += now.size - was.size;
+	if (now.tag == was.tag) {
+		if (now.tag) {
+			auto &summary = _taggedStats[now.tag];
+			summary.count += (now.size ? 1 : 0) - (was.size ? 1 : 0);
+			summary.totalSize += now.size - was.size;
+		}
+	} else {
+		if (now.tag) {
+			auto &summary = _taggedStats[now.tag];
+			summary.count += (now.size ? 1 : 0);
+			summary.totalSize += now.size;
+		}
+		if (was.tag) {
+			auto &summary = _taggedStats[was.tag];
+			summary.count -= (was.size ? 1 : 0);
+			summary.totalSize -= was.size;
+		}
+	}
+	pushStatsDelayed();
+}
+
+void DatabaseObject::pushStatsDelayed() {
+	if (_pushingStats) {
+		return;
+	}
+	_pushingStats = true;
+	_weak.with([](DatabaseObject &that) {
+		if (base::take(that._pushingStats)) {
+			that.pushStats();
+		}
+	});
+}
+
+void DatabaseObject::pushStats() {
+	if (_stats.has_consumers()) {
+		_stats.fire(collectStats());
+	}
+}
+
+void DatabaseObject::eraseMapEntry(const Map::const_iterator &i) {
+	if (i != end(_map)) {
+		const auto &entry = i->second;
+		updateStats(entry, Entry());
+		if (_minimalEntryTime != 0 && entry.useTime == _minimalEntryTime) {
+			Assert(_entriesWithMinimalTimeCount > 0);
+			if (!--_entriesWithMinimalTimeCount) {
+				_minimalEntryTime = 0;
+			}
+		}
+		_map.erase(i);
+	}
+}
+
+EstimatedTimePoint DatabaseObject::countTimePoint() const {
+	const auto now = GetUnixtime();
+	const auto delta = std::max(int64(now) - int64(_time.system), 0LL);
+	auto result = EstimatedTimePoint();
+	result.system = now;
+	result.setRelative(_time.getRelative() + delta);
+	return result;
+}
+
+void DatabaseObject::applyTimePoint(EstimatedTimePoint time) {
+	const auto possible = time.getRelative();
+	const auto current = _time.getRelative();
+	if (possible > current) {
+		_time = time;
+	}
+}
+
+void DatabaseObject::compactorDone(
+		const QString &path,
+		int64 originalReadTill) {
+	const auto size = _binlog.size();
+	const auto binlog = binlogPath();
+	const auto ready = compactReadyPath();
+	if (originalReadTill != size) {
+		originalReadTill = CatchUp(
+			path,
+			binlog,
+			_key,
+			originalReadTill,
+			_settings.readBlockSize);
+		if (originalReadTill != size) {
+			compactorFail();
+			return;
+		}
+	}
+	if (!File::Move(path, ready)) {
+		compactorFail();
+		return;
+	}
+	const auto guard = gsl::finally([&] {
+		_compactor = CompactorWrap();
+	});
+	_binlog.close();
+	if (!File::Move(ready, binlog)) {
+		compactorFail();
+		return;
+	}
+	const auto result = _binlog.open(binlog, File::Mode::ReadAppend, _key);
+	if (result != File::Result::Success) {
+		compactorFail();
+		return;
+	} else if (!_binlog.seek(_binlog.size())) {
+		_binlog.close();
+		compactorFail();
+		return;
+	}
+	_binlogExcessLength -= _compactor.excessLength;
+	Assert(_binlogExcessLength >= 0);
+}
+
+void DatabaseObject::compactorFail() {
+	const auto delay = _compactor.delayAfterFailure;
+	_compactor = CompactorWrap();
+	_compactor.nextAttempt = crl::now() + delay;
+	_compactor.delayAfterFailure = std::min(
+		delay * 2,
+		kMaxDelayAfterFailure);
+	QFile(compactReadyPath()).remove();
+}
+
+void DatabaseObject::close(FnMut<void()> &&done) {
+	if (_binlog.isOpen()) {
+		writeBundles();
+		_binlog.close();
+	}
+	invokeCallback(done);
+	clearState();
+}
+
+void DatabaseObject::clearState() {
+	_path = QString();
+	_key = {};
+	_map = {};
+	_removing = {};
+	_accessed = {};
+	_stale = {};
+	_time = {};
+	_binlogExcessLength = 0;
+	_totalSize = 0;
+	_minimalEntryTime = 0;
+	_entriesWithMinimalTimeCount = 0;
+	_taggedStats = {};
+	_pushingStats = false;
+	_writeBundlesTimer.cancel();
+	_pruneTimer.cancel();
+	_compactor = CompactorWrap();
+}
+
+void DatabaseObject::put(
+		const Key &key,
+		TaggedValue &&value,
+		FnMut<void(Error)> &&done) {
+	if (!_binlog.isOpen()) {
+		invokeCallback(done, ioError(versionPath()));
+		return;
+	}
+	if (value.bytes.isEmpty()) {
+		remove(key, std::move(done));
+		return;
+	}
+	_removing.erase(key);
+	_stale.erase(ranges::remove(_stale, key), end(_stale));
+
+	const auto checksum = CountChecksum(bytes::make_span(value.bytes));
+	const auto change = chooseKeyPlace(key, value, checksum);
+	if (change.nowPath.isEmpty()) {
+		// Nothing changed.
+		invokeCallback(done, Error::NoError());
+		recordEntryAccess(key);
+		return;
+	}
+	const auto check = [&](Error error) {
+		if (error.type != Error::Type::None) {
+			QFile(change.nowPath).remove();
+			invokeCallback(done, error);
+			return false;
+		}
+		return true;
+	};
+	if (!check(writeNewEntry(change.nowPath, std::move(value.bytes)))
+		|| !check(writeKeyPlace(key, change.nowPlace, value, checksum))) {
+		return;
+	}
+	if (!change.wasPath.isEmpty()) {
+		QFile(change.wasPath).remove();
+	}
+	invokeCallback(done, Error::NoError());
+	optimize();
+}
+
+DatabaseObject::KeyPlaceChange DatabaseObject::chooseKeyPlace(
+		const Key &key,
+		const TaggedValue &value,
+		uint32 checksum) {
+	Expects(value.bytes.size() <= _settings.maxDataSize);
+
+	auto generatePlace = [&] {
+		auto result = PlaceId();
+		do {
+			bytes::set_random(bytes::object_as_span(&result));
+		} while (!isFreePlace(result));
+		return result;
+	};
+
+	if (const auto i = _map.find(key); i != end(_map)) {
+		const auto size = size_type(value.bytes.size());
+		const auto &already = i->second;
+		const auto alreadyPath = placePath(already.place);
+		if (already.tag == value.tag
+			&& already.size == size
+			&& already.checksum == checksum
+			&& readValueData(already.place, size) == value.bytes) {
+			return KeyPlaceChange{ alreadyPath, QString() };
+		}
+		const auto nowPlace = generatePlace();
+		return KeyPlaceChange{ alreadyPath, placePath(nowPlace), nowPlace };
+	}
+	const auto nowPlace = generatePlace();
+	return KeyPlaceChange{ QString(), placePath(nowPlace), nowPlace };
+}
+
+Error DatabaseObject::writeNewEntry(
+		const QString &path,
+		QByteArray &&content) {
+	auto file = File();
+	switch (file.open(path, File::Mode::Write, _key)) {
+	case File::Result::Failed:
+		return ioError(path);
+
+	case File::Result::LockFailed:
+		return Error{ Error::Type::LockFailed, path };
+
+	case File::Result::Success:
+		return (file.writeWithPadding(bytes::make_detached_span(content))
+			&& file.flush())
+			? Error::NoError()
+			: ioError(path);
+
+	default: Unexpected("Result in DatabaseObject::put.");
+	}
+}
+
+template <typename StoreRecord>
+Error DatabaseObject::writeKeyPlaceGeneric(
+		StoreRecord &&record,
+		const Key &key,
+		const PlaceId &place,
+		const TaggedValue &value,
+		uint32 checksum) {
+	Expects(value.bytes.size() <= _settings.maxDataSize);
+
+	const auto size = size_type(value.bytes.size());
+	record.tag = value.tag;
+	record.key = key;
+	record.setSize(size);
+	record.checksum = checksum;
+	record.place = place;
+	const auto result = placePath(record.place);
+	auto writeable = record;
+	const auto success = _binlog.write(bytes::object_as_span(&writeable));
+	if (!success) {
+		_binlog.close();
+		return ioError(binlogPath());
+	}
+	_binlog.flush();
+
+	const auto applied = processRecordStore(
+		&record,
+		std::is_class<std::decay_t<StoreRecord>>{});
+	Assert(applied);
+	return Error::NoError();
+}
+
+Error DatabaseObject::writeKeyPlace(
+		const Key &key,
+		const PlaceId &place,
+		const TaggedValue &data,
+		uint32 checksum) {
+	if (!_settings.trackEstimatedTime) {
+		return writeKeyPlaceGeneric(Store(), key, place, data, checksum);
+	}
+	auto record = StoreWithTime();
+	record.time = countTimePoint();
+	const auto writing = record.time.getRelative();
+	const auto current = _time.getRelative();
+	Assert(writing >= current);
+	if ((writing - current) * crl::time(1000)
+		< _settings.writeBundleDelay) {
+		// We don't want to produce a lot of unique _time.relative values.
+		// So if change in it is not large we stick to the old value.
+		record.time = _time;
+	}
+	return writeKeyPlaceGeneric(record, key, place, data, checksum);
+}
+
+template <typename StoreRecord>
+Error DatabaseObject::writeExistingPlaceGeneric(
+		StoreRecord &&record,
+		const Key &key,
+		const Entry &entry) {
+	record.key = key;
+	record.tag = entry.tag;
+	record.setSize(entry.size);
+	record.checksum = entry.checksum;
+	if (const auto i = _map.find(key); i != end(_map)) {
+		const auto &already = i->second;
+		if (already.tag == record.tag
+			&& already.size == entry.size
+			&& already.checksum == entry.checksum
+			&& (readValueData(already.place, already.size)
+				== readValueData(entry.place, entry.size))) {
+			return Error::NoError();
+		}
+	}
+	record.place = entry.place;
+	auto writeable = record;
+	const auto success = _binlog.write(bytes::object_as_span(&writeable));
+	if (!success) {
+		_binlog.close();
+		return ioError(binlogPath());
+	}
+	_binlog.flush();
+
+	const auto applied = processRecordStore(
+		&record,
+		std::is_class<StoreRecord>{});
+	Assert(applied);
+	return Error::NoError();
+}
+
+Error DatabaseObject::writeExistingPlace(
+		const Key &key,
+		const Entry &entry) {
+	if (!_settings.trackEstimatedTime) {
+		return writeExistingPlaceGeneric(Store(), key, entry);
+	}
+	auto record = StoreWithTime();
+	record.time = countTimePoint();
+	const auto writing = record.time.getRelative();
+	const auto current = _time.getRelative();
+	Assert(writing >= current);
+	if ((writing - current) * crl::time(1000)
+		< _settings.writeBundleDelay) {
+		// We don't want to produce a lot of unique _time.relative values.
+		// So if change in it is not large we stick to the old value.
+		record.time = _time;
+	}
+	return writeExistingPlaceGeneric(std::move(record), key, entry);
+}
+
+void DatabaseObject::get(
+		const Key &key,
+		FnMut<void(TaggedValue&&)> &&done) {
+	const auto i = _map.find(key);
+	if (i == _map.end()) {
+		invokeCallback(done, TaggedValue());
+		return;
+	}
+	const auto &entry = i->second;
+
+	auto bytes = readValueData(entry.place, entry.size);
+	if (bytes.isEmpty()) {
+		remove(key, nullptr);
+		invokeCallback(done, TaggedValue());
+	} else if (CountChecksum(bytes::make_span(bytes)) != entry.checksum) {
+		remove(key, nullptr);
+		invokeCallback(done, TaggedValue());
+	} else {
+		invokeCallback(done, TaggedValue(std::move(bytes), entry.tag));
+		recordEntryAccess(key);
+	}
+}
+
+void DatabaseObject::getWithSizes(
+		const Key &key,
+		std::vector<Key> &&keys,
+		FnMut<void(QByteArray&&, std::vector<int>&&)> &&done) {
+	get(key, [&](TaggedValue &&value) {
+		if (value.bytes.isEmpty()) {
+			invokeCallback(done, QByteArray(), std::vector<int>());
+			return;
+		}
+
+		auto sizes = keys | ranges::view::transform([&](const Key &sizeKey) {
+			const auto i = _map.find(sizeKey);
+			return (i != end(_map)) ? int(i->second.size) : 0;
+		}) | ranges::to_vector;
+
+		invokeCallback(done, std::move(value.bytes), std::move(sizes));
+	});
+}
+
+QByteArray DatabaseObject::readValueData(
+		PlaceId place,
+		size_type size) const {
+	const auto path = placePath(place);
+	File data;
+	const auto result = data.open(path, File::Mode::Read, _key);
+	switch (result) {
+	case File::Result::Failed:
+	case File::Result::WrongKey: return QByteArray();
+	case File::Result::Success: {
+		auto result = QByteArray(size, Qt::Uninitialized);
+		const auto bytes = bytes::make_detached_span(result);
+		const auto read = data.readWithPadding(bytes);
+		if (read != size) {
+			return QByteArray();
+		}
+		return result;
+	} break;
+	}
+	Unexpected("Result in DatabaseObject::get.");
+}
+
+void DatabaseObject::recordEntryAccess(const Key &key) {
+	if (!_settings.trackEstimatedTime) {
+		return;
+	}
+	_accessed.emplace(key);
+	writeMultiAccessLazy();
+	optimize();
+}
+
+void DatabaseObject::remove(const Key &key, FnMut<void(Error)> &&done) {
+	if (!_binlog.isOpen()) {
+		invokeCallback(done, ioError(versionPath()));
+		return;
+	}
+	const auto i = _map.find(key);
+	if (i != _map.end()) {
+		_removing.emplace(key);
+		writeMultiRemoveLazy();
+
+		const auto path = placePath(i->second.place);
+		eraseMapEntry(i);
+		if (QFile(path).remove() || !QFile(path).exists()) {
+			invokeCallback(done, Error::NoError());
+		} else {
+			invokeCallback(done, ioError(path));
+		}
+	} else {
+		invokeCallback(done, Error::NoError());
+	}
+}
+
+void DatabaseObject::putIfEmpty(
+		const Key &key,
+		TaggedValue &&value,
+		FnMut<void(Error)> &&done) {
+	if (_map.find(key) != end(_map)) {
+		invokeCallback(done, Error::NoError());
+		return;
+	}
+	put(key, std::move(value), std::move(done));
+}
+
+void DatabaseObject::copyIfEmpty(
+		const Key &from,
+		const Key &to,
+		FnMut<void(Error)> &&done) {
+	if (_map.find(to) != end(_map)) {
+		invokeCallback(done, Error::NoError());
+		return;
+	}
+	get(from, [&](TaggedValue &&value) {
+		put(to, std::move(value), std::move(done));
+	});
+}
+
+void DatabaseObject::moveIfEmpty(
+		const Key &from,
+		const Key &to,
+		FnMut<void(Error)> &&done) {
+	if (_map.find(to) != end(_map)) {
+		invokeCallback(done, Error::NoError());
+		return;
+	}
+	const auto i = _map.find(from);
+	if (i == _map.end()) {
+		invokeCallback(done, Error::NoError());
+		return;
+	}
+	_removing.emplace(from);
+
+	const auto entry = i->second;
+	eraseMapEntry(i);
+
+	const auto result = writeMultiRemove();
+	if (result.type != Error::Type::None) {
+		invokeCallback(done, result);
+		return;
+	}
+	_removing.erase(to);
+	_stale.erase(ranges::remove(_stale, to), end(_stale));
+	invokeCallback(done, writeExistingPlace(to, entry));
+}
+
+rpl::producer<Stats> DatabaseObject::stats() const {
+	return _stats.events_starting_with(collectStats());
+}
+
+Stats DatabaseObject::collectStats() const {
+	auto result = Stats();
+	result.tagged = _taggedStats;
+	result.full.count = _map.size();
+	result.full.totalSize = _totalSize;
+	result.clearing = (_cleaner.object != nullptr) || !_stale.empty();
+	return result;
+}
+
+void DatabaseObject::writeBundlesLazy() {
+	if (!_writeBundlesTimer.isActive()) {
+		_writeBundlesTimer.callOnce(_settings.writeBundleDelay);
+	}
+}
+
+void DatabaseObject::writeMultiRemoveLazy() {
+	if (_removing.size() == _settings.maxBundledRecords) {
+		writeMultiRemove();
+	} else {
+		writeBundlesLazy();
+	}
+}
+
+Error DatabaseObject::writeMultiRemove() {
+	Expects(_removing.size() <= _settings.maxBundledRecords);
+
+	if (_removing.empty()) {
+		return Error::NoError();
+	}
+	const auto size = _removing.size();
+	auto header = MultiRemove(size);
+	auto list = std::vector<MultiRemove::Part>();
+	list.reserve(size);
+	for (const auto &key : base::take(_removing)) {
+		list.push_back(key);
+	}
+	if (_binlog.write(bytes::object_as_span(&header))
+		&& _binlog.write(bytes::make_span(list))) {
+		_binlog.flush();
+		_binlogExcessLength += bytes::object_as_span(&header).size()
+			+ bytes::make_span(list).size();
+		return Error::NoError();
+	}
+	_binlog.close();
+	return ioError(binlogPath());
+}
+
+void DatabaseObject::writeMultiAccessLazy() {
+	if (_accessed.size() == _settings.maxBundledRecords) {
+		writeMultiAccess();
+	} else {
+		writeBundlesLazy();
+	}
+}
+
+Error DatabaseObject::writeMultiAccess() {
+	if (_accessed.empty()) {
+		return Error::NoError();
+	}
+	return writeMultiAccessBlock();
+}
+
+Error DatabaseObject::writeMultiAccessBlock() {
+	Expects(_settings.trackEstimatedTime);
+	Expects(_accessed.size() <= _settings.maxBundledRecords);
+
+	const auto time = countTimePoint();
+	const auto size = _accessed.size();
+	auto header = MultiAccess(time, size);
+	auto list = std::vector<MultiAccess::Part>();
+	if (size > 0) {
+		list.reserve(size);
+		for (const auto &key : base::take(_accessed)) {
+			list.push_back(key);
+		}
+	}
+	_time = time;
+	for (const auto &entry : list) {
+		if (const auto i = _map.find(entry); i != end(_map)) {
+			i->second.useTime = _time.getRelative();
+		}
+	}
+
+	if (_binlog.write(bytes::object_as_span(&header))
+		&& (!size || _binlog.write(bytes::make_span(list)))) {
+		_binlog.flush();
+		_binlogExcessLength += bytes::object_as_span(&header).size()
+			+ bytes::make_span(list).size();
+		return Error::NoError();
+	}
+	_binlog.close();
+	return ioError(binlogPath());
+}
+
+void DatabaseObject::writeBundles() {
+	writeMultiRemove();
+	if (_settings.trackEstimatedTime) {
+		writeMultiAccess();
+	}
+}
+
+void DatabaseObject::createCleaner() {
+	auto done = [weak = _weak](Error error) {
+		weak.with([=](DatabaseObject &that) {
+			that.cleanerDone(error);
+		});
+	};
+	_cleaner.object = std::make_unique<Cleaner>(
+		_base,
+		_cleaner.guard.make_guard(),
+		std::move(done));
+	pushStatsDelayed();
+}
+
+void DatabaseObject::cleanerDone(Error error) {
+	invokeCallback(_cleaner.done);
+	_cleaner = CleanerWrap();
+	pushStatsDelayed();
+}
+
+void DatabaseObject::checkCompactor() {
+	if (_compactor.object
+		|| !_settings.compactAfterExcess
+		|| _binlogExcessLength < _settings.compactAfterExcess) {
+		return;
+	} else if (_settings.compactAfterFullSize
+		&& (_binlogExcessLength * _settings.compactAfterFullSize
+			< _settings.compactAfterExcess * _binlog.size())) {
+		return;
+	} else if (crl::now() < _compactor.nextAttempt || !_binlog.isOpen()) {
+		return;
+	}
+	auto info = Compactor::Info();
+	info.till = _binlog.size();
+	info.systemTime = _time.system;
+	info.keysCount = _map.size();
+	_compactor.object = std::make_unique<Compactor>(
+		_weak,
+		_compactor.guard.make_guard(),
+		_path,
+		_settings,
+		base::duplicate(_key),
+		info);
+	_compactor.excessLength = _binlogExcessLength;
+}
+
+void DatabaseObject::clear(FnMut<void(Error)> &&done) {
+	auto key = std::move(_key);
+	if (!key.empty()) {
+		close(nullptr);
+	}
+	const auto version = findAvailableVersion();
+	if (!writeVersion(version)) {
+		invokeCallback(done, ioError(versionPath()));
+		return;
+	}
+	if (key.empty()) {
+		invokeCallback(done, Error::NoError());
+		createCleaner();
+		return;
+	}
+	open(std::move(key), std::move(done));
+}
+
+void DatabaseObject::clearByTag(uint8 tag, FnMut<void(Error)> &&done) {
+	const auto hadStale = !_stale.empty();
+	for (const auto &[key, entry] : _map) {
+		if (entry.tag == tag) {
+			_stale.push_back(key);
+		}
+	}
+	if (!hadStale) {
+		startStaleClear();
+	}
+	invokeCallback(done, Error::NoError());
+}
+
+void DatabaseObject::waitForCleaner(FnMut<void()> &&done) {
+	while (!_stale.empty()) {
+		clearStaleChunk();
+	}
+	if (_cleaner.object) {
+		_cleaner.done = std::move(done);
+	} else {
+		invokeCallback(done);
+	}
+}
+
+auto DatabaseObject::getManyRaw(const std::vector<Key> &keys) const
+-> std::vector<Raw> {
+	auto result = std::vector<Raw>();
+	result.reserve(keys.size());
+	for (const auto &key : keys) {
+		if (const auto i = _map.find(key); i != end(_map)) {
+			result.push_back(*i);
+		}
+	}
+	return result;
+}
+
+DatabaseObject::~DatabaseObject() {
+	close(nullptr);
+}
+
+auto DatabaseObject::findAvailableVersion() const -> Version {
+	const auto entries = QDir(_base).entryList(
+		QDir::Dirs | QDir::NoDotAndDotDot);
+	auto versions = base::flat_set<Version>();
+	for (const auto entry : entries) {
+		versions.insert(entry.toInt());
+	}
+	auto result = Version();
+	for (const auto version : versions) {
+		if (result != version) {
+			break;
+		}
+		++result;
+	}
+	return result;
+}
+
+QString DatabaseObject::versionPath() const {
+	return VersionFilePath(_base);
+}
+
+bool DatabaseObject::writeVersion(Version version) {
+	return WriteVersionValue(_base, version);
+}
+
+auto DatabaseObject::readVersion() const -> Version {
+	if (const auto result = ReadVersionValue(_base)) {
+		return *result;
+	}
+	return Version();
+}
+
+QString DatabaseObject::placePath(PlaceId place) const {
+	return _path + PlaceFromId(place);
+}
+
+bool DatabaseObject::isFreePlace(PlaceId place) const {
+	return !QFile(placePath(place)).exists();
+}
+
+} // namespace details
+} // namespace Cache
+} // namespace Storage
diff --git a/Telegram/lib_storage/storage/cache/storage_cache_database_object.h b/Telegram/lib_storage/storage/cache/storage_cache_database_object.h
new file mode 100644
index 0000000..efd6151
--- /dev/null
+++ b/Telegram/lib_storage/storage/cache/storage_cache_database_object.h
@@ -0,0 +1,269 @@
+// This file is part of Desktop App Toolkit,
+// a set of libraries for developing nice desktop applications.
+//
+// For license and copyright information please follow this link:
+// https://github.com/desktop-app/legal/blob/master/LEGAL
+//
+#pragma once
+
+#include "storage/cache/storage_cache_database.h"
+#include "storage/storage_encrypted_file.h"
+#include "base/binary_guard.h"
+#include "base/concurrent_timer.h"
+#include "base/bytes.h"
+#include "base/flat_set.h"
+#include <set>
+#include <rpl/event_stream.h>
+
+namespace Storage {
+namespace Cache {
+namespace details {
+
+class Cleaner;
+class Compactor;
+
+class DatabaseObject {
+public:
+	using Settings = Cache::Database::Settings;
+	DatabaseObject(
+		crl::weak_on_queue<DatabaseObject> weak,
+		const QString &path,
+		const Settings &settings);
+	void reconfigure(const Settings &settings);
+	void updateSettings(const SettingsUpdate &update);
+
+	void open(EncryptionKey &&key, FnMut<void(Error)> &&done);
+	void close(FnMut<void()> &&done);
+
+	void put(
+		const Key &key,
+		TaggedValue &&value,
+		FnMut<void(Error)> &&done);
+	void get(const Key &key, FnMut<void(TaggedValue&&)> &&done);
+	void remove(const Key &key, FnMut<void(Error)> &&done);
+
+	void putIfEmpty(
+		const Key &key,
+		TaggedValue &&value,
+		FnMut<void(Error)> &&done);
+	void copyIfEmpty(
+		const Key &from,
+		const Key &to,
+		FnMut<void(Error)> &&done);
+	void moveIfEmpty(
+		const Key &from,
+		const Key &to,
+		FnMut<void(Error)> &&done);
+
+	void getWithSizes(
+		const Key &key,
+		std::vector<Key> &&keys,
+		FnMut<void(QByteArray&&, std::vector<int>&&)> &&done);
+
+	rpl::producer<Stats> stats() const;
+
+	void clear(FnMut<void(Error)> &&done);
+	void clearByTag(uint8 tag, FnMut<void(Error)> &&done);
+	void waitForCleaner(FnMut<void()> &&done);
+
+	static QString BinlogFilename();
+	static QString CompactReadyFilename();
+
+	void compactorDone(const QString &path, int64 originalReadTill);
+	void compactorFail();
+
+	struct Entry {
+		Entry() = default;
+		Entry(
+			PlaceId place,
+			uint8 tag,
+			uint32 checksum,
+			size_type size,
+			uint64 useTime);
+
+		uint64 useTime = 0;
+		size_type size = 0;
+		uint32 checksum = 0;
+		PlaceId place = { { 0 } };
+		uint8 tag = 0;
+	};
+	using Raw = std::pair<Key, Entry>;
+	std::vector<Raw> getManyRaw(const std::vector<Key> &keys) const;
+
+	~DatabaseObject();
+
+private:
+	struct CleanerWrap {
+		std::unique_ptr<Cleaner> object;
+		base::binary_guard guard;
+		FnMut<void()> done;
+	};
+	struct CompactorWrap {
+		std::unique_ptr<Compactor> object;
+		int64 excessLength = 0;
+		crl::time nextAttempt = 0;
+		crl::time delayAfterFailure = 10 * crl::time(1000);
+		base::binary_guard guard;
+	};
+	struct KeyPlaceChange {
+		QString wasPath;
+		QString nowPath;
+		PlaceId nowPlace;
+	};
+	using Map = std::unordered_map<Key, Entry>;
+
+	template <typename Callback, typename ...Args>
+	void invokeCallback(Callback &&callback, Args &&...args) const;
+
+	Error ioError(const QString &path) const;
+
+	void checkSettings();
+	QString computePath(Version version) const;
+	QString binlogPath(Version version) const;
+	QString binlogPath() const;
+	QString compactReadyPath(Version version) const;
+	QString compactReadyPath() const;
+	Error openSomeBinlog(EncryptionKey &&key);
+	Error openNewBinlog(EncryptionKey &key);
+	File::Result openBinlog(
+		Version version,
+		File::Mode mode,
+		EncryptionKey &key);
+	bool readHeader();
+	bool writeHeader();
+
+	void readBinlog();
+	template <typename Reader, typename ...Handlers>
+	void readBinlogHelper(Reader &reader, Handlers &&...handlers);
+	template <typename Record, typename Postprocess>
+	bool processRecordStoreGeneric(
+		const Record *record,
+		Postprocess &&postprocess);
+	bool processRecordStore(const Store *record, std::is_class<Store>);
+	bool processRecordStore(
+		const StoreWithTime *record,
+		std::is_class<StoreWithTime>);
+	template <typename Record, typename GetElement>
+	bool processRecordMultiStore(
+		const Record &header,
+		const GetElement &element);
+	template <typename GetElement>
+	bool processRecordMultiRemove(
+		const MultiRemove &header,
+		const GetElement &element);
+	template <typename GetElement>
+	bool processRecordMultiAccess(
+		const MultiAccess &header,
+		const GetElement &element);
+
+	void optimize();
+	void checkCompactor();
+	void adjustRelativeTime();
+	bool startDelayedPruning();
+	uint64 countRelativeTime() const;
+	EstimatedTimePoint countTimePoint() const;
+	void applyTimePoint(EstimatedTimePoint time);
+
+	uint64 pruneBeforeTime() const;
+	void prune();
+	void collectTimeStale(
+		base::flat_set<Key> &stale,
+		int64 &staleTotalSize);
+	void collectSizeStale(
+		base::flat_set<Key> &stale,
+		int64 &staleTotalSize);
+	void startStaleClear();
+	void clearStaleNow(const base::flat_set<Key> &stale);
+	void clearStaleChunkDelayed();
+	void clearStaleChunk();
+
+	void updateStats(const Entry &was, const Entry &now);
+	Stats collectStats() const;
+	void pushStatsDelayed();
+	void pushStats();
+
+	void setMapEntry(const Key &key, Entry &&entry);
+	void eraseMapEntry(const Map::const_iterator &i);
+	void recordEntryAccess(const Key &key);
+	QByteArray readValueData(PlaceId place, size_type size) const;
+
+	Version findAvailableVersion() const;
+	QString versionPath() const;
+	bool writeVersion(Version version);
+	Version readVersion() const;
+
+	QString placePath(PlaceId place) const;
+	bool isFreePlace(PlaceId place) const;
+
+	KeyPlaceChange chooseKeyPlace(
+		const Key &key,
+		const TaggedValue &value,
+		uint32 checksum);
+	Error writeNewEntry(
+		const QString &path,
+		QByteArray &&content);
+	template <typename StoreRecord>
+	Error writeKeyPlaceGeneric(
+		StoreRecord &&record,
+		const Key &key,
+		const PlaceId &place,
+		const TaggedValue &value,
+		uint32 checksum);
+	Error writeKeyPlace(
+		const Key &key,
+		const PlaceId &place,
+		const TaggedValue &value,
+		uint32 checksum);
+	template <typename StoreRecord>
+	Error writeExistingPlaceGeneric(
+		StoreRecord &&record,
+		const Key &key,
+		const Entry &entry);
+	Error writeExistingPlace(
+		const Key &key,
+		const Entry &entry);
+	void writeMultiRemoveLazy();
+	Error writeMultiRemove();
+	void writeMultiAccessLazy();
+	Error writeMultiAccess();
+	Error writeMultiAccessBlock();
+	void writeBundlesLazy();
+	void writeBundles();
+
+	void createCleaner();
+	void cleanerDone(Error error);
+	void clearState();
+
+	crl::weak_on_queue<DatabaseObject> _weak;
+	QString _base, _path;
+	Settings _settings;
+	EncryptionKey _key;
+	File _binlog;
+	Map _map;
+	std::set<Key> _removing;
+	std::set<Key> _accessed;
+	std::vector<Key> _stale;
+
+	EstimatedTimePoint _time;
+
+	int64 _binlogExcessLength = 0;
+	int64 _totalSize = 0;
+	uint64 _minimalEntryTime = 0;
+	size_type _entriesWithMinimalTimeCount = 0;
+
+	base::flat_map<uint8, TaggedSummary> _taggedStats;
+	rpl::event_stream<Stats> _stats;
+	bool _pushingStats = false;
+	bool _clearingStale = false;
+
+	base::ConcurrentTimer _writeBundlesTimer;
+	base::ConcurrentTimer _pruneTimer;
+
+	CleanerWrap _cleaner;
+	CompactorWrap _compactor;
+
+};
+
+} // namespace details
+} // namespace Cache
+} // namespace Storage
diff --git a/Telegram/lib_storage/storage/cache/storage_cache_types.cpp b/Telegram/lib_storage/storage/cache/storage_cache_types.cpp
new file mode 100644
index 0000000..143711e
--- /dev/null
+++ b/Telegram/lib_storage/storage/cache/storage_cache_types.cpp
@@ -0,0 +1,137 @@
+// This file is part of Desktop App Toolkit,
+// a set of libraries for developing nice desktop applications.
+//
+// For license and copyright information please follow this link:
+// https://github.com/desktop-app/legal/blob/master/LEGAL
+//
+#include "storage/cache/storage_cache_types.h"
+
+#include <QtCore/QDir>
+
+namespace Storage {
+namespace Cache {
+namespace details {
+namespace {
+
+template <typename Packed>
+inline Packed ReadTo(size_type count) {
+	Expects(count >= 0 && count < (1 << (Packed().size() * 8)));
+
+	auto result = Packed();
+	for (auto &element : result) {
+		element = uint8(count & 0xFF);
+		count >>= 8;
+	}
+	return result;
+}
+
+template <typename Packed>
+inline size_type ReadFrom(const Packed &count) {
+	auto result = size_type();
+	for (auto &element : (count | ranges::view::reverse)) {
+		result <<= 8;
+		result |= size_type(element);
+	}
+	return result;
+}
+
+template <typename Packed>
+inline size_type ValidateStrictCount(const Packed &count) {
+	const auto result = ReadFrom(count);
+	return (result != 0) ? result : -1;
+}
+
+} // namespace
+
+TaggedValue::TaggedValue(QByteArray &&bytes, uint8 tag)
+: bytes(std::move(bytes)), tag(tag) {
+}
+
+QString ComputeBasePath(const QString &original) {
+	const auto result = QDir(original).absolutePath();
+	return result.endsWith('/') ? result : (result + '/');
+}
+
+QString VersionFilePath(const QString &base) {
+	Expects(base.endsWith('/'));
+
+	return base + QStringLiteral("version");
+}
+
+std::optional<Version> ReadVersionValue(const QString &base) {
+	QFile file(VersionFilePath(base));
+	if (!file.open(QIODevice::ReadOnly)) {
+		return std::nullopt;
+	}
+	const auto bytes = file.read(sizeof(Version));
+	if (bytes.size() != sizeof(Version)) {
+		return std::nullopt;
+	}
+	return *reinterpret_cast<const Version*>(bytes.data());
+}
+
+bool WriteVersionValue(const QString &base, Version value) {
+	if (!QDir().mkpath(base)) {
+		return false;
+	}
+	const auto bytes = QByteArray::fromRawData(
+		reinterpret_cast<const char*>(&value),
+		sizeof(value));
+	QFile file(VersionFilePath(base));
+	if (!file.open(QIODevice::WriteOnly)) {
+		return false;
+	} else if (file.write(bytes) != bytes.size()) {
+		return false;
+	}
+	return file.flush();
+}
+
+BasicHeader::BasicHeader()
+: format(static_cast<uint32>(Format::Format_0))
+, flags(0) {
+}
+
+void Store::setSize(size_type size) {
+	this->size = ReadTo<EntrySize>(size);
+}
+
+size_type Store::getSize() const {
+	return ReadFrom(size);
+}
+
+MultiStore::MultiStore(size_type count)
+: type(kType)
+, count(ReadTo<RecordsCount>(count)) {
+	Expects(count >= 0 && count < kBundledRecordsLimit);
+}
+
+size_type MultiStore::validateCount() const {
+	return ValidateStrictCount(count);
+}
+
+MultiRemove::MultiRemove(size_type count)
+: type(kType)
+, count(ReadTo<RecordsCount>(count)) {
+	Expects(count >= 0 && count < kBundledRecordsLimit);
+}
+
+size_type MultiRemove::validateCount() const {
+	return ValidateStrictCount(count);
+}
+
+MultiAccess::MultiAccess(
+	EstimatedTimePoint time,
+	size_type count)
+: type(kType)
+, count(ReadTo<RecordsCount>(count))
+, time(time) {
+	Expects(count >= 0 && count < kBundledRecordsLimit);
+}
+
+size_type MultiAccess::validateCount() const {
+	return ReadFrom(count);
+}
+
+} // namespace details
+} // namespace Cache
+} // namespace Storage
diff --git a/Telegram/lib_storage/storage/cache/storage_cache_types.h b/Telegram/lib_storage/storage/cache/storage_cache_types.h
new file mode 100644
index 0000000..0faf4d3
--- /dev/null
+++ b/Telegram/lib_storage/storage/cache/storage_cache_types.h
@@ -0,0 +1,238 @@
+// This file is part of Desktop App Toolkit,
+// a set of libraries for developing nice desktop applications.
+//
+// For license and copyright information please follow this link:
+// https://github.com/desktop-app/legal/blob/master/LEGAL
+//
+#pragma once
+
+#include "base/basic_types.h"
+#include "base/flat_map.h"
+#include "base/optional.h"
+#include <crl/crl_time.h>
+#include <QtCore/QString>
+#include <QtCore/QByteArray>
+
+namespace Storage {
+namespace Cache {
+
+struct Key {
+	uint64 high = 0;
+	uint64 low = 0;
+};
+
+inline bool operator==(const Key &a, const Key &b) {
+	return (a.high == b.high) && (a.low == b.low);
+}
+
+inline bool operator!=(const Key &a, const Key &b) {
+	return !(a == b);
+}
+
+inline bool operator<(const Key &a, const Key &b) {
+	return std::tie(a.high, a.low) < std::tie(b.high, b.low);
+}
+
+struct Error {
+	enum class Type {
+		None,
+		IO,
+		WrongKey,
+		LockFailed,
+	};
+	Type type = Type::None;
+	QString path;
+
+	static Error NoError();
+};
+
+inline Error Error::NoError() {
+	return Error();
+}
+
+namespace details {
+
+using RecordType = uint8;
+using PlaceId = std::array<uint8, 7>;
+using EntrySize = std::array<uint8, 3>;
+using RecordsCount = std::array<uint8, 3>;
+
+constexpr auto kRecordSizeUnknown = size_type(-1);
+constexpr auto kRecordSizeInvalid = size_type(-2);
+constexpr auto kBundledRecordsLimit
+	= size_type(1 << (RecordsCount().size() * 8));
+constexpr auto kDataSizeLimit = size_type(1 << (EntrySize().size() * 8));
+
+struct Settings {
+	size_type maxBundledRecords = 16 * 1024;
+	size_type readBlockSize = 8 * 1024 * 1024;
+	size_type maxDataSize = (kDataSizeLimit - 1);
+	crl::time writeBundleDelay = 15 * 60 * crl::time(1000);
+	size_type staleRemoveChunk = 256;
+
+	int64 compactAfterExcess = 8 * 1024 * 1024;
+	int64 compactAfterFullSize = 0;
+	size_type compactChunkSize = 16 * 1024;
+
+	bool trackEstimatedTime = true;
+	int64 totalSizeLimit = 1024 * 1024 * 1024;
+	size_type totalTimeLimit = 31 * 24 * 60 * 60; // One month in seconds.
+	crl::time pruneTimeout = 5 * crl::time(1000);
+	crl::time maxPruneCheckTimeout = 3600 * crl::time(1000);
+
+	bool clearOnWrongKey = false;
+};
+
+struct SettingsUpdate {
+	int64 totalSizeLimit = Settings().totalSizeLimit;
+	size_type totalTimeLimit = Settings().totalTimeLimit;
+};
+
+struct TaggedValue {
+	TaggedValue() = default;
+	TaggedValue(QByteArray &&bytes, uint8 tag);
+
+	QByteArray bytes;
+	uint8 tag = 0;
+};
+
+struct TaggedSummary {
+	size_type count = 0;
+	int64 totalSize = 0;
+};
+struct Stats {
+	TaggedSummary full;
+	base::flat_map<uint8, TaggedSummary> tagged;
+	bool clearing = false;
+};
+
+using Version = int32;
+
+QString ComputeBasePath(const QString &original);
+QString VersionFilePath(const QString &base);
+std::optional<Version> ReadVersionValue(const QString &base);
+bool WriteVersionValue(const QString &base, Version value);
+
+template <typename Record>
+constexpr auto GoodForEncryption = ((sizeof(Record) & 0x0F) == 0);
+
+enum class Format : uint32 {
+	Format_0,
+};
+
+struct BasicHeader {
+	BasicHeader();
+
+	static constexpr auto kTrackEstimatedTime = 0x01U;
+
+	Format getFormat() const {
+		return static_cast<Format>(format);
+	}
+	void setFormat(Format format) {
+		this->format = static_cast<uint32>(format);
+	}
+
+	uint32 format : 8;
+	uint32 flags : 24;
+	uint32 systemTime = 0;
+	uint32 reserved1 = 0;
+	uint32 reserved2 = 0;
+};
+
+struct EstimatedTimePoint {
+	uint32 relative1 = 0;
+	uint32 relative2 = 0;
+	uint32 system = 0;
+
+	void setRelative(uint64 value) {
+		relative1 = uint32(value & 0xFFFFFFFFU);
+		relative2 = uint32((value >> 32) & 0xFFFFFFFFU);
+	}
+	uint64 getRelative() const {
+		return uint64(relative1) | (uint64(relative2) << 32);
+	}
+};
+
+struct Store {
+	static constexpr auto kType = RecordType(0x01);
+
+	void setSize(size_type size);
+	size_type getSize() const;
+
+	RecordType type = kType;
+	uint8 tag = 0;
+	EntrySize size = { { 0 } };
+	PlaceId place = { { 0 } };
+	uint32 checksum = 0;
+	Key key;
+};
+
+struct StoreWithTime : Store {
+	EstimatedTimePoint time;
+	uint32 reserved = 0;
+};
+
+struct MultiStore {
+	static constexpr auto kType = RecordType(0x02);
+
+	explicit MultiStore(size_type count = 0);
+
+	RecordType type = kType;
+	RecordsCount count = { { 0 } };
+	uint32 reserved1 = 0;
+	uint32 reserved2 = 0;
+	uint32 reserved3 = 0;
+
+	using Part = Store;
+	size_type validateCount() const;
+};
+struct MultiStoreWithTime : MultiStore {
+	using MultiStore::MultiStore;
+
+	using Part = StoreWithTime;
+};
+
+struct MultiRemove {
+	static constexpr auto kType = RecordType(0x03);
+
+	explicit MultiRemove(size_type count = 0);
+
+	RecordType type = kType;
+	RecordsCount count = { { 0 } };
+	uint32 reserved1 = 0;
+	uint32 reserved2 = 0;
+	uint32 reserved3 = 0;
+
+	using Part = Key;
+	size_type validateCount() const;
+};
+
+struct MultiAccess {
+	static constexpr auto kType = RecordType(0x04);
+
+	explicit MultiAccess(
+		EstimatedTimePoint time,
+		size_type count = 0);
+
+	RecordType type = kType;
+	RecordsCount count = { { 0 } };
+	EstimatedTimePoint time;
+
+	using Part = Key;
+	size_type validateCount() const;
+};
+
+} // namespace details
+} // namespace Cache
+} // namespace Storage
+
+namespace std {
+
+template <>
+struct hash<Storage::Cache::Key> {
+	size_t operator()(const Storage::Cache::Key &key) const {
+		return (hash<uint64>()(key.high) ^ hash<uint64>()(key.low));
+	}
+};
+
+} // namespace std
diff --git a/Telegram/lib_storage/storage/storage_clear_legacy.cpp b/Telegram/lib_storage/storage/storage_clear_legacy.cpp
new file mode 100644
index 0000000..255fd3e
--- /dev/null
+++ b/Telegram/lib_storage/storage/storage_clear_legacy.cpp
@@ -0,0 +1,52 @@
+// This file is part of Desktop App Toolkit,
+// a set of libraries for developing nice desktop applications.
+//
+// For license and copyright information please follow this link:
+// https://github.com/desktop-app/legal/blob/master/LEGAL
+//
+#include "storage/storage_clear_legacy.h"
+
+#include <crl/crl_async.h>
+
+namespace Storage {
+namespace {
+
+constexpr auto kClearPartSize = size_type(10000);
+
+} // namespace
+
+void ClearLegacyFilesPart(
+		const QString &base,
+		CollectGoodFiles filter,
+		base::flat_set<QString> &&skip = {}) {
+	filter([
+		=,
+		files = details::CollectFiles(base, kClearPartSize, skip)
+	](base::flat_set<QString> &&skip) mutable {
+		crl::async([
+			=,
+			files = std::move(files),
+			skip = std::move(skip)
+		]() mutable {
+			for (const auto &name : files) {
+				if (!skip.contains(name)
+					&& !details::RemoveLegacyFile(base + name)) {
+					skip.emplace(name);
+				}
+			}
+			if (files.size() == kClearPartSize) {
+				ClearLegacyFilesPart(base, filter, std::move(skip));
+			}
+		});
+	});
+}
+
+void ClearLegacyFiles(const QString &base, CollectGoodFiles filter) {
+	Expects(base.endsWith('/'));
+
+	crl::async([=] {
+		ClearLegacyFilesPart(base, std::move(filter));
+	});
+}
+
+} // namespace Storage
diff --git a/Telegram/lib_storage/storage/storage_clear_legacy.h b/Telegram/lib_storage/storage/storage_clear_legacy.h
new file mode 100644
index 0000000..3723729
--- /dev/null
+++ b/Telegram/lib_storage/storage/storage_clear_legacy.h
@@ -0,0 +1,25 @@
+// This file is part of Desktop App Toolkit,
+// a set of libraries for developing nice desktop applications.
+//
+// For license and copyright information please follow this link:
+// https://github.com/desktop-app/legal/blob/master/LEGAL
+//
+#pragma once
+
+namespace Storage {
+
+using CollectGoodFiles = Fn<void(FnMut<void(base::flat_set<QString>&&)>)>;
+
+void ClearLegacyFiles(const QString &base, CollectGoodFiles filter);
+
+namespace details {
+
+std::vector<QString> CollectFiles(
+	const QString &base,
+	size_type limit,
+	const base::flat_set<QString> &skip);
+
+bool RemoveLegacyFile(const QString &path);
+
+} // namespace details
+} // namespace Storage
diff --git a/Telegram/lib_storage/storage/storage_clear_legacy_posix.cpp b/Telegram/lib_storage/storage/storage_clear_legacy_posix.cpp
new file mode 100644
index 0000000..4ab7fa5
--- /dev/null
+++ b/Telegram/lib_storage/storage/storage_clear_legacy_posix.cpp
@@ -0,0 +1,100 @@
+// This file is part of Desktop App Toolkit,
+// a set of libraries for developing nice desktop applications.
+//
+// For license and copyright information please follow this link:
+// https://github.com/desktop-app/legal/blob/master/LEGAL
+//
+#include "storage/storage_clear_legacy.h"
+
+#include <sys/stat.h>
+#include <dirent.h>
+#include <unistd.h>
+
+namespace Storage {
+namespace details {
+
+std::vector<QString> CollectFiles(
+		const QString &base,
+		size_type limit,
+		const base::flat_set<QString> &skip) {
+	Expects(base.endsWith('/'));
+	Expects(limit > 0);
+
+	const auto path = QFile::encodeName(base);
+	const auto folder = path.mid(0, path.size() - 1);
+	const auto directory = opendir(folder.constData());
+	if (!directory) {
+		return {};
+	}
+	const auto guard = gsl::finally([&] { closedir(directory); });
+
+	auto result = std::vector<QString>();
+	while (const auto entry = readdir(directory)) {
+		const auto local = entry->d_name;
+		if (!strcmp(local, ".") || !strcmp(local, "..")) {
+			continue;
+		}
+
+		const auto full = path + QByteArray(local);
+		const auto data = full.constData();
+		struct stat statbuf = { 0 };
+		if (stat(full.constData(), &statbuf) != 0 || S_ISDIR(statbuf.st_mode)) {
+			continue;
+		}
+
+		auto name = QFile::decodeName(local);
+		if (!skip.contains(name)) {
+			result.push_back(std::move(name));
+		}
+		if (result.size() == limit) {
+			break;
+		}
+	}
+	return result;
+
+// // It looks like POSIX solution works fine on macOS so no need for Cocoa solution.
+//
+//	NSString *native = [NSString stringWithUTF8String:utf8.constData()];
+//	NSFileManager *manager = [NSFileManager defaultManager];
+//	NSArray *properties = [NSArray arrayWithObject:NSURLIsDirectoryKey];
+//	NSDirectoryEnumerator *enumerator = [manager
+//		enumeratorAtURL:[NSURL fileURLWithPath:native]
+//		includingPropertiesForKeys:properties
+//		options:0
+//		errorHandler:^(NSURL *url, NSError *error) {
+//			return NO;
+//		}];
+//
+//	auto result = std::vector<QString>();
+//	for (NSURL *url in enumerator) {
+//		NSNumber *isDirectory = nil;
+//		NSError *error = nil;
+//		if (![url getResourceValue:&isDirectory forKey:NSURLIsDirectoryKey error:&error]) {
+//			break;
+//		} else if ([isDirectory boolValue]) {
+//			continue;
+//		}
+//		NSString *full = [url path];
+//		NSRange r = [full rangeOfString:native];
+//		if (r.location != 0) {
+//			break;
+//		}
+//		NSString *file = [full substringFromIndex:r.length + 1];
+//		auto name = QString::fromUtf8([file cStringUsingEncoding:NSUTF8StringEncoding]);
+//		if (!skip.contains(name)) {
+//			result.push_back(std::move(name));
+//		}
+//		if (result.size() == limit) {
+//			break;
+//		}
+//	}
+//	return result;
+}
+
+bool RemoveLegacyFile(const QString &path) {
+	const auto native = QFile::encodeName(path);
+	return unlink(native.constData()) == 0;
+}
+
+} // namespace details
+} // namespace Storage
diff --git a/Telegram/lib_storage/storage/storage_clear_legacy_win.cpp b/Telegram/lib_storage/storage/storage_clear_legacy_win.cpp
new file mode 100644
index 0000000..7155b61
--- /dev/null
+++ b/Telegram/lib_storage/storage/storage_clear_legacy_win.cpp
@@ -0,0 +1,61 @@
+// This file is part of Desktop App Toolkit,
+// a set of libraries for developing nice desktop applications.
+//
+// For license and copyright information please follow this link:
+// https://github.com/desktop-app/legal/blob/master/LEGAL
+//
+#include "storage/storage_clear_legacy.h"
+
+#include "base/platform/win/base_windows_h.h"
+
+namespace Storage {
+namespace details {
+
+std::vector<QString> CollectFiles(
+		const QString &base,
+		size_type limit,
+		const base::flat_set<QString> &skip) {
+	Expects(base.endsWith('/'));
+	Expects(limit > 0);
+
+	const auto native = QDir::toNativeSeparators(base).toStdWString();
+	const auto search = native + L'*';
+
+	auto data = WIN32_FIND_DATA{ 0 };
+	const auto handle = FindFirstFileEx(
+		search.c_str(),
+		FindExInfoBasic,
+		&data,
+		FindExSearchNameMatch,
+		nullptr,
+		0);
+	if (handle == INVALID_HANDLE_VALUE) {
+		return {};
+	}
+	const auto guard = gsl::finally([&] { FindClose(handle); });
+
+	auto result = std::vector<QString>();
+	do {
+		const auto full = native + data.cFileName;
+		if (data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
+			continue;
+		}
+		const auto file = QString::fromWCharArray(
+			data.cFileName,
+			full.size() - native.size());
+		auto name = QDir::fromNativeSeparators(file);
+		if (!skip.contains(name)) {
+			result.push_back(std::move(name));
+		}
+	} while (result.size() != limit && FindNextFile(handle, &data));
+
+	return result;
+}
+
+bool RemoveLegacyFile(const QString &path) {
+	const auto native = QDir::toNativeSeparators(path).toStdWString();
+	return (::DeleteFile(native.c_str()) != 0);
+}
+
+} // namespace details
+} // namespace Storage
diff --git a/Telegram/lib_storage/storage/storage_databases.cpp b/Telegram/lib_storage/storage/storage_databases.cpp
new file mode 100644
index 0000000..6fd0809
--- /dev/null
+++ b/Telegram/lib_storage/storage/storage_databases.cpp
@@ -0,0 +1,103 @@
+// This file is part of Desktop App Toolkit,
+// a set of libraries for developing nice desktop applications.
+//
+// For license and copyright information please follow this link:
+// https://github.com/desktop-app/legal/blob/master/LEGAL
+//
+#include "storage/storage_databases.h"
+
+#include "storage/cache/storage_cache_database.h"
+
+namespace Storage {
+
+DatabasePointer::DatabasePointer(
+	not_null<Databases*> owner,
+	const std::unique_ptr<Cache::Database> &value)
+: _value(value.get())
+, _owner(owner) {
+}
+
+DatabasePointer::DatabasePointer(DatabasePointer &&other)
+: _value(base::take(other._value))
+, _owner(other._owner) {
+}
+
+DatabasePointer &DatabasePointer::operator=(DatabasePointer &&other) {
+	if (this != &other) {
+		destroy();
+		_owner = other._owner;
+		_value = base::take(other._value);
+	}
+	return *this;
+}
+
+DatabasePointer::~DatabasePointer() {
+	destroy();
+}
+
+Cache::Database *DatabasePointer::get() const {
+	return _value;
+}
+
+Cache::Database &DatabasePointer::operator*() const {
+	Expects(_value != nullptr);
+
+	return *get();
+}
+
+Cache::Database *DatabasePointer::operator->() const {
+	Expects(_value != nullptr);
+
+	return get();
+}
+
+DatabasePointer::operator bool() const {
+	return get() != nullptr;
+}
+
+void DatabasePointer::destroy() {
+	if (const auto value = base::take(_value)) {
+		_owner->destroy(value);
+	}
+}
+
+Databases::Kept::Kept(std::unique_ptr<Cache::Database> &&database)
+: database(std::move(database)) {
+}
+
+DatabasePointer Databases::get(
+		const QString &path,
+		const Cache::details::Settings &settings) {
+	if (const auto i = _map.find(path); i != end(_map)) {
+		auto &kept = i->second;
+		Assert(kept.destroying.alive());
+		kept.destroying = nullptr;
+		kept.database->reconfigure(settings);
+		return DatabasePointer(this, kept.database);
+	}
+	const auto [i, ok] = _map.emplace(
+		path,
+		std::make_unique<Cache::Database>(path, settings));
+	return DatabasePointer(this, i->second.database);
+}
+
+void Databases::destroy(Cache::Database *database) {
+	for (auto &entry : _map) {
+		const auto &path = entry.first; // Need to capture it in lambda.
+		auto &kept = entry.second;
+		if (kept.database.get() == database) {
+			Assert(!kept.destroying.alive());
+			database->close();
+			database->waitForCleaner([
+				=,
+				guard = kept.destroying.make_guard()
+			]() mutable {
+				crl::on_main(std::move(guard), [=] {
+					_map.erase(path);
+				});
+			});
+		}
+	}
+}
+
+} // namespace Storage
diff --git a/Telegram/lib_storage/storage/storage_databases.h b/Telegram/lib_storage/storage/storage_databases.h
new file mode 100644
index 0000000..fd5fcca
--- /dev/null
+++ b/Telegram/lib_storage/storage/storage_databases.h
@@ -0,0 +1,70 @@
+// This file is part of Desktop App Toolkit,
+// a set of libraries for developing nice desktop applications.
+//
+// For license and copyright information please follow this link:
+// https://github.com/desktop-app/legal/blob/master/LEGAL
+//
+#pragma once
+
+#include "storage/cache/storage_cache_database.h"
+#include "base/binary_guard.h"
+
+namespace Storage {
+namespace Cache {
+namespace details {
+struct Settings;
+} // namespace details
+class Database;
+} // namespace Cache
+
+class Databases;
+
+class DatabasePointer {
+public:
+	DatabasePointer(const DatabasePointer &other) = delete;
+	DatabasePointer(DatabasePointer &&other);
+	DatabasePointer &operator=(const DatabasePointer &other) = delete;
+	DatabasePointer &operator=(DatabasePointer &&other);
+	~DatabasePointer();
+
+	Cache::Database *get() const;
+	Cache::Database &operator*() const;
+	Cache::Database *operator->() const;
+	explicit operator bool() const;
+
+private:
+	friend class Databases;
+
+	DatabasePointer(
+		not_null<Databases*> owner,
+		const std::unique_ptr<Cache::Database> &value);
+	void destroy();
+
+	Cache::Database *_value = nullptr;
+	not_null<Databases*> _owner;
+
+};
+
+class Databases {
+public:
+	DatabasePointer get(
+		const QString &path,
+		const Cache::details::Settings &settings);
+
+private:
+	friend class DatabasePointer;
+
+	struct Kept {
+		Kept(std::unique_ptr<Cache::Database> &&database);
+
+		std::unique_ptr<Cache::Database> database;
+		base::binary_guard destroying;
+	};
+
+	void destroy(Cache::Database *database);
+
+	std::map<QString, Kept> _map;
+
+};
+
+} // namespace Storage
diff --git a/Telegram/lib_storage/storage/storage_encrypted_file.cpp b/Telegram/lib_storage/storage/storage_encrypted_file.cpp
new file mode 100644
index 0000000..ca62baa
--- /dev/null
+++ b/Telegram/lib_storage/storage/storage_encrypted_file.cpp
@@ -0,0 +1,347 @@
+// This file is part of Desktop App Toolkit,
+// a set of libraries for developing nice desktop applications.
+//
+// For license and copyright information please follow this link:
+// https://github.com/desktop-app/legal/blob/master/LEGAL
+//
+#include "storage/storage_encrypted_file.h"
+
+#include "base/openssl_help.h"
+
+namespace Storage {
+namespace {
+
+constexpr auto kBlockSize = CtrState::kBlockSize;
+
+enum class Format : uint32 {
+	Format_0,
+};
+
+struct BasicHeader {
+	BasicHeader();
+
+	void setFormat(Format format) {
+		this->format = static_cast<uint32>(format);
+	}
+	Format getFormat() const {
+		return static_cast<Format>(format);
+	}
+
+	bytes::array<kSaltSize> salt = { { bytes::type() } };
+	uint32 format : 8;
+	uint32 reserved1 : 24;
+	uint32 reserved2 = 0;
+	uint64 applicationVersion = 0;
+	bytes::array<openssl::kSha256Size> checksum = { { bytes::type() } };
+};
+
+BasicHeader::BasicHeader()
+: format(static_cast<uint32>(Format::Format_0))
+, reserved1(0) {
+}
+
+} // namespace
+
+File::Result File::open(
+		const QString &path,
+		Mode mode,
+		const EncryptionKey &key) {
+	close();
+
+	const auto info = QFileInfo(path);
+	const auto dir = info.absoluteDir();
+	if (mode != Mode::Read && !dir.exists()) {
+		if (!QDir().mkpath(dir.absolutePath())) {
+			return Result::Failed;
+		}
+	}
+
+	_data.setFileName(info.absoluteFilePath());
+	const auto result = attemptOpen(mode, key);
+	if (result != Result::Success) {
+		close();
+	}
+	return result;
+
+	static_assert(sizeof(BasicHeader) == kSaltSize
+		+ sizeof(uint64) * 2
+		+ openssl::kSha256Size, "Unexpected paddings in the header.");
+	static_assert(
+		(sizeof(BasicHeader) - kSaltSize) % kBlockSize == 0,
+		"Not way to encrypt the header.");
+}
+
+File::Result File::attemptOpen(Mode mode, const EncryptionKey &key) {
+	switch (mode) {
+	case Mode::Read: return attemptOpenForRead(key);
+	case Mode::ReadAppend: return attemptOpenForReadAppend(key);
+	case Mode::Write: return attemptOpenForWrite(key);
+	}
+	Unexpected("Mode in Storage::File::attemptOpen.");
+}
+
+File::Result File::attemptOpenForRead(const EncryptionKey &key) {
+	if (!_data.open(QIODevice::ReadOnly)) {
+		return Result::Failed;
+	}
+	return readHeader(key);
+}
+
+File::Result File::attemptOpenForReadAppend(const EncryptionKey &key) {
+	if (!_lock.lock(_data, QIODevice::ReadWrite)) {
+		return Result::LockFailed;
+	}
+	const auto size = _data.size();
+	if (!size) {
+		return writeHeader(key) ? Result::Success : Result::Failed;
+	}
+	return readHeader(key);
+}
+
+File::Result File::attemptOpenForWrite(const EncryptionKey &key) {
+	if (!_lock.lock(_data, QIODevice::WriteOnly)) {
+		return Result::LockFailed;
+	}
+	return writeHeader(key) ? Result::Success : Result::Failed;
+}
+
+bool File::writeHeader(const EncryptionKey &key) {
+	Expects(!_state.has_value());
+	Expects(_data.pos() == 0);
+
+	const auto magic = bytes::make_span("TDEF");
+	if (!writePlain(magic.subspan(0, base::FileLock::kSkipBytes))) {
+		return false;
+	}
+
+	auto header = BasicHeader();
+	bytes::set_random(header.salt);
+	_state = key.prepareCtrState(header.salt);
+
+	const auto headerBytes = bytes::object_as_span(&header);
+	const auto checkSize = headerBytes.size() - header.checksum.size();
+	bytes::copy(
+		header.checksum,
+		openssl::Sha256(
+			key.data(),
+			headerBytes.subspan(0, checkSize)));
+
+	if (writePlain(header.salt) != header.salt.size()) {
+		return false;
+	} else if (!write(headerBytes.subspan(header.salt.size()))) {
+		return false;
+	}
+	_dataSize = 0;
+	return true;
+}
+
+File::Result File::readHeader(const EncryptionKey &key) {
+	Expects(!_state.has_value());
+	Expects(_data.pos() == 0);
+
+	if (!_data.seek(base::FileLock::kSkipBytes)) {
+		return Result::Failed;
+	}
+	auto header = BasicHeader();
+	const auto headerBytes = bytes::object_as_span(&header);
+	if (readPlain(headerBytes) != headerBytes.size()) {
+		return Result::Failed;
+	}
+	_state = key.prepareCtrState(header.salt);
+	decrypt(headerBytes.subspan(header.salt.size()));
+
+	const auto checkSize = headerBytes.size() - header.checksum.size();
+	const auto checksum = openssl::Sha256(
+		key.data(),
+		headerBytes.subspan(0, checkSize));
+	if (bytes::compare(header.checksum, checksum) != 0) {
+		return Result::WrongKey;
+	} else if (header.getFormat() != Format::Format_0) {
+		return Result::Failed;
+	}
+	_dataSize = _data.size()
+		- int64(sizeof(BasicHeader))
+		- base::FileLock::kSkipBytes;
+	Assert(_dataSize >= 0);
+	if (const auto bad = (_dataSize % kBlockSize)) {
+		_dataSize -= bad;
+	}
+	return Result::Success;
+}
+
+size_type File::readPlain(bytes::span bytes) {
+	return _data.read(reinterpret_cast<char*>(bytes.data()), bytes.size());
+}
+
+size_type File::writePlain(bytes::const_span bytes) {
+	return _data.write(
+		reinterpret_cast<const char*>(bytes.data()),
+		bytes.size());
+}
+
+void File::decrypt(bytes::span bytes) {
+	Expects(_state.has_value());
+
+	_state->decrypt(bytes, _encryptionOffset);
+	_encryptionOffset += bytes.size();
+}
+
+void File::encrypt(bytes::span bytes) {
+	Expects(_state.has_value());
+
+	_state->encrypt(bytes, _encryptionOffset);
+	_encryptionOffset += bytes.size();
+}
+
+size_type File::read(bytes::span bytes) {
+	Expects(bytes.size() % kBlockSize == 0);
+
+	auto count = readPlain(bytes);
+	if (const auto back = -(count % kBlockSize)) {
+		if (!_data.seek(_data.pos() + back)) {
+			return 0;
+		}
+		count += back;
+	}
+	if (count) {
+		decrypt(bytes.subspan(0, count));
+	}
+	return count;
+}
+
+bool File::write(bytes::span bytes) {
+	Expects(bytes.size() % kBlockSize == 0);
+
+	if (!isOpen()) {
+		return false;
+	}
+	encrypt(bytes);
+	const auto count = writePlain(bytes);
+	if (count == bytes.size()) {
+		_dataSize = std::max(_dataSize, offset());
+	} else {
+		decryptBack(bytes);
+		if (count > 0) {
+			_data.seek(_data.pos() - count);
+		}
+		return false;
+	}
+	return true;
+}
+
+void File::decryptBack(bytes::span bytes) {
+	Expects(_encryptionOffset >= bytes.size());
+
+	_encryptionOffset -= bytes.size();
+	decrypt(bytes);
+	_encryptionOffset -= bytes.size();
+}
+
+size_type File::readWithPadding(bytes::span bytes) {
+	const auto size = bytes.size();
+	const auto part = size % kBlockSize;
+	const auto good = size - part;
+	if (good) {
+		const auto succeed = read(bytes.subspan(0, good));
+		if (succeed != good) {
+			return succeed;
+		}
+	}
+	if (!part) {
+		return good;
+	}
+	auto storage = bytes::array<kBlockSize>();
+	const auto padded = bytes::make_span(storage);
+	const auto succeed = read(padded);
+	if (!succeed) {
+		return good;
+	}
+	Assert(succeed == kBlockSize);
+	bytes::copy(bytes.subspan(good), padded.subspan(0, part));
+	return size;
+}
+
+bool File::writeWithPadding(bytes::span bytes) {
+	const auto size = bytes.size();
+	const auto part = size % kBlockSize;
+	const auto good = size - part;
+	if (good && !write(bytes.subspan(0, good))) {
+		return false;
+	}
+	if (!part) {
+		return true;
+	}
+	auto storage = bytes::array<kBlockSize>();
+	const auto padded = bytes::make_span(storage);
+	bytes::copy(padded, bytes.subspan(good));
+	bytes::set_random(padded.subspan(part));
+	if (write(padded)) {
+		return true;
+	}
+	if (good) {
+		decryptBack(bytes.subspan(0, good));
+		_data.seek(_data.pos() - good);
+	}
+	return false;
+}
+
+bool File::flush() {
+	return _data.flush();
+}
+
+void File::close() {
+	_lock.unlock();
+	_data.close();
+	_data.setFileName(QString());
+	_dataSize = _encryptionOffset = 0;
+	_state = std::nullopt;
+}
+
+bool File::isOpen() const {
+	return _data.isOpen();
+}
+
+int64 File::size() const {
+	return _dataSize;
+}
+
+int64 File::offset() const {
+	const auto realOffset = kSaltSize + _encryptionOffset;
+	const auto skipOffset = sizeof(BasicHeader);
+	return (realOffset >= skipOffset) ? (realOffset - skipOffset) : 0;
+}
+
+bool File::seek(int64 offset) {
+	const auto realOffset = sizeof(BasicHeader) + offset;
+	if (offset < 0 || offset > _dataSize) {
+		return false;
+	} else if (!_data.seek(base::FileLock::kSkipBytes + realOffset)) {
+		return false;
+	}
+	_encryptionOffset = realOffset - kSaltSize;
+	return true;
+}
+
+bool File::Move(const QString &from, const QString &to) {
+	QFile source(from);
+	if (!source.exists()) {
+		return false;
+	}
+	QFile destination(to);
+	if (destination.exists()) {
+		{
+			base::FileLock locker;
+			if (!locker.lock(destination, QIODevice::WriteOnly)) {
+				return false;
+			}
+		}
+		destination.close();
+		if (!destination.remove()) {
+			return false;
+		}
+	}
+	return source.rename(to);
+}
+
+
+} // namespace Storage
diff --git a/Telegram/lib_storage/storage/storage_encrypted_file.h b/Telegram/lib_storage/storage/storage_encrypted_file.h
new file mode 100644
index 0000000..301aafa
--- /dev/null
+++ b/Telegram/lib_storage/storage/storage_encrypted_file.h
@@ -0,0 +1,72 @@
+// This file is part of Desktop App Toolkit,
+// a set of libraries for developing nice desktop applications.
+//
+// For license and copyright information please follow this link:
+// https://github.com/desktop-app/legal/blob/master/LEGAL
+//
+#pragma once
+
+#include "storage/storage_encryption.h"
+#include "base/bytes.h"
+#include "base/optional.h"
+#include "base/file_lock.h"
+
+namespace Storage {
+
+class File {
+public:
+	enum class Mode {
+		Read,
+		ReadAppend,
+		Write,
+	};
+	enum class Result {
+		Failed,
+		LockFailed,
+		WrongKey,
+		Success,
+	};
+	Result open(const QString &path, Mode mode, const EncryptionKey &key);
+
+	size_type read(bytes::span bytes);
+	bool write(bytes::span bytes);
+
+	size_type readWithPadding(bytes::span bytes);
+	bool writeWithPadding(bytes::span bytes);
+
+	bool flush();
+
+	bool isOpen() const;
+	int64 size() const;
+	int64 offset() const;
+	bool seek(int64 offset);
+
+	void close();
+
+	static bool Move(const QString &from, const QString &to);
+
+private:
+	Result attemptOpen(Mode mode, const EncryptionKey &key);
+	Result attemptOpenForRead(const EncryptionKey &key);
+	Result attemptOpenForReadAppend(const EncryptionKey &key);
+	Result attemptOpenForWrite(const EncryptionKey &key);
+
+	bool writeHeader(const EncryptionKey &key);
+	Result readHeader(const EncryptionKey &key);
+
+	size_type readPlain(bytes::span bytes);
+	size_type writePlain(bytes::const_span bytes);
+	void decrypt(bytes::span bytes);
+	void encrypt(bytes::span bytes);
+	void decryptBack(bytes::span bytes);
+
+	QFile _data;
+	base::FileLock _lock;
+	int64 _encryptionOffset = 0;
+	int64 _dataSize = 0;
+
+	std::optional<CtrState> _state;
+
+};
+
+} // namespace Storage
diff --git a/Telegram/lib_storage/storage/storage_encryption.cpp b/Telegram/lib_storage/storage/storage_encryption.cpp
new file mode 100644
index 0000000..c4c14ef
--- /dev/null
+++ b/Telegram/lib_storage/storage/storage_encryption.cpp
@@ -0,0 +1,109 @@
+// This file is part of Desktop App Toolkit,
+// a set of libraries for developing nice desktop applications.
+//
+// For license and copyright information please follow this link:
+// https://github.com/desktop-app/legal/blob/master/LEGAL
+//
+#include "storage/storage_encryption.h"
+
+#include "base/openssl_help.h"
+
+namespace Storage {
+
+CtrState::CtrState(bytes::const_span key, bytes::const_span iv) {
+	Expects(key.size() == _key.size());
+	Expects(iv.size() == _iv.size());
+
+	bytes::copy(_key, key);
+	bytes::copy(_iv, iv);
+}
+
+template <typename Method>
+void CtrState::process(bytes::span data, int64 offset, Method method) {
+	Expects((data.size() % kBlockSize) == 0);
+	Expects((offset % kBlockSize) == 0);
+
+	AES_KEY aes;
+	AES_set_encrypt_key(
+		reinterpret_cast<const uchar*>(_key.data()),
+		_key.size() * CHAR_BIT,
+		&aes);
+
+	unsigned char ecountBuf[kBlockSize] = { 0 };
+	unsigned int offsetInBlock = 0;
+	const auto blockIndex = offset / kBlockSize;
+	auto iv = incrementedIv(blockIndex);
+
+	CRYPTO_ctr128_encrypt(
+		reinterpret_cast<const uchar*>(data.data()),
+		reinterpret_cast<uchar*>(data.data()),
+		data.size(),
+		&aes,
+		reinterpret_cast<unsigned char*>(iv.data()),
+		ecountBuf,
+		&offsetInBlock,
+		(block128_f)method);
+}
+
+auto CtrState::incrementedIv(int64 blockIndex)
+-> bytes::array<kIvSize> {
+	Expects(blockIndex >= 0);
+
+	if (!blockIndex) {
+		return _iv;
+	}
+	auto result = _iv;
+	auto digits = kIvSize;
+	auto increment = uint64(blockIndex);
+	do {
+		--digits;
+		increment += static_cast<uint64>(result[digits]);
+		result[digits] = static_cast<bytes::type>(increment & 0xFFULL);
+		increment >>= 8;
+	} while (digits != 0 && increment != 0);
+	return result;
+}
+
+void CtrState::encrypt(bytes::span data, int64 offset) {
+	return process(data, offset, AES_encrypt);
+}
+
+void CtrState::decrypt(bytes::span data, int64 offset) {
+	return process(data, offset, AES_encrypt);
+}
+
+EncryptionKey::EncryptionKey(bytes::vector &&data)
+: _data(std::move(data)) {
+	Expects(_data.size() == kSize || _data.size() == kSize_v2);
+}
+
+bool EncryptionKey::empty() const {
+	return _data.empty();
+}
+
+EncryptionKey::operator bool() const {
+	return !empty();
+}
+
+const bytes::vector &EncryptionKey::data() const {
+	return _data;
+}
+
+CtrState EncryptionKey::prepareCtrState(bytes::const_span salt) const {
+	Expects(salt.size() == kSaltSize);
+	Expects(!empty());
+
+	const auto data = bytes::make_span(_data);
+	const auto key = openssl::Sha256(
+		data.subspan(0, data.size() / 2),
+		salt.subspan(0, kSaltSize / 2));
+	const auto iv = openssl::Sha256(
+		data.subspan(data.size() / 2),
+		salt.subspan(kSaltSize / 2));
+
+	return CtrState(
+		key,
+		bytes::make_span(iv).subspan(0, CtrState::kIvSize));
+}
+
+} // namespace Storage
diff --git a/Telegram/lib_storage/storage/storage_encryption.h b/Telegram/lib_storage/storage/storage_encryption.h
new file mode 100644
index 0000000..d2cfa2f
--- /dev/null
+++ b/Telegram/lib_storage/storage/storage_encryption.h
@@ -0,0 +1,58 @@
+// This file is part of Desktop App Toolkit,
+// a set of libraries for developing nice desktop applications.
+//
+// For license and copyright information please follow this link:
+// https://github.com/desktop-app/legal/blob/master/LEGAL
+//
+#pragma once
+
+#include "base/bytes.h"
+
+namespace Storage {
+
+constexpr auto kSaltSize = size_type(64);
+
+class CtrState {
+public:
+	static constexpr auto kBlockSize = size_type(16);
+	static constexpr auto kKeySize = size_type(32);
+	static constexpr auto kIvSize = kBlockSize;
+
+	CtrState(bytes::const_span key, bytes::const_span iv);
+
+	void encrypt(bytes::span data, int64 offset);
+	void decrypt(bytes::span data, int64 offset);
+
+private:
+	template <typename Method>
+	void process(bytes::span data, int64 offset, Method method);
+
+	bytes::array<kIvSize> incrementedIv(int64 blockIndex);
+
+	static constexpr auto EcountSize = kBlockSize;
+
+	bytes::array<kKeySize> _key;
+	bytes::array<kIvSize> _iv;
+
+};
+
+class EncryptionKey {
+public:
+	static constexpr auto kSize = size_type(256);
+	static constexpr auto kSize_v2 = size_type(64);
+
+	EncryptionKey() = default;
+	explicit EncryptionKey(bytes::vector &&data);
+
+	bool empty() const;
+	explicit operator bool() const;
+
+	const bytes::vector &data() const;
+	CtrState prepareCtrState(bytes::const_span salt) const;
+
+private:
+	bytes::vector _data;
+
+};
+
+} // namespace Storage
diff --git a/Telegram/lib_storage/storage/storage_pch.cpp b/Telegram/lib_storage/storage/storage_pch.cpp
new file mode 100644
index 0000000..cea68d1
--- /dev/null
+++ b/Telegram/lib_storage/storage/storage_pch.cpp
@@ -0,0 +1,9 @@
+// This file is part of Desktop App Toolkit,
+// a set of libraries for developing nice desktop applications.
+//
+// For license and copyright information please follow this link:
+// https://github.com/desktop-app/legal/blob/master/LEGAL
+//
+#include "storage/storage_pch.h"
+
+// Precompiled header helper.
diff --git a/Telegram/lib_storage/storage/storage_pch.h b/Telegram/lib_storage/storage/storage_pch.h
new file mode 100644
index 0000000..36f6676
--- /dev/null
+++ b/Telegram/lib_storage/storage/storage_pch.h
@@ -0,0 +1,27 @@
+// This file is part of Desktop App Toolkit,
+// a set of libraries for developing nice desktop applications.
+//
+// For license and copyright information please follow this link:
+// https://github.com/desktop-app/legal/blob/master/LEGAL
+//
+
+#include <QtCore/QFile>
+#include <QtCore/QFileInfo>
+#include <QtCore/QDir>
+#include <QtCore/QByteArray>
+#include <QtCore/QString>
+
+#include <crl/crl.h>
+#include <rpl/rpl.h>
+
+#include <vector>
+#include <unordered_map>
+#include <unordered_set>
+#include <set>
+
+#include <range/v3/all.hpp>
+
+#include "base/flat_map.h"
+#include "base/flat_set.h"
+#include "base/optional.h"
+#include "base/openssl_help.h"
Submodule Telegram/lib_tl 89a1e3fed..b0388a1a0:
diff --git a/Telegram/lib_tl/CMakeLists.txt b/Telegram/lib_tl/CMakeLists.txt
new file mode 100644
index 0000000..b17f135
--- /dev/null
+++ b/Telegram/lib_tl/CMakeLists.txt
@@ -0,0 +1,31 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+add_library(lib_tl OBJECT)
+add_library(desktop-app::lib_tl ALIAS lib_tl)
+init_target(lib_tl)
+
+get_filename_component(src_loc . REALPATH)
+
+nice_target_sources(lib_tl ${src_loc}
+PRIVATE
+    tl/tl_basic_types.cpp
+    tl/tl_basic_types.h
+    tl/tl_boxed.h
+    tl/tl_type_owner.h
+
+    tl/generate_tl.py
+)
+
+target_include_directories(lib_tl
+PUBLIC
+    ${src_loc}
+)
+
+target_link_libraries(lib_tl
+PUBLIC
+    desktop-app::lib_base
+)
diff --git a/Telegram/lib_tl/tl/generate_tl.py b/Telegram/lib_tl/tl/generate_tl.py
index 083f497..3e4cbc8 100644
--- a/Telegram/lib_tl/tl/generate_tl.py
+++ b/Telegram/lib_tl/tl/generate_tl.py
@@ -39,9 +39,9 @@ def addTextSerialize(typeList, typeData, typesDict, idPrefix, primeType, boxed,
 
       templateArgument = ''
       if (isTemplate != ''):
-          templateArgument = '<MTP::SecureRequest>'
+          templateArgument = '<SerializedRequest>'
 
-      result += 'bool Serialize_' + name + '(MTPStringLogger &to, int32 stage, int32 lev, Types &types, Types &vtypes, StagesFlags &stages, StagesFlags &flags, const ' + primeType + ' *start, const ' + primeType + ' *end, uint32 iflag) {\n'
+      result += 'bool Serialize_' + name + '(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, StagesFlags &stages, StagesFlags &flags, const ' + primeType + ' *start, const ' + primeType + ' *end, uint32 iflag) {\n'
       if (len(conditions)):
         result += '\tauto flag = ' + prefix + name + templateArgument + '::Flags::from_raw(iflag);\n\n'
       if (len(prms)):
@@ -162,8 +162,11 @@ def readAndGenerate(inputFiles, outputPath, scheme):
   outputSource = outputPath + '.cpp'
   outputConversionHeader = outputPath + '-conversion.h'
   outputConversionSource = outputPath + '-conversion.cpp'
+  outputSerializationHeader = outputPath + '-dump_to_text.h'
+  outputSerializationSource = outputPath + '-dump_to_text.cpp'
   outputHeaderBasename = os.path.basename(outputHeader)
   outputConversionHeaderBasename = os.path.basename(outputConversionHeader)
+  outputSerializationHeaderBasename = os.path.basename(outputSerializationHeader)
 
   prefixes = scheme.get('prefixes', {})
   dataPrefix = prefixes.get('data', '')
@@ -196,16 +199,11 @@ def readAndGenerate(inputFiles, outputPath, scheme):
   synonyms = scheme.get('synonyms', {})
   writeSections = scheme.get('sections', [])
   readWriteSection = 'read-write' in writeSections
-  serializationSection = 'serialization' in writeSections
 
   primitiveTypeNames = scheme.get('types')
   typeIdType = primitiveTypeNames.get('typeId')
   primeType = primitiveTypeNames.get('prime', '')
   bufferType = primitiveTypeNames.get('buffer', '')
-  if primeType == '' or bufferType == '':
-    if readWriteSection or serializationSection:
-      print('Required types not provided.')
-      sys.exit(1)
 
   writeConversion = 'conversion' in scheme
   conversionScheme = scheme.get('conversion', {})
@@ -224,6 +222,15 @@ def readAndGenerate(inputFiles, outputPath, scheme):
   def conversionMove(name):
     return conversionTemplate('move_object_as', name)
 
+  writeSerialization = 'dumpToText' in scheme
+  serializationScheme = scheme.get('dumpToText', {})
+  serializationInclude = serializationScheme.get('include') if writeSerialization else ''
+
+  if primeType == '' or bufferType == '':
+    if readWriteSection or writeSerialization:
+      print('Required types not provided.')
+      sys.exit(1)
+
   def isBuiltinType(name):
     return name in builtinTypes or name in builtinTemplateTypes
 
@@ -1113,16 +1120,12 @@ def readAndGenerate(inputFiles, outputPath, scheme):
     flagOperators += 'inline ' + parentName + '::Flags mtpCastFlags(' + childName + '::Flags flags) { return static_cast<' + parentName + '::Flag>(flags.value()); }\n'
     flagOperators += 'inline ' + parentName + '::Flags mtpCastFlags(MTPflags<' + childName + '::Flags> flags) { return mtpCastFlags(flags.v); }\n'
 
-  textSerializeHeader = ''
   textSerializeSource = ''
-  if serializationSection:
-    textSerializeHeader = '\n\
-// Human-readable text serialization\n\
-[[nodiscard]] bool mtpTextSerializeType(MTPStringLogger &to, const ' + primeType + ' *&from, const ' + primeType + ' *end, ' + primeType + ' cons, uint32 level, ' + primeType + ' vcons);\n'
+  if writeSerialization:
+    # manual types added here
 
-  # manual types added here
     textSerializeMethods += '\
-bool _serialize_rpc_result(MTPStringLogger &to, int32 stage, int32 lev, Types &types, Types &vtypes, StagesFlags &stages, StagesFlags &flags, const ' + primeType + ' *start, const ' + primeType + ' *end, uint32 iflag) {\n\
+bool Serialize_rpc_result(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, StagesFlags &stages, StagesFlags &flags, const ' + primeType + ' *start, const ' + primeType + ' *end, uint32 iflag) {\n\
 	if (stage) {\n\
 		to.add(",\\n").addSpaces(lev);\n\
 	} else {\n\
@@ -1137,7 +1140,7 @@ bool _serialize_rpc_result(MTPStringLogger &to, int32 stage, int32 lev, Types &t
 	return true;\n\
 }\n\
 \n\
-bool _serialize_msg_container(MTPStringLogger &to, int32 stage, int32 lev, Types &types, Types &vtypes, StagesFlags &stages, StagesFlags &flags, const ' + primeType + ' *start, const ' + primeType + ' *end, uint32 iflag) {\n\
+bool Serialize_msg_container(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, StagesFlags &stages, StagesFlags &flags, const ' + primeType + ' *start, const ' + primeType + ' *end, uint32 iflag) {\n\
 	if (stage) {\n\
 		to.add(",\\n").addSpaces(lev);\n\
 	} else {\n\
@@ -1151,7 +1154,7 @@ bool _serialize_msg_container(MTPStringLogger &to, int32 stage, int32 lev, Types
 	return true;\n\
 }\n\
 \n\
-bool _serialize_core_message(MTPStringLogger &to, int32 stage, int32 lev, Types &types, Types &vtypes, StagesFlags &stages, StagesFlags &flags, const ' + primeType + ' *start, const ' + primeType + ' *end, uint32 iflag) {\n\
+bool Serialize_core_message(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, StagesFlags &stages, StagesFlags &flags, const ' + primeType + ' *start, const ' + primeType + ' *end, uint32 iflag) {\n\
 	if (stage) {\n\
 		to.add(",\\n").addSpaces(lev);\n\
 	} else {\n\
@@ -1170,20 +1173,21 @@ bool _serialize_core_message(MTPStringLogger &to, int32 stage, int32 lev, Types
 \n'
 
     textSerializeInit += '\
-	result.insert(' + idPrefix + 'rpc_result, _serialize_rpc_result);\n\
-	result.insert(' + idPrefix + 'msg_container, _serialize_msg_container);\n\
-	result.insert(' + idPrefix + 'core_message, _serialize_core_message);\n'
+	result.insert(' + idPrefix + 'rpc_result, Serialize_rpc_result);\n\
+	result.insert(' + idPrefix + 'msg_container, Serialize_msg_container);\n\
+	result.insert(' + idPrefix + 'core_message, Serialize_core_message);\n'
     textSerializeSource = '\n\
+namespace {\n\
+\n\
 using Types = QVector<' + typeIdType + '>;\n\
 using StagesFlags = QVector<int32>;\n\
 \n\
 ' + textSerializeMethods + '\n\
-namespace {\n\
 \n\
-using TextSerializer = bool (*)(MTPStringLogger &to, int32 stage, int32 lev, Types &types, Types &vtypes, StagesFlags &stages, StagesFlags &flags, const ' + primeType + ' *start, const ' + primeType + ' *end, uint32 iflag);\n\
+using TextSerializer = bool (*)(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, StagesFlags &stages, StagesFlags &flags, const ' + primeType + ' *start, const ' + primeType + ' *end, uint32 iflag);\n\
 using TextSerializers = QMap<' + typeIdType + ', TextSerializer>;\n\
 \n\
-QMap<' + typeIdType + ', TextSerializer> createTextSerializers() {\n\
+QMap<' + typeIdType + ', TextSerializer> CreateTextSerializers() {\n\
 	auto result = QMap<' + typeIdType + ', TextSerializer>();\n\
 \n\
 ' + textSerializeInit + '\n\
@@ -1192,8 +1196,8 @@ QMap<' + typeIdType + ', TextSerializer> createTextSerializers() {\n\
 \n\
 } // namespace\n\
 \n\
-bool mtpTextSerializeType(MTPStringLogger &to, const ' + primeType + ' *&from, const ' + primeType + ' *end, ' + primeType + ' cons, uint32 level, ' + primeType + ' vcons) {\n\
-	static auto serializers = createTextSerializers();\n\
+bool DumpToTextType(DumpToTextBuffer &to, const ' + primeType + ' *&from, const ' + primeType + ' *end, ' + primeType + ' cons, uint32 level, ' + primeType + ' vcons) {\n\
+	static auto kSerializers = CreateTextSerializers();\n\
 \n\
 	QVector<' + typeIdType + '> types, vtypes;\n\
 	QVector<int32> stages, flags;\n\
@@ -1221,13 +1225,13 @@ bool mtpTextSerializeType(MTPStringLogger &to, const ' + primeType + ' *&from, c
 		}\n\
 \n\
 		int32 lev = level + types.size() - 1;\n\
-		auto it = serializers.constFind(type);\n\
-		if (it != serializers.cend()) {\n\
+		auto it = kSerializers.constFind(type);\n\
+		if (it != kSerializers.cend()) {\n\
 			if (!(*it.value())(to, stage, lev, types, vtypes, stages, flags, from, end, flag)) {\n\
 				to.error();\n\
 				return false;\n\
 			}\n\
-		} else if (mtpTextSerializeCore(to, from, end, type, lev, vtype)) {\n\
+		} else if (DumpToTextCore(to, from, end, type, lev, vtype)) {\n\
 			types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();\n\
 		} else {\n\
 			to.error();\n\
@@ -1253,7 +1257,7 @@ bool mtpTextSerializeType(MTPStringLogger &to, const ' + primeType + ' *&from, c
 ' + ('namespace ' + globalNamespace + ' {\n' if globalNamespace != '' else '') + '\
 ' + ('namespace ' + creatorNamespace + ' {\n' if creatorNamespace != '' else '') + '\
 \n\
-' + ('inline constexpr auto CurrentLayer = ' + primeType + '(' + str(layer) + ');\n\n' if layer != 0 else '') +'\
+' + ('inline constexpr auto kCurrentLayer = ' + primeType + '(' + str(layer) + ');\n\n' if layer != 0 else '') +'\
 class TypeCreator;\n\
 \n\
 ' + ('} // namespace ' + creatorNamespace + '\n\n' if creatorNamespace != '' else '') + '\
@@ -1280,7 +1284,7 @@ enum {\n\
 ' + flagOperators + '\n\
 // Factory methods declaration\n\
 ' + factories + '\n\
-' + ('} // namespace ' + globalNamespace + '\n' if globalNamespace != '' else '') + textSerializeHeader
+' + ('} // namespace ' + globalNamespace + '\n' if globalNamespace != '' else '')
 
   source = '\
 // WARNING! All changes made in this file will be lost!\n\
@@ -1300,7 +1304,7 @@ public:\n\
 ' + ('} // namespace ' + creatorNamespace + '\n\n' if creatorNamespace != '' else '') + '\
 // Methods definition\n\
 ' + methods + '\n\
-' + ('} // namespace ' + globalNamespace + '\n' if globalNamespace != '' else '') + textSerializeSource
+' + ('} // namespace ' + globalNamespace + '\n' if globalNamespace != '' else '')
 
   conversionHeader = '\
 // WARNING! All changes made in this file will be lost!\n\
@@ -1326,6 +1330,33 @@ public:\n\
 ' + conversionSource + '\n\
 ' + ('} // namespace ' + globalNamespace + '\n' if globalNamespace != '' else '')
 
+  serializationHeader = '\
+// WARNING! All changes made in this file will be lost!\n\
+// Created from ' + inputNames + ' by \'generate.py\'\n\
+//\n\
+#pragma once\n\
+\n\
+' + ('#include "' + builtinInclude + '"\n\n' if builtinInclude != '' else '') + '\
+namespace MTP::details {\n\
+\n\
+struct DumpToTextBuffer;\n\
+\n\
+[[nodiscard]] bool DumpToTextType(DumpToTextBuffer &to, const ' + primeType + ' *&from, const ' + primeType + ' *end, ' + primeType + ' cons = 0, uint32 level = 0, ' + primeType + ' vcons = 0);\n\
+\n\
+} // namespace MTP::details\n'
+
+  serializationSource = '\
+// WARNING! All changes made in this file will be lost!\n\
+// Created from ' + inputNames + ' by \'generate.py\'\n\
+//\n\
+#include "' + outputSerializationHeaderBasename + '"\n\
+#include "' + outputHeaderBasename + '"\n\
+#include "' + serializationInclude + '"\n\
+\n\
+namespace MTP::details {\n\
+' + textSerializeSource + '\n\
+} // namespace MTP::details\n'
+
   alreadyHeader = ''
   if os.path.isfile(outputHeader):
     with open(outputHeader, 'r') as already:
@@ -1358,3 +1389,23 @@ public:\n\
     if alreadySource != conversionSource:
       with open(outputConversionSource, 'w') as out:
         out.write(conversionSource)
+
+  if writeSerialization:
+    alreadyHeader = ''
+    if os.path.isfile(outputSerializationHeader):
+      with open(outputSerializationHeader, 'r') as already:
+        alreadyHeader = already.read()
+    if alreadyHeader != serializationHeader:
+      with open(outputSerializationHeader, 'w') as out:
+        out.write(serializationHeader)
+
+    alreadySource = ''
+    if os.path.isfile(outputSerializationSource):
+      with open(outputSerializationSource, 'r') as already:
+        alreadySource = already.read()
+    if alreadySource != serializationSource:
+      with open(outputSerializationSource, 'w') as out:
+        out.write(serializationSource)
+
+  with open(outputPath + '.timestamp', 'w') as out:
+    out.write('1')
diff --git a/Telegram/lib_tl/tl/tl_basic_types.cpp b/Telegram/lib_tl/tl/tl_basic_types.cpp
index ec22350..4162487 100644
--- a/Telegram/lib_tl/tl/tl_basic_types.cpp
+++ b/Telegram/lib_tl/tl/tl_basic_types.cpp
@@ -6,3 +6,10 @@
 //
 #include "tl/tl_basic_types.h"
 
+namespace tl {
+
+QString utf16(const QByteArray &v) {
+	return QString::fromUtf8(v);
+}
+
+} // namespace tl
diff --git a/Telegram/lib_tl/tl/tl_basic_types.h b/Telegram/lib_tl/tl/tl_basic_types.h
index 6e62f3e..80a8468 100644
--- a/Telegram/lib_tl/tl/tl_basic_types.h
+++ b/Telegram/lib_tl/tl/tl_basic_types.h
@@ -510,9 +510,7 @@ inline bool operator!=(const string_type &a, const string_type &b) {
 	return a.v != b.v;
 }
 
-inline QString utf16(const QByteArray &v) {
-	return QString::fromUtf8(v);
-}
+QString utf16(const QByteArray &v);
 
 inline QByteArray utf8(const QByteArray &v) {
 	return v;
Submodule Telegram/lib_ui 55aec1954..a5df8e8e5:
diff --git a/Telegram/lib_ui/CMakeLists.txt b/Telegram/lib_ui/CMakeLists.txt
new file mode 100644
index 0000000..687b25f
--- /dev/null
+++ b/Telegram/lib_ui/CMakeLists.txt
@@ -0,0 +1,200 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+add_library(lib_ui OBJECT)
+add_library(desktop-app::lib_ui ALIAS lib_ui)
+init_target(lib_ui)
+
+include(cmake/generate_palette.cmake)
+include(cmake/generate_styles.cmake)
+include(cmake/generate_emoji.cmake)
+
+get_filename_component(src_loc . REALPATH)
+
+set(style_files
+    ui/basic.style
+    ui/layers/layers.style
+    ui/widgets/widgets.style
+)
+set(qrc_files
+    fonts/fonts.qrc
+    qt_conf/linux.qrc
+    qt_conf/mac.qrc
+    qt_conf/win.qrc
+)
+
+generate_palette(lib_ui ui/colors.palette)
+generate_styles(lib_ui ${src_loc} "${style_files}" ui/colors.palette)
+generate_emoji(lib_ui emoji_suggestions/emoji_autocomplete.json)
+
+set_target_properties(lib_ui PROPERTIES AUTOMOC ON AUTORCC ON)
+
+target_precompile_headers(lib_ui PRIVATE ${src_loc}/ui/ui_pch.h)
+nice_target_sources(lib_ui ${src_loc}
+PRIVATE
+    ${qrc_files}
+    ${style_files}
+    ui/colors.palette
+    emoji_suggestions/emoji_autocomplete.json
+
+    ui/effects/animation_value.cpp
+    ui/effects/animation_value.h
+    ui/effects/animations.cpp
+    ui/effects/animations.h
+    ui/effects/cross_animation.cpp
+    ui/effects/cross_animation.h
+    ui/effects/fade_animation.cpp
+    ui/effects/fade_animation.h
+    ui/effects/numbers_animation.cpp
+    ui/effects/numbers_animation.h
+    ui/effects/panel_animation.cpp
+    ui/effects/panel_animation.h
+    ui/effects/radial_animation.cpp
+    ui/effects/radial_animation.h
+    ui/effects/ripple_animation.cpp
+    ui/effects/ripple_animation.h
+    ui/effects/slide_animation.cpp
+    ui/effects/slide_animation.h
+    ui/image/image_prepare.cpp
+    ui/image/image_prepare.h
+    ui/layers/box_content.cpp
+    ui/layers/box_content.h
+    ui/layers/box_layer_widget.cpp
+    ui/layers/box_layer_widget.h
+    ui/layers/generic_box.cpp
+    ui/layers/generic_box.h
+    ui/layers/layer_manager.cpp
+    ui/layers/layer_manager.h
+    ui/layers/layer_widget.cpp
+    ui/layers/layer_widget.h
+    ui/platform/linux/ui_window_linux.cpp
+    ui/platform/linux/ui_window_linux.h
+    ui/platform/linux/ui_utility_linux.cpp
+    ui/platform/linux/ui_utility_linux.h
+    ui/platform/mac/ui_window_mac.h
+    ui/platform/mac/ui_window_mac.mm
+    ui/platform/mac/ui_window_title_mac.h
+    ui/platform/mac/ui_window_title_mac.mm
+    ui/platform/mac/ui_utility_mac.h
+    ui/platform/mac/ui_utility_mac.mm
+    ui/platform/win/ui_window_shadow_win.cpp
+    ui/platform/win/ui_window_shadow_win.h
+    ui/platform/win/ui_window_title_win.cpp
+    ui/platform/win/ui_window_title_win.h
+    ui/platform/win/ui_window_win.cpp
+    ui/platform/win/ui_window_win.h
+    ui/platform/win/ui_utility_win.cpp
+    ui/platform/win/ui_utility_win.h
+    ui/platform/ui_platform_window.h
+    ui/platform/ui_platform_utility.h
+    ui/style/style_core.cpp
+    ui/style/style_core.h
+    ui/style/style_core_color.cpp
+    ui/style/style_core_color.h
+    ui/style/style_core_direction.cpp
+    ui/style/style_core_direction.h
+    ui/style/style_core_font.cpp
+    ui/style/style_core_font.h
+    ui/style/style_core_icon.cpp
+    ui/style/style_core_icon.h
+    ui/style/style_core_scale.cpp
+    ui/style/style_core_scale.h
+    ui/style/style_core_types.cpp
+    ui/style/style_core_types.h
+    ui/text/text.cpp
+    ui/text/text.h
+    ui/text/text_block.cpp
+    ui/text/text_block.h
+    ui/text/text_entity.cpp
+    ui/text/text_entity.h
+    ui/text/text_isolated_emoji.h
+    ui/text/text_utilities.cpp
+    ui/text/text_utilities.h
+    ui/toast/toast.cpp
+    ui/toast/toast.h
+    ui/toast/toast_manager.cpp
+    ui/toast/toast_manager.h
+    ui/toast/toast_widget.cpp
+    ui/toast/toast_widget.h
+    ui/widgets/box_content_divider.cpp
+    ui/widgets/box_content_divider.h
+    ui/widgets/buttons.cpp
+    ui/widgets/buttons.h
+    ui/widgets/checkbox.cpp
+    ui/widgets/checkbox.h
+    ui/widgets/dropdown_menu.cpp
+    ui/widgets/dropdown_menu.h
+    ui/widgets/inner_dropdown.cpp
+    ui/widgets/inner_dropdown.h
+    ui/widgets/input_fields.cpp
+    ui/widgets/input_fields.h
+    ui/widgets/labels.cpp
+    ui/widgets/labels.h
+    ui/widgets/menu.cpp
+    ui/widgets/menu.h
+    ui/widgets/popup_menu.cpp
+    ui/widgets/popup_menu.h
+    ui/widgets/scroll_area.cpp
+    ui/widgets/scroll_area.h
+    ui/widgets/shadow.cpp
+    ui/widgets/shadow.h
+    ui/widgets/tooltip.cpp
+    ui/widgets/tooltip.h
+    ui/widgets/window.cpp
+    ui/widgets/window.h
+    ui/wrap/fade_wrap.cpp
+    ui/wrap/fade_wrap.h
+    ui/wrap/padding_wrap.cpp
+    ui/wrap/padding_wrap.h
+    ui/wrap/slide_wrap.cpp
+    ui/wrap/slide_wrap.h
+    ui/wrap/vertical_layout.cpp
+    ui/wrap/vertical_layout.h
+    ui/wrap/wrap.h
+    ui/abstract_button.cpp
+    ui/abstract_button.h
+    ui/basic_click_handlers.cpp
+    ui/basic_click_handlers.h
+    ui/click_handler.cpp
+    ui/click_handler.h
+    ui/delayed_activation.cpp
+    ui/delayed_activation.h
+    ui/emoji_config.cpp
+    ui/emoji_config.h
+    ui/focus_persister.h
+    ui/inactive_press.cpp
+    ui/inactive_press.h
+    ui/integration.cpp
+    ui/integration.h
+    ui/main_queue_processor.cpp
+    ui/main_queue_processor.h
+    ui/painter.h
+    ui/ph.cpp
+    ui/ph.h
+    ui/rect_part.h
+    ui/round_rect.cpp
+    ui/round_rect.h
+    ui/rp_widget.cpp
+    ui/rp_widget.h
+    ui/ui_log.cpp
+    ui/ui_log.h
+    ui/ui_utility.cpp
+    ui/ui_utility.h
+    emoji_suggestions/emoji_suggestions.cpp
+    emoji_suggestions/emoji_suggestions.h
+    emoji_suggestions/emoji_suggestions_helper.h
+)
+
+target_include_directories(lib_ui
+PUBLIC
+    ${src_loc}
+    ${src_loc}/emoji_suggestions
+)
+
+target_link_libraries(lib_ui
+PUBLIC
+    desktop-app::lib_base
+)
diff --git a/Telegram/lib_ui/cmake/generate_emoji.cmake b/Telegram/lib_ui/cmake/generate_emoji.cmake
new file mode 100644
index 0000000..a85dac8
--- /dev/null
+++ b/Telegram/lib_ui/cmake/generate_emoji.cmake
@@ -0,0 +1,29 @@
+function(generate_emoji target_name suggestions_json)
+    set(gen_dst ${CMAKE_CURRENT_BINARY_DIR}/gen)
+    file(MAKE_DIRECTORY ${gen_dst})
+
+    set(gen_timestamp ${gen_dst}/emoji.timestamp)
+    set(gen_files
+        ${gen_dst}/emoji.cpp
+        ${gen_dst}/emoji.h
+        ${gen_dst}/emoji_suggestions_data.cpp
+        ${gen_dst}/emoji_suggestions_data.h
+    )
+
+    set(gen_src ${CMAKE_CURRENT_SOURCE_DIR}/${suggestions_json})
+    add_custom_command(
+    OUTPUT
+        ${gen_timestamp}
+    BYPRODUCTS
+        ${gen_files}
+    COMMAND
+        codegen_emoji
+        -o${gen_dst}
+        ${gen_src}
+    COMMENT "Generating emoji (${target_name})"
+    DEPENDS
+        codegen_emoji
+        ${gen_src}
+    )
+    generate_target(${target_name} emoji ${gen_timestamp} "${gen_files}" ${gen_dst})
+endfunction()
diff --git a/Telegram/lib_ui/cmake/generate_palette.cmake b/Telegram/lib_ui/cmake/generate_palette.cmake
new file mode 100644
index 0000000..e3f7043
--- /dev/null
+++ b/Telegram/lib_ui/cmake/generate_palette.cmake
@@ -0,0 +1,32 @@
+function(generate_palette target_name palette_file)
+    set(gen_dst ${CMAKE_CURRENT_BINARY_DIR}/gen)
+    file(MAKE_DIRECTORY ${gen_dst})
+
+    set(gen_timestamp ${gen_dst}/styles/palette.timestamp)
+    set(gen_files
+         ${gen_dst}/styles/palette.cpp
+         ${gen_dst}/styles/palette.h
+    )
+
+    set(gen_src ${CMAKE_CURRENT_SOURCE_DIR}/${palette_file})
+    add_custom_command(
+    OUTPUT
+       ${gen_timestamp}
+    BYPRODUCTS
+        ${gen_files}
+    COMMAND
+        codegen_style
+        -I${gen_dst}
+        -o${gen_dst}/styles
+        -t${gen_dst}/styles/palette
+        -w${CMAKE_CURRENT_SOURCE_DIR}
+        ${gen_src}
+    COMMENT "Generating palette (${target_name})"
+    DEPENDS
+        codegen_style
+        ${gen_src}
+    MAIN_DEPENDENCY
+        ${gen_src}
+    )
+    generate_target(${target_name} palette ${gen_timestamp} "${gen_files}" ${gen_dst})
+endfunction()
diff --git a/Telegram/lib_ui/cmake/generate_styles.cmake b/Telegram/lib_ui/cmake/generate_styles.cmake
new file mode 100644
index 0000000..84617ea
--- /dev/null
+++ b/Telegram/lib_ui/cmake/generate_styles.cmake
@@ -0,0 +1,40 @@
+function(generate_styles target_name src_loc style_files dependent_style_files)
+    set(gen_dst ${CMAKE_CURRENT_BINARY_DIR}/gen)
+    file(MAKE_DIRECTORY ${gen_dst})
+
+    set(gen_timestamp ${gen_dst}/styles/${target_name}_style.timestamp)
+    set(gen_files "")
+    set(full_generation_sources "")
+    set(full_dependencies_list ${dependent_style_files})
+    foreach (file ${style_files})
+        list(APPEND full_generation_sources ${src_loc}/${file})
+        get_filename_component(file_name ${file} NAME_WLE)
+        list(APPEND gen_files
+            ${gen_dst}/styles/style_${file_name}.cpp
+            ${gen_dst}/styles/style_${file_name}.h
+        )
+    endforeach()
+    list(APPEND full_dependencies_list ${full_generation_sources})
+
+    add_custom_command(
+    OUTPUT
+        ${gen_timestamp}
+    BYPRODUCTS
+        ${gen_files}
+    COMMAND
+        codegen_style
+        -I${src_loc}
+        -I${submodules_loc}/lib_ui
+        -I${submodules_loc}/Resources
+        -o${gen_dst}/styles
+        -t${gen_dst}/styles/${target_name}_style
+        -w${CMAKE_CURRENT_SOURCE_DIR}
+        ${full_generation_sources}
+    COMMENT "Generating styles (${target_name})"
+    DEPENDS
+        codegen_style
+        ${full_dependencies_list}
+    )
+
+    generate_target(${target_name} styles ${gen_timestamp} "${gen_files}" ${gen_dst})
+endfunction()
diff --git a/Telegram/lib_ui/ui/basic_click_handlers.cpp b/Telegram/lib_ui/ui/basic_click_handlers.cpp
index 6599f8c..534ea57 100644
--- a/Telegram/lib_ui/ui/basic_click_handlers.cpp
+++ b/Telegram/lib_ui/ui/basic_click_handlers.cpp
@@ -16,12 +16,17 @@
 #include <QtGui/QDesktopServices>
 #include <QtGui/QGuiApplication>
 
+QString TextClickHandler::readable() const {
+	const auto result = url();
+	return result.startsWith(qstr("internal:")) ? QString() : result;
+}
+
 UrlClickHandler::UrlClickHandler(const QString &url, bool fullDisplayed)
 : TextClickHandler(fullDisplayed)
 , _originalUrl(url) {
 	if (isEmail()) {
 		_readable = _originalUrl;
-	} else {
+	} else if (!_originalUrl.startsWith(qstr("internal:"))) {
 		const auto original = QUrl(_originalUrl);
 		const auto good = QUrl(original.isValid()
 			? original.toEncoded()
diff --git a/Telegram/lib_ui/ui/basic_click_handlers.h b/Telegram/lib_ui/ui/basic_click_handlers.h
index 4335cce..ffcab83 100644
--- a/Telegram/lib_ui/ui/basic_click_handlers.h
+++ b/Telegram/lib_ui/ui/basic_click_handlers.h
@@ -29,9 +29,7 @@ public:
 
 protected:
 	virtual QString url() const = 0;
-	virtual QString readable() const {
-		return url();
-	}
+	virtual QString readable() const;
 
 	bool _fullDisplayed;
 
diff --git a/Telegram/lib_ui/ui/effects/animations.cpp b/Telegram/lib_ui/ui/effects/animations.cpp
index 874f07e..426a085 100644
--- a/Telegram/lib_ui/ui/effects/animations.cpp
+++ b/Telegram/lib_ui/ui/effects/animations.cpp
@@ -113,6 +113,7 @@ void Manager::stop(not_null<Basic*> animation) {
 		const auto i = ranges::find(_active, value, proj);
 		if (i != end(_active)) {
 			*i = nullptr;
+			_removedWhileUpdating = true;
 		}
 	} else if (empty(_active)) {
 		stopTimer();
@@ -138,6 +139,12 @@ void Manager::update() {
 	};
 	_active.erase(ranges::remove_if(_active, isFinished), end(_active));
 
+	if (_removedWhileUpdating) {
+		_removedWhileUpdating = false;
+		const auto proj = &ActiveBasicPointer::get;
+		_active.erase(ranges::remove(_active, nullptr, proj), end(_active));
+	}
+
 	if (!empty(_starting)) {
 		_active.insert(
 			end(_active),
diff --git a/Telegram/lib_ui/ui/effects/animations.h b/Telegram/lib_ui/ui/effects/animations.h
index 41665c3..c7eabf6 100644
--- a/Telegram/lib_ui/ui/effects/animations.h
+++ b/Telegram/lib_ui/ui/effects/animations.h
@@ -198,6 +198,7 @@ private:
 	crl::time _lastUpdateTime = 0;
 	int _timerId = 0;
 	bool _updating = false;
+	bool _removedWhileUpdating = false;
 	bool _scheduled = false;
 	bool _forceImmediateUpdate = false;
 	std::vector<ActiveBasicPointer> _active;
diff --git a/Telegram/lib_ui/ui/effects/radial_animation.cpp b/Telegram/lib_ui/ui/effects/radial_animation.cpp
index 3a3ff77..83bb308 100644
--- a/Telegram/lib_ui/ui/effects/radial_animation.cpp
+++ b/Telegram/lib_ui/ui/effects/radial_animation.cpp
@@ -144,7 +144,14 @@ void InfiniteRadialAnimation::draw(
 		QPainter &p,
 		QPoint position,
 		int outerWidth) {
-	draw(p, position, _st.size, outerWidth);
+	Draw(
+		p,
+		computeState(),
+		position,
+		_st.size,
+		outerWidth,
+		_st.color,
+		_st.thickness);
 }
 
 void InfiniteRadialAnimation::draw(
@@ -152,8 +159,24 @@ void InfiniteRadialAnimation::draw(
 		QPoint position,
 		QSize size,
 		int outerWidth) {
-	const auto state = computeState();
+	Draw(
+		p,
+		computeState(),
+		position,
+		size,
+		outerWidth,
+		_st.color,
+		_st.thickness);
+}
 
+void InfiniteRadialAnimation::Draw(
+		QPainter &p,
+		const RadialState &state,
+		QPoint position,
+		QSize size,
+		int outerWidth,
+		QPen pen,
+		int thickness) {
 	auto o = p.opacity();
 	p.setOpacity(o * state.shown);
 
@@ -166,10 +189,9 @@ void InfiniteRadialAnimation::draw(
 	const auto was = p.pen();
 	const auto brush = p.brush();
 	if (anim::Disabled()) {
-		anim::DrawStaticLoading(p, rect, _st.thickness, _st.color);
+		anim::DrawStaticLoading(p, rect, thickness, pen);
 	} else {
-		auto pen = _st.color->p;
-		pen.setWidth(_st.thickness);
+		pen.setWidth(thickness);
 		pen.setCapStyle(Qt::RoundCap);
 		p.setPen(pen);
 
diff --git a/Telegram/lib_ui/ui/effects/radial_animation.h b/Telegram/lib_ui/ui/effects/radial_animation.h
index 2581372..984e49a 100644
--- a/Telegram/lib_ui/ui/effects/radial_animation.h
+++ b/Telegram/lib_ui/ui/effects/radial_animation.h
@@ -27,10 +27,10 @@ public:
 	template <typename Callback>
 	RadialAnimation(Callback &&callback);
 
-	float64 opacity() const {
+	[[nodiscard]] float64 opacity() const {
 		return _opacity;
 	}
-	bool animating() const {
+	[[nodiscard]] bool animating() const {
 		return _animation.animating();
 	}
 
@@ -44,7 +44,7 @@ public:
 		int32 thickness,
 		style::color color) const;
 
-	RadialState computeState() const;
+	[[nodiscard]] RadialState computeState() const;
 
 private:
 	crl::time _firstStart = 0;
@@ -72,7 +72,7 @@ public:
 		Callback &&callback,
 		const style::InfiniteRadialAnimation &st);
 
-	bool animating() const {
+	[[nodiscard]] bool animating() const {
 		return _animation.animating();
 	}
 
@@ -89,7 +89,16 @@ public:
 		QSize size,
 		int outerWidth);
 
-	RadialState computeState();
+	static void Draw(
+		QPainter &p,
+		const RadialState &state,
+		QPoint position,
+		QSize size,
+		int outerWidth,
+		QPen pen,
+		int thickness);
+
+	[[nodiscard]] RadialState computeState();
 
 private:
 	const style::InfiniteRadialAnimation &_st;
diff --git a/Telegram/lib_ui/ui/image/image_prepare.cpp b/Telegram/lib_ui/ui/image/image_prepare.cpp
index 5a86d26..b2c2270 100644
--- a/Telegram/lib_ui/ui/image/image_prepare.cpp
+++ b/Telegram/lib_ui/ui/image/image_prepare.cpp
@@ -516,7 +516,6 @@ void prepareRound(
 	}
 	Assert(!image.isNull());
 
-	image.setDevicePixelRatio(style::DevicePixelRatio());
 	image = std::move(image).convertToFormat(
 		QImage::Format_ARGB32_Premultiplied);
 	Assert(!image.isNull());
diff --git a/Telegram/lib_ui/ui/layers/box_content.h b/Telegram/lib_ui/ui/layers/box_content.h
index 6d49519..28426d5 100644
--- a/Telegram/lib_ui/ui/layers/box_content.h
+++ b/Telegram/lib_ui/ui/layers/box_content.h
@@ -184,6 +184,14 @@ public:
 		return _delegate;
 	}
 
+	void setNoContentMargin(bool noContentMargin) {
+		if (_noContentMargin != noContentMargin) {
+			_noContentMargin = noContentMargin;
+			setAttribute(Qt::WA_OpaquePaintEvent, !_noContentMargin);
+		}
+		getDelegate()->setNoContentMargin(noContentMargin);
+	}
+
 public slots:
 	void onScrollToY(int top, int bottom = -1);
 
@@ -196,13 +204,6 @@ protected:
 		getDelegate()->setLayerType(layerType);
 	}
 
-	void setNoContentMargin(bool noContentMargin) {
-		if (_noContentMargin != noContentMargin) {
-			_noContentMargin = noContentMargin;
-			setAttribute(Qt::WA_OpaquePaintEvent, !_noContentMargin);
-		}
-		getDelegate()->setNoContentMargin(noContentMargin);
-	}
 	void setDimensions(
 			int newWidth,
 			int maxHeight,
diff --git a/Telegram/lib_ui/ui/layers/layer_widget.cpp b/Telegram/lib_ui/ui/layers/layer_widget.cpp
index 6a05357..91df272 100644
--- a/Telegram/lib_ui/ui/layers/layer_widget.cpp
+++ b/Telegram/lib_ui/ui/layers/layer_widget.cpp
@@ -462,10 +462,10 @@ void LayerStackWidget::setCacheImages() {
 
 void LayerStackWidget::closeLayer(not_null<LayerWidget*> layer) {
 	const auto weak = Ui::MakeWeak(layer.get());
-	if (weak->inFocusChain()) {
+	if (Ui::InFocusChain(layer)) {
 		setFocus();
 	}
-	if (!weak || !weak->setClosing()) {
+	if (!layer->setClosing()) {
 		// This layer is already closing.
 		return;
 	} else if (!weak) {
@@ -734,9 +734,11 @@ void LayerStackWidget::appendBox(
 LayerWidget *LayerStackWidget::pushBox(
 		object_ptr<BoxContent> box,
 		anim::type animated) {
-	auto oldLayer = currentLayer();
+	const auto oldLayer = currentLayer();
 	if (oldLayer) {
-		if (oldLayer->inFocusChain()) setFocus();
+		if (Ui::InFocusChain(oldLayer)) {
+			setFocus();
+		}
 		oldLayer->hide();
 	}
 	_layers.push_back(
@@ -793,7 +795,7 @@ void LayerStackWidget::clearClosingLayers() {
 	while (!_closingLayers.empty()) {
 		const auto index = _closingLayers.size() - 1;
 		const auto layer = _closingLayers.back().get();
-		if (layer->inFocusChain()) {
+		if (Ui::InFocusChain(layer)) {
 			setFocus();
 		}
 
diff --git a/Telegram/lib_ui/ui/rp_widget.h b/Telegram/lib_ui/ui/rp_widget.h
index bfadb9f..8cffbe5 100644
--- a/Telegram/lib_ui/ui/rp_widget.h
+++ b/Telegram/lib_ui/ui/rp_widget.h
@@ -28,10 +28,6 @@ public:
 		return QMargins();
 	}
 
-	bool inFocusChain() const {
-		return Ui::InFocusChain(this);
-	}
-
 	void hideChildren() {
 		for (auto child : Base::children()) {
 			if (child->isWidgetType()) {
diff --git a/Telegram/lib_ui/ui/text/text.cpp b/Telegram/lib_ui/ui/text/text.cpp
index 724000b..e395f5e 100644
--- a/Telegram/lib_ui/ui/text/text.cpp
+++ b/Telegram/lib_ui/ui/text/text.cpp
@@ -3214,6 +3214,17 @@ TextForMimeData String::toText(
 	if (composeExpanded) {
 		result.expanded.reserve(_text.size());
 	}
+	const auto insertEntity = [&](EntityInText &&entity) {
+		auto i = result.rich.entities.end();
+		while (i != result.rich.entities.begin()) {
+			auto j = i;
+			if ((--j)->offset() <= entity.offset()) {
+				break;
+			}
+			i = j;
+		}
+		result.rich.entities.insert(i, std::move(entity));
+	};
 	auto linkStart = 0;
 	auto markdownTrackers = composeEntities
 		? std::vector<MarkdownTagTracker>{
@@ -3231,7 +3242,7 @@ TextForMimeData String::toText(
 		for (auto &tracker : markdownTrackers) {
 			const auto flag = tracker.flag;
 			if ((oldFlags & flag) && !(newFlags & flag)) {
-				result.rich.entities.push_back({
+				insertEntity({
 					tracker.type,
 					tracker.start,
 					result.rich.text.size() - tracker.start });
@@ -3256,15 +3267,17 @@ TextForMimeData String::toText(
 		if (!composeExpanded && !composeEntities) {
 			return;
 		}
+		const auto skipLink = (entity.type == EntityType::CustomUrl)
+			&& (entity.data.startsWith(qstr("internal:")));
 		if (composeExpanded) {
 			result.expanded.append(full);
-			if (entity.type == EntityType::CustomUrl) {
+			if (entity.type == EntityType::CustomUrl && !skipLink) {
 				const auto &url = entity.data;
 				result.expanded.append(qstr(" (")).append(url).append(')');
 			}
 		}
-		if (composeEntities) {
-			result.rich.entities.push_back({
+		if (composeEntities && !skipLink) {
+			insertEntity({
 				entity.type,
 				linkStart,
 				full.size(),
diff --git a/Telegram/lib_ui/ui/ui_utility.cpp b/Telegram/lib_ui/ui/ui_utility.cpp
index e7e5e59..2b3d6e2 100644
--- a/Telegram/lib_ui/ui/ui_utility.cpp
+++ b/Telegram/lib_ui/ui/ui_utility.cpp
@@ -8,8 +8,8 @@
 
 #include "ui/style/style_core.h"
 
+#include <QtWidgets/QApplication>
 #include <QtGui/QWindow>
-#include <QtGui/QGuiApplication>
 #include <QtGui/QtEvents>
 
 #include <array>
@@ -82,6 +82,10 @@ void SendPendingEventsRecursive(QWidget *target, bool parentHiddenFlag) {
 
 } // namespace
 
+bool AppInFocus() {
+	return QApplication::focusWidget() != nullptr;
+}
+
 void SendPendingMoveResizeEvents(not_null<QWidget*> target) {
 	CreateWidgetStateRecursive(target);
 	SendPendingEventsRecursive(target, !target->isVisible());
diff --git a/Telegram/lib_ui/ui/ui_utility.h b/Telegram/lib_ui/ui/ui_utility.h
index 3b2f77a..4a1ce5e 100644
--- a/Telegram/lib_ui/ui/ui_utility.h
+++ b/Telegram/lib_ui/ui/ui_utility.h
@@ -98,6 +98,8 @@ inline not_null<std::decay_t<Value>*> AttachAsChild(
 		std::forward<Value>(value))->value();
 }
 
+[[nodiscard]] bool AppInFocus();
+
 [[nodiscard]] inline bool InFocusChain(not_null<const QWidget*> widget) {
 	if (const auto top = widget->window()) {
 		if (auto focused = top->focusWidget()) {
diff --git a/Telegram/lib_ui/ui/widgets/input_fields.cpp b/Telegram/lib_ui/ui/widgets/input_fields.cpp
index fb6b171..db17e0c 100644
--- a/Telegram/lib_ui/ui/widgets/input_fields.cpp
+++ b/Telegram/lib_ui/ui/widgets/input_fields.cpp
@@ -3152,6 +3152,10 @@ bool InputField::commitMarkdownReplacement(
 
 	cursor.setCharFormat(_defaultCharFormat);
 	_inner->setTextCursor(cursor);
+
+	// Fire the tag to the spellchecker.
+	_markdownTagApplies.fire({ from, till, -1, -1, false, tag });
+
 	return true;
 }
 
diff --git a/Telegram/lib_ui/ui/widgets/input_fields.h b/Telegram/lib_ui/ui/widgets/input_fields.h
index 4fd9dbc..2873ea7 100644
--- a/Telegram/lib_ui/ui/widgets/input_fields.h
+++ b/Telegram/lib_ui/ui/widgets/input_fields.h
@@ -330,6 +330,9 @@ public:
 	auto documentContentsChanges() {
 		return _documentContentsChanges.events();
 	}
+	auto markdownTagApplies() {
+		return _markdownTagApplies.events();
+	}
 
 	~InputField();
 
@@ -535,6 +538,7 @@ private:
 	bool _instantReplacesEnabled = true;
 
 	rpl::event_stream<DocumentChangeInfo> _documentContentsChanges;
+	rpl::event_stream<MarkdownTag> _markdownTagApplies;
 
 };
 
diff --git a/Telegram/lib_ui/ui/widgets/popup_menu.cpp b/Telegram/lib_ui/ui/widgets/popup_menu.cpp
index 17ecfb4..64ef28b 100644
--- a/Telegram/lib_ui/ui/widgets/popup_menu.cpp
+++ b/Telegram/lib_ui/ui/widgets/popup_menu.cpp
@@ -519,7 +519,8 @@ PopupMenu::~PopupMenu() {
 		delete submenu;
 	}
 	if (const auto parent = parentWidget()) {
-		if (QApplication::focusWidget() != nullptr) {
+		if (QApplication::focusWidget() != nullptr
+			&& Ui::InFocusChain(parent->window())) {
 			ActivateWindowDelayed(parent);
 		}
 	}
diff --git a/Telegram/lib_ui/ui/widgets/widgets.style b/Telegram/lib_ui/ui/widgets/widgets.style
index a463c50..04eabf0 100644
--- a/Telegram/lib_ui/ui/widgets/widgets.style
+++ b/Telegram/lib_ui/ui/widgets/widgets.style
@@ -794,7 +794,7 @@ SettingsSlider {
 	barFg: color;
 	barFgActive: color;
 	labelTop: pixels;
-	labelFont: font;
+	labelStyle: TextStyle;
 	labelFg: color;
 	labelFgActive: color;
 	duration: int;
@@ -812,7 +812,7 @@ defaultSettingsSlider: SettingsSlider {
 	barFg: sliderBgInactive;
 	barFgActive: sliderBgActive;
 	labelTop: 17px;
-	labelFont: normalFont;
+	labelStyle: defaultTextStyle;
 	labelFg: windowActiveTextFg;
 	labelFgActive: windowActiveTextFg;
 	duration: 150;
@@ -824,7 +824,7 @@ defaultTabsSlider: SettingsSlider(defaultSettingsSlider) {
 	barSkip: 0px;
 	barFg: transparent;
 	labelTop: 19px;
-	labelFont: semiboldFont;
+	labelStyle: semiboldTextStyle;
 	labelFg: windowSubTextFg;
 	labelFgActive: lightButtonFg;
 	rippleBottomSkip: 1px;
diff --git a/changelog.txt b/changelog.txt
index 5241eca18..dbe1796b9 100644
--- a/changelog.txt
+++ b/changelog.txt
@@ -1,3 +1,17 @@
+1.9.3 (31.12.19)
+
+- Videos in chats start playing automatically.
+- Resume playback from where you left off when watching long videos and listening to long audio tracks.
+- Control automatic playback for videos, GIFs and round video messages in Settings > Advanced > Automatic media download.
+- Enjoy system spell checker support on all modern systems.
+
+1.9.2 beta (29.12.19)
+
+- Videos in chats start playing automatically.
+- Resume playback from where you left off when watching long videos.
+- Control videos, GIFs and round video messages automatic playback in Settings > Advanced > Automatic media download.
+- Spell checker on Linux using Enchant.
+
 1.9.1 beta (06.11.19)
 
 - Bug fixes and other minor improvements.
Submodule cmake 000000000...449066752 (new submodule)
diff --git a/cmake/CMakeLists.txt b/cmake/CMakeLists.txt
new file mode 100644
index 0000000..037b2eb
--- /dev/null
+++ b/cmake/CMakeLists.txt
@@ -0,0 +1,10 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+add_subdirectory(external)
+if (DESKTOP_APP_USE_GLIBC_WRAPS)
+    add_subdirectory(linux_glibc_wraps)
+endif()
diff --git a/cmake/external/CMakeLists.txt b/cmake/external/CMakeLists.txt
new file mode 100644
index 0000000..4187ad3
--- /dev/null
+++ b/cmake/external/CMakeLists.txt
@@ -0,0 +1,26 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+add_subdirectory(auto_updates)
+add_subdirectory(crash_reports)
+add_subdirectory(expected)
+add_subdirectory(ffmpeg)
+add_subdirectory(gsl)
+add_subdirectory(iconv)
+add_subdirectory(lz4)
+add_subdirectory(openal)
+add_subdirectory(openssl)
+add_subdirectory(opus)
+add_subdirectory(qt)
+add_subdirectory(qr_code_generator)
+add_subdirectory(ranges)
+add_subdirectory(rlottie)
+if (APPLE)
+    add_subdirectory(sp_media_key_tap)
+endif()
+add_subdirectory(variant)
+add_subdirectory(xxhash)
+add_subdirectory(zlib)
diff --git a/cmake/external/auto_updates/CMakeLists.txt b/cmake/external/auto_updates/CMakeLists.txt
new file mode 100644
index 0000000..15b5f8c
--- /dev/null
+++ b/cmake/external/auto_updates/CMakeLists.txt
@@ -0,0 +1,22 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+add_library(external_auto_updates INTERFACE IMPORTED GLOBAL)
+add_library(desktop-app::external_auto_updates ALIAS external_auto_updates)
+
+if (WIN32)
+    add_subdirectory(lzma)
+    target_link_libraries(external_auto_updates
+    INTERFACE
+        desktop-app::external_lzma
+    )
+else()
+    add_subdirectory(xz)
+    target_link_libraries(external_auto_updates
+    INTERFACE
+        desktop-app::external_xz
+    )
+endif()
diff --git a/cmake/external/auto_updates/lzma/CMakeLists.txt b/cmake/external/auto_updates/lzma/CMakeLists.txt
new file mode 100644
index 0000000..be81966
--- /dev/null
+++ b/cmake/external/auto_updates/lzma/CMakeLists.txt
@@ -0,0 +1,20 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+add_library(external_lzma INTERFACE IMPORTED GLOBAL)
+add_library(desktop-app::external_lzma ALIAS external_lzma)
+
+target_include_directories(external_lzma SYSTEM
+INTERFACE
+    ${libs_loc}/lzma/C
+)
+
+set(lzma_lib_loc ${libs_loc}/lzma/C/Util/LzmaLib/$<IF:$<CONFIG:Debug>,Debug,Release>)
+
+target_link_libraries(external_lzma
+INTERFACE
+    ${lzma_lib_loc}/LzmaLib.lib
+)
diff --git a/cmake/external/auto_updates/xz/CMakeLists.txt b/cmake/external/auto_updates/xz/CMakeLists.txt
new file mode 100644
index 0000000..604ca7d
--- /dev/null
+++ b/cmake/external/auto_updates/xz/CMakeLists.txt
@@ -0,0 +1,36 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+add_library(external_xz INTERFACE IMPORTED GLOBAL)
+add_library(desktop-app::external_xz ALIAS external_xz)
+
+if (DESKTOP_APP_USE_PACKAGED)
+    find_package(LibLZMA REQUIRED)
+    target_link_libraries(external_xz INTERFACE LibLZMA::LibLZMA)
+elseif (APPLE AND NOT build_osx)
+    target_include_directories(external_xz
+    INTERFACE
+        /usr/local/macos/include
+    )
+    target_link_libraries(external_xz
+    INTERFACE
+        /usr/local/macos/lib/liblzma.a
+    )
+elseif (APPLE)
+    target_include_directories(external_xz
+    INTERFACE
+        /usr/local/include
+    )
+    target_link_libraries(external_xz
+    INTERFACE
+        /usr/local/lib/liblzma.a
+    )
+else()
+    target_link_static_libraries(external_xz
+    INTERFACE
+        lzma
+    )
+endif()
diff --git a/cmake/external/crash_reports/CMakeLists.txt b/cmake/external/crash_reports/CMakeLists.txt
new file mode 100644
index 0000000..a741bcb
--- /dev/null
+++ b/cmake/external/crash_reports/CMakeLists.txt
@@ -0,0 +1,22 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+add_library(external_crash_reports INTERFACE IMPORTED GLOBAL)
+add_library(desktop-app::external_crash_reports ALIAS external_crash_reports)
+
+if (WIN32 OR LINUX OR build_macstore)
+    add_subdirectory(breakpad)
+    target_link_libraries(external_crash_reports
+    INTERFACE
+        desktop-app::external_breakpad
+    )
+else()
+    add_subdirectory(crashpad)
+    target_link_libraries(external_crash_reports
+    INTERFACE
+        desktop-app::external_crashpad
+    )
+endif()
diff --git a/cmake/external/crash_reports/breakpad/CMakeLists.txt b/cmake/external/crash_reports/breakpad/CMakeLists.txt
new file mode 100644
index 0000000..c09243d
--- /dev/null
+++ b/cmake/external/crash_reports/breakpad/CMakeLists.txt
@@ -0,0 +1,29 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+add_library(external_breakpad INTERFACE IMPORTED GLOBAL)
+add_library(desktop-app::external_breakpad ALIAS external_breakpad)
+
+target_include_directories(external_breakpad SYSTEM
+INTERFACE
+    ${libs_loc}/breakpad/src
+)
+
+set(breakpad_lib_loc ${libs_loc}/breakpad/src/out/$<IF:$<CONFIG:Debug>,Debug,Release>/obj/client)
+
+if (WIN32)
+    target_link_libraries(external_breakpad
+    INTERFACE
+        ${breakpad_lib_loc}/windows/common.lib
+        ${breakpad_lib_loc}/windows/handler/exception_handler.lib
+        ${breakpad_lib_loc}/windows/crash_generation/crash_generation_client.lib
+    )
+elseif (LINUX)
+    target_link_static_libraries(external_breakpad
+    INTERFACE
+        breakpad_client
+    )
+endif()
diff --git a/cmake/external/crash_reports/crashpad/CMakeLists.txt b/cmake/external/crash_reports/crashpad/CMakeLists.txt
new file mode 100644
index 0000000..93aecba
--- /dev/null
+++ b/cmake/external/crash_reports/crashpad/CMakeLists.txt
@@ -0,0 +1,24 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+add_library(external_crashpad INTERFACE IMPORTED GLOBAL)
+add_library(desktop-app::external_crashpad ALIAS external_crashpad)
+
+target_include_directories(external_crashpad SYSTEM
+INTERFACE
+    ${libs_loc}/crashpad
+    ${libs_loc}/crashpad/third_party/mini_chromium/mini_chromium
+)
+
+set(crashpad_lib_loc ${libs_loc}/crashpad/out/$<IF:$<CONFIG:Debug>,Debug,Release>)
+
+target_link_libraries(external_crashpad
+INTERFACE
+    ${crashpad_lib_loc}/libbase.a
+    ${crashpad_lib_loc}/libcrashpad_client.a
+    ${crashpad_lib_loc}/libcrashpad_util.a
+    bsm
+)
diff --git a/cmake/external/expected/CMakeLists.txt b/cmake/external/expected/CMakeLists.txt
new file mode 100644
index 0000000..53ec233
--- /dev/null
+++ b/cmake/external/expected/CMakeLists.txt
@@ -0,0 +1,13 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+add_library(external_expected INTERFACE IMPORTED GLOBAL)
+add_library(desktop-app::external_expected ALIAS external_expected)
+
+target_include_directories(external_expected SYSTEM
+INTERFACE
+    ${third_party_loc}/expected/include
+)
diff --git a/cmake/external/ffmpeg/CMakeLists.txt b/cmake/external/ffmpeg/CMakeLists.txt
new file mode 100644
index 0000000..014fb06
--- /dev/null
+++ b/cmake/external/ffmpeg/CMakeLists.txt
@@ -0,0 +1,38 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+add_library(external_ffmpeg INTERFACE IMPORTED GLOBAL)
+add_library(desktop-app::external_ffmpeg ALIAS external_ffmpeg)
+
+target_include_directories(external_ffmpeg SYSTEM
+INTERFACE
+    ${libs_loc}/ffmpeg
+)
+
+set(ffmpeg_lib_loc ${libs_loc}/ffmpeg)
+
+target_link_libraries(external_ffmpeg
+INTERFACE
+    ${ffmpeg_lib_loc}/libavformat/libavformat.a
+    ${ffmpeg_lib_loc}/libavcodec/libavcodec.a
+    ${ffmpeg_lib_loc}/libswresample/libswresample.a
+    ${ffmpeg_lib_loc}/libswscale/libswscale.a
+    ${ffmpeg_lib_loc}/libavutil/libavutil.a
+)
+if (LINUX)
+    target_link_static_libraries(external_ffmpeg
+    INTERFACE
+        va-x11
+        va-drm
+        va
+        vdpau
+        drm
+        Xi
+        Xext
+        Xfixes
+        Xrender
+    )
+endif()
diff --git a/cmake/external/gsl/CMakeLists.txt b/cmake/external/gsl/CMakeLists.txt
new file mode 100644
index 0000000..c7a0883
--- /dev/null
+++ b/cmake/external/gsl/CMakeLists.txt
@@ -0,0 +1,13 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+add_library(external_gsl INTERFACE IMPORTED GLOBAL)
+add_library(desktop-app::external_gsl ALIAS external_gsl)
+
+target_include_directories(external_gsl SYSTEM
+INTERFACE
+    ${third_party_loc}/GSL/include
+)
diff --git a/cmake/external/iconv/CMakeLists.txt b/cmake/external/iconv/CMakeLists.txt
new file mode 100644
index 0000000..5db2c1f
--- /dev/null
+++ b/cmake/external/iconv/CMakeLists.txt
@@ -0,0 +1,20 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+add_library(external_iconv INTERFACE IMPORTED GLOBAL)
+add_library(desktop-app::external_iconv ALIAS external_iconv)
+
+if (APPLE AND NOT build_osx)
+    target_link_libraries(external_iconv
+    INTERFACE
+        /usr/local/macos/lib/libiconv.a
+    )
+elseif (APPLE)
+    target_link_libraries(external_iconv
+    INTERFACE
+        /usr/local/lib/libiconv.a
+    )
+endif()
diff --git a/cmake/external/lz4/CMakeLists.txt b/cmake/external/lz4/CMakeLists.txt
new file mode 100644
index 0000000..49821af
--- /dev/null
+++ b/cmake/external/lz4/CMakeLists.txt
@@ -0,0 +1,29 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+add_library(external_lz4 OBJECT)
+add_library(desktop-app::external_lz4 ALIAS external_lz4)
+init_target(external_lz4 "(external)")
+
+set(lz4_loc ${third_party_loc}/lz4/lib)
+
+target_sources(external_lz4
+PRIVATE
+    ${lz4_loc}/lz4.c
+    ${lz4_loc}/lz4.h
+    ${lz4_loc}/lz4frame.c
+    ${lz4_loc}/lz4frame.h
+    ${lz4_loc}/lz4frame_static.h
+    ${lz4_loc}/lz4hc.c
+    ${lz4_loc}/lz4hc.h
+    ${lz4_loc}/xxhash.c
+    ${lz4_loc}/xxhash.h
+)
+
+target_include_directories(external_lz4
+PUBLIC
+    ${lz4_loc}
+)
diff --git a/cmake/external/openal/CMakeLists.txt b/cmake/external/openal/CMakeLists.txt
new file mode 100644
index 0000000..e2e4992
--- /dev/null
+++ b/cmake/external/openal/CMakeLists.txt
@@ -0,0 +1,43 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+add_library(external_openal INTERFACE IMPORTED GLOBAL)
+add_library(desktop-app::external_openal ALIAS external_openal)
+
+if (WIN32)
+    target_include_directories(external_openal SYSTEM
+    INTERFACE
+        ${libs_loc}/openal-soft/include
+    )
+    target_link_libraries(external_openal
+    INTERFACE
+        ${libs_loc}/openal-soft/build/$<IF:$<CONFIG:Debug>,Debug,Release>/OpenAL32.lib
+    )
+elseif(APPLE AND NOT build_osx)
+    target_include_directories(external_openal SYSTEM
+    INTERFACE
+        /usr/local/macos/include
+    )
+    target_link_libraries(external_openal
+    INTERFACE
+        /usr/local/macos/lib/libopenal.a
+    )
+else()
+    target_include_directories(external_openal SYSTEM
+    INTERFACE
+        /usr/local/include
+    )
+    target_link_static_libraries(external_openal
+    INTERFACE
+        openal
+    )
+endif()
+
+target_compile_definitions(external_openal
+INTERFACE
+    AL_LIBTYPE_STATIC
+    AL_ALEXT_PROTOTYPES
+)
diff --git a/cmake/external/openssl/CMakeLists.txt b/cmake/external/openssl/CMakeLists.txt
new file mode 100644
index 0000000..bcbcbfa
--- /dev/null
+++ b/cmake/external/openssl/CMakeLists.txt
@@ -0,0 +1,58 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+add_library(external_openssl INTERFACE IMPORTED GLOBAL)
+add_library(desktop-app::external_openssl ALIAS external_openssl)
+
+if (LINUX)
+    target_include_directories(external_openssl SYSTEM
+    INTERFACE
+        /usr/local/desktop-app/openssl-1.1.1/include
+    )
+elseif (NOT APPLE OR NOT build_osx)
+    target_include_directories(external_openssl SYSTEM
+    INTERFACE
+        ${libs_loc}/openssl_1_1_1/include
+    )
+else()
+    target_include_directories(external_openssl SYSTEM
+    INTERFACE
+        ${libs_loc}/openssl/include
+    )
+endif()
+
+if (WIN32)
+    set(openssl_lib_ext lib)
+    set(openssl_lib_loc ${libs_loc}/openssl_1_1_1/out32$<$<CONFIG:Debug>:.dbg>)
+else()
+    set(openssl_lib_ext a)
+    if (APPLE)
+        if (NOT build_osx)
+            set(openssl_lib_loc ${libs_loc}/openssl_1_1_1)
+        else()
+            set(openssl_lib_loc ${libs_loc}/openssl)
+        endif()
+    else()
+        set(openssl_lib_loc /usr/local/desktop-app/openssl-1.1.1/lib)
+    endif()
+endif()
+
+target_link_libraries(external_openssl
+INTERFACE
+    ${openssl_lib_loc}/libssl.${openssl_lib_ext}
+    ${openssl_lib_loc}/libcrypto.${openssl_lib_ext}
+)
+
+if (LINUX)
+    if (DESKTOP_APP_USE_GLIBC_WRAPS)
+        target_link_libraries(external_openssl
+        INTERFACE
+            desktop-app::linux_glibc_wraps
+            $<TARGET_FILE:desktop-app::linux_glibc_wraps>
+        )
+    endif()
+    target_link_libraries(external_openssl INTERFACE pthread)
+endif()
diff --git a/cmake/external/opus/CMakeLists.txt b/cmake/external/opus/CMakeLists.txt
new file mode 100644
index 0000000..00c2508
--- /dev/null
+++ b/cmake/external/opus/CMakeLists.txt
@@ -0,0 +1,45 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+add_library(external_opus INTERFACE IMPORTED GLOBAL)
+add_library(desktop-app::external_opus ALIAS external_opus)
+
+target_include_directories(external_opus SYSTEM
+INTERFACE
+    ${libs_loc}/opus/include
+)
+
+if (WIN32)
+    set(opus_lib_loc ${libs_loc}/opus/win32/VS2015/Win32/$<IF:$<CONFIG:Debug>,Debug,Release>)
+
+    target_link_libraries(external_opus
+    INTERFACE
+        ${opus_lib_loc}/opus.lib
+    )
+elseif (APPLE AND NOT build_osx)
+    target_include_directories(external_opus
+    INTERFACE
+        /usr/local/macos/include
+    )
+    target_link_libraries(external_opus
+    INTERFACE
+        /usr/local/macos/lib/libopus.a
+    )
+elseif (APPLE)
+    target_include_directories(external_opus
+    INTERFACE
+        /usr/local/include
+    )
+    target_link_libraries(external_opus
+    INTERFACE
+        /usr/local/lib/libopus.a
+    )
+else()
+    target_link_static_libraries(external_opus
+    INTERFACE
+        opus
+    )
+endif()
diff --git a/cmake/external/qr_code_generator/CMakeLists.txt b/cmake/external/qr_code_generator/CMakeLists.txt
new file mode 100644
index 0000000..0f81125
--- /dev/null
+++ b/cmake/external/qr_code_generator/CMakeLists.txt
@@ -0,0 +1,27 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+add_library(external_qr_code_generator OBJECT)
+add_library(desktop-app::external_qr_code_generator ALIAS external_qr_code_generator)
+init_target(external_qr_code_generator "(external)")
+
+set(qr_loc ${third_party_loc}/QR)
+set(qr_src ${qr_loc}/cpp)
+
+nice_target_sources(external_qr_code_generator ${qr_src}
+PRIVATE
+    BitBuffer.cpp
+    BitBuffer.hpp
+    QrCode.cpp
+    QrCode.hpp
+    QrSegment.cpp
+    QrSegment.hpp
+)
+
+target_include_directories(external_qr_code_generator
+PUBLIC
+    ${qr_src}
+)
diff --git a/cmake/external/qt/CMakeLists.txt b/cmake/external/qt/CMakeLists.txt
new file mode 100644
index 0000000..1a56319
--- /dev/null
+++ b/cmake/external/qt/CMakeLists.txt
@@ -0,0 +1,217 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+add_library(external_qt INTERFACE IMPORTED GLOBAL)
+add_library(desktop-app::external_qt ALIAS external_qt)
+
+if (LINUX)
+    if (NOT build_linux32)
+        target_compile_definitions(external_qt INTERFACE Q_OS_LINUX64)
+    else()
+        target_compile_definitions(external_qt INTERFACE Q_OS_LINUX32)
+    endif()
+endif()
+
+target_include_directories(external_qt SYSTEM
+INTERFACE
+    ${qt_loc}/include
+    ${qt_loc}/include/QtCore
+    ${qt_loc}/include/QtGui
+    ${qt_loc}/include/QtDBus
+    ${qt_loc}/include/QtCore/${qt_version}
+    ${qt_loc}/include/QtGui/${qt_version}
+    ${qt_loc}/include/QtCore/${qt_version}/QtCore
+    ${qt_loc}/include/QtGui/${qt_version}/QtGui
+)
+
+target_compile_definitions(external_qt
+INTERFACE
+    _REENTRANT
+    QT_STATICPLUGIN
+    QT_PLUGIN
+    QT_WIDGETS_LIB
+    QT_NETWORK_LIB
+    QT_GUI_LIB
+    QT_CORE_LIB
+)
+
+if (WIN32)
+    set(qt_lib_prefix "")
+    set(qt_lib_suffix $<$<CONFIG:Debug>:d>.lib)
+else()
+    set(qt_lib_prefix lib)
+    if (APPLE)
+        set(qt_lib_suffix $<$<CONFIG:Debug>:_debug>.a)
+    else()
+        set(qt_lib_suffix .a)
+    endif()
+endif()
+
+set(common_qt_libs
+    plugins/imageformats/${qt_lib_prefix}qwebp
+    plugins/imageformats/${qt_lib_prefix}qgif
+    plugins/imageformats/${qt_lib_prefix}qjpeg
+    lib/${qt_lib_prefix}Qt5PrintSupport
+    lib/${qt_lib_prefix}Qt5AccessibilitySupport
+    lib/${qt_lib_prefix}Qt5FontDatabaseSupport
+    lib/${qt_lib_prefix}Qt5EventDispatcherSupport
+    lib/${qt_lib_prefix}Qt5ThemeSupport
+    lib/${qt_lib_prefix}Qt5Network
+    lib/${qt_lib_prefix}Qt5Widgets
+    lib/${qt_lib_prefix}Qt5Gui
+    lib/${qt_lib_prefix}qtharfbuzz
+    lib/${qt_lib_prefix}qtlibpng
+)
+
+set(qt_libs_list "")
+if (WIN32)
+    set(qt_libs
+        ${common_qt_libs}
+        lib/${qt_lib_prefix}Qt5Core
+        lib/${qt_lib_prefix}Qt5WindowsUIAutomationSupport
+        lib/${qt_lib_prefix}qtmain
+        lib/${qt_lib_prefix}qtfreetype
+        lib/${qt_lib_prefix}qtpcre2
+        plugins/platforms/${qt_lib_prefix}qwindows
+    )
+    foreach (lib ${qt_libs})
+        list(APPEND qt_libs_list "${qt_loc}/${lib}${qt_lib_suffix}")
+    endforeach()
+elseif (APPLE)
+    if (NOT build_osx)
+        set(qt_libs
+            ${common_qt_libs}
+            lib/${qt_lib_prefix}Qt5Core
+            lib/${qt_lib_prefix}Qt5GraphicsSupport
+            lib/${qt_lib_prefix}Qt5ClipboardSupport
+            lib/${qt_lib_prefix}qtfreetype
+            lib/${qt_lib_prefix}qtpcre2
+            plugins/platforms/${qt_lib_prefix}qcocoa
+            plugins/bearer/${qt_lib_prefix}qgenericbearer
+        )
+    else()
+        set(qt_libs
+            lib/${qt_lib_prefix}Qt5PrintSupport
+            lib/${qt_lib_prefix}Qt5PlatformSupport
+            lib/${qt_lib_prefix}Qt5Network
+            lib/${qt_lib_prefix}Qt5Widgets
+            lib/${qt_lib_prefix}Qt5Gui
+            lib/${qt_lib_prefix}Qt5Core
+            lib/${qt_lib_prefix}qtharfbuzzng
+            lib/${qt_lib_prefix}qtfreetype
+            lib/${qt_lib_prefix}qtpcre
+            plugins/platforms/${qt_lib_prefix}qcocoa
+            plugins/imageformats/${qt_lib_prefix}qwebp
+            plugins/bearer/${qt_lib_prefix}qgenericbearer
+        )
+    endif()
+    foreach (lib ${qt_libs})
+        list(APPEND qt_libs_list "${qt_loc}/${lib}${qt_lib_suffix}")
+    endforeach()
+    target_link_libraries(external_qt
+    INTERFACE
+        desktop-app::external_zlib
+        cups
+    )
+else()
+    set(qt_libs
+        plugins/platforminputcontexts/${qt_lib_prefix}composeplatforminputcontextplugin
+        plugins/platforminputcontexts/${qt_lib_prefix}ibusplatforminputcontextplugin
+        plugins/platforminputcontexts/${qt_lib_prefix}fcitxplatforminputcontextplugin
+        plugins/platforminputcontexts/${qt_lib_prefix}himeplatforminputcontextplugin
+        plugins/platforminputcontexts/${qt_lib_prefix}nimfplatforminputcontextplugin
+        plugins/platforms/${qt_lib_prefix}qxcb
+        lib/${qt_lib_prefix}Qt5XcbQpa
+        lib/${qt_lib_prefix}Qt5LinuxAccessibilitySupport
+        lib/${qt_lib_prefix}Qt5ServiceSupport
+        lib/${qt_lib_prefix}Qt5EdidSupport
+        plugins/bearer/${qt_lib_prefix}qconnmanbearer
+        plugins/bearer/${qt_lib_prefix}qgenericbearer
+        plugins/bearer/${qt_lib_prefix}qnmbearer
+        ${common_qt_libs}
+        lib/${qt_lib_prefix}Qt5DBus
+        lib/${qt_lib_prefix}Qt5Core
+        lib/${qt_lib_prefix}qtpcre2
+        lib/${qt_lib_prefix}xcb-static
+    )
+    foreach (lib ${qt_libs})
+        list(APPEND qt_libs_list "${qt_loc}/${lib}${qt_lib_suffix}")
+    endforeach()
+endif()
+
+target_link_libraries(external_qt
+INTERFACE
+    ${qt_libs_list}
+)
+
+if (LINUX)
+    target_include_directories(external_qt SYSTEM
+    INTERFACE
+        ${qt_loc}/mkspecs/linux-g++
+    )
+    target_link_options(external_qt
+    INTERFACE
+        -static-libstdc++
+        -pthread
+        -rdynamic
+    )
+    if (DESKTOP_APP_USE_GLIBC_WRAPS)
+        target_link_options(external_qt
+        INTERFACE
+            -Wl,-wrap,aligned_alloc
+            -Wl,-wrap,secure_getenv
+            -Wl,-wrap,clock_gettime
+            -Wl,--no-as-needed,-lrt
+        )
+        if (NOT build_linux32)
+            target_link_options(external_qt
+            INTERFACE
+                -Wl,-wrap,__divmodti4
+            )
+        else()
+            target_link_options(external_qt
+            INTERFACE
+                -Wl,-wrap,__divmoddi4
+            )
+        endif()
+    endif()
+    target_link_static_libraries(external_qt
+    INTERFACE
+        SM
+        ICE
+        fontconfig
+        freetype
+        expat
+        z
+        xcb-shm
+        xcb-xfixes
+        xcb-render
+        xkbcommon
+        xkbcommon-x11
+        Xrender
+        icutu
+        icui18n
+        icuuc
+        icudata
+    )
+    if (DESKTOP_APP_USE_GLIBC_WRAPS)
+        target_link_libraries(external_qt
+        INTERFACE
+            desktop-app::linux_glibc_wraps
+            $<TARGET_FILE:desktop-app::linux_glibc_wraps>
+        )
+    endif()
+    target_link_libraries(external_qt
+    INTERFACE
+        xcb
+        X11
+        X11-xcb
+        dbus-1
+        dl
+        glib-2.0
+        pthread
+    )
+endif()
diff --git a/cmake/external/qt/package.cmake b/cmake/external/qt/package.cmake
new file mode 100644
index 0000000..36a1dfd
--- /dev/null
+++ b/cmake/external/qt/package.cmake
@@ -0,0 +1,28 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+if (NOT APPLE OR NOT build_osx)
+    set(qt_version 5.12.5)
+else()
+    set(qt_version 5.6.2)
+endif()
+
+if (WIN32)
+    set(qt_loc ${libs_loc}/Qt-${qt_version})
+else()
+    set(qt_loc /usr/local/desktop-app/Qt-${qt_version})
+endif()
+
+set(Qt5_DIR ${qt_loc}/lib/cmake/Qt5)
+
+find_package(Qt5 COMPONENTS Core Gui Widgets Network REQUIRED)
+
+if (LINUX)
+    find_package(Qt5 COMPONENTS DBus)
+endif()
+
+set_property(GLOBAL PROPERTY AUTOGEN_SOURCE_GROUP "(gen)")
+set_property(GLOBAL PROPERTY AUTOGEN_TARGETS_FOLDER "(gen)")
diff --git a/cmake/external/ranges/CMakeLists.txt b/cmake/external/ranges/CMakeLists.txt
new file mode 100644
index 0000000..4c75ecb
--- /dev/null
+++ b/cmake/external/ranges/CMakeLists.txt
@@ -0,0 +1,21 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+add_library(external_ranges INTERFACE IMPORTED GLOBAL)
+add_library(desktop-app::external_ranges ALIAS external_ranges)
+
+target_include_directories(external_ranges SYSTEM
+INTERFACE
+    ${libs_loc}/range-v3/include
+)
+
+if (WIN32)
+    target_compile_options(external_ranges
+    INTERFACE
+        /experimental:preprocessor # need for range-v3 see https://github.com/ericniebler/range-v3#supported-compilers
+        /wd5105 # needed for `/experimental:preprocessor`, suppressing C5105 "macro expansion producing 'defined' has undefined behavior"
+    )
+endif()
\ No newline at end of file
diff --git a/cmake/external/rlottie/CMakeLists.txt b/cmake/external/rlottie/CMakeLists.txt
new file mode 100644
index 0000000..4fc3a54
--- /dev/null
+++ b/cmake/external/rlottie/CMakeLists.txt
@@ -0,0 +1,118 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+add_library(external_rlottie OBJECT)
+add_library(desktop-app::external_rlottie ALIAS external_rlottie)
+init_target(external_rlottie "(external)")
+
+get_filename_component(src_loc . REALPATH)
+set(rlottie_loc ${third_party_loc}/rlottie)
+
+target_sources(external_rlottie PRIVATE ${src_loc}/config/config.h)
+nice_target_sources(external_rlottie ${rlottie_loc}
+PRIVATE
+    inc/rlottie.h
+    inc/rlottie_capi.h
+    inc/rlottiecommon.h
+
+    src/lottie/lottieanimation.cpp
+    src/lottie/lottieitem.cpp
+    src/lottie/lottieitem.h
+    src/lottie/lottiekeypath.cpp
+    src/lottie/lottiekeypath.h
+    src/lottie/lottieloader.cpp
+    src/lottie/lottieloader.h
+    src/lottie/lottiemodel.cpp
+    src/lottie/lottiemodel.h
+    src/lottie/lottieparser.cpp
+    src/lottie/lottieparser.h
+    src/lottie/lottieproxymodel.cpp
+    src/lottie/lottieproxymodel.h
+
+    src/vector/freetype/v_ft_math.cpp
+    src/vector/freetype/v_ft_math.h
+    src/vector/freetype/v_ft_raster.cpp
+    src/vector/freetype/v_ft_raster.h
+    src/vector/freetype/v_ft_stroker.cpp
+    src/vector/freetype/v_ft_stroker.h
+    src/vector/freetype/v_ft_types.h
+
+    # src/vector/pixman/pixman-arm-neon-asm.h
+    # src/vector/pixman/pixman-arm-neon-asm.S
+    src/vector/pixman/vregion.cpp
+    src/vector/pixman/vregion.h
+
+    src/vector/vbezier.cpp
+    src/vector/vbezier.h
+    src/vector/vbitmap.cpp
+    src/vector/vbitmap.h
+    src/vector/vbrush.cpp
+    src/vector/vbrush.h
+    src/vector/vcompositionfunctions.cpp
+    src/vector/vcowptr.h
+    src/vector/vdasher.cpp
+    src/vector/vdasher.h
+    src/vector/vdebug.cpp
+    src/vector/vdebug.h
+    src/vector/vdrawable.cpp
+    src/vector/vdrawable.h
+    src/vector/vdrawhelper.cpp
+    src/vector/vdrawhelper.h
+    src/vector/vdrawhelper_neon.cpp
+    src/vector/vdrawhelper_sse2.cpp
+    src/vector/velapsedtimer.cpp
+    src/vector/velapsedtimer.h
+    src/vector/vglobal.h
+    src/vector/vimageloader.cpp
+    src/vector/vimageloader.h
+    src/vector/vinterpolator.cpp
+    src/vector/vinterpolator.h
+    src/vector/vline.h
+    src/vector/vmatrix.cpp
+    src/vector/vmatrix.h
+    src/vector/vpainter.cpp
+    src/vector/vpainter.h
+    src/vector/vpath.cpp
+    src/vector/vpath.h
+    src/vector/vpathmesure.cpp
+    src/vector/vpathmesure.h
+    src/vector/vpoint.h
+    src/vector/vraster.cpp
+    src/vector/vraster.h
+    src/vector/vrect.cpp
+    src/vector/vrect.h
+    src/vector/vrle.cpp
+    src/vector/vrle.h
+    src/vector/vstackallocator.h
+    src/vector/vtaskqueue.h
+)
+
+target_compile_definitions(external_rlottie
+PUBLIC
+    LOT_BUILD
+PRIVATE
+    _USE_MATH_DEFINES
+    "RAPIDJSON_ASSERT=(void)"
+)
+
+target_include_directories(external_rlottie
+PUBLIC
+    ${rlottie_loc}/inc
+PRIVATE
+    ${src_loc}/config
+    ${rlottie_loc}/src/lottie
+    ${rlottie_loc}/src/vector
+    ${rlottie_loc}/src/vector/pixman
+    ${rlottie_loc}/src/vector/freetype
+)
+
+if (WIN32)
+    target_compile_options(external_rlottie
+    PRIVATE
+        /w44244 # 'initializing': conversion from 'double' to 'float'
+        /w44251 # needs to have dll-interface to be used by clients of class
+    )
+endif()
diff --git a/cmake/external/rlottie/config/config.h b/cmake/external/rlottie/config/config.h
new file mode 100644
index 0000000..ea8e097
--- /dev/null
+++ b/cmake/external/rlottie/config/config.h
@@ -0,0 +1,25 @@
+// This file is part of Desktop App Toolkit,
+// a set of libraries for developing nice desktop applications.
+//
+// For license and copyright information please follow this link:
+// https://github.com/desktop-app/legal/blob/master/LEGAL
+//
+#ifndef CONFIG_H
+#define CONFIG_H
+
+// enable threading
+#define LOTTIE_THREAD_SUPPORT
+
+//enable logging
+//#define LOTTIE_LOGGING_SUPPORT
+
+//enable module building of image loader
+//#define LOTTIE_IMAGE_MODULE_SUPPORT
+
+//enable lottie model caching
+//#define LOTTIE_CACHE_SUPPORT
+
+// disable image loader
+#define LOTTIE_IMAGE_MODULE_DISABLED
+
+#endif  // CONFIG_H
diff --git a/cmake/external/sp_media_key_tap/CMakeLists.txt b/cmake/external/sp_media_key_tap/CMakeLists.txt
new file mode 100644
index 0000000..dff4e2a
--- /dev/null
+++ b/cmake/external/sp_media_key_tap/CMakeLists.txt
@@ -0,0 +1,26 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+if (EXISTS ${third_party_loc}/SPMediaKeyTap)
+    add_library(external_sp_media_key_tap OBJECT)
+    add_library(desktop-app::external_sp_media_key_tap ALIAS external_sp_media_key_tap)
+    init_target(external_sp_media_key_tap "(external)")
+
+    set(sp_media_key_tap_loc ${third_party_loc}/SPMediaKeyTap)
+
+    target_sources(external_sp_media_key_tap
+    PRIVATE
+        ${sp_media_key_tap_loc}/SPMediaKeyTap.m
+        ${sp_media_key_tap_loc}/SPMediaKeyTap.h
+        ${sp_media_key_tap_loc}/SPInvocationGrabbing/NSObject+SPInvocationGrabbing.m
+        ${sp_media_key_tap_loc}/SPInvocationGrabbing/NSObject+SPInvocationGrabbing.h
+    )
+    
+    target_include_directories(external_sp_media_key_tap SYSTEM
+    INTERFACE
+        ${sp_media_key_tap_loc}
+    )
+endif()
diff --git a/cmake/external/variant/CMakeLists.txt b/cmake/external/variant/CMakeLists.txt
new file mode 100644
index 0000000..5b5beef
--- /dev/null
+++ b/cmake/external/variant/CMakeLists.txt
@@ -0,0 +1,13 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+add_library(external_variant INTERFACE IMPORTED GLOBAL)
+add_library(desktop-app::external_variant ALIAS external_variant)
+
+target_include_directories(external_variant SYSTEM
+INTERFACE
+    ${third_party_loc}/variant/include
+)
diff --git a/cmake/external/xxhash/CMakeLists.txt b/cmake/external/xxhash/CMakeLists.txt
new file mode 100644
index 0000000..ba98eda
--- /dev/null
+++ b/cmake/external/xxhash/CMakeLists.txt
@@ -0,0 +1,18 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+add_library(external_xxhash INTERFACE IMPORTED GLOBAL)
+add_library(desktop-app::external_xxhash ALIAS external_xxhash)
+
+target_include_directories(external_xxhash SYSTEM
+INTERFACE
+    ${third_party_loc}/xxHash
+)
+
+target_compile_definitions(external_xxhash
+INTERFACE
+    XXH_INLINE_ALL
+)
diff --git a/cmake/external/zlib/CMakeLists.txt b/cmake/external/zlib/CMakeLists.txt
new file mode 100644
index 0000000..d2bc1fc
--- /dev/null
+++ b/cmake/external/zlib/CMakeLists.txt
@@ -0,0 +1,51 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+add_library(external_zlib INTERFACE IMPORTED GLOBAL)
+add_library(desktop-app::external_zlib ALIAS external_zlib)
+
+if (NOT WIN32)
+    add_library(external_minizip STATIC)
+    init_target(external_minizip "(external)")
+
+    set(minizip_loc ${third_party_loc}/minizip)
+
+    target_sources(external_minizip
+    PRIVATE
+        ${minizip_loc}/crypt.h
+        ${minizip_loc}/ioapi.c
+        ${minizip_loc}/ioapi.h
+        ${minizip_loc}/zip.c
+        ${minizip_loc}/zip.h
+        ${minizip_loc}/unzip.c
+        ${minizip_loc}/unzip.h
+    )
+
+    target_include_directories(external_minizip SYSTEM
+    INTERFACE
+        ${minizip_loc}
+    )
+
+    target_link_libraries(external_zlib INTERFACE external_minizip)
+endif()
+
+target_include_directories(external_zlib SYSTEM
+INTERFACE
+    ${libs_loc}/zlib
+    ${libs_loc}/zlib/contrib/minizip
+)
+
+if (WIN32)
+    target_compile_definitions(external_zlib INTERFACE ZLIB_WINAPI)
+
+    set(zlib_lib_loc ${libs_loc}/zlib/contrib/vstudio/vc14/x86/ZlibStat$<IF:$<CONFIG:Debug>,Debug,ReleaseWithoutAsm>)
+
+    target_link_libraries(external_zlib INTERFACE ${zlib_lib_loc}/zlibstat.lib)
+elseif (APPLE)
+    target_link_libraries(external_zlib INTERFACE /usr/local/lib/libz.a)
+else()
+    target_link_static_libraries(external_zlib INTERFACE z)
+endif()
diff --git a/cmake/generate_target.cmake b/cmake/generate_target.cmake
new file mode 100644
index 0000000..611067f
--- /dev/null
+++ b/cmake/generate_target.cmake
@@ -0,0 +1,14 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+function(generate_target parent_name postfix generated_timestamp generated_files gen_dst)
+    add_custom_target(${parent_name}_${postfix} DEPENDS ${generated_timestamp})
+    init_target_folder(${parent_name}_${postfix} "(gen)")
+    add_dependencies(${parent_name} ${parent_name}_${postfix})
+    target_sources(${parent_name} PRIVATE ${generated_files})
+    target_include_directories(${parent_name} PUBLIC ${gen_dst})
+    source_group("(gen)" FILES ${generated_files})
+endfunction()
diff --git a/cmake/init_target.cmake b/cmake/init_target.cmake
new file mode 100644
index 0000000..c7a1244
--- /dev/null
+++ b/cmake/init_target.cmake
@@ -0,0 +1,44 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+function(init_target_folder target_name folder_name)
+    if (NOT "${folder_name}" STREQUAL "")
+        set_target_properties(${target_name} PROPERTIES FOLDER ${folder_name})
+    endif()
+endfunction()
+
+function(init_target target_name) # init_target(my_target folder_name)
+    if (ARGC GREATER 1)
+        if (${ARGV1} STREQUAL cxx_std_14 OR ${ARGV1} STREQUAL cxx_std_11)
+            target_compile_features(${target_name} PUBLIC ${ARGV1})
+        else()
+            target_compile_features(${target_name} PUBLIC cxx_std_17)
+            init_target_folder(${target_name} ${ARGV1})
+        endif()
+    else()
+        target_compile_features(${target_name} PUBLIC cxx_std_17)
+    endif()
+    if (WIN32)
+        set_target_properties(${target_name} PROPERTIES
+            MSVC_RUNTIME_LIBRARY "MultiThreaded$<$<CONFIG:Debug>:Debug>")
+    endif()
+    target_link_libraries(${target_name} PUBLIC desktop-app::common_options)
+    set_target_properties(${target_name} PROPERTIES
+        LINK_SEARCH_START_STATIC 1
+        XCODE_ATTRIBUTE_CLANG_ENABLE_OBJC_WEAK YES
+        XCODE_ATTRIBUTE_GCC_INLINES_ARE_PRIVATE_EXTERN YES
+        XCODE_ATTRIBUTE_GCC_SYMBOLS_PRIVATE_EXTERN YES
+        XCODE_ATTRIBUTE_GCC_OPTIMIZATION_LEVEL $<IF:$<CONFIG:Debug>,0,fast>
+        XCODE_ATTRIBUTE_LLVM_LTO $<IF:$<CONFIG:Debug>,NO,YES>
+    )
+    if (WIN32)
+        set_target_properties(${target_name} PROPERTIES
+            INTERPROCEDURAL_OPTIMIZATION_RELEASE True
+            INTERPROCEDURAL_OPTIMIZATION_RELWITHDEBINFO True
+            INTERPROCEDURAL_OPTIMIZATION_MINSIZEREL True
+        )
+    endif()
+endfunction()
diff --git a/cmake/linux_glibc_wraps/CMakeLists.txt b/cmake/linux_glibc_wraps/CMakeLists.txt
new file mode 100644
index 0000000..49a4329
--- /dev/null
+++ b/cmake/linux_glibc_wraps/CMakeLists.txt
@@ -0,0 +1,22 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+add_library(linux_glibc_wraps STATIC)
+add_library(desktop-app::linux_glibc_wraps ALIAS linux_glibc_wraps)
+
+get_filename_component(src_loc . REALPATH)
+
+nice_target_sources(linux_glibc_wraps ${src_loc}
+PRIVATE
+    platform/linux/linux_glibc_wraps.c
+    platform/linux/linux_glibc_wraps_32.c
+    platform/linux/linux_glibc_wraps_64.c
+)
+if (NOT build_linux32)
+    set_source_files_properties(${src_loc}/platform/linux/linux_glibc_wraps_32.c PROPERTIES HEADER_FILE_ONLY TRUE)
+else()
+    set_source_files_properties(${src_loc}/platform/linux/linux_glibc_wraps_64.c PROPERTIES HEADER_FILE_ONLY TRUE)
+endif()
diff --git a/cmake/linux_glibc_wraps/platform/linux/linux_glibc_wraps.c b/cmake/linux_glibc_wraps/platform/linux/linux_glibc_wraps.c
new file mode 100644
index 0000000..1770ab1
--- /dev/null
+++ b/cmake/linux_glibc_wraps/platform/linux/linux_glibc_wraps.c
@@ -0,0 +1,29 @@
+// This file is part of Desktop App Toolkit,
+// a set of libraries for developing nice desktop applications.
+//
+// For license and copyright information please follow this link:
+// https://github.com/desktop-app/legal/blob/master/LEGAL
+//
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/types.h>
+
+void *__wrap_aligned_alloc(size_t alignment, size_t size) {
+	void *result = NULL;
+	return (posix_memalign(&result, alignment, size) == 0)
+		? result
+		: NULL;
+}
+
+int enable_secure_inited = 0;
+int enable_secure = 1;
+
+char *__wrap_secure_getenv(const char *name) {
+	if (enable_secure_inited == 0) {
+		enable_secure_inited = 1;
+		enable_secure = (geteuid() != getuid())
+		|| (getegid() != getgid());
+	}
+	return enable_secure ? NULL : getenv(name);
+}
+
diff --git a/cmake/linux_glibc_wraps/platform/linux/linux_glibc_wraps.gyp b/cmake/linux_glibc_wraps/platform/linux/linux_glibc_wraps.gyp
new file mode 100644
index 0000000..fe4cf49
--- /dev/null
+++ b/cmake/linux_glibc_wraps/platform/linux/linux_glibc_wraps.gyp
@@ -0,0 +1,36 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+{
+  'includes': [
+    '../../common/common.gypi',
+  ],
+  'targets': [{
+    'target_name': 'linux_glibc_wraps',
+    'type': 'static_library',
+    'variables': {
+      'src_loc': '.',
+    },
+    'configurations': {
+      'Debug': {
+      },
+      'Release': {
+      },
+    },
+    'sources': [
+      '<(src_loc)/linux_glibc_wraps.c',
+    ],
+    'conditions': [[ '"<!(uname -m)" == "x86_64" or "<!(uname -m)" == "aarch64"', {
+      'sources': [
+        '<(src_loc)/linux_glibc_wraps_64.c',
+      ],
+    }, {
+      'sources': [
+        '<(src_loc)/linux_glibc_wraps_32.c',
+      ],
+    }]],
+  }],
+}
diff --git a/cmake/linux_glibc_wraps/platform/linux/linux_glibc_wraps_32.c b/cmake/linux_glibc_wraps/platform/linux/linux_glibc_wraps_32.c
new file mode 100644
index 0000000..a50f265
--- /dev/null
+++ b/cmake/linux_glibc_wraps/platform/linux/linux_glibc_wraps_32.c
@@ -0,0 +1,49 @@
+// This file is part of Desktop App Toolkit,
+// a set of libraries for developing nice desktop applications.
+//
+// For license and copyright information please follow this link:
+// https://github.com/desktop-app/legal/blob/master/LEGAL
+//
+#include <time.h>
+#include <stdint.h>
+
+#if defined(_M_IX86) || defined(__i386__)
+#define GETTIME_GLIBC_VERSION "2.2"
+#elif defined(_M_ARM) || defined(__arm__)
+#define GETTIME_GLIBC_VERSION "2.4"
+#else
+#error Please add glibc wraps for your architecture
+#endif
+
+int __clock_gettime_glibc_old(clockid_t clk_id, struct timespec *tp);
+__asm__(".symver __clock_gettime_glibc_old,clock_gettime@GLIBC_" GETTIME_GLIBC_VERSION);
+
+int __wrap_clock_gettime(clockid_t clk_id, struct timespec *tp) {
+        return __clock_gettime_glibc_old(clk_id, tp);
+}
+
+uint64_t __udivmoddi4(uint64_t num, uint64_t den, uint64_t *rem_p);
+
+int64_t __wrap___divmoddi4(int64_t num, int64_t den, int64_t *rem_p) {
+	int minus = 0;
+	int64_t v;
+
+	if (num < 0) {
+		num = -num;
+		minus = 1;
+	}
+	if (den < 0) {
+		den = -den;
+		minus ^= 1;
+	}
+
+	v = __udivmoddi4(num, den, (uint64_t *)rem_p);
+	if (minus) {
+		v = -v;
+		if (rem_p)
+			*rem_p = -(*rem_p);
+	}
+
+	return v;
+}
+
diff --git a/cmake/linux_glibc_wraps/platform/linux/linux_glibc_wraps_64.c b/cmake/linux_glibc_wraps/platform/linux/linux_glibc_wraps_64.c
new file mode 100644
index 0000000..b04f513
--- /dev/null
+++ b/cmake/linux_glibc_wraps/platform/linux/linux_glibc_wraps_64.c
@@ -0,0 +1,52 @@
+// This file is part of Desktop App Toolkit,
+// a set of libraries for developing nice desktop applications.
+//
+// For license and copyright information please follow this link:
+// https://github.com/desktop-app/legal/blob/master/LEGAL
+//
+#include <time.h>
+
+#if defined(_M_X64) || defined(__x86_64__)
+#define GETTIME_GLIBC_VERSION "2.2.5"
+#elif defined(__aarch64__)
+#define GETTIME_GLIBC_VERSION "2.17"
+#else
+#error Please add glibc wraps for your architecture
+#endif
+
+typedef unsigned int UTItype __attribute__ ((mode (TI)));
+typedef int TItype __attribute__ ((mode (TI)));
+
+int __clock_gettime_glibc_old(clockid_t clk_id, struct timespec *tp);
+__asm__(".symver __clock_gettime_glibc_old,clock_gettime@GLIBC_" GETTIME_GLIBC_VERSION);
+
+
+int __wrap_clock_gettime(clockid_t clk_id, struct timespec *tp) {
+        return __clock_gettime_glibc_old(clk_id, tp);
+}
+
+UTItype __udivmodti4(UTItype num, UTItype den, UTItype *rem_p);
+
+TItype __wrap___divmodti4(TItype num, TItype den, TItype *rem_p) {
+        int minus = 0;
+        TItype v;
+
+        if (num < 0) {
+                num = -num;
+                minus = 1;
+        }
+        if (den < 0) {
+                den = -den;
+                minus ^= 1;
+        }
+
+        v = __udivmodti4(num, den, (UTItype *)rem_p);
+        if (minus) {
+                v = -v;
+                if (rem_p)
+                        *rem_p = -(*rem_p);
+        }
+
+        return v;
+}
+
diff --git a/cmake/nice_target_sources.cmake b/cmake/nice_target_sources.cmake
new file mode 100644
index 0000000..2ac58d4
--- /dev/null
+++ b/cmake/nice_target_sources.cmake
@@ -0,0 +1,71 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+function(nice_target_sources target_name src_loc)
+    set(list ${ARGV})
+    list(REMOVE_AT list 0 1)
+
+    set(writing_now "")
+    set(private_sources "")
+    set(public_sources "")
+    set(interface_sources "")
+    set(not_win_sources "")
+    set(not_mac_sources "")
+    set(not_linux_sources "")
+    foreach (entry ${list})
+        if (${entry} STREQUAL "PRIVATE" OR ${entry} STREQUAL "PUBLIC" OR ${entry} STREQUAL "INTERFACE")
+            set(writing_now ${entry})
+        else()
+            set(full_name ${src_loc}/${entry})
+            if (${entry} MATCHES "(^|/)win/" OR ${entry} MATCHES "(^|/)winrc/" OR ${entry} MATCHES "(^|/)windows/" OR ${entry} MATCHES "[_\\/]win\\.")
+                list(APPEND not_mac_sources ${full_name})
+                list(APPEND not_linux_sources ${full_name})
+            elseif (${entry} MATCHES "(^|/)mac/" OR ${entry} MATCHES "(^|/)darwin/" OR ${entry} MATCHES "(^|/)osx/" OR ${entry} MATCHES "[_\\/]mac\\." OR ${entry} MATCHES "[_\\/]darwin\\." OR ${entry} MATCHES "[_\\/]osx\\.")
+                list(APPEND not_win_sources ${full_name})
+                list(APPEND not_linux_sources ${full_name})
+            elseif (${entry} MATCHES "(^|/)linux/" OR ${entry} MATCHES "[_\\/]linux\\.")
+                list(APPEND not_win_sources ${full_name})
+                list(APPEND not_mac_sources ${full_name})
+            elseif (${entry} MATCHES "(^|/)posix/" OR ${entry} MATCHES "[_\\/]posix\\.")
+                list(APPEND not_win_sources ${full_name})
+            endif()
+            if ("${writing_now}" STREQUAL "PRIVATE")
+                list(APPEND private_sources ${full_name})
+            elseif ("${writing_now}" STREQUAL "PUBLIC")
+                list(APPEND public_sources ${full_name})
+            elseif ("${writing_now}" STREQUAL "INTERFACE")
+                list(APPEND interface_sources ${full_name})
+            else()
+                message(FATAL_ERROR "Unknown sources scope for target ${target_name}")
+            endif()
+            if (${src_loc} MATCHES "/Resources$")
+                source_group(TREE ${src_loc} PREFIX Resources FILES ${full_name})
+            else()
+                source_group(TREE ${src_loc} PREFIX Sources FILES ${full_name})
+            endif()
+        endif()
+    endforeach()
+
+    if (NOT "${public_sources}" STREQUAL "")
+        target_sources(${target_name} PUBLIC ${public_sources})
+    endif()
+    if (NOT "${private_sources}" STREQUAL "")
+        target_sources(${target_name} PRIVATE ${private_sources})
+    endif()
+    if (NOT "${interface_sources}" STREQUAL "")
+        target_sources(${target_name} INTERFACE ${interface_sources})
+    endif()
+    if (WIN32)
+        set_source_files_properties(${not_win_sources} PROPERTIES HEADER_FILE_ONLY TRUE)
+        set_source_files_properties(${not_win_sources} PROPERTIES SKIP_AUTOGEN TRUE)
+    elseif (APPLE)
+        set_source_files_properties(${not_mac_sources} PROPERTIES HEADER_FILE_ONLY TRUE)
+        set_source_files_properties(${not_mac_sources} PROPERTIES SKIP_AUTOGEN TRUE)
+    elseif (LINUX)
+        set_source_files_properties(${not_linux_sources} PROPERTIES HEADER_FILE_ONLY TRUE)
+        set_source_files_properties(${not_linux_sources} PROPERTIES SKIP_AUTOGEN TRUE)
+    endif()
+endfunction()
diff --git a/cmake/options.cmake b/cmake/options.cmake
new file mode 100644
index 0000000..56dbe48
--- /dev/null
+++ b/cmake/options.cmake
@@ -0,0 +1,30 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+add_library(common_options INTERFACE)
+add_library(desktop-app::common_options ALIAS common_options)
+
+target_compile_definitions(common_options
+INTERFACE
+    $<IF:$<CONFIG:Debug>,_DEBUG,NDEBUG>
+)
+
+if (DESKTOP_APP_DISABLE_CRASH_REPORTS)
+    target_compile_definitions(common_options
+    INTERFACE
+        DESKTOP_APP_DISABLE_CRASH_REPORTS
+    )
+endif()
+
+if (WIN32)
+    include(cmake/options_win.cmake)
+elseif (APPLE)
+    include(cmake/options_mac.cmake)
+elseif (LINUX)
+    include(cmake/options_linux.cmake)
+else()
+    message(FATAL_ERROR "Unknown platform type")
+endif()
diff --git a/cmake/options_linux.cmake b/cmake/options_linux.cmake
new file mode 100644
index 0000000..a6a13c9
--- /dev/null
+++ b/cmake/options_linux.cmake
@@ -0,0 +1,40 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+target_compile_options(common_options
+INTERFACE
+    $<IF:$<CONFIG:Debug>,,-Ofast -fno-strict-aliasing>
+    -pipe
+    -Wall
+    -Werror
+    -W
+    -fPIC
+    -Wno-unused-variable
+    -Wno-unused-parameter
+    -Wno-unused-function
+    -Wno-switch
+    -Wno-comment
+    -Wno-unused-but-set-variable
+    -Wno-missing-field-initializers
+    -Wno-sign-compare
+    -Wno-attributes
+    -Wno-parentheses
+    -Wno-stringop-overflow
+    -Wno-maybe-uninitialized
+    -Wno-error=class-memaccess
+)
+target_link_options(common_options
+INTERFACE
+    $<IF:$<CONFIG:Debug>,,-Ofast>
+)
+if (build_linux32)
+    target_compile_options(common_options INTERFACE -g0)
+    target_link_options(common_options INTERFACE -g0)
+else()
+    target_compile_options(common_options INTERFACE $<IF:$<CONFIG:Debug>,,-g -flto>)
+    target_link_options(common_options INTERFACE $<IF:$<CONFIG:Debug>,,-g -flto -fuse-linker-plugin>)
+endif()
+
diff --git a/cmake/options_mac.cmake b/cmake/options_mac.cmake
new file mode 100644
index 0000000..6be7263
--- /dev/null
+++ b/cmake/options_mac.cmake
@@ -0,0 +1,70 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+if (build_osx)
+    target_compile_definitions(common_options INTERFACE OS_OSX)
+else()
+    if (build_macstore)
+        target_compile_definitions(common_options
+        INTERFACE
+            OS_MAC_STORE
+            MAC_USE_BREAKPAD
+        )
+    endif()
+    target_include_directories(common_options
+    INTERFACE
+        /usr/local/macos/include
+    )
+endif()
+
+target_compile_options(common_options
+INTERFACE
+    -pipe
+    -g
+    -Wall
+    -Werror
+    -W
+    -fPIE
+    -Wno-deprecated-declarations # temp for range-v3
+    -Wno-unused-variable
+    -Wno-unused-parameter
+    -Wno-unused-function
+    -Wno-switch
+    -Wno-comment
+    -Wno-missing-field-initializers
+    -Wno-sign-compare
+    -Wno-unknown-attributes
+    -Wno-pragma-system-header-outside-header
+)
+
+target_link_frameworks(common_options
+INTERFACE
+    Cocoa
+    CoreFoundation
+    CoreServices
+    CoreText
+    CoreGraphics
+    CoreMedia
+    IOSurface
+    Metal
+    OpenGL
+    AudioUnit
+    ApplicationServices
+    Foundation
+    AGL
+    Security
+    SystemConfiguration
+    Carbon
+    AudioToolbox
+    VideoToolbox
+    VideoDecodeAcceleration
+    AVFoundation
+    CoreAudio
+    QuartzCore
+    AppKit
+    CoreWLAN
+    IOKit
+)
diff --git a/cmake/options_win.cmake b/cmake/options_win.cmake
new file mode 100644
index 0000000..54906f7
--- /dev/null
+++ b/cmake/options_win.cmake
@@ -0,0 +1,72 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+target_compile_definitions(common_options
+INTERFACE
+    WIN32
+    _WINDOWS
+    _SCL_SECURE_NO_WARNINGS
+    _USING_V110_SDK71_
+    NOMINMAX
+    UNICODE
+    _UNICODE
+)
+target_compile_options(common_options
+INTERFACE
+    /permissive-
+    # /Qspectre
+    /W1
+    /WX
+    /MP     # Enable multi process build.
+    /EHsc   # Catch C++ exceptions only, extern C functions never throw a C++ exception.
+    /w14834 # [[nodiscard]]
+    /w15038 # wrong initialization order
+    /w14265 # class has virtual functions, but destructor is not virtual
+    /wd4068 # Disable "warning C4068: unknown pragma"
+    /Zc:wchar_t- # don't tread wchar_t as builtin type
+    /Zi
+)
+
+target_link_options(common_options
+INTERFACE
+    $<IF:$<CONFIG:Debug>,/NODEFAULTLIB:LIBCMT,/DEBUG;/OPT:REF>
+)
+
+target_link_libraries(common_options
+INTERFACE
+    winmm
+    imm32
+    ws2_32
+    kernel32
+    user32
+    gdi32
+    winspool
+    comdlg32
+    advapi32
+    shell32
+    ole32
+    oleaut32
+    uuid
+    odbc32
+    odbccp32
+    Shlwapi
+    Iphlpapi
+    Gdiplus
+    Strmiids
+    Netapi32
+    Userenv
+    Version
+    Dwmapi
+    Wtsapi32
+    UxTheme
+    DbgHelp
+    Rstrtmgr
+    Crypt32
+)
+
+if (build_winstore)
+    target_compile_definitions(common_options INTERFACE OS_WIN_STORE)
+endif()
diff --git a/cmake/run_cmake.py b/cmake/run_cmake.py
new file mode 100644
index 0000000..8ae7861
--- /dev/null
+++ b/cmake/run_cmake.py
@@ -0,0 +1,57 @@
+'''
+This file is part of Telegram Desktop,
+the official desktop application for the Telegram messaging service.
+
+For license and copyright information please follow this link:
+https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
+'''
+import sys, os, shutil, subprocess
+
+def run(project, arguments, buildType=''):
+    scriptPath = os.path.dirname(os.path.realpath(__file__))
+    basePath = scriptPath + '/../out/' + buildType
+
+    cmake = ['cmake']
+    for arg in arguments:
+        if arg == 'debug':
+            cmake.append('-DCMAKE_BUILD_TYPE=Debug')
+        elif arg != 'force':
+            cmake.append(arg)
+
+    if sys.platform == 'win32':
+        cmake.append('-AWin32')
+    elif sys.platform == 'darwin':
+        cmake.append('-GXcode')
+    elif buildType:
+        cmake.append('-DCMAKE_BUILD_TYPE=' + buildType)
+    elif not '-DCMAKE_BUILD_TYPE=Debug' in cmake:
+        cmake.append('-DCMAKE_BUILD_TYPE=Release')
+
+    specialTarget = ''
+    specialTargetFile = scriptPath + '/../' + project + '/build/target'
+    if os.path.isfile(specialTargetFile):
+        with open(specialTargetFile, 'r') as f:
+            for line in f:
+                target = line.strip()
+                if len(target) > 0:
+                    cmake.append('-DDESKTOP_APP_SPECIAL_TARGET=' + target)
+
+    cmake.extend(['-Werror=dev', '-Werror=deprecated', '--warn-uninitialized', '..' if not buildType else '../..'])
+    command = ' '.join(cmake)
+
+    if not os.path.exists(basePath):
+        os.makedirs(basePath)
+    elif 'force' in arguments:
+        paths = os.listdir(basePath)
+        for path in paths:
+            if path.lower().startswith('cmake'):
+                full = basePath + '/' + path
+                if os.path.isdir(full):
+                    shutil.rmtree(full, ignore_errors=False)
+                else:
+                    os.remove(full)
+        print('Cleared previous.')
+    os.chdir(basePath)
+    subprocess.call(command, shell=True)
+
+    return 0
diff --git a/cmake/target_link_frameworks.cmake b/cmake/target_link_frameworks.cmake
new file mode 100644
index 0000000..f5fe9a6
--- /dev/null
+++ b/cmake/target_link_frameworks.cmake
@@ -0,0 +1,41 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+function(target_link_frameworks target_name)
+    set(list ${ARGV})
+    list(REMOVE_AT list 0)
+
+    set(writing_now "")
+    set(private_frameworks "")
+    set(public_frameworks "")
+    set(interface_frameworks "")
+    foreach (entry ${list})    
+        if (${entry} STREQUAL "PRIVATE" OR ${entry} STREQUAL "PUBLIC" OR ${entry} STREQUAL "INTERFACE")
+            set(writing_now ${entry})
+        else()
+            set(full_argument "-framework ${entry}")
+            if ("${writing_now}" STREQUAL "PRIVATE")
+                list(APPEND private_frameworks ${full_argument})
+            elseif ("${writing_now}" STREQUAL "PUBLIC")
+                list(APPEND public_frameworks ${full_argument})
+            elseif ("${writing_now}" STREQUAL "INTERFACE")
+                list(APPEND interface_frameworks ${full_argument})
+            else()
+                message(FATAL_ERROR "Unknown frameworks scope for target ${target_name}")
+            endif()
+        endif()
+    endforeach()
+
+    if (NOT "${public_frameworks}" STREQUAL "")
+        target_link_libraries(${target_name} PUBLIC ${public_frameworks})
+    endif()
+    if (NOT "${private_frameworks}" STREQUAL "")
+        target_link_libraries(${target_name} PRIVATE ${private_frameworks})
+    endif()
+    if (NOT "${interface_frameworks}" STREQUAL "")
+        target_link_libraries(${target_name} INTERFACE ${interface_frameworks})
+    endif()
+endfunction()
diff --git a/cmake/target_link_static_libraries.cmake b/cmake/target_link_static_libraries.cmake
new file mode 100644
index 0000000..2aa2875
--- /dev/null
+++ b/cmake/target_link_static_libraries.cmake
@@ -0,0 +1,45 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+function(target_link_static_libraries target_name)
+    set(list ${ARGV})
+    list(REMOVE_AT list 0)
+
+    set(writing_now "")
+    set(private_libs "")
+    set(public_libs "")
+    set(interface_libs "")
+    foreach (entry ${list})
+        if (${entry} STREQUAL "PRIVATE" OR ${entry} STREQUAL "PUBLIC" OR ${entry} STREQUAL "INTERFACE")
+            set(writing_now ${entry})
+        else()
+            find_library(static_lib_${entry} lib${entry}.a)
+            set(full_path "${static_lib_${entry}}")
+            if (${full_path} STREQUAL static_lib_${entry}-NOTFOUND)
+                message(FATAL_ERROR "Could not find static library lib${entry}.a")
+            endif()
+            if ("${writing_now}" STREQUAL "PRIVATE")
+                list(APPEND private_libs ${full_path})
+            elseif ("${writing_now}" STREQUAL "PUBLIC")
+                list(APPEND public_libs ${full_path})
+            elseif ("${writing_now}" STREQUAL "INTERFACE")
+                list(APPEND interface_libs ${full_path})
+            else()
+                message(FATAL_ERROR "Unknown frameworks scope for target ${target_name}")
+            endif()
+        endif()
+    endforeach()
+
+    if (NOT "${public_libs}" STREQUAL "")
+        target_link_libraries(${target_name} PUBLIC ${public_libs})
+    endif()
+    if (NOT "${private_libs}" STREQUAL "")
+        target_link_libraries(${target_name} PRIVATE ${private_libs})
+    endif()
+    if (NOT "${interface_libs}" STREQUAL "")
+        target_link_libraries(${target_name} INTERFACE ${interface_libs})
+    endif()
+endfunction()
diff --git a/cmake/variables.cmake b/cmake/variables.cmake
new file mode 100644
index 0000000..b3d7ff4
--- /dev/null
+++ b/cmake/variables.cmake
@@ -0,0 +1,88 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+set(DESKTOP_APP_SPECIAL_TARGET "" CACHE STRING "Use special platform target, like 'mas' for Mac App Store.")
+option(DESKTOP_APP_DISABLE_CRASH_REPORTS "Disable crash report generation." OFF)
+option(DESKTOP_APP_DISABLE_SPELLCHECK "Disable spellcheck library." OFF)
+option(DESKTOP_APP_LOTTIE_USE_CACHE "Use caching in lottie animations." ON)
+option(DESKTOP_APP_USE_GLIBC_WRAPS "Use wraps for new GLIBC features." OFF)
+option(DESKTOP_APP_USE_PACKAGED "Find libraries using CMake instead of exact paths." ON)
+
+function(report_bad_special_target)
+    message(FATAL_ERROR "Bad special target '${DESKTOP_APP_SPECIAL_TARGET}'")
+endfunction()
+
+if (DESKTOP_APP_SPECIAL_TARGET STREQUAL ""
+    OR DESKTOP_APP_SPECIAL_TARGET STREQUAL "uwp"
+    OR DESKTOP_APP_SPECIAL_TARGET STREQUAL "mas")
+    set(disable_autoupdate 1)
+endif()
+
+if (NOT DESKTOP_APP_SPECIAL_TARGET STREQUAL "")
+    set(DESKTOP_APP_USE_GLIBC_WRAPS ON)
+    set(DESKTOP_APP_USE_PACKAGED OFF)
+endif()
+
+if (NOT DESKTOP_APP_SPECIAL_TARGET STREQUAL "osx")
+    set(CMAKE_OSX_DEPLOYMENT_TARGET 10.12 CACHE STRING "Minimum OS X deployment version" FORCE)
+else()
+    set(DESKTOP_APP_DISABLE_SPELLCHECK ON)
+    set(CMAKE_OSX_DEPLOYMENT_TARGET 10.10 CACHE STRING "Minimum OS X deployment version" FORCE)
+endif()
+
+set(build_osx 0)
+set(build_macstore 0)
+set(build_winstore 0)
+set(build_linux32 0)
+
+if (WIN32)
+    if (DESKTOP_APP_SPECIAL_TARGET STREQUAL "uwp")
+        set(build_winstore 1)
+    elseif (NOT DESKTOP_APP_SPECIAL_TARGET STREQUAL ""
+        AND NOT DESKTOP_APP_SPECIAL_TARGET STREQUAL "win")
+        report_bad_special_target()
+    endif()
+    set(DESKTOP_APP_USE_GLIBC_WRAPS OFF)
+elseif (APPLE)
+    if (DESKTOP_APP_SPECIAL_TARGET STREQUAL "osx")
+        set(build_osx 1)
+        set(CMAKE_OSX_DEPLOYMENT_TARGET 10.10)
+    elseif (DESKTOP_APP_SPECIAL_TARGET STREQUAL "mas")
+        set(build_macstore 1)
+    elseif (NOT DESKTOP_APP_SPECIAL_TARGET STREQUAL ""
+        AND NOT DESKTOP_APP_SPECIAL_TARGET STREQUAL "mac")
+        report_bad_special_target()
+    endif()
+    set(DESKTOP_APP_USE_GLIBC_WRAPS OFF)
+else()
+    set(LINUX 1)
+    execute_process(COMMAND uname -m OUTPUT_VARIABLE machine_uname)
+    if (NOT ${machine_uname} MATCHES "x86_64" AND NOT ${machine_uname} MATCHES "aarch64")
+        set(build_linux32 1)
+    endif()
+    if (DESKTOP_APP_SPECIAL_TARGET STREQUAL "linux")
+        if (build_linux32)
+            report_bad_special_target()
+        endif()
+    elseif (DESKTOP_APP_SPECIAL_TARGET STREQUAL "linux32")
+        if (NOT build_linux32)
+            report_bad_special_target()
+        endif()
+    elseif (NOT DESKTOP_APP_SPECIAL_TARGET STREQUAL "")
+        report_bad_special_target()
+    endif()
+    set(CMAKE_AR /usr/bin/gcc-ar)
+    set(CMAKE_RANLIB /usr/bin/gcc-ranlib)
+    set(CMAKE_NM /usr/bin/gcc-nm)
+endif()
+
+if (NOT APPLE OR build_osx)
+    get_filename_component(libs_loc "../Libraries" REALPATH)
+else()
+    get_filename_component(libs_loc "../Libraries/macos" REALPATH)
+endif()
+get_filename_component(third_party_loc "Telegram/ThirdParty" REALPATH)
+get_filename_component(submodules_loc "Telegram" REALPATH)
diff --git a/cmake/version.cmake b/cmake/version.cmake
new file mode 100644
index 0000000..bea8506
--- /dev/null
+++ b/cmake/version.cmake
@@ -0,0 +1,76 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+function(desktop_app_parse_version file)
+    file(STRINGS ${file} lines)
+    foreach (line ${lines})
+        string(REPLACE " " ";" parts ${line})
+        list(GET parts 0 name)
+        if (${name} STREQUAL "AppVersionOriginal")
+            list(LENGTH parts length)
+            math(EXPR index "${length} - 1")
+            list(GET parts ${index} version)
+            break()
+        endif()
+    endforeach()
+
+    if (NOT ${version} MATCHES "[0-9]+\.[0-9]+(\.[0-9]+(\.([0-9]+|beta))?)?")
+        message(FATAL_ERROR "Bad version: ${version}, check ${file}")
+    endif()
+
+    message("Version: ${version}")
+
+    set(beta 0)
+    set(beta_bool "false")
+    set(alpha 0)
+
+    string(REPLACE "." ";" components ${version})
+    list(LENGTH components components_count)
+    list(GET components 0 major)
+    list(GET components 1 minor)
+    if (${components_count} GREATER 2)
+        list(GET components 2 patch)
+        if (${components_count} GREATER 3)
+            list(GET components 3 alpha)
+            if (${alpha} STREQUAL beta)
+                set(beta 1)
+                set(beta_bool "true")
+                set(alpha 0)
+            endif()
+        endif()
+    endif()
+
+    if (DESKTOP_APP_SPECIAL_TARGET STREQUAL "")
+        set(alpha 0)
+    endif()
+
+    math(EXPR version_int "${major} * 1000000 + ${minor} * 1000 + ${patch}")
+
+    set(str_major ${major}.${minor})
+    set(str_normal ${str_major}.${patch})
+    if (${patch} STREQUAL 0)
+        set(str_small ${str_major})
+    else()
+        set(str_small ${str_normal})
+    endif()
+
+    if (NOT ${alpha} STREQUAL 0)
+        math(EXPR version_int_alpha "${version_int} * 1000 + ${alpha}")
+    else()
+        set(version_int_alpha 0)
+    endif()
+    set(version_dot ${str_normal}.${alpha})
+    string(REPLACE "." "," version_comma ${version_dot})
+
+    set(desktop_app_version_int ${version_int} PARENT_SCOPE)
+    set(desktop_app_version_int_alpha ${version_int_alpha} PARENT_SCOPE)
+    set(desktop_app_version_string ${str_normal} PARENT_SCOPE)
+    set(desktop_app_version_string_small ${str_small} PARENT_SCOPE)
+    set(desktop_app_version_beta_bool ${beta_bool} PARENT_SCOPE)
+    set(desktop_app_version_dot ${version_dot} PARENT_SCOPE)
+    set(desktop_app_version_comma ${version_dot} PARENT_SCOPE)
+    set(desktop_app_version_cmake ${version_dot} PARENT_SCOPE)
+endfunction()
diff --git a/docs/building-cmake.md b/docs/building-cmake.md
index 8d046a62f..54d2ba123 100644
--- a/docs/building-cmake.md
+++ b/docs/building-cmake.md
@@ -10,17 +10,26 @@ You will require **api_id** and **api_hash** to access the Telegram API servers.
 
 ### Install software and required packages
 
-You will need GCC 8.1 installed. To install them and all the required dependencies run
+You will need GCC 8 installed. To install them and all the required dependencies run
 
     sudo apt-get install software-properties-common -y && \
-    sudo apt-get install git libexif-dev liblzma-dev libz-dev libssl-dev libappindicator-dev libicu-dev libdee-dev libdrm-dev dh-autoreconf autoconf automake build-essential libass-dev libfreetype6-dev libgpac-dev libsdl1.2-dev libtheora-dev libtool libva-dev libvdpau-dev libvorbis-dev libxcb1-dev libxcb-image0-dev libxcb-shm0-dev libxcb-xfixes0-dev libxcb-keysyms1-dev libxcb-icccm4-dev libxcb-render-util0-dev libxcb-util0-dev libxcb-xkb-dev libxrender-dev libasound-dev libpulse-dev libxcb-sync0-dev libxcb-randr0-dev libx11-xcb-dev libffi-dev libncurses5-dev pkg-config texi2html zlib1g-dev yasm xutils-dev bison python-xcbgen chrpath gperf -y && \
+    sudo apt-get install git libexif-dev liblzma-dev libz-dev libssl-dev \
+    libappindicator-dev libicu-dev libdee-dev libdrm-dev dh-autoreconf \
+    autoconf automake build-essential libass-dev libfreetype6-dev \
+    libgpac-dev libsdl1.2-dev libtheora-dev libtool libva-dev libvdpau-dev \
+    libvorbis-dev libenchant-dev libxcb1-dev libxcb-image0-dev libxcb-shm0-dev \
+    libxcb-xfixes0-dev libxcb-keysyms1-dev libxcb-icccm4-dev libatspi2.0-dev \
+    libxcb-render-util0-dev libxcb-util0-dev libxcb-xkb-dev libxrender-dev \
+    libasound-dev libpulse-dev libxcb-sync0-dev libxcb-randr0-dev bison \
+    libx11-xcb-dev libffi-dev libncurses5-dev pkg-config texi2html yasm \
+    zlib1g-dev xutils-dev python-xcbgen chrpath gperf -y --force-yes && \
     sudo add-apt-repository ppa:ubuntu-toolchain-r/test -y && \
     sudo apt-get update && \
     sudo apt-get install gcc-8 g++-8 -y && \
     sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-8 60 && \
     sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-8 60 && \
     sudo update-alternatives --config gcc && \
-    sudo add-apt-repository --remove ppa:ubuntu-toolchain-r/test -y && \
+    sudo add-apt-repository --remove ppa:ubuntu-toolchain-r/test -y
 
 You can set the multithreaded make parameter by running
 
@@ -37,14 +46,15 @@ Go to ***BuildPath*** and run
 
     git clone https://github.com/Kitware/CMake cmake
     cd cmake
-    git checkout v3.15.3
+    git checkout v3.16.0
     ./bootstrap
     make $MAKE_THREADS_CNT
     sudo make install
+    cd ..
 
     git clone https://github.com/desktop-app/patches.git
     cd patches
-    git checkout 4aa377c
+    git checkout 395b620
     cd ../
     git clone --branch 0.9.1 https://github.com/ericniebler/range-v3
 
@@ -237,7 +247,27 @@ Go to ***BuildPath*** and run
     git clone https://github.com/desktop-app/nimf.git
     cd ../../../..
 
-    ./configure -prefix "/usr/local/desktop-app/Qt-5.12.5" -release -force-debug-info -opensource -confirm-license -qt-zlib -qt-libpng -qt-libjpeg -qt-harfbuzz -qt-pcre -qt-xcb -system-freetype -fontconfig -no-opengl -no-gtk -static -openssl-linked -I "/usr/local/desktop-app/openssl-1.1.1/include" OPENSSL_LIBS="/usr/local/desktop-app/openssl-1.1.1/lib/libssl.a /usr/local/desktop-app/openssl-1.1.1/lib/libcrypto.a -ldl -lpthread" -nomake examples -nomake tests
+    OPENSSL_DIR=/usr/local/desktop-app/openssl-1.1.1
+    ./configure -prefix "/usr/local/desktop-app/Qt-5.12.5" \
+    -release \
+    -force-debug-info \
+    -opensource \
+    -confirm-license \
+    -qt-zlib \
+    -qt-libpng \
+    -qt-libjpeg \
+    -qt-harfbuzz \
+    -qt-pcre \
+    -qt-xcb \
+    -system-freetype \
+    -fontconfig \
+    -no-opengl \
+    -no-gtk \
+    -static \
+    -openssl-linked \
+    -I "$OPENSSL_DIR/include" OPENSSL_LIBS="$OPENSSL_DIR/lib/libssl.a $OPENSSL_DIR/lib/libcrypto.a -ldl -lpthread" \
+    -nomake examples \
+    -nomake tests
 
     make $MAKE_THREADS_CNT
     sudo make install
@@ -274,7 +304,7 @@ Go to ***BuildPath*** and run
 
 Go to ***BuildPath*/tdesktop/Telegram** and run (using [your **api_id** and **api_hash**](#obtain-your-api-credentials))
 
-    gyp/refresh.sh --api-id YOUR_API_ID --api-hash YOUR_API_HASH
+    ./configure.sh -D TDESKTOP_API_ID=YOUR_API_ID -D TDESKTOP_API_HASH=YOUR_API_HASH -D DESKTOP_APP_USE_PACKAGED=OFF
 
 To make Debug version go to ***BuildPath*/tdesktop/out/Debug** and run
 
@@ -284,6 +314,6 @@ To make Release version go to ***BuildPath*/tdesktop/out/Release** and run
 
     make $MAKE_THREADS_CNT
 
-You can debug your builds from Qt Creator, just open **CMakeLists.txt** from ***BuildPath*/tdesktop/out/Debug** and launch with debug.
+You can debug your builds from Qt Creator, just open ***BuildPath*/tdesktop/CMakeLists.txt**, configure to a separate directory with correct options and launch with debug.
 
 [api_credentials]: api_credentials.md
diff --git a/docs/building-msvc.md b/docs/building-msvc.md
index baf337cf9..2638aeea0 100644
--- a/docs/building-msvc.md
+++ b/docs/building-msvc.md
@@ -32,7 +32,7 @@ Open **x86 Native Tools Command Prompt for VS 2019.bat**, go to ***BuildPath***
     cd ThirdParty
     git clone https://github.com/desktop-app/patches.git
     cd patches
-    git checkout 4aa377c
+    git checkout 395b620
     cd ../
     git clone https://chromium.googlesource.com/external/gyp
     cd gyp
@@ -64,7 +64,7 @@ Open **x86 Native Tools Command Prompt for VS 2019.bat**, go to ***BuildPath***
 
     git clone https://github.com/desktop-app/patches.git
     cd patches
-    git checkout 4aa377c
+    git checkout 395b620
     cd ..
     git clone --branch 0.9.1 https://github.com/ericniebler/range-v3 range-v3
 
@@ -164,16 +164,13 @@ Open **x86 Native Tools Command Prompt for VS 2019.bat**, go to ***BuildPath***
     jom -j4 install
     cd ..
 
-    cd ../tdesktop/Telegram
-    gyp\refresh.bat
-
 ## Build the project
 
-If you want to pass a build define (like `TDESKTOP_DISABLE_AUTOUPDATE` or `TDESKTOP_DISABLE_NETWORK_PROXY`), call `set TDESKTOP_BUILD_DEFINES=TDESKTOP_DISABLE_AUTOUPDATE,TDESKTOP_DISABLE_NETWORK_PROXY,...` (comma seperated string)
+Go to ***BuildPath*\\tdesktop\\Telegram** and run (using [your **api_id** and **api_hash**](#obtain-your-api-credentials))
 
-After, call **gyp\refresh.bat** once again.
+    configure.bat -D TDESKTOP_API_ID=YOUR_API_ID -D TDESKTOP_API_HASH=YOUR_API_HASH -D DESKTOP_APP_USE_PACKAGED=OFF
 
-* Open ***BuildPath*\\tdesktop\\Telegram\\Telegram.sln** in Visual Studio 2019
+* Open ***BuildPath*\\tdesktop\\out\\Telegram.sln** in Visual Studio 2019
 * Select Telegram project and press Build > Build Telegram (Debug and Release configurations)
 * The result Telegram.exe will be located in **D:\TBuild\tdesktop\out\Debug** (and **Release**)
 
diff --git a/docs/building-osx.md b/docs/building-osx.md
index 8d51ed56b..66b16a7be 100644
--- a/docs/building-osx.md
+++ b/docs/building-osx.md
@@ -1,5 +1,7 @@
 ## Build instructions for Xcode 10.1
 
+**NB** These are used for OS X 10.10/10.11 build, after the [Building using Xcode][xcode] instructions.
+
 ### Prepare folder
 
 Choose a folder for the future build, for example **/Users/user/TBuild**. It will be named ***BuildPath*** in the rest of this document. All commands will be launched from Terminal.
@@ -33,7 +35,7 @@ Go to ***BuildPath*** and run
 
     git clone https://github.com/desktop-app/patches.git
     cd patches
-    git checkout 4aa377c
+    git checkout 395b620
     cd ../
     git clone https://chromium.googlesource.com/external/gyp
     git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git
@@ -50,7 +52,7 @@ Go to ***BuildPath*** and run
 
     git clone https://github.com/desktop-app/patches.git
     cd patches
-    git checkout 4aa377c
+    git checkout 395b620
     cd ../
     git clone --branch 0.9.1 https://github.com/ericniebler/range-v3
 
@@ -247,10 +249,10 @@ Go to ***BuildPath*** and run
 
 ### Building the project
 
-Go to ***BuildPath*/tdesktop/Telegram** and run
+Go to ***BuildPath*/tdesktop/Telegram** and run (using [your **api_id** and **api_hash**](#obtain-your-api-credentials))
 
-    gyp/refresh.sh
+    ./configure.sh -D TDESKTOP_API_ID=YOUR_API_ID -D TDESKTOP_API_HASH=YOUR_API_HASH -D DESKTOP_APP_USE_PACKAGED=OFF
 
-Then launch Xcode, open ***BuildPath*/tdesktop/Telegram/Telegram.xcodeproj** and build for Debug / Release.
+Then launch Xcode, open ***BuildPath*/tdesktop/out/Telegram.xcodeproj** and build for Debug / Release.
 
 [api_credentials]: api_credentials.md
diff --git a/docs/building-qmake.md b/docs/building-qmake.md
index aeca87688..79348b4dd 100644
--- a/docs/building-qmake.md
+++ b/docs/building-qmake.md
@@ -1,7 +1,7 @@
 Building via qmake
 ==================
 
-**NB** These are outdated, please refer to [Building using GYP/CMake][cmake] instructions.
+**NB** These are outdated, please refer to [Building using CMake][cmake] instructions.
 
 The following commands assume the following environment variables are set:
 
diff --git a/docs/building-qtcreator.md b/docs/building-qtcreator.md
index 3115fb2d2..aa592148f 100644
--- a/docs/building-qtcreator.md
+++ b/docs/building-qtcreator.md
@@ -1,6 +1,6 @@
 ## Build instructions for Qt Creator 3.5.1 under Ubuntu 12.04
 
-**NB** These are outdated, please refer to [Building using GYP/CMake][cmake] instructions.
+**NB** These are outdated, please refer to [Building using CMake][cmake] instructions.
 
 ### Prepare
 
@@ -30,7 +30,7 @@ By git – in Terminal go to **/home/user/TBuild** and run
 
 Install dev libraries
 
-    sudo apt-get install libexif-dev liblzma-dev libz-dev libssl-dev libappindicator-dev libunity-dev
+    sudo apt-get install libexif-dev liblzma-dev libz-dev libssl-dev libappindicator-dev libunity-dev libenchant-dev
 
 #### zlib 1.2.8
 
diff --git a/docs/building-xcode-mas.md b/docs/building-xcode-mas.md
index 57602c4ba..f3a1ad471 100644
--- a/docs/building-xcode-mas.md
+++ b/docs/building-xcode-mas.md
@@ -6,9 +6,9 @@
 
 Go to ***BuildPath*** and run
 
-    MACOSX_DEPLOYMENT_TARGET=10.8
+    MACOSX_DEPLOYMENT_TARGET=10.12
 
-    cd Libraries
+    cd Libraries/macos
 
     git clone https://chromium.googlesource.com/breakpad/breakpad
     cd breakpad
@@ -17,7 +17,7 @@ Go to ***BuildPath*** and run
     cd src/third_party/lss
     git checkout a91633d1
     cd ../../..
-    git apply ../../tdesktop/Telegram/Patches/breakpad.diff
+    git apply ../patches/breakpad.diff
     cd src/client/mac
     xcodebuild -project Breakpad.xcodeproj -target Breakpad -configuration Debug build
     xcodebuild -project Breakpad.xcodeproj -target Breakpad -configuration Release build
diff --git a/docs/building-xcode-old.md b/docs/building-xcode-old.md
index 694614d6a..a2d88b884 100644
--- a/docs/building-xcode-old.md
+++ b/docs/building-xcode-old.md
@@ -1,6 +1,6 @@
 ## Build instructions for Xcode 10.1
 
-**NB** These are used for OS X 10.6/10.7 build, after the [Building using Xcode][xcode] instructions.
+**NB** These are outdated, please refer to [Building using Xcode][xcode] instructions.
 
 ### Download libraries
 
diff --git a/docs/building-xcode.md b/docs/building-xcode.md
index a780a4ba0..b4ac69397 100644
--- a/docs/building-xcode.md
+++ b/docs/building-xcode.md
@@ -33,7 +33,7 @@ Go to ***BuildPath*** and run
 
     git clone https://github.com/desktop-app/patches.git
     cd patches
-    git checkout 4aa377c
+    git checkout 395b620
     cd ../
     git clone https://chromium.googlesource.com/external/gyp
     git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git
@@ -50,7 +50,7 @@ Go to ***BuildPath*** and run
 
     git clone https://github.com/desktop-app/patches.git
     cd patches
-    git checkout 4aa377c
+    git checkout 395b620
     cd ../
     git clone --branch 0.9.1 https://github.com/ericniebler/range-v3
 
@@ -237,6 +237,7 @@ Go to ***BuildPath*** and run
     git submodule update qtbase
     git submodule update qtimageformats
     cd qtbase
+    git cherry-pick 7ac4e55
     git apply ../../patches/qtbase_5_12_5.diff
     cd ..
 
@@ -247,10 +248,10 @@ Go to ***BuildPath*** and run
 
 ### Building the project
 
-Go to ***BuildPath*/tdesktop/Telegram** and run
+Go to ***BuildPath*/tdesktop/Telegram** and run (using [your **api_id** and **api_hash**](#obtain-your-api-credentials))
 
-    gyp/refresh.sh
+    ./configure.sh -D TDESKTOP_API_ID=YOUR_API_ID -D TDESKTOP_API_HASH=YOUR_API_HASH -D DESKTOP_APP_USE_PACKAGED=OFF
 
-Then launch Xcode, open ***BuildPath*/tdesktop/Telegram/Telegram.xcodeproj** and build for Debug / Release.
+Then launch Xcode, open ***BuildPath*/tdesktop/out/Telegram.xcodeproj** and build for Debug / Release.
 
 [api_credentials]: api_credentials.md
diff --git a/lib/xdg/kotatogramdesktop.desktop b/lib/xdg/kotatogramdesktop.desktop
index e21852113..6d195be0e 100644
--- a/lib/xdg/kotatogramdesktop.desktop
+++ b/lib/xdg/kotatogramdesktop.desktop
@@ -7,7 +7,7 @@ Icon=kotatogram
 Terminal=false
 StartupWMClass=KotatogramDesktop
 Type=Application
-Categories=Network;InstantMessaging;Qt;
+Categories=Chat;Network;InstantMessaging;Qt;
 MimeType=x-scheme-handler/tg;
 Keywords=tg;chat;im;messaging;messenger;sms;tdesktop;kotatogram;
 X-GNOME-UsesNotifications=true
diff --git a/snap/snapcraft.yaml b/snap/snapcraft.yaml
index 1ce38168b..8919c5496 100644
--- a/snap/snapcraft.yaml
+++ b/snap/snapcraft.yaml
@@ -68,6 +68,7 @@ parts:
     build-packages:
       - libappindicator-dev
       - libappindicator3-dev
+      - libenchant-dev
       - libexif-dev
       - libicu-dev
       - liblzma-dev
