diff --git a/.gitmodules b/.gitmodules
index f206a48c7..8bf8047de 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -64,3 +64,6 @@
 [submodule "Telegram/lib_qr"]
 	path = Telegram/lib_qr
 	url = https://github.com/desktop-app/lib_qr.git
+[submodule "Telegram/ThirdParty/sonnet"]
+	path = Telegram/ThirdParty/sonnet
+	url = https://github.com/KDE/sonnet
diff --git a/Telegram/CMakeLists.txt b/Telegram/CMakeLists.txt
index b00bd61e5..277acdb45 100644
--- a/Telegram/CMakeLists.txt
+++ b/Telegram/CMakeLists.txt
@@ -94,6 +94,10 @@ if (NOT DESKTOP_APP_DISABLE_CRASH_REPORTS)
     target_link_libraries(Telegram PRIVATE desktop-app::external_crash_reports)
 endif()
 
+if (LINUX AND NOT DESKTOP_APP_DISABLE_SPELLCHECK AND NOT DESKTOP_APP_USE_PACKAGED)
+    target_link_libraries(Telegram PRIVATE desktop-app::external_sonnet)
+endif()
+
 target_precompile_headers(Telegram PRIVATE ${src_loc}/stdafx.h)
 nice_target_sources(Telegram ${src_loc}
 PRIVATE
Submodule Telegram/lib_spellcheck contains modified content
diff --git a/Telegram/lib_spellcheck/CMakeLists.txt b/Telegram/lib_spellcheck/CMakeLists.txt
index 282e732..5b264ec 100644
--- a/Telegram/lib_spellcheck/CMakeLists.txt
+++ b/Telegram/lib_spellcheck/CMakeLists.txt
@@ -44,4 +44,6 @@ if (LINUX)
 
     pkg_search_module(ENCHANT REQUIRED enchant-2 enchant)
     target_include_directories(lib_spellcheck PRIVATE ${ENCHANT_INCLUDE_DIRS})
+
+    target_link_libraries(lib_spellcheck PUBLIC desktop-app::external_sonnet)
 endif()
diff --git a/Telegram/lib_spellcheck/spellcheck/platform/linux/spellcheck_linux.cpp b/Telegram/lib_spellcheck/spellcheck/platform/linux/spellcheck_linux.cpp
index a465cc6..be96fb8 100644
--- a/Telegram/lib_spellcheck/spellcheck/platform/linux/spellcheck_linux.cpp
+++ b/Telegram/lib_spellcheck/spellcheck/platform/linux/spellcheck_linux.cpp
@@ -4,25 +4,35 @@
 // Author: Nicholas Guriev <guriev-ns@ya.ru>, public domain, 2019
 // License: CC0, https://creativecommons.org/publicdomain/zero/1.0/legalcode
 
-#include <set>
 #include <QLocale>
 
+#ifdef DESKTOP_APP_USE_PACKAGED
+#include <Sonnet/GuessLanguage>
+#else
+#include "guesslanguage.h"
+#endif
+
 #include "spellcheck/spellcheck_utils.h"
 #include "spellcheck/platform/linux/linux_enchant.h"
 
 #include "spellcheck/platform/linux/spellcheck_linux.h"
 #include "base/integration.h"
+#include "base/flat_map.h"
 
 namespace Platform::Spellchecker {
 namespace {
 
+constexpr auto kMinReliability = 0.1;
+constexpr auto kMaxItems = 5;
+
+using DictPtr = std::shared_ptr<enchant::Dict>;
+
 class EnchantSpellChecker {
 public:
-	bool isAvailable();
-	auto knownLanguages();
+	std::vector<QString> knownLanguages();
 	bool checkSpelling(const QString &word);
-	auto findSuggestions(const QString &word);
-	void addWord(const QString &wordToAdd);
+	std::vector<QString> findSuggestions(const QString &word);
+	void addWord(const QString &word);
 	void ignoreWord(const QString &word);
 	void removeWord(const QString &word);
 	bool isWordInDictionary(const QString &word);
@@ -31,41 +41,21 @@ public:
 private:
 	EnchantSpellChecker();
 	EnchantSpellChecker(const EnchantSpellChecker&) = delete;
-	EnchantSpellChecker& operator =(const EnchantSpellChecker&) = delete;
+	EnchantSpellChecker &operator=(const EnchantSpellChecker&) = delete;
 
-	std::unique_ptr<enchant::Broker> _brokerHandle;
-	std::vector<std::unique_ptr<enchant::Dict>> _validators;
+	DictPtr getValidatorByWord(const QString &word);
+
+	Sonnet::GuessLanguage _guessLanguage;
+	enchant::Broker _brokerHandle;
+	base::flat_map<QString, DictPtr> _validatorCache;
+
+	QString _prevLang;
+	QString _locale;
 };
 
 EnchantSpellChecker::EnchantSpellChecker() {
-	if (!enchant::loader::do_explicit_linking()) return;
-
-	std::set<std::string> langs;
-	_brokerHandle = std::make_unique<enchant::Broker>();
-	_brokerHandle->list_dicts([](
-			const char *language,
-			const char *provider,
-			const char *description,
-			const char *filename,
-			void *our_payload) {
-		static_cast<decltype(langs)*>(our_payload)->insert(language);
-	}, &langs);
-	using DictPtr = std::unique_ptr<enchant::Dict>;
-	_validators.reserve(langs.size());
-	try {
-		std::string langTag = QLocale::system().name().toStdString();
-		_validators.push_back(DictPtr(_brokerHandle->request_dict(langTag)));
-		langs.erase(langTag);
-	} catch (const enchant::Exception &e) {
-		// no first dictionary found
-	}
-	for (const std::string &language : langs) {
-		try {
-			_validators.push_back(DictPtr(_brokerHandle->request_dict(language)));
-		} catch (const enchant::Exception &e) {
-			base::Integration::Instance().logMessage(QString("Catch after request_dict: ") + e.what());
-		}
-	}
+	_prevLang = _locale = QLocale::system().name();
+	_guessLanguage.setLimits(kMaxItems, kMinReliability);
 }
 
 EnchantSpellChecker *EnchantSpellChecker::instance() {
@@ -73,71 +63,101 @@ EnchantSpellChecker *EnchantSpellChecker::instance() {
 	return &capsule;
 }
 
-bool EnchantSpellChecker::isAvailable() {
-	return !_validators.empty();
-}
+DictPtr EnchantSpellChecker::getValidatorByWord(const QString &word) {
+	// If GuessLanguage can't guess the language, it fallback to the first available dictionary in this list
+	// Note: when Sonnet is built statically, it can use only Hunspell
+	const auto guessLangs = QStringList() << _prevLang << _locale;
 
-auto EnchantSpellChecker::knownLanguages() {
-	return _validators | ranges::views::transform([](const auto &validator) {
-		return QString(validator->get_lang().c_str());
-	}) | ranges::to_vector;
-}
+	const auto lang = _guessLanguage.identify(word, guessLangs);
+	_prevLang = lang;
 
-bool EnchantSpellChecker::checkSpelling(const QString &word) {
-	auto w = word.toStdString();
-	return ranges::any_of(_validators, [&](const auto &validator) {
+	auto &validator = _validatorCache[lang];
+
+	if (!validator) {
 		try {
-			return validator->check(w);
+			validator.reset(_brokerHandle.request_dict(lang.toStdString()));
 		} catch (const enchant::Exception &e) {
-			base::Integration::Instance().logMessage(QString("Catch after check '") + word + "': " + e.what());
-			return true;
+			base::Integration::Instance().logMessage(
+				QStringLiteral("Catch after request_dict: %1").arg(e.what()));
 		}
-	}) || _validators.empty();
+	}
+
+	return validator;
+}
+
+std::vector<QString> EnchantSpellChecker::knownLanguages() {
+	std::vector<QString> langs;
+	_brokerHandle.list_dicts([](
+			const char *language,
+			const char *provider,
+			const char *description,
+			const char *filename,
+			void *our_payload) {
+		static_cast<decltype(langs)*>(our_payload)
+			->push_back(QString::fromLatin1(language));
+	}, &langs);
+	return langs;
 }
 
-auto EnchantSpellChecker::findSuggestions(const QString &word) {
-	auto w = word.toStdString();
+bool EnchantSpellChecker::checkSpelling(const QString &word) {
+	auto validator = getValidatorByWord(word);
+	if (!validator) return true;
+
+	try {
+		return validator->check(word.toStdString());
+	} catch (const enchant::Exception &e) {
+		base::Integration::Instance().logMessage(
+			QStringLiteral("Catch after check %1: %2")
+				.arg(word).arg(e.what()));
+		return true;
+	}
+}
+
+std::vector<QString> EnchantSpellChecker::findSuggestions(
+		const QString &word) {
+	auto validator = getValidatorByWord(word);
 	std::vector<QString> result;
-	for (const auto &validator : _validators) {
-		for (const auto &replacement : validator->suggest(w)) {
-			if (!replacement.empty()) {
-				result.push_back(replacement.c_str());
-			}
-			if (result.size() >= Platform::Spellchecker::kMaxSuggestions) {
-				break;
-			}
+	if (!validator) return result;
+
+	for (const auto &replacement : validator->suggest(word.toStdString())) {
+		if (!replacement.empty()) {
+			result.push_back(replacement.c_str());
 		}
-		if (!result.empty()) {
+		if (result.size() >= Platform::Spellchecker::kMaxSuggestions) {
 			break;
 		}
 	}
 	return result;
 }
 
-void EnchantSpellChecker::addWord(const QString &wordToAdd) {
-	auto word = wordToAdd.toStdString();
-	auto &&first = _validators.at(0);
-	first->add(word);
-	first->add_to_session(word);
+void EnchantSpellChecker::addWord(const QString &word) {
+	auto validator = getValidatorByWord(word);
+	if (!validator) return;
+
+	validator->add(word.toStdString());
 }
 
 void EnchantSpellChecker::ignoreWord(const QString &word) {
-	_validators.at(0)->add_to_session(word.toStdString());
+	auto validator = getValidatorByWord(word);
+	if (!validator) return;
+
+	validator->add_to_session(word.toStdString());
 }
 
 void EnchantSpellChecker::removeWord(const QString &word) {
-	auto w = word.toStdString();
-	for (const auto &validator : _validators) {
-		validator->remove_from_session(w);
-		validator->remove(w);
-	}
+	auto validator = getValidatorByWord(word);
+	if (!validator) return;
+
+	const auto w = word.toStdString();
+	validator->remove_from_session(w);
+	validator->remove(w);
 }
 
 bool EnchantSpellChecker::isWordInDictionary(const QString &word) {
-	auto w = word.toStdString();
-	return ranges::any_of(_validators, [&w](const auto &validator) {
-		return validator->is_added(w);
-	});
+	auto validator = getValidatorByWord(word);
+	if (!validator) return false;
+
+	return validator->is_added(word.toStdString());
 }
 
 } // namespace
@@ -146,7 +166,8 @@ void Init() {
 }
 
 bool IsAvailable() {
-	return EnchantSpellChecker::instance()->isAvailable();
+	static auto Available = enchant::loader::do_explicit_linking();
+	return Available;
 }
 
 void KnownLanguages(std::vector<QString> *langCodes) {
Submodule cmake contains modified content
diff --git a/cmake/external/CMakeLists.txt b/cmake/external/CMakeLists.txt
index 4187ad3..de044e1 100644
--- a/cmake/external/CMakeLists.txt
+++ b/cmake/external/CMakeLists.txt
@@ -9,6 +9,9 @@ add_subdirectory(crash_reports)
 add_subdirectory(expected)
 add_subdirectory(ffmpeg)
 add_subdirectory(gsl)
+if (LINUX)
+    add_subdirectory(hunspell)
+endif()
 add_subdirectory(iconv)
 add_subdirectory(lz4)
 add_subdirectory(openal)
@@ -18,6 +21,9 @@ add_subdirectory(qt)
 add_subdirectory(qr_code_generator)
 add_subdirectory(ranges)
 add_subdirectory(rlottie)
+if (LINUX)
+    add_subdirectory(sonnet)
+endif()
 if (APPLE)
     add_subdirectory(sp_media_key_tap)
 endif()
diff --git a/cmake/external/hunspell/CMakeLists.txt b/cmake/external/hunspell/CMakeLists.txt
new file mode 100644
index 0000000..88fd143
--- /dev/null
+++ b/cmake/external/hunspell/CMakeLists.txt
@@ -0,0 +1,25 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+add_library(external_hunspell INTERFACE IMPORTED GLOBAL)
+add_library(desktop-app::external_hunspell ALIAS external_hunspell)
+
+if (DESKTOP_APP_USE_PACKAGED)
+    find_package(PkgConfig REQUIRED)
+    pkg_check_modules(HUNSPELL hunspell)
+    target_include_directories(external_hunspell INTERFACE ${HUNSPELL_INCLUDE_DIRS})
+else()
+    target_include_directories(external_hunspell SYSTEM
+    INTERFACE
+        ${libs_loc}/hunspell/src/hunspell
+    )
+endif()
+
+if (DESKTOP_APP_USE_PACKAGED)
+    target_link_libraries(external_hunspell INTERFACE ${HUNSPELL_LIBRARIES})
+else()
+    target_link_static_libraries(external_sonnet INTERFACE hunspell)
+endif()
diff --git a/cmake/external/sonnet/CMakeLists.txt b/cmake/external/sonnet/CMakeLists.txt
new file mode 100644
index 0000000..96ef3d1
--- /dev/null
+++ b/cmake/external/sonnet/CMakeLists.txt
@@ -0,0 +1,84 @@
+# This file is part of Desktop App Toolkit,
+# a set of libraries for developing nice desktop applications.
+#
+# For license and copyright information please follow this link:
+# https://github.com/desktop-app/legal/blob/master/LEGAL
+
+if (DESKTOP_APP_USE_PACKAGED)
+    add_library(external_sonnet INTERFACE IMPORTED GLOBAL)
+    add_library(desktop-app::external_sonnet ALIAS external_sonnet)
+
+    find_package(KF5Sonnet)
+
+    if (KF5Sonnet_FOUND)
+        target_link_libraries(external_sonnet INTERFACE KF5::SonnetCore)
+    endif()
+else()
+    add_subdirectory(parsetrigrams)
+
+    add_library(external_sonnet OBJECT)
+    add_library(desktop-app::external_sonnet ALIAS external_sonnet)
+    init_target(external_sonnet "(external)")
+
+    get_filename_component(src_loc . REALPATH)
+    set(sonnet_loc ${third_party_loc}/sonnet)
+
+    set_target_properties(external_sonnet PROPERTIES AUTOMOC ON AUTORCC ON)
+
+    add_custom_command(OUTPUT "${CMAKE_BINARY_DIR}/data/trigrams.map"
+                       COMMAND external_parsetrigrams "${sonnet_loc}/data/trigrams" > "${CMAKE_BINARY_DIR}/data/trigrams.map")
+    configure_file(${sonnet_loc}/data/trigrams.qrc.in ${CMAKE_BINARY_DIR}/data/trigrams.qrc @ONLY)
+
+    target_sources(external_sonnet
+    PRIVATE
+        ${CMAKE_BINARY_DIR}/data/trigrams.qrc
+        ${sonnet_loc}/src/core/backgroundchecker.cpp
+        ${sonnet_loc}/src/core/backgroundchecker.h
+        ${sonnet_loc}/src/core/backgroundchecker_p.h
+        ${sonnet_loc}/src/core/client.cpp
+        ${sonnet_loc}/src/core/client_p.h
+        ${sonnet_loc}/src/core/guesslanguage.cpp
+        ${sonnet_loc}/src/core/guesslanguage.h
+        ${sonnet_loc}/src/core/languagefilter.cpp
+        ${sonnet_loc}/src/core/languagefilter_p.h
+        ${sonnet_loc}/src/core/loader.cpp
+        ${sonnet_loc}/src/core/loader_p.h
+        ${sonnet_loc}/src/core/settings.cpp
+        ${sonnet_loc}/src/core/settings_p.h
+        ${sonnet_loc}/src/core/speller.cpp
+        ${sonnet_loc}/src/core/speller.h
+        ${sonnet_loc}/src/core/spellerplugin.cpp
+        ${sonnet_loc}/src/core/spellerplugin_p.h
+        ${sonnet_loc}/src/core/textbreaks.cpp
+        ${sonnet_loc}/src/core/textbreaks_p.h
+        ${sonnet_loc}/src/core/tokenizer.cpp
+        ${sonnet_loc}/src/core/tokenizer_p.h
+        ${sonnet_loc}/src/plugins/hunspell/hunspellclient.cpp
+        ${sonnet_loc}/src/plugins/hunspell/hunspellclient.h
+        ${sonnet_loc}/src/plugins/hunspell/hunspelldict.cpp
+        ${sonnet_loc}/src/plugins/hunspell/hunspelldict.h
+        ${src_loc}/config/core_debug.cpp
+        ${src_loc}/config/core_debug.h
+        ${src_loc}/config/hunspelldebug.cpp
+        ${src_loc}/config/hunspelldebug.h
+    )
+
+    target_compile_definitions(external_sonnet
+    PRIVATE
+        QT_USE_QSTRINGBUILDER
+        SONNET_STATIC
+    )
+
+    target_include_directories(external_sonnet
+    PUBLIC
+        ${sonnet_loc}/src/core
+        ${sonnet_loc}/src/plugins/hunspell
+        ${src_loc}/config
+    )
+
+    target_link_libraries(external_sonnet
+    PUBLIC
+        desktop-app::external_qt
+        desktop-app::external_hunspell
+    )
+endif()
diff --git a/cmake/external/sonnet/config/config-hunspell.h b/cmake/external/sonnet/config/config-hunspell.h
new file mode 100644
index 0000000..80eddda
--- /dev/null
+++ b/cmake/external/sonnet/config/config-hunspell.h
@@ -0,0 +1 @@
+#define USE_OLD_HUNSPELL_API 0
diff --git a/cmake/external/sonnet/config/core_debug.cpp b/cmake/external/sonnet/config/core_debug.cpp
new file mode 100644
index 0000000..c3aa700
--- /dev/null
+++ b/cmake/external/sonnet/config/core_debug.cpp
@@ -0,0 +1,2 @@
+#include "core_debug.h"
+Q_LOGGING_CATEGORY(SONNET_LOG_CORE, "sonnet.core", QtInfoMsg)
diff --git a/cmake/external/sonnet/config/core_debug.h b/cmake/external/sonnet/config/core_debug.h
new file mode 100644
index 0000000..ba71c23
--- /dev/null
+++ b/cmake/external/sonnet/config/core_debug.h
@@ -0,0 +1,4 @@
+#pragma once
+
+#include <QLoggingCategory>
+Q_DECLARE_LOGGING_CATEGORY(SONNET_LOG_CORE)
diff --git a/cmake/external/sonnet/config/hunspelldebug.cpp b/cmake/external/sonnet/config/hunspelldebug.cpp
new file mode 100644
index 0000000..527f60d
--- /dev/null
+++ b/cmake/external/sonnet/config/hunspelldebug.cpp
@@ -0,0 +1,2 @@
+#include "hunspelldebug.h"
+Q_LOGGING_CATEGORY(SONNET_HUNSPELL, "sonnet.plugins.hunspell", QtInfoMsg)
diff --git a/cmake/external/sonnet/config/hunspelldebug.h b/cmake/external/sonnet/config/hunspelldebug.h
new file mode 100644
index 0000000..26b2455
--- /dev/null
+++ b/cmake/external/sonnet/config/hunspelldebug.h
@@ -0,0 +1,4 @@
+#pragma once
+
+#include <QLoggingCategory>
+Q_DECLARE_LOGGING_CATEGORY(SONNET_HUNSPELL)
diff --git a/cmake/external/sonnet/config/sonnetcore_export.h b/cmake/external/sonnet/config/sonnetcore_export.h
new file mode 100644
index 0000000..db467d8
--- /dev/null
+++ b/cmake/external/sonnet/config/sonnetcore_export.h
@@ -0,0 +1 @@
+#define SONNETCORE_EXPORT
diff --git a/cmake/external/sonnet/parsetrigrams/CMakeLists.txt b/cmake/external/sonnet/parsetrigrams/CMakeLists.txt
new file mode 100644
index 0000000..bf61d46
--- /dev/null
+++ b/cmake/external/sonnet/parsetrigrams/CMakeLists.txt
@@ -0,0 +1,14 @@
+add_executable(external_parsetrigrams)
+init_target(external_parsetrigrams "(external)")
+
+set(sonnet_loc ${third_party_loc}/sonnet)
+
+target_sources(external_parsetrigrams
+PRIVATE
+    ${sonnet_loc}/data/parsetrigrams.cpp
+)
+
+target_link_libraries(external_parsetrigrams
+PUBLIC
+    desktop-app::external_qt
+)
diff --git a/cmake/options.cmake b/cmake/options.cmake
index 56dbe48..a207f28 100644
--- a/cmake/options.cmake
+++ b/cmake/options.cmake
@@ -19,6 +19,13 @@ if (DESKTOP_APP_DISABLE_CRASH_REPORTS)
     )
 endif()
 
+if (DESKTOP_APP_USE_PACKAGED)
+    target_compile_definitions(common_options
+    INTERFACE
+        DESKTOP_APP_USE_PACKAGED
+    )
+endif()
+
 if (WIN32)
     include(cmake/options_win.cmake)
 elseif (APPLE)
